#ifndef UE4SS_SDK_Engine_HPP
#define UE4SS_SDK_Engine_HPP

#include "Engine_enums.hpp"

struct FA2CSPose : public FA2Pose
{
    TArray<uint8> ComponentSpaceFlags;                                                // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FA2Pose
{
    TArray<FTransform> Bones;                                                         // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FActivateDevicePropertyParams
{
    FPlatformUserId UserId;                                                           // 0x0000 (size: 0x4)
    FInputDeviceId DeviceID;                                                          // 0x0004 (size: 0x4)
    uint8 bLooping;                                                                   // 0x0008 (size: 0x1)
    uint8 bIgnoreTimeDilation;                                                        // 0x0008 (size: 0x1)
    uint8 bPlayWhilePaused;                                                           // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FActivatedCells
{
    TSet<UWorldPartitionRuntimeCell*> Cells;                                          // 0x0000 (size: 0x50)

}; // Size: 0xA0

struct FActiveCameraShakeInfo
{
    class UCameraShakeBase* ShakeInstance;                                            // 0x0000 (size: 0x8)
    TWeakObjectPtr<class UCameraShakeSourceComponent> ShakeSource;                    // 0x0008 (size: 0x8)
    bool bIsCustomInitialized;                                                        // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FActiveDeviceProperty
{
    TWeakObjectPtr<class UInputDeviceProperty> Property;                              // 0x0000 (size: 0x8)

}; // Size: 0x20

struct FActiveForceFeedbackEffect
{
    class UForceFeedbackEffect* ForceFeedbackEffect;                                  // 0x0000 (size: 0x8)
    TSet<FInputDevicePropertyHandle> ActiveDeviceProperties;                          // 0x0020 (size: 0x50)

}; // Size: 0x70

struct FActiveHapticFeedbackEffect
{
    class UHapticFeedbackEffect_Base* HapticEffect;                                   // 0x0000 (size: 0x8)

}; // Size: 0x48

struct FActorComponentInstanceData : public FInstanceCacheDataBase
{
    class UObject* SourceComponentTemplate;                                           // 0x0058 (size: 0x8)
    EComponentCreationMethod SourceComponentCreationMethod;                           // 0x0060 (size: 0x1)
    int32 SourceComponentTypeSerializedIndex;                                         // 0x0064 (size: 0x4)

}; // Size: 0x68

struct FActorComponentInstanceSourceInfo
{
    class UObject* SourceComponentTemplate;                                           // 0x0000 (size: 0x8)
    EComponentCreationMethod SourceComponentCreationMethod;                           // 0x0008 (size: 0x1)
    int32 SourceComponentTypeSerializedIndex;                                         // 0x000C (size: 0x4)

}; // Size: 0x10

struct FActorComponentTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FActorContainerID
{
    FGuid Guid;                                                                       // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FActorDataLayer
{
    FName Name;                                                                       // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FActorDesc
{
    FGuid Guid;                                                                       // 0x0000 (size: 0x10)
    UClass* NativeClass;                                                              // 0x0010 (size: 0x8)
    FSoftObjectPath Class;                                                            // 0x0018 (size: 0x20)
    FName Name;                                                                       // 0x0038 (size: 0x8)
    FName Label;                                                                      // 0x0040 (size: 0x8)
    FBox Bounds;                                                                      // 0x0048 (size: 0x38)
    FName RuntimeGrid;                                                                // 0x0080 (size: 0x8)
    bool bIsSpatiallyLoaded;                                                          // 0x0088 (size: 0x1)
    bool bActorIsEditorOnly;                                                          // 0x0089 (size: 0x1)
    FName ActorPackage;                                                               // 0x008C (size: 0x8)
    FName ActorPath;                                                                  // 0x0094 (size: 0x8)
    TArray<FSoftObjectPath> DataLayerAssets;                                          // 0x00A0 (size: 0x10)

}; // Size: 0xB0

struct FActorFolderSet
{
    TSet<UActorFolder*> ActorFolders;                                                 // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FActorInstanceData : public FInstanceCacheDataBase
{
    TSubclassOf<class AActor> ActorClass;                                             // 0x0058 (size: 0x8)

}; // Size: 0x60

struct FActorInstanceHandle
{
    TWeakObjectPtr<class UObject> ReferenceObject;                                    // 0x0000 (size: 0x8)

}; // Size: 0x20

struct FActorLocatorFragment
{
    FSoftObjectPath Path;                                                             // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FActorLocatorFragmentResolveParameter
{
    class UWorld* StreamingWorld;                                                     // 0x0000 (size: 0x8)
    FActorContainerID ContainerID;                                                    // 0x0008 (size: 0x10)
    FTopLevelAssetPath SourceAssetPath;                                               // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FActorPlacementDataLayers
{
    TArray<FName> DataLayerInstanceNames;                                             // 0x0000 (size: 0x10)
    FName ExternalDataLayerName;                                                      // 0x0010 (size: 0x8)
    FName CurrentColorizedDataLayerInstanceName;                                      // 0x0018 (size: 0x8)
    int32 ContextID;                                                                  // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FActorTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FAlphaBlend
{
    class UCurveFloat* CustomCurve;                                                   // 0x0000 (size: 0x8)
    float BlendTime;                                                                  // 0x0008 (size: 0x4)
    EAlphaBlendOption BlendOption;                                                    // 0x0024 (size: 0x1)

}; // Size: 0x30

struct FAlphaBlendArgs
{
    class UCurveFloat* CustomCurve;                                                   // 0x0000 (size: 0x8)
    float BlendTime;                                                                  // 0x0008 (size: 0x4)
    EAlphaBlendOption BlendOption;                                                    // 0x000C (size: 0x1)

}; // Size: 0x10

struct FAngularDriveConstraint
{
    FConstraintDrive TwistDrive;                                                      // 0x0000 (size: 0x10)
    FConstraintDrive SwingDrive;                                                      // 0x0010 (size: 0x10)
    FConstraintDrive SlerpDrive;                                                      // 0x0020 (size: 0x10)
    FRotator OrientationTarget;                                                       // 0x0030 (size: 0x18)
    FVector AngularVelocityTarget;                                                    // 0x0048 (size: 0x18)
    TEnumAsByte<EAngularDriveMode::Type> AngularDriveMode;                            // 0x0060 (size: 0x1)

}; // Size: 0x68

struct FAnimBlueprintConstantData
{
}; // Size: 0x1

struct FAnimBlueprintDebugData
{
}; // Size: 0x1

struct FAnimBlueprintFunction
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    FName Group;                                                                      // 0x0008 (size: 0x8)
    int32 OutputPoseNodeIndex;                                                        // 0x0010 (size: 0x4)
    TArray<FName> InputPoseNames;                                                     // 0x0018 (size: 0x10)
    TArray<int32> InputPoseNodeIndices;                                               // 0x0028 (size: 0x10)
    bool bImplemented;                                                                // 0x0070 (size: 0x1)

}; // Size: 0x78

struct FAnimBlueprintMutableData
{
}; // Size: 0x1

struct FAnimComponentSpacePoseContext : public FAnimExecutionContext
{
}; // Size: 0x10

struct FAnimCompressedCurveIndexedName
{
    FName CurveName;                                                                  // 0x0000 (size: 0x8)

}; // Size: 0xC

struct FAnimCurveBase
{
    FName CurveName;                                                                  // 0x0000 (size: 0x8)
    int32 CurveTypeFlags;                                                             // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FAnimCurveParam
{
    FName Name;                                                                       // 0x0000 (size: 0x8)

}; // Size: 0xC

struct FAnimCurveType
{
    bool bMaterial;                                                                   // 0x0000 (size: 0x1)
    bool bMorphtarget;                                                                // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FAnimDataModelNotifPayload
{
}; // Size: 0x10

struct FAnimExecutionContext
{
}; // Size: 0x10

struct FAnimGraphBlendOptions
{
    float BlendInTime;                                                                // 0x0000 (size: 0x4)
    class UBlendProfile* BlendInProfile;                                              // 0x0008 (size: 0x8)
    float BlendOutTime;                                                               // 0x0010 (size: 0x4)
    class UBlendProfile* BlendOutProfile;                                             // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FAnimGroupInfo
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    FLinearColor Color;                                                               // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FAnimGroupInstance
{
}; // Size: 0x78

struct FAnimInitializationContext : public FAnimExecutionContext
{
}; // Size: 0x10

struct FAnimInstanceLocatorFragment
{
    EAnimInstanceLocatorFragmentType Type;                                            // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FAnimInstanceProxy
{
}; // Size: 0x740

struct FAnimLinkableElement
{
    class UAnimMontage* LinkedMontage;                                                // 0x0008 (size: 0x8)
    int32 SlotIndex;                                                                  // 0x0010 (size: 0x4)
    int32 SegmentIndex;                                                               // 0x0014 (size: 0x4)
    TEnumAsByte<EAnimLinkMethod::Type> LinkMethod;                                    // 0x0018 (size: 0x1)
    TEnumAsByte<EAnimLinkMethod::Type> CachedLinkMethod;                              // 0x0019 (size: 0x1)
    float SegmentBeginTime;                                                           // 0x001C (size: 0x4)
    float SegmentLength;                                                              // 0x0020 (size: 0x4)
    float LinkValue;                                                                  // 0x0024 (size: 0x4)
    class UAnimSequenceBase* LinkedSequence;                                          // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FAnimMontageInstance
{
    class UAnimMontage* Montage;                                                      // 0x0000 (size: 0x8)
    bool bPlaying;                                                                    // 0x0038 (size: 0x1)
    float DefaultBlendTimeMultiplier;                                                 // 0x003C (size: 0x4)
    TArray<int32> NextSections;                                                       // 0x0108 (size: 0x10)
    TArray<int32> PrevSections;                                                       // 0x0118 (size: 0x10)
    TArray<FAnimNotifyEvent> ActiveStateBranchingPoints;                              // 0x0138 (size: 0x10)
    float Position;                                                                   // 0x0148 (size: 0x4)
    float PlayRate;                                                                   // 0x014C (size: 0x4)
    FAlphaBlend Blend;                                                                // 0x0150 (size: 0x30)
    int32 DisableRootMotionCount;                                                     // 0x01B4 (size: 0x4)

}; // Size: 0x1D8

struct FAnimNodeConstantData
{
    TScriptInterface<class IAnimClassInterface> AnimClassInterface;                   // 0x0000 (size: 0x10)
    int32 NodeIndex;                                                                  // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FAnimNodeData
{
    TScriptInterface<class IAnimClassInterface> AnimClassInterface;                   // 0x0000 (size: 0x10)
    TArray<uint32> Entries;                                                           // 0x0010 (size: 0x10)
    int32 NodeIndex;                                                                  // 0x0020 (size: 0x4)
    uint32 Flags;                                                                     // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FAnimNodeExposedValueHandler
{
}; // Size: 0x8

struct FAnimNodeExposedValueHandler_Base : public FAnimNodeExposedValueHandler
{
    class UFunction* Function;                                                        // 0x0008 (size: 0x8)
    FName BoundFunction;                                                              // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FAnimNodeExposedValueHandler_PropertyAccess : public FAnimNodeExposedValueHandler_Base
{
    TArray<FExposedValueCopyRecord> CopyRecords;                                      // 0x0018 (size: 0x10)

}; // Size: 0x30

struct FAnimNodeFunctionRef
{
    FName ClassName;                                                                  // 0x0000 (size: 0x8)
    FName FunctionName;                                                               // 0x0008 (size: 0x8)
    UClass* Class;                                                                    // 0x0010 (size: 0x8)
    class UFunction* Function;                                                        // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FAnimNodeReference
{
}; // Size: 0x10

struct FAnimNodeStructData
{
    TMap<FName, int32> NameToIndexMap;                                                // 0x0000 (size: 0x50)
    int32 NumProperties;                                                              // 0x0050 (size: 0x4)

}; // Size: 0x58

struct FAnimNode_ApplyMeshSpaceAdditive : public FAnimNode_Base
{
    FPoseLink base;                                                                   // 0x0010 (size: 0x10)
    FPoseLink Additive;                                                               // 0x0020 (size: 0x10)
    EAnimAlphaInputType AlphaInputType;                                               // 0x0030 (size: 0x1)
    float Alpha;                                                                      // 0x0034 (size: 0x4)
    uint8 bAlphaBoolEnabled;                                                          // 0x0038 (size: 0x1)
    FInputAlphaBoolBlend AlphaBoolBlend;                                              // 0x0040 (size: 0x48)
    FName AlphaCurveName;                                                             // 0x0088 (size: 0x8)
    FInputScaleBias AlphaScaleBias;                                                   // 0x0090 (size: 0x8)
    FInputScaleBiasClamp AlphaScaleBiasClamp;                                         // 0x0098 (size: 0x30)
    int32 LODThreshold;                                                               // 0x00C8 (size: 0x4)

}; // Size: 0xD0

struct FAnimNode_AssetPlayerBase : public FAnimNode_AssetPlayerRelevancyBase
{
    float BlendWeight;                                                                // 0x0020 (size: 0x4)
    float InternalTimeAccumulator;                                                    // 0x0024 (size: 0x4)

}; // Size: 0x38

struct FAnimNode_AssetPlayerRelevancyBase : public FAnimNode_Base
{
}; // Size: 0x10

struct FAnimNode_Base
{
}; // Size: 0x10

struct FAnimNode_ConvertComponentToLocalSpace : public FAnimNode_Base
{
    FComponentSpacePoseLink ComponentPose;                                            // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FAnimNode_ConvertLocalToComponentSpace : public FAnimNode_Base
{
    FPoseLink LocalPose;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FAnimNode_CustomProperty : public FAnimNode_Base
{
    TArray<FName> SourcePropertyNames;                                                // 0x0010 (size: 0x10)
    TArray<FName> DestPropertyNames;                                                  // 0x0020 (size: 0x10)
    class UObject* TargetInstance;                                                    // 0x0030 (size: 0x8)

}; // Size: 0x58

struct FAnimNode_DeadBlending : public FAnimNode_Base
{
    FPoseLink Source;                                                                 // 0x0018 (size: 0x10)
    bool bAlwaysUseDefaultBlendSettings;                                              // 0x0028 (size: 0x1)
    float DefaultBlendDuration;                                                       // 0x002C (size: 0x4)
    class UBlendProfile* DefaultBlendProfile;                                         // 0x0030 (size: 0x8)
    EAlphaBlendOption DefaultBlendMode;                                               // 0x0038 (size: 0x1)
    class UCurveFloat* DefaultCustomBlendCurve;                                       // 0x0040 (size: 0x8)
    float BlendTimeMultiplier;                                                        // 0x0048 (size: 0x4)
    bool bLinearlyInterpolateScales;                                                  // 0x004C (size: 0x1)
    TArray<FName> FilteredCurves;                                                     // 0x0050 (size: 0x10)
    TArray<FName> ExtrapolationFilteredCurves;                                        // 0x0060 (size: 0x10)
    TArray<FBoneReference> FilteredBones;                                             // 0x0070 (size: 0x10)
    float ExtrapolationHalfLife;                                                      // 0x0080 (size: 0x4)
    float ExtrapolationHalfLifeMin;                                                   // 0x0084 (size: 0x4)
    float ExtrapolationHalfLifeMax;                                                   // 0x0088 (size: 0x4)
    float MaximumTranslationVelocity;                                                 // 0x008C (size: 0x4)
    float MaximumRotationVelocity;                                                    // 0x0090 (size: 0x4)
    float MaximumScaleVelocity;                                                       // 0x0094 (size: 0x4)
    float MaximumCurveVelocity;                                                       // 0x0098 (size: 0x4)
    bool bResetOnBecomingRelevant;                                                    // 0x009C (size: 0x1)
    TArray<FInertializationRequest> RequestQueue;                                     // 0x02D0 (size: 0x10)
    class UCurveFloat* InertializationCustomBlendCurve;                               // 0x0548 (size: 0x8)
    class UObject* InertializationRequestAnimInstance;                                // 0x0568 (size: 0x8)

}; // Size: 0x570

struct FAnimNode_Inertialization : public FAnimNode_Base
{
    FPoseLink Source;                                                                 // 0x0018 (size: 0x10)
    class UBlendProfile* DefaultBlendProfile;                                         // 0x0028 (size: 0x8)
    TArray<FName> FilteredCurves;                                                     // 0x0030 (size: 0x10)
    TArray<FBoneReference> FilteredBones;                                             // 0x0040 (size: 0x10)
    bool bResetOnBecomingRelevant;                                                    // 0x0050 (size: 0x1)
    bool bForwardRequestsThroughSkippedCachedPoseNodes;                               // 0x0051 (size: 0x1)
    TArray<FInertializationRequest> RequestQueue;                                     // 0x0228 (size: 0x10)
    class UObject* InertializationRequestAnimInstance;                                // 0x0438 (size: 0x8)

}; // Size: 0x440

struct FAnimNode_LinkedAnimGraph : public FAnimNode_CustomProperty
{
    TArray<FPoseLink> InputPoses;                                                     // 0x0058 (size: 0x10)
    TArray<FName> InputPoseNames;                                                     // 0x0068 (size: 0x10)
    TSubclassOf<class UAnimInstance> InstanceClass;                                   // 0x0078 (size: 0x8)
    class UBlendProfile* PendingBlendOutProfile;                                      // 0x0098 (size: 0x8)
    class UBlendProfile* PendingBlendInProfile;                                       // 0x00A8 (size: 0x8)
    uint8 bReceiveNotifiesFromLinkedInstances;                                        // 0x00B0 (size: 0x1)
    uint8 bPropagateNotifiesToLinkedInstances;                                        // 0x00B0 (size: 0x1)

}; // Size: 0xB8

struct FAnimNode_LinkedAnimLayer : public FAnimNode_LinkedAnimGraph
{
    TSubclassOf<class UAnimLayerInterface> Interface;                                 // 0x00B8 (size: 0x8)
    FName Layer;                                                                      // 0x00C0 (size: 0x8)

}; // Size: 0xC8

struct FAnimNode_LinkedInputPose : public FAnimNode_Base
{
    FName Name;                                                                       // 0x0010 (size: 0x8)
    FName Graph;                                                                      // 0x0018 (size: 0x8)
    FPoseLink InputPose;                                                              // 0x0020 (size: 0x10)

}; // Size: 0xB8

struct FAnimNode_Root : public FAnimNode_Base
{
    FPoseLink Result;                                                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FAnimNode_SaveCachedPose : public FAnimNode_Base
{
    FPoseLink Pose;                                                                   // 0x0010 (size: 0x10)
    FName CachePoseName;                                                              // 0x0020 (size: 0x8)

}; // Size: 0x80

struct FAnimNode_SequencePlayer : public FAnimNode_SequencePlayerBase
{
    class UAnimSequenceBase* Sequence;                                                // 0x0040 (size: 0x8)

}; // Size: 0x48

struct FAnimNode_SequencePlayerBase : public FAnimNode_AssetPlayerBase
{
    FInputScaleBiasClampState PlayRateScaleBiasClampState;                            // 0x0038 (size: 0x8)

}; // Size: 0x40

struct FAnimNode_SequencePlayer_Standalone : public FAnimNode_SequencePlayerBase
{
    FName GroupName;                                                                  // 0x0040 (size: 0x8)
    TEnumAsByte<EAnimGroupRole::Type> GroupRole;                                      // 0x0048 (size: 0x1)
    EAnimSyncMethod Method;                                                           // 0x0049 (size: 0x1)
    bool bIgnoreForRelevancyTest;                                                     // 0x004A (size: 0x1)
    class UAnimSequenceBase* Sequence;                                                // 0x0050 (size: 0x8)
    float PlayRateBasis;                                                              // 0x0058 (size: 0x4)
    float PlayRate;                                                                   // 0x005C (size: 0x4)
    FInputScaleBiasClampConstants PlayRateScaleBiasClampConstants;                    // 0x0060 (size: 0x2C)
    float StartPosition;                                                              // 0x008C (size: 0x4)
    bool bLoopAnimation;                                                              // 0x0090 (size: 0x1)
    bool bStartFromMatchingPose;                                                      // 0x0091 (size: 0x1)

}; // Size: 0x98

struct FAnimNode_SingleNode : public FAnimNode_Base
{
    FPoseLink SourcePose;                                                             // 0x0010 (size: 0x10)

}; // Size: 0x30

struct FAnimNode_StateMachine : public FAnimNode_Base
{
    int32 StateMachineIndexInClass;                                                   // 0x0010 (size: 0x4)
    int32 MaxTransitionsPerFrame;                                                     // 0x0014 (size: 0x4)
    int32 MaxTransitionsRequests;                                                     // 0x0018 (size: 0x4)
    bool bSkipFirstUpdateTransition;                                                  // 0x001C (size: 0x1)
    bool bReinitializeOnBecomingRelevant;                                             // 0x001D (size: 0x1)
    bool bCreateNotifyMetaData;                                                       // 0x001E (size: 0x1)
    bool bAllowConduitEntryStates;                                                    // 0x001F (size: 0x1)

}; // Size: 0xC8

struct FAnimNode_StateResult : public FAnimNode_Root
{
}; // Size: 0x20

struct FAnimNode_TransitionPoseEvaluator : public FAnimNode_Base
{
    int32 FramesToCachePose;                                                          // 0x0088 (size: 0x4)
    TEnumAsByte<EEvaluatorDataSource::Type> DataSource;                               // 0x0090 (size: 0x1)
    TEnumAsByte<EEvaluatorMode::Type> EvaluatorMode;                                  // 0x0091 (size: 0x1)

}; // Size: 0xA8

struct FAnimNode_TransitionResult : public FAnimNode_Base
{
    bool bCanEnterTransition;                                                         // 0x0010 (size: 0x1)

}; // Size: 0x28

struct FAnimNode_UseCachedPose : public FAnimNode_Base
{
    FPoseLink LinkToCachingNode;                                                      // 0x0010 (size: 0x10)
    FName CachePoseName;                                                              // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FAnimNotifyArray
{
    TArray<FAnimNotifyEventReference> Notifies;                                       // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FAnimNotifyContext
{
}; // Size: 0x18

struct FAnimNotifyEvent : public FAnimLinkableElement
{
    float TriggerTimeOffset;                                                          // 0x0030 (size: 0x4)
    float EndTriggerTimeOffset;                                                       // 0x0034 (size: 0x4)
    float TriggerWeightThreshold;                                                     // 0x0038 (size: 0x4)
    FName NotifyName;                                                                 // 0x003C (size: 0x8)
    class UAnimNotify* Notify;                                                        // 0x0048 (size: 0x8)
    class UAnimNotifyState* NotifyStateClass;                                         // 0x0050 (size: 0x8)
    float Duration;                                                                   // 0x0058 (size: 0x4)
    FAnimLinkableElement EndLink;                                                     // 0x0060 (size: 0x30)
    bool bConvertedFromBranchingPoint;                                                // 0x0090 (size: 0x1)
    TEnumAsByte<EMontageNotifyTickType::Type> MontageTickType;                        // 0x0091 (size: 0x1)
    float NotifyTriggerChance;                                                        // 0x0094 (size: 0x4)
    TEnumAsByte<ENotifyFilterType::Type> NotifyFilterType;                            // 0x0098 (size: 0x1)
    int32 NotifyFilterLOD;                                                            // 0x009C (size: 0x4)
    bool bCanBeFilteredViaRequest;                                                    // 0x00A0 (size: 0x1)
    bool bTriggerOnDedicatedServer;                                                   // 0x00A1 (size: 0x1)
    bool bTriggerOnFollower;                                                          // 0x00A2 (size: 0x1)
    int32 TrackIndex;                                                                 // 0x00A4 (size: 0x4)

}; // Size: 0xB8

struct FAnimNotifyEventReference
{
    class UMirrorDataTable* MirrorTable;                                              // 0x0018 (size: 0x8)
    class UObject* NotifySource;                                                      // 0x0020 (size: 0x8)

}; // Size: 0x30

struct FAnimNotifyQueue
{
    TArray<FAnimNotifyEventReference> AnimNotifies;                                   // 0x0010 (size: 0x10)
    TMap<class FName, class FAnimNotifyArray> UnfilteredMontageAnimNotifies;          // 0x0020 (size: 0x50)

}; // Size: 0x70

struct FAnimNotifyTrack
{
    FName TrackName;                                                                  // 0x0000 (size: 0x8)
    FLinearColor TrackColor;                                                          // 0x0008 (size: 0x10)

}; // Size: 0x38

struct FAnimParentNodeAssetOverride
{
    class UAnimationAsset* NewAsset;                                                  // 0x0000 (size: 0x8)
    FGuid ParentNodeGuid;                                                             // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FAnimPoseContext : public FAnimExecutionContext
{
}; // Size: 0x10

struct FAnimSegment
{
    class UAnimSequenceBase* AnimReference;                                           // 0x0000 (size: 0x8)
    float StartPos;                                                                   // 0x0008 (size: 0x4)
    float AnimStartTime;                                                              // 0x000C (size: 0x4)
    float AnimEndTime;                                                                // 0x0010 (size: 0x4)
    float AnimPlayRate;                                                               // 0x0014 (size: 0x4)
    int32 LoopingCount;                                                               // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FAnimSequenceTrackContainer
{
    TArray<FRawAnimSequenceTrack> AnimationTracks;                                    // 0x0000 (size: 0x10)
    TArray<FName> TrackNames;                                                         // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FAnimSetMeshLinkup
{
    TArray<int32> BoneToTrackTable;                                                   // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FAnimSingleNodeInstanceProxy : public FAnimInstanceProxy
{
}; // Size: 0x840

struct FAnimSlotDesc
{
    FName SlotName;                                                                   // 0x0000 (size: 0x8)
    int32 NumChannels;                                                                // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FAnimSlotGroup
{
    FName GroupName;                                                                  // 0x0000 (size: 0x8)
    TArray<FName> SlotNames;                                                          // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FAnimSubsystem
{
}; // Size: 0x8

struct FAnimSubsystemInstance
{
}; // Size: 0x8

struct FAnimSubsystemInstance_NodeRelevancy : public FAnimSubsystemInstance
{
}; // Size: 0xA8

struct FAnimSubsystem_Base : public FAnimSubsystem
{
}; // Size: 0x18

struct FAnimSubsystem_BlendSpaceGraph : public FAnimSubsystem
{
    TArray<class UBlendSpace*> BlendSpaces;                                           // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FAnimSubsystem_PropertyAccess : public FAnimSubsystem
{
    FPropertyAccessLibrary Library;                                                   // 0x0008 (size: 0x78)

}; // Size: 0x80

struct FAnimSubsystem_SharedLinkedAnimLayers : public FAnimSubsystemInstance
{
    TArray<FLinkedAnimLayerClassData> ClassesData;                                    // 0x0008 (size: 0x10)
    TArray<class TSubclassOf<UAnimInstance>> PersistentClasses;                       // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FAnimSubsystem_Tag : public FAnimSubsystem
{
    TMap<FName, int32> NodeIndices;                                                   // 0x0008 (size: 0x50)

}; // Size: 0x60

struct FAnimSyncMarker
{
    FName MarkerName;                                                                 // 0x0000 (size: 0x8)
    float Time;                                                                       // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FAnimTickRecord
{
    class UAnimationAsset* SourceAsset;                                               // 0x0000 (size: 0x8)

}; // Size: 0x70

struct FAnimTrack
{
    TArray<FAnimSegment> AnimSegments;                                                // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FAnimUpdateContext : public FAnimExecutionContext
{
}; // Size: 0x10

struct FAnimUpdateRateParameters
{
    EUpdateRateShiftBucket ShiftBucket;                                               // 0x0001 (size: 0x1)
    uint8 bInterpolateSkippedFrames;                                                  // 0x0002 (size: 0x1)
    uint8 bShouldUseLodMap;                                                           // 0x0002 (size: 0x1)
    uint8 bShouldUseMinLod;                                                           // 0x0002 (size: 0x1)
    uint8 bSkipUpdate;                                                                // 0x0002 (size: 0x1)
    uint8 bSkipEvaluation;                                                            // 0x0002 (size: 0x1)
    int32 UpdateRate;                                                                 // 0x0004 (size: 0x4)
    int32 EvaluationRate;                                                             // 0x0008 (size: 0x4)
    float TickedPoseOffestTime;                                                       // 0x000C (size: 0x4)
    float AdditionalTime;                                                             // 0x0010 (size: 0x4)
    int32 BaseNonRenderedUpdateRate;                                                  // 0x0018 (size: 0x4)
    int32 MaxEvalRateForInterpolation;                                                // 0x001C (size: 0x4)
    TArray<float> BaseVisibleDistanceFactorThesholds;                                 // 0x0020 (size: 0x10)
    TMap<int32, int32> LODToFrameSkipMap;                                             // 0x0030 (size: 0x50)
    int32 SkippedUpdateFrames;                                                        // 0x0080 (size: 0x4)
    int32 SkippedEvalFrames;                                                          // 0x0084 (size: 0x4)

}; // Size: 0x88

struct FAnimatedBoneAttribute
{
    FAnimationAttributeIdentifier Identifier;                                         // 0x0000 (size: 0x40)
    FAttributeCurve Curve;                                                            // 0x0040 (size: 0xB0)

}; // Size: 0xF0

struct FAnimationActiveTransitionEntry
{
    class UBlendProfile* BlendProfile;                                                // 0x00B8 (size: 0x8)

}; // Size: 0xC8

struct FAnimationAttributeIdentifier
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    FName BoneName;                                                                   // 0x0008 (size: 0x8)
    int32 BoneIndex;                                                                  // 0x0010 (size: 0x4)
    class UScriptStruct* ScriptStruct;                                                // 0x0018 (size: 0x8)
    FSoftObjectPath ScriptStructPath;                                                 // 0x0020 (size: 0x20)

}; // Size: 0x40

struct FAnimationCurveData
{
    TArray<FFloatCurve> FloatCurves;                                                  // 0x0000 (size: 0x10)
    TArray<FTransformCurve> TransformCurves;                                          // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FAnimationCurveIdentifier
{
    FName CurveName;                                                                  // 0x0000 (size: 0x8)
    ERawCurveTrackTypes CurveType;                                                    // 0x0008 (size: 0x1)
    ETransformCurveChannel Channel;                                                   // 0x0009 (size: 0x1)
    EVectorCurveChannel Axis;                                                         // 0x000A (size: 0x1)

}; // Size: 0xC

struct FAnimationErrorStats
{
}; // Size: 0x10

struct FAnimationFrameSnapshot
{
}; // Size: 0x1

struct FAnimationGroupReference
{
    EAnimSyncMethod Method;                                                           // 0x0000 (size: 0x1)
    FName GroupName;                                                                  // 0x0004 (size: 0x8)
    TEnumAsByte<EAnimGroupRole::Type> GroupRole;                                      // 0x000C (size: 0x1)

}; // Size: 0x10

struct FAnimationPotentialTransition
{
}; // Size: 0x30

struct FAnimationRecordingSettings
{
    bool bRecordInWorldSpace;                                                         // 0x0000 (size: 0x1)
    bool bRemoveRootAnimation;                                                        // 0x0001 (size: 0x1)
    bool bAutoSaveAsset;                                                              // 0x0002 (size: 0x1)
    FFrameRate SampleFrameRate;                                                       // 0x0004 (size: 0x8)
    float Length;                                                                     // 0x000C (size: 0x4)
    EAnimInterpolationType Interpolation;                                             // 0x0010 (size: 0x1)
    TEnumAsByte<ERichCurveInterpMode> InterpMode;                                     // 0x0011 (size: 0x1)
    TEnumAsByte<ERichCurveTangentMode> TangentMode;                                   // 0x0012 (size: 0x1)
    bool bRecordTransforms;                                                           // 0x0014 (size: 0x1)
    bool bRecordMorphTargets;                                                         // 0x0015 (size: 0x1)
    bool bRecordAttributeCurves;                                                      // 0x0016 (size: 0x1)
    bool bRecordMaterialCurves;                                                       // 0x0017 (size: 0x1)
    bool bTransactRecording;                                                          // 0x0018 (size: 0x1)
    TArray<FString> IncludeAnimationNames;                                            // 0x0020 (size: 0x10)
    TArray<FString> ExcludeAnimationNames;                                            // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FAnimationState : public FAnimationStateBase
{
    TArray<FAnimationTransitionRule> Transitions;                                     // 0x0008 (size: 0x10)
    int32 StateRootNodeIndex;                                                         // 0x0018 (size: 0x4)
    int32 StartNotify;                                                                // 0x001C (size: 0x4)
    int32 EndNotify;                                                                  // 0x0020 (size: 0x4)
    int32 FullyBlendedNotify;                                                         // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FAnimationStateBase
{
    FName StateName;                                                                  // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FAnimationTrackAddedPayload : public FAnimationTrackPayload
{
    int32 TrackIndex;                                                                 // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FAnimationTrackPayload : public FEmptyPayload
{
    FName Name;                                                                       // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FAnimationTransitionBetweenStates : public FAnimationStateBase
{
    int32 PreviousState;                                                              // 0x0008 (size: 0x4)
    int32 NextState;                                                                  // 0x000C (size: 0x4)
    float CrossfadeDuration;                                                          // 0x0010 (size: 0x4)
    int32 StartNotify;                                                                // 0x0014 (size: 0x4)
    int32 EndNotify;                                                                  // 0x0018 (size: 0x4)
    int32 InterruptNotify;                                                            // 0x001C (size: 0x4)
    EAlphaBlendOption BlendMode;                                                      // 0x0020 (size: 0x1)
    class UCurveFloat* CustomCurve;                                                   // 0x0028 (size: 0x8)
    class UBlendProfile* BlendProfile;                                                // 0x0030 (size: 0x8)
    TEnumAsByte<ETransitionLogicType::Type> LogicType;                                // 0x0038 (size: 0x1)

}; // Size: 0x40

struct FAnimationTransitionRule
{
    FName RuleToExecute;                                                              // 0x0000 (size: 0x8)
    bool TransitionReturnVal;                                                         // 0x0008 (size: 0x1)
    int32 TransitionIndex;                                                            // 0x000C (size: 0x4)

}; // Size: 0x10

struct FAssetCompileData
{
    TWeakObjectPtr<class UObject> Asset;                                              // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FAssetEditorOrbitCameraPosition
{
    bool bIsSet;                                                                      // 0x0000 (size: 0x1)
    FVector CamOrbitPoint;                                                            // 0x0008 (size: 0x18)
    FVector CamOrbitZoom;                                                             // 0x0020 (size: 0x18)
    FRotator CamOrbitRotation;                                                        // 0x0038 (size: 0x18)

}; // Size: 0x50

struct FAssetImportInfo
{
}; // Size: 0x1

struct FAssetLocatorFragment
{
    FTopLevelAssetPath Path;                                                          // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FAssetManagerRedirect
{
    FString Old;                                                                      // 0x0000 (size: 0x10)
    FString New;                                                                      // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FAssetManagerSearchRules
{
    TArray<FString> AssetScanPaths;                                                   // 0x0000 (size: 0x10)
    TArray<FString> IncludePatterns;                                                  // 0x0010 (size: 0x10)
    TArray<FString> ExcludePatterns;                                                  // 0x0020 (size: 0x10)
    UClass* AssetBaseClass;                                                           // 0x0030 (size: 0x8)
    bool bHasBlueprintClasses;                                                        // 0x0038 (size: 0x1)
    bool bForceSynchronousScan;                                                       // 0x0039 (size: 0x1)
    bool bSkipVirtualPathExpansion;                                                   // 0x003A (size: 0x1)
    bool bSkipManagerIncludeCheck;                                                    // 0x003B (size: 0x1)

}; // Size: 0x50

struct FAssetMapping
{
    class UAnimationAsset* SourceAsset;                                               // 0x0000 (size: 0x8)
    class UAnimationAsset* TargetAsset;                                               // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FAsyncPhysicsTimestamp
{
    int32 ServerFrame;                                                                // 0x0000 (size: 0x4)
    int32 LocalFrame;                                                                 // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FAttenuationSubmixSendSettings : public FSoundSubmixSendInfoBase
{
}; // Size: 0xB0

struct FAttributeCurve : public FIndexedCurve
{
    TArray<FAttributeKey> keys;                                                       // 0x0068 (size: 0x10)
    FSoftObjectPath ScriptStructPath;                                                 // 0x0078 (size: 0x20)
    class UScriptStruct* ScriptStruct;                                                // 0x0098 (size: 0x8)
    bool bShouldInterpolate;                                                          // 0x00A0 (size: 0x1)

}; // Size: 0xB0

struct FAttributeKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)

}; // Size: 0x18

struct FAttributePayload : public FEmptyPayload
{
    FAnimationAttributeIdentifier Identifier;                                         // 0x0000 (size: 0x40)

}; // Size: 0x40

struct FAudioBasedVibrationData
{
    class USoundBase* Sound;                                                          // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FAudioComponentParam : public FAudioParameter
{
    class USoundWave* SoundWaveParam;                                                 // 0x00A0 (size: 0x8)

}; // Size: 0xA8

struct FAudioEQEffect : public FAudioEffectParameters
{
    float FrequencyCenter0;                                                           // 0x0010 (size: 0x4)
    float Gain0;                                                                      // 0x0014 (size: 0x4)
    float Bandwidth0;                                                                 // 0x0018 (size: 0x4)
    float FrequencyCenter1;                                                           // 0x001C (size: 0x4)
    float Gain1;                                                                      // 0x0020 (size: 0x4)
    float Bandwidth1;                                                                 // 0x0024 (size: 0x4)
    float FrequencyCenter2;                                                           // 0x0028 (size: 0x4)
    float Gain2;                                                                      // 0x002C (size: 0x4)
    float Bandwidth2;                                                                 // 0x0030 (size: 0x4)
    float FrequencyCenter3;                                                           // 0x0034 (size: 0x4)
    float Gain3;                                                                      // 0x0038 (size: 0x4)
    float Bandwidth3;                                                                 // 0x003C (size: 0x4)

}; // Size: 0x40

struct FAudioEffectParameters
{
}; // Size: 0x8

struct FAudioQualitySettings
{
    FText DisplayName;                                                                // 0x0000 (size: 0x10)
    int32 MaxChannels;                                                                // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FAudioReverbEffect : public FAudioEffectParameters
{
}; // Size: 0x48

struct FAudioVolumeSubmixOverrideSettings
{
    class USoundSubmix* Submix;                                                       // 0x0000 (size: 0x8)
    TArray<class USoundEffectSubmixPreset*> SubmixEffectChain;                        // 0x0008 (size: 0x10)
    float CrossfadeTime;                                                              // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FAudioVolumeSubmixSendSettings
{
    EAudioVolumeLocationState ListenerLocationState;                                  // 0x0000 (size: 0x1)
    EAudioVolumeLocationState SourceLocationState;                                    // 0x0001 (size: 0x1)
    TArray<FSoundSubmixSendInfo> SubmixSends;                                         // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FAutoCompleteNode
{
    int32 IndexChar;                                                                  // 0x0000 (size: 0x4)
    TArray<int32> AutoCompleteListIndices;                                            // 0x0008 (size: 0x10)

}; // Size: 0x28

struct FBPComponentClassOverride
{
    FName ComponentName;                                                              // 0x0000 (size: 0x8)
    UClass* ComponentClass;                                                           // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FBPEditorBookmarkNode
{
    FGuid NodeGuid;                                                                   // 0x0000 (size: 0x10)
    FGuid ParentGuid;                                                                 // 0x0010 (size: 0x10)
    FText DisplayName;                                                                // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FBPInterfaceDescription
{
    TSubclassOf<class UInterface> Interface;                                          // 0x0000 (size: 0x8)
    TArray<class UEdGraph*> Graphs;                                                   // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FBPVariableDescription
{
    FName VarName;                                                                    // 0x0000 (size: 0x8)
    FGuid VarGuid;                                                                    // 0x0008 (size: 0x10)
    FEdGraphPinType VarType;                                                          // 0x0018 (size: 0x58)
    FString FriendlyName;                                                             // 0x0070 (size: 0x10)
    FText Category;                                                                   // 0x0080 (size: 0x10)
    uint64 PropertyFlags;                                                             // 0x0090 (size: 0x8)
    FName RepNotifyFunc;                                                              // 0x0098 (size: 0x8)
    TEnumAsByte<ELifetimeCondition> ReplicationCondition;                             // 0x00A0 (size: 0x1)
    TArray<FBPVariableMetaDataEntry> MetaDataArray;                                   // 0x00A8 (size: 0x10)
    FString DefaultValue;                                                             // 0x00B8 (size: 0x10)

}; // Size: 0xC8

struct FBPVariableMetaDataEntry
{
    FName DataKey;                                                                    // 0x0000 (size: 0x8)
    FString DataValue;                                                                // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FBakedAnimationState
{
    FName StateName;                                                                  // 0x0000 (size: 0x8)
    TArray<FBakedStateExitTransition> Transitions;                                    // 0x0008 (size: 0x10)
    int32 StateRootNodeIndex;                                                         // 0x0018 (size: 0x4)
    int32 StartNotify;                                                                // 0x001C (size: 0x4)
    int32 EndNotify;                                                                  // 0x0020 (size: 0x4)
    int32 FullyBlendedNotify;                                                         // 0x0024 (size: 0x4)
    bool bIsAConduit;                                                                 // 0x0028 (size: 0x1)
    int32 EntryRuleNodeIndex;                                                         // 0x002C (size: 0x4)
    TArray<int32> PlayerNodeIndices;                                                  // 0x0030 (size: 0x10)
    TArray<int32> LayerNodeIndices;                                                   // 0x0040 (size: 0x10)
    bool bAlwaysResetOnEntry;                                                         // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FBakedAnimationStateMachine
{
    FName MachineName;                                                                // 0x0000 (size: 0x8)
    int32 InitialState;                                                               // 0x0008 (size: 0x4)
    TArray<FBakedAnimationState> States;                                              // 0x0010 (size: 0x10)
    TArray<FAnimationTransitionBetweenStates> Transitions;                            // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FBakedCustomAttributePerBoneData
{
}; // Size: 0x1

struct FBakedFloatCustomAttribute
{
}; // Size: 0x1

struct FBakedIntegerCustomAttribute
{
}; // Size: 0x1

struct FBakedStateExitTransition
{
    int32 CanTakeDelegateIndex;                                                       // 0x0000 (size: 0x4)
    int32 CustomResultNodeIndex;                                                      // 0x0004 (size: 0x4)
    int32 TransitionIndex;                                                            // 0x0008 (size: 0x4)
    bool bDesiredTransitionReturnValue;                                               // 0x000C (size: 0x1)
    bool bAutomaticRemainingTimeRule;                                                 // 0x000D (size: 0x1)
    float AutomaticRuleTriggerTime;                                                   // 0x0010 (size: 0x4)
    FName SyncGroupNameToRequireValidMarkersRule;                                     // 0x0014 (size: 0x8)
    TArray<int32> PoseEvaluatorLinks;                                                 // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FBakedStringCustomAttribute
{
}; // Size: 0x1

struct FBandwidthTestGenerator
{
    TArray<FBandwidthTestItem> ReplicatedBuffers;                                     // 0x0000 (size: 0x10)

}; // Size: 0x20

struct FBandwidthTestItem
{
    TArray<uint8> Kilobyte;                                                           // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FBaseAttenuationSettings
{
    EAttenuationDistanceModel DistanceAlgorithm;                                      // 0x0008 (size: 0x1)
    TEnumAsByte<EAttenuationShape::Type> AttenuationShape;                            // 0x0009 (size: 0x1)
    ENaturalSoundFalloffMode FalloffMode;                                             // 0x000A (size: 0x1)
    float dBAttenuationAtMax;                                                         // 0x000C (size: 0x4)
    FVector AttenuationShapeExtents;                                                  // 0x0010 (size: 0x18)
    float ConeOffset;                                                                 // 0x0028 (size: 0x4)
    float FalloffDistance;                                                            // 0x002C (size: 0x4)
    float ConeSphereRadius;                                                           // 0x0030 (size: 0x4)
    float ConeSphereFalloffDistance;                                                  // 0x0034 (size: 0x4)
    FRuntimeFloatCurve CustomAttenuationCurve;                                        // 0x0038 (size: 0x88)

}; // Size: 0xC0

struct FBaseComponentReference
{
    FName ComponentProperty;                                                          // 0x0000 (size: 0x8)
    FString PathToComponent;                                                          // 0x0008 (size: 0x10)

}; // Size: 0x20

struct FBasedMovementInfo
{
    uint16 BaseID;                                                                    // 0x0000 (size: 0x2)
    class UPrimitiveComponent* MovementBase;                                          // 0x0008 (size: 0x8)
    FName BoneName;                                                                   // 0x0010 (size: 0x8)
    FVector_NetQuantize100 Location;                                                  // 0x0018 (size: 0x18)
    FRotator Rotation;                                                                // 0x0030 (size: 0x18)
    bool bServerHasBaseComponent;                                                     // 0x0048 (size: 0x1)
    bool bRelativeRotation;                                                           // 0x0049 (size: 0x1)
    bool bServerHasVelocity;                                                          // 0x004A (size: 0x1)

}; // Size: 0x50

struct FBasedPosition
{
    class AActor* base;                                                               // 0x0000 (size: 0x8)
    FVector Position;                                                                 // 0x0008 (size: 0x18)
    FVector CachedBaseLocation;                                                       // 0x0020 (size: 0x18)
    FRotator CachedBaseRotation;                                                      // 0x0038 (size: 0x18)
    FVector CachedTransPosition;                                                      // 0x0050 (size: 0x18)

}; // Size: 0x68

struct FBatchedLine
{
    FVector Start;                                                                    // 0x0000 (size: 0x18)
    FVector End;                                                                      // 0x0018 (size: 0x18)
    FLinearColor Color;                                                               // 0x0030 (size: 0x10)
    float Thickness;                                                                  // 0x0040 (size: 0x4)
    float RemainingLifeTime;                                                          // 0x0044 (size: 0x4)
    uint8 DepthPriority;                                                              // 0x0048 (size: 0x1)
    uint32 BatchID;                                                                   // 0x004C (size: 0x4)

}; // Size: 0x50

struct FBatchedPoint
{
    FVector Position;                                                                 // 0x0000 (size: 0x18)
    FLinearColor Color;                                                               // 0x0018 (size: 0x10)
    float PointSize;                                                                  // 0x0028 (size: 0x4)
    float RemainingLifeTime;                                                          // 0x002C (size: 0x4)
    uint8 DepthPriority;                                                              // 0x0030 (size: 0x1)
    uint32 BatchID;                                                                   // 0x0034 (size: 0x4)

}; // Size: 0x38

struct FBeamModifierOptions
{
    uint8 bModify;                                                                    // 0x0000 (size: 0x1)
    uint8 bScale;                                                                     // 0x0000 (size: 0x1)
    uint8 bLock;                                                                      // 0x0000 (size: 0x1)

}; // Size: 0x4

struct FBeamTargetData
{
    FName TargetName;                                                                 // 0x0000 (size: 0x8)
    float TargetPercentage;                                                           // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FBlendFilter
{
}; // Size: 0x10

struct FBlendParameter
{
    FString DisplayName;                                                              // 0x0000 (size: 0x10)
    float Min;                                                                        // 0x0010 (size: 0x4)
    float Max;                                                                        // 0x0014 (size: 0x4)
    int32 GridNum;                                                                    // 0x0018 (size: 0x4)
    bool bSnapToGrid;                                                                 // 0x001C (size: 0x1)
    bool bWrapInput;                                                                  // 0x001D (size: 0x1)

}; // Size: 0x20

struct FBlendProfileBoneEntry
{
    FBoneReference BoneReference;                                                     // 0x0000 (size: 0x10)
    float BlendScale;                                                                 // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FBlendSample
{
    class UAnimSequence* Animation;                                                   // 0x0000 (size: 0x8)
    FVector SampleValue;                                                              // 0x0008 (size: 0x18)
    float RateScale;                                                                  // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FBlendSampleData
{
    int32 SampleDataIndex;                                                            // 0x0000 (size: 0x4)
    class UAnimSequence* Animation;                                                   // 0x0008 (size: 0x8)
    float TotalWeight;                                                                // 0x0010 (size: 0x4)
    float WeightRate;                                                                 // 0x0014 (size: 0x4)
    float Time;                                                                       // 0x0018 (size: 0x4)
    float PreviousTime;                                                               // 0x001C (size: 0x4)
    float SamplePlayRate;                                                             // 0x0020 (size: 0x4)

}; // Size: 0x60

struct FBlendSpaceBlendProfile
{
    class UBlendProfile* BlendProfile;                                                // 0x0000 (size: 0x8)
    float TargetWeightInterpolationSpeedPerSec;                                       // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FBlendSpaceData
{
    TArray<FBlendSpaceSegment> Segments;                                              // 0x0000 (size: 0x10)
    TArray<FBlendSpaceTriangle> Triangles;                                            // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FBlendSpaceSegment
{
    int32 SampleIndices;                                                              // 0x0000 (size: 0x8)
    float Vertices;                                                                   // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FBlendSpaceTriangle
{
    int32 SampleIndices;                                                              // 0x0000 (size: 0xC)
    FVector2D Vertices;                                                               // 0x0010 (size: 0x30)
    FBlendSpaceTriangleEdgeInfo EdgeInfo;                                             // 0x0040 (size: 0x78)

}; // Size: 0xB8

struct FBlendSpaceTriangleEdgeInfo
{
    FVector2D Normal;                                                                 // 0x0000 (size: 0x10)
    int32 NeighbourTriangleIndex;                                                     // 0x0010 (size: 0x4)
    int32 AdjacentPerimeterTriangleIndices;                                           // 0x0014 (size: 0x8)
    int32 AdjacentPerimeterVertexIndices;                                             // 0x001C (size: 0x8)

}; // Size: 0x28

struct FBlueprintComponentChangedPropertyInfo
{
    FName PropertyName;                                                               // 0x0000 (size: 0x8)
    int32 ArrayIndex;                                                                 // 0x0008 (size: 0x4)
    class UStruct* PropertyScope;                                                     // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FBlueprintComponentDelegateBinding
{
    FName ComponentPropertyName;                                                      // 0x0000 (size: 0x8)
    FName DelegatePropertyName;                                                       // 0x0008 (size: 0x8)
    FName FunctionNameToBind;                                                         // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FBlueprintCookedComponentInstancingData
{
    TArray<FBlueprintComponentChangedPropertyInfo> ChangedPropertyList;               // 0x0000 (size: 0x10)
    bool bHasValidCookedData;                                                         // 0x0021 (size: 0x1)

}; // Size: 0x48

struct FBlueprintDebugData
{
}; // Size: 0x1

struct FBlueprintEditorPromotionSettings
{
    FFilePath FirstMeshPath;                                                          // 0x0000 (size: 0x10)
    FFilePath SecondMeshPath;                                                         // 0x0010 (size: 0x10)
    FFilePath DefaultParticleAsset;                                                   // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FBlueprintInputActionDelegateBinding : public FBlueprintInputDelegateBinding
{
    FName InputActionName;                                                            // 0x0004 (size: 0x8)
    TEnumAsByte<EInputEvent> InputKeyEvent;                                           // 0x000C (size: 0x1)
    FName FunctionNameToBind;                                                         // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FBlueprintInputAxisDelegateBinding : public FBlueprintInputDelegateBinding
{
    FName InputAxisName;                                                              // 0x0004 (size: 0x8)
    FName FunctionNameToBind;                                                         // 0x000C (size: 0x8)

}; // Size: 0x14

struct FBlueprintInputAxisKeyDelegateBinding : public FBlueprintInputDelegateBinding
{
    FKey AxisKey;                                                                     // 0x0008 (size: 0x18)
    FName FunctionNameToBind;                                                         // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FBlueprintInputDelegateBinding
{
    uint8 bConsumeInput;                                                              // 0x0000 (size: 0x1)
    uint8 bExecuteWhenPaused;                                                         // 0x0000 (size: 0x1)
    uint8 bOverrideParentBinding;                                                     // 0x0000 (size: 0x1)

}; // Size: 0x4

struct FBlueprintInputKeyDelegateBinding : public FBlueprintInputDelegateBinding
{
    FInputChord InputChord;                                                           // 0x0008 (size: 0x20)
    TEnumAsByte<EInputEvent> InputKeyEvent;                                           // 0x0028 (size: 0x1)
    FName FunctionNameToBind;                                                         // 0x002C (size: 0x8)

}; // Size: 0x38

struct FBlueprintInputTouchDelegateBinding : public FBlueprintInputDelegateBinding
{
    TEnumAsByte<EInputEvent> InputKeyEvent;                                           // 0x0004 (size: 0x1)
    FName FunctionNameToBind;                                                         // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FBlueprintMacroCosmeticInfo
{
}; // Size: 0x1

struct FBodyInstance : public FBodyInstanceCore
{
    TEnumAsByte<ECollisionChannel> ObjectType;                                        // 0x001E (size: 0x1)
    TEnumAsByte<ECollisionEnabled::Type> CollisionEnabled;                            // 0x0020 (size: 0x1)
    ESleepFamily SleepFamily;                                                         // 0x0059 (size: 0x1)
    TEnumAsByte<EDOFMode::Type> DOFMode;                                              // 0x005A (size: 0x1)
    uint8 bUseCCD;                                                                    // 0x005B (size: 0x1)
    uint8 bUseMACD;                                                                   // 0x005B (size: 0x1)
    uint8 bIgnoreAnalyticCollisions;                                                  // 0x005B (size: 0x1)
    uint8 bNotifyRigidBodyCollision;                                                  // 0x005B (size: 0x1)
    uint8 bSmoothEdgeCollisions;                                                      // 0x005B (size: 0x1)
    uint8 bLockTranslation;                                                           // 0x005B (size: 0x1)
    uint8 bLockRotation;                                                              // 0x005B (size: 0x1)
    uint8 bLockXTranslation;                                                          // 0x005C (size: 0x1)
    uint8 bLockYTranslation;                                                          // 0x005C (size: 0x1)
    uint8 bLockZTranslation;                                                          // 0x005C (size: 0x1)
    uint8 bLockXRotation;                                                             // 0x005C (size: 0x1)
    uint8 bLockYRotation;                                                             // 0x005C (size: 0x1)
    uint8 bLockZRotation;                                                             // 0x005C (size: 0x1)
    uint8 bOverrideMaxAngularVelocity;                                                // 0x005C (size: 0x1)
    uint8 bOverrideMaxDepenetrationVelocity;                                          // 0x005D (size: 0x1)
    uint8 bOverrideWalkableSlopeOnInstance;                                           // 0x005D (size: 0x1)
    uint8 bInterpolateWhenSubStepping;                                                // 0x005D (size: 0x1)
    uint8 bInertiaConditioning;                                                       // 0x005D (size: 0x1)
    uint8 bOneWayInteraction;                                                         // 0x005D (size: 0x1)
    uint8 bOverrideSolverAsyncDeltaTime;                                              // 0x005D (size: 0x1)
    float SolverAsyncDeltaTime;                                                       // 0x0060 (size: 0x4)
    FName CollisionProfileName;                                                       // 0x0080 (size: 0x8)
    uint8 PositionSolverIterationCount;                                               // 0x0088 (size: 0x1)
    uint8 VelocitySolverIterationCount;                                               // 0x0089 (size: 0x1)
    FCollisionResponse CollisionResponses;                                            // 0x0090 (size: 0x30)
    float MaxDepenetrationVelocity;                                                   // 0x00C0 (size: 0x4)
    float MassInKgOverride;                                                           // 0x00C4 (size: 0x4)
    float LinearDamping;                                                              // 0x00D0 (size: 0x4)
    float AngularDamping;                                                             // 0x00D4 (size: 0x4)
    FVector CustomDOFPlaneNormal;                                                     // 0x00D8 (size: 0x18)
    FVector COMNudge;                                                                 // 0x00F0 (size: 0x18)
    float MassScale;                                                                  // 0x0108 (size: 0x4)
    FVector InertiaTensorScale;                                                       // 0x0110 (size: 0x18)
    FWalkableSlopeOverride WalkableSlopeOverride;                                     // 0x0138 (size: 0x10)
    class UPhysicalMaterial* PhysMaterialOverride;                                    // 0x0148 (size: 0x8)
    float MaxAngularVelocity;                                                         // 0x0150 (size: 0x4)
    float CustomSleepThresholdMultiplier;                                             // 0x0154 (size: 0x4)
    float StabilizationThresholdMultiplier;                                           // 0x0158 (size: 0x4)
    float PhysicsBlendWeight;                                                         // 0x015C (size: 0x4)

}; // Size: 0x198

struct FBodyInstanceAsyncPhysicsTickHandle
{
}; // Size: 0x8

struct FBoneAnimationTrack
{
    FRawAnimSequenceTrack InternalTrackData;                                          // 0x0000 (size: 0x30)
    int32 BoneTreeIndex;                                                              // 0x0030 (size: 0x4)
    FName Name;                                                                       // 0x0034 (size: 0x8)

}; // Size: 0x40

struct FBoneFilter
{
    bool bExcludeSelf;                                                                // 0x0000 (size: 0x1)
    FName BoneName;                                                                   // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FBoneMirrorExport
{
    FName BoneName;                                                                   // 0x0000 (size: 0x8)
    FName SourceBoneName;                                                             // 0x0008 (size: 0x8)
    TEnumAsByte<EAxis::Type> BoneFlipAxis;                                            // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FBoneMirrorInfo
{
    int32 SourceIndex;                                                                // 0x0000 (size: 0x4)
    TEnumAsByte<EAxis::Type> BoneFlipAxis;                                            // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FBoneNode
{
    TEnumAsByte<EBoneTranslationRetargetingMode::Type> TranslationRetargetingMode;    // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FBoneReductionSetting
{
    TArray<FName> BonesToRemove;                                                      // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FBoneReference
{
    FName BoneName;                                                                   // 0x0000 (size: 0x8)

}; // Size: 0x10

struct FBoneSocketTarget
{
    bool bUseSocket;                                                                  // 0x0000 (size: 0x1)
    FBoneReference BoneReference;                                                     // 0x0004 (size: 0x10)
    FSocketReference SocketReference;                                                 // 0x0020 (size: 0x70)

}; // Size: 0x90

struct FBookmark2DJumpToSettings
{
}; // Size: 0x1

struct FBookmarkBaseJumpToSettings
{
}; // Size: 0x1

struct FBookmarkJumpToSettings : public FBookmarkBaseJumpToSettings
{
}; // Size: 0x1

struct FBracketPayload : public FEmptyPayload
{
    FString Description;                                                              // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FBranchFilter
{
    FName BoneName;                                                                   // 0x0000 (size: 0x8)
    int32 BlendDepth;                                                                 // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FBranchingPoint : public FAnimLinkableElement
{
    FName EventName;                                                                  // 0x0030 (size: 0x8)
    float TriggerTimeOffset;                                                          // 0x0038 (size: 0x4)

}; // Size: 0x40

struct FBranchingPointMarker
{
    int32 NotifyIndex;                                                                // 0x0000 (size: 0x4)
    float TriggerTime;                                                                // 0x0004 (size: 0x4)
    TEnumAsByte<EAnimNotifyEventType::Type> NotifyEventType;                          // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FBranchingPointNotifyPayload
{
}; // Size: 0x20

struct FBroadphaseSettings
{
    bool bUseMBPOnClient;                                                             // 0x0000 (size: 0x1)
    bool bUseMBPOnServer;                                                             // 0x0001 (size: 0x1)
    bool bUseMBPOuterBounds;                                                          // 0x0002 (size: 0x1)
    FBox MBPBounds;                                                                   // 0x0008 (size: 0x38)
    FBox MBPOuterBounds;                                                              // 0x0040 (size: 0x38)
    uint32 MBPNumSubdivs;                                                             // 0x0078 (size: 0x4)

}; // Size: 0x80

struct FBuildPromotionImportWorkflowSettings
{
    FEditorImportWorkflowDefinition Diffuse;                                          // 0x0000 (size: 0x20)
    FEditorImportWorkflowDefinition Normal;                                           // 0x0020 (size: 0x20)
    FEditorImportWorkflowDefinition StaticMesh;                                       // 0x0040 (size: 0x20)
    FEditorImportWorkflowDefinition ReimportStaticMesh;                               // 0x0060 (size: 0x20)
    FEditorImportWorkflowDefinition BlendShapeMesh;                                   // 0x0080 (size: 0x20)
    FEditorImportWorkflowDefinition MorphMesh;                                        // 0x00A0 (size: 0x20)
    FEditorImportWorkflowDefinition SkeletalMesh;                                     // 0x00C0 (size: 0x20)
    FEditorImportWorkflowDefinition Animation;                                        // 0x00E0 (size: 0x20)
    FEditorImportWorkflowDefinition Sound;                                            // 0x0100 (size: 0x20)
    FEditorImportWorkflowDefinition SurroundSound;                                    // 0x0120 (size: 0x20)
    TArray<FEditorImportWorkflowDefinition> OtherAssetsToImport;                      // 0x0140 (size: 0x10)

}; // Size: 0x150

struct FBuildPromotionNewProjectSettings
{
    FDirectoryPath NewProjectFolderOverride;                                          // 0x0000 (size: 0x10)
    FString NewProjectNameOverride;                                                   // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FBuildPromotionOpenAssetSettings
{
    FFilePath BlueprintAsset;                                                         // 0x0000 (size: 0x10)
    FFilePath MaterialAsset;                                                          // 0x0010 (size: 0x10)
    FFilePath ParticleSystemAsset;                                                    // 0x0020 (size: 0x10)
    FFilePath SkeletalMeshAsset;                                                      // 0x0030 (size: 0x10)
    FFilePath StaticMeshAsset;                                                        // 0x0040 (size: 0x10)
    FFilePath TextureAsset;                                                           // 0x0050 (size: 0x10)

}; // Size: 0x60

struct FBuildPromotionTestSettings
{
    FFilePath DefaultStaticMeshAsset;                                                 // 0x0000 (size: 0x10)
    FBuildPromotionImportWorkflowSettings ImportWorkflow;                             // 0x0010 (size: 0x150)
    FBuildPromotionOpenAssetSettings OpenAssets;                                      // 0x0160 (size: 0x60)
    FBuildPromotionNewProjectSettings NewProjectSettings;                             // 0x01C0 (size: 0x20)
    FFilePath SourceControlMaterial;                                                  // 0x01E0 (size: 0x10)

}; // Size: 0x1F0

struct FBuilderPoly
{
    TArray<int32> VertexIndices;                                                      // 0x0000 (size: 0x10)
    int32 Direction;                                                                  // 0x0010 (size: 0x4)
    FName ItemName;                                                                   // 0x0014 (size: 0x8)
    int32 PolyFlags;                                                                  // 0x001C (size: 0x4)

}; // Size: 0x20

struct FCachedAnimAssetPlayerData
{
    FName StateMachineName;                                                           // 0x0000 (size: 0x8)
    FName StateName;                                                                  // 0x0008 (size: 0x8)

}; // Size: 0x18

struct FCachedAnimRelevancyData
{
    FName StateMachineName;                                                           // 0x0000 (size: 0x8)
    FName StateName;                                                                  // 0x0008 (size: 0x8)

}; // Size: 0x1C

struct FCachedAnimStateArray
{
    TArray<FCachedAnimStateData> States;                                              // 0x0000 (size: 0x10)

}; // Size: 0x18

struct FCachedAnimStateData
{
    FName StateMachineName;                                                           // 0x0000 (size: 0x8)
    FName StateName;                                                                  // 0x0008 (size: 0x8)

}; // Size: 0x1C

struct FCachedAnimTransitionData
{
    FName StateMachineName;                                                           // 0x0000 (size: 0x8)
    FName FromStateName;                                                              // 0x0008 (size: 0x8)
    FName ToStateName;                                                                // 0x0010 (size: 0x8)

}; // Size: 0x24

struct FCachedFloatCurve
{
    FName CurveName;                                                                  // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FCachedKeyToActionInfo
{
    TWeakObjectPtr<class UPlayerInput> PlayerInput;                                   // 0x0000 (size: 0x8)

}; // Size: 0x70

struct FCachedPoseIndices
{
    TArray<int32> OrderedSavedPoseNodeIndices;                                        // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FCameraCacheEntry
{
    float Timestamp;                                                                  // 0x0000 (size: 0x4)
    FMinimalViewInfo POV;                                                             // 0x0010 (size: 0x800)

}; // Size: 0x810

struct FCameraExposureSettings
{
    TEnumAsByte<EAutoExposureMethod> Method;                                          // 0x0000 (size: 0x1)
    float LowPercent;                                                                 // 0x0004 (size: 0x4)
    float HighPercent;                                                                // 0x0008 (size: 0x4)
    float MinBrightness;                                                              // 0x000C (size: 0x4)
    float MaxBrightness;                                                              // 0x0010 (size: 0x4)
    float SpeedUp;                                                                    // 0x0014 (size: 0x4)
    float SpeedDown;                                                                  // 0x0018 (size: 0x4)
    float Bias;                                                                       // 0x001C (size: 0x4)
    class UCurveFloat* BiasCurve;                                                     // 0x0020 (size: 0x8)
    class UTexture* MeterMask;                                                        // 0x0028 (size: 0x8)
    float HistogramLogMin;                                                            // 0x0030 (size: 0x4)
    float HistogramLogMax;                                                            // 0x0034 (size: 0x4)
    float CalibrationConstant;                                                        // 0x0038 (size: 0x4)
    uint8 ApplyPhysicalCameraExposure;                                                // 0x003C (size: 0x1)

}; // Size: 0x40

struct FCameraLensInterfaceClassSupport
{
    TSubclassOf<class AActor> Class;                                                  // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FCameraShakeDuration
{
    float Duration;                                                                   // 0x0000 (size: 0x4)
    ECameraShakeDurationType Type;                                                    // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FCameraShakeInfo
{
    FCameraShakeDuration Duration;                                                    // 0x0000 (size: 0x8)
    float BlendIn;                                                                    // 0x0008 (size: 0x4)
    float BlendOut;                                                                   // 0x000C (size: 0x4)

}; // Size: 0x10

struct FCameraShakePatternScrubParams
{
    float AbsoluteTime;                                                               // 0x0000 (size: 0x4)
    float ShakeScale;                                                                 // 0x0004 (size: 0x4)
    float DynamicScale;                                                               // 0x0008 (size: 0x4)
    FMinimalViewInfo POV;                                                             // 0x0010 (size: 0x800)

}; // Size: 0x810

struct FCameraShakePatternStartParams
{
    bool bIsRestarting;                                                               // 0x0000 (size: 0x1)
    bool bOverrideDuration;                                                           // 0x0001 (size: 0x1)
    float DurationOverride;                                                           // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FCameraShakePatternStopParams
{
    bool bImmediately;                                                                // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FCameraShakePatternUpdateParams
{
    float DeltaTime;                                                                  // 0x0000 (size: 0x4)
    float ShakeScale;                                                                 // 0x0004 (size: 0x4)
    float DynamicScale;                                                               // 0x0008 (size: 0x4)
    FMinimalViewInfo POV;                                                             // 0x0010 (size: 0x800)

}; // Size: 0x810

struct FCameraShakePatternUpdateResult
{
}; // Size: 0x740

struct FCanvasIcon
{
    class UTexture* Texture;                                                          // 0x0000 (size: 0x8)
    float U;                                                                          // 0x0008 (size: 0x4)
    float V;                                                                          // 0x000C (size: 0x4)
    float UL;                                                                         // 0x0010 (size: 0x4)
    float VL;                                                                         // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FCanvasUVTri
{
    FVector2D V0_Pos;                                                                 // 0x0000 (size: 0x10)
    FVector2D V0_UV;                                                                  // 0x0010 (size: 0x10)
    FLinearColor V0_Color;                                                            // 0x0020 (size: 0x10)
    FVector2D V1_Pos;                                                                 // 0x0030 (size: 0x10)
    FVector2D V1_UV;                                                                  // 0x0040 (size: 0x10)
    FLinearColor V1_Color;                                                            // 0x0050 (size: 0x10)
    FVector2D V2_Pos;                                                                 // 0x0060 (size: 0x10)
    FVector2D V2_UV;                                                                  // 0x0070 (size: 0x10)
    FLinearColor V2_Color;                                                            // 0x0080 (size: 0x10)

}; // Size: 0x90

struct FChannelDefinition
{
    FName ChannelName;                                                                // 0x0000 (size: 0x8)
    FName ClassName;                                                                  // 0x0008 (size: 0x8)
    UClass* ChannelClass;                                                             // 0x0010 (size: 0x8)
    int32 StaticChannelIndex;                                                         // 0x0018 (size: 0x4)
    uint8 bTickOnCreate;                                                              // 0x001C (size: 0x1)
    uint8 bServerOpen;                                                                // 0x001C (size: 0x1)
    uint8 bClientOpen;                                                                // 0x001C (size: 0x1)
    uint8 bInitialServer;                                                             // 0x001C (size: 0x1)
    uint8 bInitialClient;                                                             // 0x001C (size: 0x1)

}; // Size: 0x20

struct FChaosBreakEvent
{
    class UPrimitiveComponent* Component;                                             // 0x0000 (size: 0x8)
    FVector Location;                                                                 // 0x0008 (size: 0x18)
    FVector Velocity;                                                                 // 0x0020 (size: 0x18)
    FVector AngularVelocity;                                                          // 0x0038 (size: 0x18)
    FVector Extents;                                                                  // 0x0050 (size: 0x18)
    float Mass;                                                                       // 0x0068 (size: 0x4)
    int32 Index;                                                                      // 0x006C (size: 0x4)
    bool bFromCrumble;                                                                // 0x0070 (size: 0x1)

}; // Size: 0x78

struct FChaosCrumblingEvent
{
    class UPrimitiveComponent* Component;                                             // 0x0000 (size: 0x8)
    FVector Location;                                                                 // 0x0008 (size: 0x18)
    FQuat Orientation;                                                                // 0x0020 (size: 0x20)
    FVector LinearVelocity;                                                           // 0x0040 (size: 0x18)
    FVector AngularVelocity;                                                          // 0x0058 (size: 0x18)
    float Mass;                                                                       // 0x0070 (size: 0x4)
    FBox LocalBounds;                                                                 // 0x0078 (size: 0x38)
    TArray<int32> Children;                                                           // 0x00B0 (size: 0x10)

}; // Size: 0xC0

struct FChaosPhysicsSettings
{
    EChaosThreadingMode DefaultThreadingModel;                                        // 0x0000 (size: 0x1)
    EChaosSolverTickMode DedicatedThreadTickMode;                                     // 0x0001 (size: 0x1)
    EChaosBufferMode DedicatedThreadBufferMode;                                       // 0x0002 (size: 0x1)

}; // Size: 0x3

struct FChaosRemovalEvent
{
    class UPrimitiveComponent* Component;                                             // 0x0000 (size: 0x8)
    FVector Location;                                                                 // 0x0008 (size: 0x18)
    float Mass;                                                                       // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FCharacterMoveResponsePackedBits : public FCharacterNetworkSerializationPackedBits
{
}; // Size: 0xC8

struct FCharacterMovementComponentPostPhysicsTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FCharacterMovementComponentPrePhysicsTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FCharacterNetworkSerializationPackedBits
{
}; // Size: 0xC8

struct FCharacterNetworkSerializationPackedBitsNetSerializerConfig : public FNetSerializerConfig
{
    uint32 MaxAllowedDataBits;                                                        // 0x0010 (size: 0x4)
    uint32 MaxAllowedObjectReferences;                                                // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FCharacterServerMovePackedBits : public FCharacterNetworkSerializationPackedBits
{
}; // Size: 0xC8

struct FChildActorAttachedActorInfo
{
    TWeakObjectPtr<class AActor> Actor;                                               // 0x0000 (size: 0x8)
    FName SocketName;                                                                 // 0x0008 (size: 0x8)
    FTransform RelativeTransform;                                                     // 0x0010 (size: 0x60)

}; // Size: 0x70

struct FChildActorComponentInstanceData : public FSceneComponentInstanceData
{
    TSubclassOf<class AActor> ChildActorClass;                                        // 0x00B8 (size: 0x8)
    FName ChildActorName;                                                             // 0x00C0 (size: 0x8)
    TArray<FChildActorAttachedActorInfo> AttachedActors;                              // 0x00C8 (size: 0x10)

}; // Size: 0xF8

struct FClassRedirect
{
    FName ObjectName;                                                                 // 0x0000 (size: 0x8)
    FName OldClassName;                                                               // 0x0008 (size: 0x8)
    FName NewClassName;                                                               // 0x0010 (size: 0x8)
    FName OldSubobjName;                                                              // 0x0018 (size: 0x8)
    FName NewSubobjName;                                                              // 0x0020 (size: 0x8)
    FName NewClassClass;                                                              // 0x0028 (size: 0x8)
    FName NewClassPackage;                                                            // 0x0030 (size: 0x8)
    bool InstanceOnly;                                                                // 0x0038 (size: 0x1)

}; // Size: 0x3C

struct FClientReceiveData
{
    class APlayerController* LocalPC;                                                 // 0x0000 (size: 0x8)
    FName MessageType;                                                                // 0x0008 (size: 0x8)
    int32 MessageIndex;                                                               // 0x0010 (size: 0x4)
    FString MessageString;                                                            // 0x0018 (size: 0x10)
    class APlayerState* RelatedPlayerState_1;                                         // 0x0028 (size: 0x8)
    class APlayerState* RelatedPlayerState_2;                                         // 0x0030 (size: 0x8)
    class UObject* OptionalObject;                                                    // 0x0038 (size: 0x8)

}; // Size: 0x40

struct FClothPhysicsProperties_Legacy
{
    float VerticalResistance;                                                         // 0x0000 (size: 0x4)
    float HorizontalResistance;                                                       // 0x0004 (size: 0x4)
    float BendResistance;                                                             // 0x0008 (size: 0x4)
    float ShearResistance;                                                            // 0x000C (size: 0x4)
    float Friction;                                                                   // 0x0010 (size: 0x4)
    float Damping;                                                                    // 0x0014 (size: 0x4)
    float TetherStiffness;                                                            // 0x0018 (size: 0x4)
    float TetherLimit;                                                                // 0x001C (size: 0x4)
    float Drag;                                                                       // 0x0020 (size: 0x4)
    float StiffnessFrequency;                                                         // 0x0024 (size: 0x4)
    float GravityScale;                                                               // 0x0028 (size: 0x4)
    float MassScale;                                                                  // 0x002C (size: 0x4)
    float InertiaBlend;                                                               // 0x0030 (size: 0x4)
    float SelfCollisionThickness;                                                     // 0x0034 (size: 0x4)
    float SelfCollisionSquashScale;                                                   // 0x0038 (size: 0x4)
    float SelfCollisionStiffness;                                                     // 0x003C (size: 0x4)
    float SolverFrequency;                                                            // 0x0040 (size: 0x4)
    float FiberCompression;                                                           // 0x0044 (size: 0x4)
    float FiberExpansion;                                                             // 0x0048 (size: 0x4)
    float FiberResistance;                                                            // 0x004C (size: 0x4)

}; // Size: 0x50

struct FClothingAssetData_Legacy
{
    FName AssetName;                                                                  // 0x0000 (size: 0x8)
    FString ApexFileName;                                                             // 0x0008 (size: 0x10)
    bool bClothPropertiesChanged;                                                     // 0x0018 (size: 0x1)
    FClothPhysicsProperties_Legacy PhysicsProperties;                                 // 0x001C (size: 0x50)

}; // Size: 0x70

struct FClusterNode
{
    FVector3f BoundMin;                                                               // 0x0000 (size: 0xC)
    int32 FirstChild;                                                                 // 0x000C (size: 0x4)
    FVector3f BoundMax;                                                               // 0x0010 (size: 0xC)
    int32 LastChild;                                                                  // 0x001C (size: 0x4)
    int32 FirstInstance;                                                              // 0x0020 (size: 0x4)
    int32 LastInstance;                                                               // 0x0024 (size: 0x4)
    FVector3f MinInstanceScale;                                                       // 0x0028 (size: 0xC)
    FVector3f MaxInstanceScale;                                                       // 0x0034 (size: 0xC)

}; // Size: 0x40

struct FClusterNode_DEPRECATED
{
    FVector3f BoundMin;                                                               // 0x0000 (size: 0xC)
    int32 FirstChild;                                                                 // 0x000C (size: 0x4)
    FVector3f BoundMax;                                                               // 0x0010 (size: 0xC)
    int32 LastChild;                                                                  // 0x001C (size: 0x4)
    int32 FirstInstance;                                                              // 0x0020 (size: 0x4)
    int32 LastInstance;                                                               // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FClusterUnionBoneData
{
}; // Size: 0x8

struct FClusterUnionInitializationData
{
    class UClusterUnionComponent* ClusterUnionComponent;                              // 0x0000 (size: 0x8)
    TArray<class UPrimitiveComponent*> ProcessedComponents;                           // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FClusterUnionPendingAddData
{
    TSet<FClusterUnionBoneData> BonesData;                                            // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FClusterUnionReplicatedData
{
    uint8 ObjectState;                                                                // 0x0000 (size: 0x1)
    bool bIsAnchored;                                                                 // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FClusteredActorData
{
    bool bWasReplicatingMovement;                                                     // 0x0050 (size: 0x1)

}; // Size: 0x58

struct FClusteredComponentData
{
    TWeakObjectPtr<class UClusterUnionReplicatedProxyComponent> ReplicatedProxyComponent; // 0x0010 (size: 0x8)
    TWeakObjectPtr<class AActor> Owner;                                               // 0x0018 (size: 0x8)
    bool bWasReplicating;                                                             // 0x0020 (size: 0x1)
    bool bPendingDeletion;                                                            // 0x0021 (size: 0x1)

}; // Size: 0x28

struct FCollectionParameterBase
{
    FName ParameterName;                                                              // 0x0000 (size: 0x8)
    FGuid ID;                                                                         // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FCollectionReference
{
    FName CollectionName;                                                             // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FCollectionScalarParameter : public FCollectionParameterBase
{
    float DefaultValue;                                                               // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FCollectionVectorParameter : public FCollectionParameterBase
{
    FLinearColor DefaultValue;                                                        // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FCollisionChaosEvent
{
    FVector Location;                                                                 // 0x0000 (size: 0x18)
    FVector AccumulatedImpulse;                                                       // 0x0018 (size: 0x18)
    FVector Normal;                                                                   // 0x0030 (size: 0x18)
    float PenetrationDepth;                                                           // 0x0048 (size: 0x4)
    FCollisionChaosEventBodyInfo Body1;                                               // 0x0050 (size: 0x70)
    FCollisionChaosEventBodyInfo Body2;                                               // 0x00C0 (size: 0x70)

}; // Size: 0x130

struct FCollisionChaosEventBodyInfo
{
    FVector Velocity;                                                                 // 0x0000 (size: 0x18)
    FVector DeltaVelocity;                                                            // 0x0018 (size: 0x18)
    FVector AngularVelocity;                                                          // 0x0030 (size: 0x18)
    float Mass;                                                                       // 0x0048 (size: 0x4)
    class UPhysicalMaterial* PhysMaterial;                                            // 0x0050 (size: 0x8)
    TWeakObjectPtr<class UPrimitiveComponent> Component;                              // 0x0058 (size: 0x8)
    int32 BodyIndex;                                                                  // 0x0060 (size: 0x4)
    FName BoneName;                                                                   // 0x0064 (size: 0x8)

}; // Size: 0x70

struct FCollisionImpactData
{
    TArray<FRigidBodyContactInfo> ContactInfos;                                       // 0x0000 (size: 0x10)
    FVector TotalNormalImpulse;                                                       // 0x0010 (size: 0x18)
    FVector TotalFrictionImpulse;                                                     // 0x0028 (size: 0x18)
    bool bIsVelocityDeltaUnderThreshold;                                              // 0x0040 (size: 0x1)

}; // Size: 0x48

struct FCollisionProfileName
{
    FName Name;                                                                       // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FCollisionResponse
{
    FCollisionResponseContainer ResponseToChannels;                                   // 0x0000 (size: 0x20)
    TArray<FResponseChannel> ResponseArray;                                           // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FCollisionResponseContainer
{
    TEnumAsByte<ECollisionResponse> WorldStatic;                                      // 0x0000 (size: 0x1)
    TEnumAsByte<ECollisionResponse> WorldDynamic;                                     // 0x0001 (size: 0x1)
    TEnumAsByte<ECollisionResponse> Pawn;                                             // 0x0002 (size: 0x1)
    TEnumAsByte<ECollisionResponse> Visibility;                                       // 0x0003 (size: 0x1)
    TEnumAsByte<ECollisionResponse> Camera;                                           // 0x0004 (size: 0x1)
    TEnumAsByte<ECollisionResponse> PhysicsBody;                                      // 0x0005 (size: 0x1)
    TEnumAsByte<ECollisionResponse> Vehicle;                                          // 0x0006 (size: 0x1)
    TEnumAsByte<ECollisionResponse> Destructible;                                     // 0x0007 (size: 0x1)
    TEnumAsByte<ECollisionResponse> EngineTraceChannel1;                              // 0x0008 (size: 0x1)
    TEnumAsByte<ECollisionResponse> EngineTraceChannel2;                              // 0x0009 (size: 0x1)
    TEnumAsByte<ECollisionResponse> EngineTraceChannel3;                              // 0x000A (size: 0x1)
    TEnumAsByte<ECollisionResponse> EngineTraceChannel4;                              // 0x000B (size: 0x1)
    TEnumAsByte<ECollisionResponse> EngineTraceChannel5;                              // 0x000C (size: 0x1)
    TEnumAsByte<ECollisionResponse> EngineTraceChannel6;                              // 0x000D (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel1;                                // 0x000E (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel2;                                // 0x000F (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel3;                                // 0x0010 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel4;                                // 0x0011 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel5;                                // 0x0012 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel6;                                // 0x0013 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel7;                                // 0x0014 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel8;                                // 0x0015 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel9;                                // 0x0016 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel10;                               // 0x0017 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel11;                               // 0x0018 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel12;                               // 0x0019 (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel13;                               // 0x001A (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel14;                               // 0x001B (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel15;                               // 0x001C (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel16;                               // 0x001D (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel17;                               // 0x001E (size: 0x1)
    TEnumAsByte<ECollisionResponse> GameTraceChannel18;                               // 0x001F (size: 0x1)

}; // Size: 0x20

struct FCollisionResponseTemplate
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    TEnumAsByte<ECollisionEnabled::Type> CollisionEnabled;                            // 0x0008 (size: 0x1)
    bool bCanModify;                                                                  // 0x000A (size: 0x1)
    FName ObjectTypeName;                                                             // 0x002C (size: 0x8)
    TArray<FResponseChannel> CustomResponses;                                         // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FColorGradePerRangeSettings
{
    FVector4 Saturation;                                                              // 0x0000 (size: 0x20)
    FVector4 Contrast;                                                                // 0x0020 (size: 0x20)
    FVector4 Gamma;                                                                   // 0x0040 (size: 0x20)
    FVector4 Gain;                                                                    // 0x0060 (size: 0x20)
    FVector4 Offset;                                                                  // 0x0080 (size: 0x20)

}; // Size: 0xA0

struct FColorGradingSettings
{
    FColorGradePerRangeSettings Global;                                               // 0x0000 (size: 0xA0)
    FColorGradePerRangeSettings Shadows;                                              // 0x00A0 (size: 0xA0)
    FColorGradePerRangeSettings Midtones;                                             // 0x0140 (size: 0xA0)
    FColorGradePerRangeSettings Highlights;                                           // 0x01E0 (size: 0xA0)
    float ShadowsMax;                                                                 // 0x0280 (size: 0x4)
    float HighlightsMin;                                                              // 0x0284 (size: 0x4)
    float HighlightsMax;                                                              // 0x0288 (size: 0x4)

}; // Size: 0x290

struct FColorMaterialInput : public FMaterialInput
{
    uint8 UseConstant;                                                                // 0x0028 (size: 0x1)
    FColor Constant;                                                                  // 0x002C (size: 0x4)

}; // Size: 0x30

struct FComponentKey
{
    UClass* OwnerClass;                                                               // 0x0000 (size: 0x8)
    FName SCSVariableName;                                                            // 0x0008 (size: 0x8)
    FGuid AssociatedGuid;                                                             // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FComponentOverrideRecord
{
    UClass* ComponentClass;                                                           // 0x0000 (size: 0x8)
    class UActorComponent* ComponentTemplate;                                         // 0x0008 (size: 0x8)
    FComponentKey ComponentKey;                                                       // 0x0010 (size: 0x20)
    FBlueprintCookedComponentInstancingData CookedComponentInstancingData;            // 0x0030 (size: 0x48)

}; // Size: 0x78

struct FComponentReference : public FBaseComponentReference
{
    TWeakObjectPtr<class AActor> OtherActor;                                          // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FComponentSpacePose
{
    TArray<FTransform> Transforms;                                                    // 0x0000 (size: 0x10)
    TArray<FName> Names;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FComponentSpacePoseLink : public FPoseLinkBase
{
}; // Size: 0x10

struct FComponentSync
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    ESyncOption SyncOption;                                                           // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FCompositeReroute
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    class UMaterialExpressionReroute* Expression;                                     // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FCompositeSection : public FAnimLinkableElement
{
    FName SectionName;                                                                // 0x0030 (size: 0x8)
    FName NextSectionName;                                                            // 0x0038 (size: 0x8)
    TArray<class UAnimMetaData*> MetaData;                                            // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FCompressedRichCurve
{
}; // Size: 0x18

struct FCompressedTrack
{
    TArray<uint8> ByteStream;                                                         // 0x0000 (size: 0x10)
    TArray<float> Times;                                                              // 0x0010 (size: 0x10)
    float Mins;                                                                       // 0x0020 (size: 0xC)
    float Ranges;                                                                     // 0x002C (size: 0xC)

}; // Size: 0x38

struct FConeConstraint : public FConstraintBaseParams
{
    float Swing1LimitDegrees;                                                         // 0x0014 (size: 0x4)
    float Swing2LimitDegrees;                                                         // 0x0018 (size: 0x4)
    TEnumAsByte<EAngularConstraintMotion> Swing1Motion;                               // 0x001C (size: 0x1)
    TEnumAsByte<EAngularConstraintMotion> Swing2Motion;                               // 0x001D (size: 0x1)

}; // Size: 0x20

struct FConstrainComponentPropName
{
    FName ComponentName;                                                              // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FConstraintBaseParams
{
    float Stiffness;                                                                  // 0x0000 (size: 0x4)
    float Damping;                                                                    // 0x0004 (size: 0x4)
    float Restitution;                                                                // 0x0008 (size: 0x4)
    float ContactDistance;                                                            // 0x000C (size: 0x4)
    uint8 bSoftConstraint;                                                            // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FConstraintDrive
{
    float Stiffness;                                                                  // 0x0000 (size: 0x4)
    float Damping;                                                                    // 0x0004 (size: 0x4)
    float MaxForce;                                                                   // 0x0008 (size: 0x4)
    uint8 bEnablePositionDrive;                                                       // 0x000C (size: 0x1)
    uint8 bEnableVelocityDrive;                                                       // 0x000C (size: 0x1)

}; // Size: 0x10

struct FConstraintInstance : public FConstraintInstanceBase
{
    FName JointName;                                                                  // 0x0038 (size: 0x8)
    FName ConstraintBone1;                                                            // 0x0040 (size: 0x8)
    FName ConstraintBone2;                                                            // 0x0048 (size: 0x8)
    FVector Pos1;                                                                     // 0x0058 (size: 0x18)
    FVector PriAxis1;                                                                 // 0x0070 (size: 0x18)
    FVector SecAxis1;                                                                 // 0x0088 (size: 0x18)
    FVector Pos2;                                                                     // 0x00A0 (size: 0x18)
    FVector PriAxis2;                                                                 // 0x00B8 (size: 0x18)
    FVector SecAxis2;                                                                 // 0x00D0 (size: 0x18)
    FRotator AngularRotationOffset;                                                   // 0x00E8 (size: 0x18)
    uint8 bScaleLinearLimits;                                                         // 0x0100 (size: 0x1)
    FConstraintProfileProperties ProfileInstance;                                     // 0x0108 (size: 0x158)

}; // Size: 0x270

struct FConstraintInstanceAccessor
{
    TWeakObjectPtr<class UObject> Owner;                                              // 0x0000 (size: 0x8)
    uint32 Index;                                                                     // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FConstraintInstanceBase
{
}; // Size: 0x38

struct FConstraintProfileProperties
{
    float ProjectionLinearTolerance;                                                  // 0x0000 (size: 0x4)
    float ProjectionAngularTolerance;                                                 // 0x0004 (size: 0x4)
    float ProjectionLinearAlpha;                                                      // 0x0008 (size: 0x4)
    float ProjectionAngularAlpha;                                                     // 0x000C (size: 0x4)
    float ShockPropagationAlpha;                                                      // 0x0010 (size: 0x4)
    float LinearBreakThreshold;                                                       // 0x0014 (size: 0x4)
    float LinearPlasticityThreshold;                                                  // 0x0018 (size: 0x4)
    float AngularBreakThreshold;                                                      // 0x001C (size: 0x4)
    float AngularPlasticityThreshold;                                                 // 0x0020 (size: 0x4)
    float ContactTransferScale;                                                       // 0x0024 (size: 0x4)
    FLinearConstraint LinearLimit;                                                    // 0x0028 (size: 0x1C)
    FConeConstraint ConeLimit;                                                        // 0x0044 (size: 0x20)
    FTwistConstraint TwistLimit;                                                      // 0x0064 (size: 0x1C)
    uint8 bDisableCollision;                                                          // 0x0080 (size: 0x1)
    uint8 bParentDominates;                                                           // 0x0080 (size: 0x1)
    uint8 bEnableShockPropagation;                                                    // 0x0080 (size: 0x1)
    uint8 bEnableProjection;                                                          // 0x0080 (size: 0x1)
    uint8 bEnableMassConditioning;                                                    // 0x0080 (size: 0x1)
    uint8 bAngularBreakable;                                                          // 0x0080 (size: 0x1)
    uint8 bAngularPlasticity;                                                         // 0x0080 (size: 0x1)
    uint8 bLinearBreakable;                                                           // 0x0080 (size: 0x1)
    uint8 bLinearPlasticity;                                                          // 0x0081 (size: 0x1)
    FLinearDriveConstraint LinearDrive;                                               // 0x0088 (size: 0x60)
    FAngularDriveConstraint AngularDrive;                                             // 0x00E8 (size: 0x68)
    TEnumAsByte<EConstraintPlasticityType> LinearPlasticityType;                      // 0x0150 (size: 0x1)

}; // Size: 0x158

struct FConvolutionBloomSettings
{
    class UTexture2D* Texture;                                                        // 0x0000 (size: 0x8)
    float ScatterDispersion;                                                          // 0x0008 (size: 0x4)
    float Size;                                                                       // 0x000C (size: 0x4)
    FVector2D CenterUV;                                                               // 0x0010 (size: 0x10)
    float PreFilterMin;                                                               // 0x0020 (size: 0x4)
    float PreFilterMax;                                                               // 0x0024 (size: 0x4)
    float PreFilterMult;                                                              // 0x0028 (size: 0x4)
    float BufferScale;                                                                // 0x002C (size: 0x4)

}; // Size: 0x30

struct FCullDistanceSizePair
{
    float Size;                                                                       // 0x0000 (size: 0x4)
    float CullDistance;                                                               // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FCurveAtlasColorAdjustments
{
    uint8 bChromaKeyTexture;                                                          // 0x0000 (size: 0x1)
    float AdjustBrightness;                                                           // 0x0004 (size: 0x4)
    float AdjustBrightnessCurve;                                                      // 0x0008 (size: 0x4)
    float AdjustVibrance;                                                             // 0x000C (size: 0x4)
    float AdjustSaturation;                                                           // 0x0010 (size: 0x4)
    float AdjustRGBCurve;                                                             // 0x0014 (size: 0x4)
    float AdjustHue;                                                                  // 0x0018 (size: 0x4)
    float AdjustMinAlpha;                                                             // 0x001C (size: 0x4)
    float AdjustMaxAlpha;                                                             // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FCurveEdEntry
{
    class UObject* CurveObject;                                                       // 0x0000 (size: 0x8)
    FColor CurveColor;                                                                // 0x0008 (size: 0x4)
    FString CurveName;                                                                // 0x0010 (size: 0x10)
    int32 bHideCurve;                                                                 // 0x0020 (size: 0x4)
    int32 bColorCurve;                                                                // 0x0024 (size: 0x4)
    int32 bFloatingPointColorCurve;                                                   // 0x0028 (size: 0x4)
    int32 bClamp;                                                                     // 0x002C (size: 0x4)
    float ClampLow;                                                                   // 0x0030 (size: 0x4)
    float ClampHigh;                                                                  // 0x0034 (size: 0x4)

}; // Size: 0x38

struct FCurveEdTab
{
    FString TabName;                                                                  // 0x0000 (size: 0x10)
    TArray<FCurveEdEntry> Curves;                                                     // 0x0010 (size: 0x10)
    float ViewStartInput;                                                             // 0x0020 (size: 0x4)
    float ViewEndInput;                                                               // 0x0024 (size: 0x4)
    float ViewStartOutput;                                                            // 0x0028 (size: 0x4)
    float ViewEndOutput;                                                              // 0x002C (size: 0x4)

}; // Size: 0x30

struct FCurveFlagsChangedPayload : public FCurvePayload
{
    int32 OldFlags;                                                                   // 0x000C (size: 0x4)

}; // Size: 0x10

struct FCurveMetaData
{
    TArray<FBoneReference> LinkedBones;                                               // 0x0000 (size: 0x10)
    uint8 MaxLOD;                                                                     // 0x0010 (size: 0x1)
    FAnimCurveType Type;                                                              // 0x0011 (size: 0x2)

}; // Size: 0x18

struct FCurvePayload : public FEmptyPayload
{
    FAnimationCurveIdentifier Identifier;                                             // 0x0000 (size: 0xC)

}; // Size: 0xC

struct FCurveRenamedPayload : public FCurvePayload
{
    FAnimationCurveIdentifier NewIdentifier;                                          // 0x000C (size: 0xC)

}; // Size: 0x18

struct FCurveScaledPayload : public FCurvePayload
{
    float Factor;                                                                     // 0x000C (size: 0x4)
    float Origin;                                                                     // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FCurveTableRowHandle
{
    class UCurveTable* CurveTable;                                                    // 0x0000 (size: 0x8)
    FName RowName;                                                                    // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FCurveTrack
{
    FName CurveName;                                                                  // 0x0000 (size: 0x8)
    TArray<float> CurveWeights;                                                       // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FCustomAttribute
{
}; // Size: 0x1

struct FCustomAttributePerBoneData
{
}; // Size: 0x1

struct FCustomAttributeSetting
{
    FString Name;                                                                     // 0x0000 (size: 0x10)
    FString Meaning;                                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FCustomChannelSetup
{
    TEnumAsByte<ECollisionChannel> Channel;                                           // 0x0000 (size: 0x1)
    TEnumAsByte<ECollisionResponse> DefaultResponse;                                  // 0x0001 (size: 0x1)
    bool bTraceType;                                                                  // 0x0002 (size: 0x1)
    bool bStaticObject;                                                               // 0x0003 (size: 0x1)
    FName Name;                                                                       // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FCustomDefine
{
    FString DefineName;                                                               // 0x0000 (size: 0x10)
    FString DefineValue;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FCustomInput
{
    FName InputName;                                                                  // 0x0000 (size: 0x8)
    FExpressionInput Input;                                                           // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FCustomOutput
{
    FName OutputName;                                                                 // 0x0000 (size: 0x8)
    TEnumAsByte<ECustomMaterialOutputType> OutputType;                                // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FCustomPrimitiveData
{
    TArray<float> Data;                                                               // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FCustomProfile
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    TArray<FResponseChannel> CustomResponses;                                         // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FDPMatchingIfCondition
{
    FName Operator;                                                                   // 0x0000 (size: 0x8)
    FString Arg1;                                                                     // 0x0008 (size: 0x10)
    FString Arg2;                                                                     // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FDPMatchingRulestruct : public FDPMatchingRulestructBase
{
    TArray<FDPMatchingRulestructE> OnTrue;                                            // 0x0048 (size: 0x10)
    TArray<FDPMatchingRulestructE> OnFalse;                                           // 0x0058 (size: 0x10)

}; // Size: 0x68

struct FDPMatchingRulestructA : public FDPMatchingRulestructBase
{
    TArray<FDPMatchingRulestructBase> OnTrue;                                         // 0x0048 (size: 0x10)
    TArray<FDPMatchingRulestructBase> OnFalse;                                        // 0x0058 (size: 0x10)

}; // Size: 0x68

struct FDPMatchingRulestructB : public FDPMatchingRulestructBase
{
    TArray<FDPMatchingRulestructA> OnTrue;                                            // 0x0048 (size: 0x10)
    TArray<FDPMatchingRulestructA> OnFalse;                                           // 0x0058 (size: 0x10)

}; // Size: 0x68

struct FDPMatchingRulestructBase
{
    FString RuleName;                                                                 // 0x0008 (size: 0x10)
    TArray<FDPMatchingIfCondition> IfConditions;                                      // 0x0018 (size: 0x10)
    FString AppendFragments;                                                          // 0x0028 (size: 0x10)
    FString SetUserVar;                                                               // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FDPMatchingRulestructC : public FDPMatchingRulestructBase
{
    TArray<FDPMatchingRulestructB> OnTrue;                                            // 0x0048 (size: 0x10)
    TArray<FDPMatchingRulestructB> OnFalse;                                           // 0x0058 (size: 0x10)

}; // Size: 0x68

struct FDPMatchingRulestructD : public FDPMatchingRulestructBase
{
    TArray<FDPMatchingRulestructC> OnTrue;                                            // 0x0048 (size: 0x10)
    TArray<FDPMatchingRulestructC> OnFalse;                                           // 0x0058 (size: 0x10)

}; // Size: 0x68

struct FDPMatchingRulestructE : public FDPMatchingRulestructBase
{
    TArray<FDPMatchingRulestructD> OnTrue;                                            // 0x0048 (size: 0x10)
    TArray<FDPMatchingRulestructD> OnFalse;                                           // 0x0058 (size: 0x10)

}; // Size: 0x68

struct FDamageEvent
{
    TSubclassOf<class UDamageType> DamageTypeClass;                                   // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FDataCacheDuplicatedObjectData
{
}; // Size: 0x10

struct FDataDrivenConsoleVariable
{
    FDataDrivenCVarType Type;                                                         // 0x0000 (size: 0x1)
    FString Name;                                                                     // 0x0008 (size: 0x10)
    FString ToolTip;                                                                  // 0x0018 (size: 0x10)
    float DefaultValueFloat;                                                          // 0x0028 (size: 0x4)
    int32 DefaultValueInt;                                                            // 0x002C (size: 0x4)
    bool DefaultValueBool;                                                            // 0x0030 (size: 0x1)

}; // Size: 0x60

struct FDataDrivenShaderPlatformInfoInput
{
    FName InputName;                                                                  // 0x0000 (size: 0x8)
    TEnumAsByte<EDataDrivenShaderPlatformInfoCondition> PropertyCondition;            // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FDataLayerInstanceNames
{
    bool bIsFirstDataLayerExternal;                                                   // 0x0000 (size: 0x1)
    TArray<FName> DataLayers;                                                         // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FDataTableCategoryHandle
{
    class UDataTable* DataTable;                                                      // 0x0000 (size: 0x8)
    FName ColumnName;                                                                 // 0x0008 (size: 0x8)
    FName RowContents;                                                                // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FDataTableRowHandle
{
    class UDataTable* DataTable;                                                      // 0x0000 (size: 0x8)
    FName RowName;                                                                    // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FDebugCameraControllerSettingsViewModeIndex
{
    TEnumAsByte<EViewModeIndex> ViewModeIndex;                                        // 0x0008 (size: 0x1)

}; // Size: 0x10

struct FDebugDisplayProperty
{
    class UObject* Obj;                                                               // 0x0000 (size: 0x8)
    UClass* WithinClass;                                                              // 0x0008 (size: 0x8)

}; // Size: 0x20

struct FDebugFloatHistory
{
    TArray<float> Samples;                                                            // 0x0000 (size: 0x10)
    int32 MaxSamples;                                                                 // 0x0010 (size: 0x4)
    float MinValue;                                                                   // 0x0014 (size: 0x4)
    float MaxValue;                                                                   // 0x0018 (size: 0x4)
    bool bAutoAdjustMinMax;                                                           // 0x001C (size: 0x1)

}; // Size: 0x20

struct FDebugTextInfo
{
    class AActor* SrcActor;                                                           // 0x0000 (size: 0x8)
    FVector SrcActorOffset;                                                           // 0x0008 (size: 0x18)
    FVector SrcActorDesiredOffset;                                                    // 0x0020 (size: 0x18)
    FString DebugText;                                                                // 0x0038 (size: 0x10)
    float TimeRemaining;                                                              // 0x0048 (size: 0x4)
    float Duration;                                                                   // 0x004C (size: 0x4)
    FColor TextColor;                                                                 // 0x0050 (size: 0x4)
    uint8 bAbsoluteLocation;                                                          // 0x0054 (size: 0x1)
    uint8 bKeepAttachedToActor;                                                       // 0x0054 (size: 0x1)
    uint8 bDrawShadow;                                                                // 0x0054 (size: 0x1)
    FVector OrigActorLocation;                                                        // 0x0058 (size: 0x18)
    class UFont* Font;                                                                // 0x0070 (size: 0x8)
    float FontScale;                                                                  // 0x0078 (size: 0x4)

}; // Size: 0x80

struct FDebuggingInfoForSingleFunction
{
}; // Size: 0x190

struct FDefaultAudioBusSettings
{
    FSoftObjectPath AudioBus;                                                         // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FDefault__AnimBlueprintGeneratedStruct
{
}; // Size: 0x0

struct FDefault__UserDefinedStruct
{
}; // Size: 0x0

struct FDelegateArray
{
    TArray<FDelegateArrayDelegates> Delegates;                                        // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FDepthFieldGlowInfo
{
    uint8 bEnableGlow;                                                                // 0x0000 (size: 0x1)
    FLinearColor GlowColor;                                                           // 0x0004 (size: 0x10)
    FVector2D GlowOuterRadius;                                                        // 0x0018 (size: 0x10)
    FVector2D GlowInnerRadius;                                                        // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FDeviceColorCurveData
{
    bool bEnable;                                                                     // 0x0000 (size: 0x1)
    bool bResetAfterCompletion;                                                       // 0x0001 (size: 0x1)
    class UCurveLinearColor* DeviceColorCurve;                                        // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FDeviceColorData
{
    bool bEnable;                                                                     // 0x0000 (size: 0x1)
    bool bResetAfterCompletion;                                                       // 0x0001 (size: 0x1)
    FColor LightColor;                                                                // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FDeviceTriggerBaseData
{
    EInputDeviceTriggerMask AffectedTriggers;                                         // 0x0000 (size: 0x1)
    bool bResetUponCompletion;                                                        // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FDeviceTriggerFeedbackData
{
    class UCurveFloat* FeedbackPositionCurve;                                         // 0x0000 (size: 0x8)
    class UCurveFloat* FeedbackStrenghCurve;                                          // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FDeviceTriggerTriggerResistanceData
{
    int32 StartPosition;                                                              // 0x0000 (size: 0x4)
    int32 StartStrengh;                                                               // 0x0004 (size: 0x4)
    int32 EndPosition;                                                                // 0x0008 (size: 0x4)
    int32 EndStrengh;                                                                 // 0x000C (size: 0x4)

}; // Size: 0x10

struct FDeviceTriggerTriggerVibrationData
{
    class UCurveFloat* TriggerPositionCurve;                                          // 0x0000 (size: 0x8)
    class UCurveFloat* VibrationFrequencyCurve;                                       // 0x0008 (size: 0x8)
    class UCurveFloat* VibrationAmplitudeCurve;                                       // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FDialogueContext
{
    class UDialogueVoice* Speaker;                                                    // 0x0000 (size: 0x8)
    TArray<class UDialogueVoice*> Targets;                                            // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FDialogueContextMapping
{
    FDialogueContext Context;                                                         // 0x0000 (size: 0x18)
    class USoundWave* SoundWave;                                                      // 0x0018 (size: 0x8)
    FString LocalizationKeyFormat;                                                    // 0x0020 (size: 0x10)
    class UDialogueSoundWaveProxy* Proxy;                                             // 0x0030 (size: 0x8)

}; // Size: 0x38

struct FDialogueWaveParameter
{
    class UDialogueWave* DialogueWave;                                                // 0x0000 (size: 0x8)
    FDialogueContext Context;                                                         // 0x0008 (size: 0x18)

}; // Size: 0x20

struct FDisplacementScaling
{
    float Magnitude;                                                                  // 0x0000 (size: 0x4)
    float Center;                                                                     // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FDistanceDatum
{
    float FadeInDistanceStart;                                                        // 0x0000 (size: 0x4)
    float FadeInDistanceEnd;                                                          // 0x0004 (size: 0x4)
    float FadeOutDistanceStart;                                                       // 0x0008 (size: 0x4)
    float FadeOutDistanceEnd;                                                         // 0x000C (size: 0x4)
    float Volume;                                                                     // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FDistributionLookupTable
{
    float TimeScale;                                                                  // 0x0000 (size: 0x4)
    float TimeBias;                                                                   // 0x0004 (size: 0x4)
    TArray<float> Values;                                                             // 0x0008 (size: 0x10)
    uint8 Op;                                                                         // 0x0018 (size: 0x1)
    uint8 EntryCount;                                                                 // 0x0019 (size: 0x1)
    uint8 EntryStride;                                                                // 0x001A (size: 0x1)
    uint8 SubEntryStride;                                                             // 0x001B (size: 0x1)
    uint8 LockFlag;                                                                   // 0x001C (size: 0x1)

}; // Size: 0x20

struct FDoubleVectorParameterValue
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    FVector4d ParameterValue;                                                         // 0x0010 (size: 0x20)
    FGuid ExpressionGUID;                                                             // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FDrawToRenderTargetContext
{
    class UTextureRenderTarget2D* RenderTarget;                                       // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FDropNoteInfo
{
    FVector Location;                                                                 // 0x0000 (size: 0x18)
    FRotator Rotation;                                                                // 0x0018 (size: 0x18)
    FString Comment;                                                                  // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FDummySpacerCameraTypes
{
}; // Size: 0x1

struct FDynamicChildSubmix
{
    TArray<class USoundSubmixBase*> ChildSubmixes;                                    // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FDynamicTextureInstance : public FStreamableTextureInstance
{
    class UTexture2D* Texture;                                                        // 0x0048 (size: 0x8)
    bool bAttached;                                                                   // 0x0050 (size: 0x1)
    float OriginalRadius;                                                             // 0x0054 (size: 0x4)

}; // Size: 0x58

struct FEdGraphPinReference
{
    TWeakObjectPtr<class UEdGraphNode> OwningNode;                                    // 0x0000 (size: 0x8)
    FGuid PinId;                                                                      // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FEdGraphPinType
{
    FName PinCategory;                                                                // 0x0000 (size: 0x8)
    FName PinSubCategory;                                                             // 0x0008 (size: 0x8)
    TWeakObjectPtr<class UObject> PinSubCategoryObject;                               // 0x0010 (size: 0x8)
    FSimpleMemberReference PinSubCategoryMemberReference;                             // 0x0018 (size: 0x20)
    FEdGraphTerminalType PinValueType;                                                // 0x0038 (size: 0x1C)
    EPinContainerType ContainerType;                                                  // 0x0054 (size: 0x1)
    uint8 bIsArray;                                                                   // 0x0055 (size: 0x1)
    uint8 bIsReference;                                                               // 0x0055 (size: 0x1)
    uint8 bIsConst;                                                                   // 0x0055 (size: 0x1)
    uint8 bIsWeakPointer;                                                             // 0x0055 (size: 0x1)
    uint8 bIsUObjectWrapper;                                                          // 0x0055 (size: 0x1)
    uint8 bSerializeAsSinglePrecisionFloat;                                           // 0x0055 (size: 0x1)

}; // Size: 0x58

struct FEdGraphSchemaAction
{
    FText MenuDescription;                                                            // 0x0008 (size: 0x10)
    FText TooltipDescription;                                                         // 0x0018 (size: 0x10)
    FText Category;                                                                   // 0x0028 (size: 0x10)
    FText Keywords;                                                                   // 0x0038 (size: 0x10)
    int32 Grouping;                                                                   // 0x0048 (size: 0x4)
    int32 SectionID;                                                                  // 0x004C (size: 0x4)
    TArray<FString> MenuDescriptionArray;                                             // 0x0050 (size: 0x10)
    TArray<FString> FullSearchTitlesArray;                                            // 0x0060 (size: 0x10)
    TArray<FString> FullSearchKeywordsArray;                                          // 0x0070 (size: 0x10)
    TArray<FString> FullSearchCategoryArray;                                          // 0x0080 (size: 0x10)
    TArray<FString> LocalizedMenuDescriptionArray;                                    // 0x0090 (size: 0x10)
    TArray<FString> LocalizedFullSearchTitlesArray;                                   // 0x00A0 (size: 0x10)
    TArray<FString> LocalizedFullSearchKeywordsArray;                                 // 0x00B0 (size: 0x10)
    TArray<FString> LocalizedFullSearchCategoryArray;                                 // 0x00C0 (size: 0x10)
    FString SearchText;                                                               // 0x00D0 (size: 0x10)

}; // Size: 0xE0

struct FEdGraphSchemaAction_NewNode : public FEdGraphSchemaAction
{
    class UEdGraphNode* NodeTemplate;                                                 // 0x00E0 (size: 0x8)

}; // Size: 0xE8

struct FEdGraphTerminalType
{
    FName TerminalCategory;                                                           // 0x0000 (size: 0x8)
    FName TerminalSubCategory;                                                        // 0x0008 (size: 0x8)
    TWeakObjectPtr<class UObject> TerminalSubCategoryObject;                          // 0x0010 (size: 0x8)
    bool bTerminalIsConst;                                                            // 0x0018 (size: 0x1)
    bool bTerminalIsWeakPointer;                                                      // 0x0019 (size: 0x1)
    bool bTerminalIsUObjectWrapper;                                                   // 0x001A (size: 0x1)

}; // Size: 0x1C

struct FEditedDocumentInfo
{
    FSoftObjectPath EditedObjectPath;                                                 // 0x0000 (size: 0x20)
    FVector2D SavedViewOffset;                                                        // 0x0020 (size: 0x10)
    float SavedZoomAmount;                                                            // 0x0030 (size: 0x4)
    class UObject* EditedObject;                                                      // 0x0038 (size: 0x8)

}; // Size: 0x40

struct FEditorElement
{
    int32 Indices;                                                                    // 0x0000 (size: 0xC)
    float Weights;                                                                    // 0x000C (size: 0xC)

}; // Size: 0x18

struct FEditorImportExportTestDefinition
{
    FFilePath ImportFilePath;                                                         // 0x0000 (size: 0x10)
    FString ExportFileExtension;                                                      // 0x0010 (size: 0x10)
    bool bSkipExport;                                                                 // 0x0020 (size: 0x1)
    TArray<FImportFactorySettingValues> FactorySettings;                              // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FEditorImportWorkflowDefinition
{
    FFilePath ImportFilePath;                                                         // 0x0000 (size: 0x10)
    TArray<FImportFactorySettingValues> FactorySettings;                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FEditorMapPerformanceTestDefinition
{
    FSoftObjectPath PerformanceTestmap;                                               // 0x0000 (size: 0x20)
    int32 TestTimer;                                                                  // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FEmitterDynamicParameter
{
    FName ParamName;                                                                  // 0x0000 (size: 0x8)
    uint8 bUseEmitterTime;                                                            // 0x0008 (size: 0x1)
    uint8 bSpawnTimeOnly;                                                             // 0x0008 (size: 0x1)
    TEnumAsByte<EEmitterDynamicParameterValue> ValueMethod;                           // 0x000C (size: 0x1)
    uint8 bScaleVelocityByParamValue;                                                 // 0x0010 (size: 0x1)
    FRawDistributionFloat ParamValue;                                                 // 0x0018 (size: 0x30)

}; // Size: 0x48

struct FEmptyPayload
{
}; // Size: 0x1

struct FEncounteredStateMachineStack
{
}; // Size: 0x30

struct FEndPhysicsTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FEngineShowFlagsSetting
{
    FString ShowFlagName;                                                             // 0x0000 (size: 0x10)
    bool Enabled;                                                                     // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FEquirectProps
{
    FBox2D LeftUVRect;                                                                // 0x0000 (size: 0x28)
    FBox2D RightUVRect;                                                               // 0x0028 (size: 0x28)
    FVector2D LeftScale;                                                              // 0x0050 (size: 0x10)
    FVector2D RightScale;                                                             // 0x0060 (size: 0x10)
    FVector2D LeftBias;                                                               // 0x0070 (size: 0x10)
    FVector2D RightBias;                                                              // 0x0080 (size: 0x10)
    float Radius;                                                                     // 0x0090 (size: 0x4)

}; // Size: 0x98

struct FEventGraphFastCallPair
{
    class UFunction* FunctionToPatch;                                                 // 0x0000 (size: 0x8)
    int32 EventGraphCallOffset;                                                       // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FExponentialHeightFogData
{
    float FogDensity;                                                                 // 0x0000 (size: 0x4)
    float FogHeightFalloff;                                                           // 0x0004 (size: 0x4)
    float FogHeightOffset;                                                            // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FExposedValueCopyRecord
{
    int32 CopyIndex;                                                                  // 0x0000 (size: 0x4)
    EPostCopyOperation PostCopyOperation;                                             // 0x0004 (size: 0x1)
    bool bOnlyUpdateWhenActive;                                                       // 0x0005 (size: 0x1)

}; // Size: 0x8

struct FExposedValueHandler
{
}; // Size: 0x10

struct FExposureSettings
{
    float FixedEV100;                                                                 // 0x0000 (size: 0x4)
    bool bFixed;                                                                      // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FExpressionExecOutput
{
    class UMaterialExpression* Expression;                                            // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FExpressionInput
{
    class UMaterialExpression* Expression;                                            // 0x0000 (size: 0x8)
    int32 OutputIndex;                                                                // 0x0008 (size: 0x4)
    FName InputName;                                                                  // 0x000C (size: 0x8)
    int32 Mask;                                                                       // 0x0014 (size: 0x4)
    int32 MaskR;                                                                      // 0x0018 (size: 0x4)
    int32 MaskG;                                                                      // 0x001C (size: 0x4)
    int32 MaskB;                                                                      // 0x0020 (size: 0x4)
    int32 MaskA;                                                                      // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FExpressionOutput
{
    FName OutputName;                                                                 // 0x0000 (size: 0x8)
    int32 Mask;                                                                       // 0x0008 (size: 0x4)
    int32 MaskR;                                                                      // 0x000C (size: 0x4)
    int32 MaskG;                                                                      // 0x0010 (size: 0x4)
    int32 MaskB;                                                                      // 0x0014 (size: 0x4)
    int32 MaskA;                                                                      // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FExternalDataLayerUID
{
    uint32 Value;                                                                     // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FExternalSpatialAccelerationPayload
{
}; // Size: 0x10

struct FExternalToolDefinition
{
    FString ToolName;                                                                 // 0x0000 (size: 0x10)
    FFilePath ExecutablePath;                                                         // 0x0010 (size: 0x10)
    FString CommandLineOptions;                                                       // 0x0020 (size: 0x10)
    FDirectoryPath WorkingDirectory;                                                  // 0x0030 (size: 0x10)
    FString ScriptExtension;                                                          // 0x0040 (size: 0x10)
    FDirectoryPath ScriptDirectory;                                                   // 0x0050 (size: 0x10)

}; // Size: 0x60

struct FFXSystemSpawnParameters
{
    class UObject* WorldContextObject;                                                // 0x0000 (size: 0x8)
    class UFXSystemAsset* SystemTemplate;                                             // 0x0008 (size: 0x8)
    FVector Location;                                                                 // 0x0010 (size: 0x18)
    FRotator Rotation;                                                                // 0x0028 (size: 0x18)
    FVector Scale;                                                                    // 0x0040 (size: 0x18)
    class USceneComponent* AttachToComponent;                                         // 0x0058 (size: 0x8)
    FName AttachPointName;                                                            // 0x0060 (size: 0x8)
    TEnumAsByte<EAttachLocation::Type> LocationType;                                  // 0x0068 (size: 0x1)
    bool bAutoDestroy;                                                                // 0x0069 (size: 0x1)
    bool bAutoActivate;                                                               // 0x006A (size: 0x1)
    EPSCPoolMethod PoolingMethod;                                                     // 0x006B (size: 0x1)
    bool bPreCullCheck;                                                               // 0x006C (size: 0x1)
    bool bIsPlayerEffect;                                                             // 0x006D (size: 0x1)

}; // Size: 0x70

struct FFilmStockSettings
{
    float Slope;                                                                      // 0x0000 (size: 0x4)
    float Toe;                                                                        // 0x0004 (size: 0x4)
    float Shoulder;                                                                   // 0x0008 (size: 0x4)
    float BlackClip;                                                                  // 0x000C (size: 0x4)
    float WhiteClip;                                                                  // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FFindFloorResult
{
    uint8 bBlockingHit;                                                               // 0x0000 (size: 0x1)
    uint8 bWalkableFloor;                                                             // 0x0000 (size: 0x1)
    uint8 bLineTrace;                                                                 // 0x0000 (size: 0x1)
    float FloorDist;                                                                  // 0x0004 (size: 0x4)
    float LineDist;                                                                   // 0x0008 (size: 0x4)
    FHitResult HitResult;                                                             // 0x0010 (size: 0xF8)

}; // Size: 0x108

struct FFloatAnimationAttribute
{
    float Value;                                                                      // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FFloatCurve : public FAnimCurveBase
{
    FRichCurve FloatCurve;                                                            // 0x0010 (size: 0x80)

}; // Size: 0x90

struct FFloatDistribution
{
    FDistributionLookupTable Table;                                                   // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FFloatRK4SpringInterpolator
{
    float StiffnessConstant;                                                          // 0x0000 (size: 0x4)
    float DampeningRatio;                                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FFloatSpringState
{
}; // Size: 0xC

struct FFontCharacter
{
    int32 StartU;                                                                     // 0x0000 (size: 0x4)
    int32 StartV;                                                                     // 0x0004 (size: 0x4)
    int32 USize;                                                                      // 0x0008 (size: 0x4)
    int32 VSize;                                                                      // 0x000C (size: 0x4)
    uint8 TextureIndex;                                                               // 0x0010 (size: 0x1)
    int32 VerticalOffset;                                                             // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FFontImportOptionsData
{
    FString FontName;                                                                 // 0x0000 (size: 0x10)
    float Height;                                                                     // 0x0010 (size: 0x4)
    uint8 bEnableAntialiasing;                                                        // 0x0014 (size: 0x1)
    uint8 bEnableBold;                                                                // 0x0014 (size: 0x1)
    uint8 bEnableItalic;                                                              // 0x0014 (size: 0x1)
    uint8 bEnableUnderline;                                                           // 0x0014 (size: 0x1)
    uint8 bAlphaOnly;                                                                 // 0x0014 (size: 0x1)
    TEnumAsByte<EFontImportCharacterSet> CharacterSet;                                // 0x0018 (size: 0x1)
    FString Chars;                                                                    // 0x0020 (size: 0x10)
    FString UnicodeRange;                                                             // 0x0030 (size: 0x10)
    FString CharsFilePath;                                                            // 0x0040 (size: 0x10)
    FString CharsFileWildcard;                                                        // 0x0050 (size: 0x10)
    uint8 bCreatePrintableOnly;                                                       // 0x0060 (size: 0x1)
    uint8 bIncludeASCIIRange;                                                         // 0x0060 (size: 0x1)
    FLinearColor ForegroundColor;                                                     // 0x0064 (size: 0x10)
    uint8 bEnableDropShadow;                                                          // 0x0074 (size: 0x1)
    int32 TexturePageWidth;                                                           // 0x0078 (size: 0x4)
    int32 TexturePageMaxHeight;                                                       // 0x007C (size: 0x4)
    int32 XPadding;                                                                   // 0x0080 (size: 0x4)
    int32 YPadding;                                                                   // 0x0084 (size: 0x4)
    int32 ExtendBoxTop;                                                               // 0x0088 (size: 0x4)
    int32 ExtendBoxBottom;                                                            // 0x008C (size: 0x4)
    int32 ExtendBoxRight;                                                             // 0x0090 (size: 0x4)
    int32 ExtendBoxLeft;                                                              // 0x0094 (size: 0x4)
    uint8 bEnableLegacyMode;                                                          // 0x0098 (size: 0x1)
    int32 Kerning;                                                                    // 0x009C (size: 0x4)
    uint8 bUseDistanceFieldAlpha;                                                     // 0x00A0 (size: 0x1)
    int32 DistanceFieldScaleFactor;                                                   // 0x00A4 (size: 0x4)
    float DistanceFieldScanRadiusScale;                                               // 0x00A8 (size: 0x4)

}; // Size: 0xB0

struct FFontParameterValue
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    class UFont* FontValue;                                                           // 0x0010 (size: 0x8)
    int32 FontPage;                                                                   // 0x0018 (size: 0x4)
    FGuid ExpressionGUID;                                                             // 0x001C (size: 0x10)

}; // Size: 0x30

struct FFontRenderInfo
{
    uint8 bClipText;                                                                  // 0x0000 (size: 0x1)
    uint8 bEnableShadow;                                                              // 0x0000 (size: 0x1)
    FDepthFieldGlowInfo GlowInfo;                                                     // 0x0008 (size: 0x38)

}; // Size: 0x40

struct FForceFeedbackAttenuationSettings : public FBaseAttenuationSettings
{
}; // Size: 0xC0

struct FForceFeedbackChannelDetails
{
    uint8 bAffectsLeftLarge;                                                          // 0x0000 (size: 0x1)
    uint8 bAffectsLeftSmall;                                                          // 0x0000 (size: 0x1)
    uint8 bAffectsRightLarge;                                                         // 0x0000 (size: 0x1)
    uint8 bAffectsRightSmall;                                                         // 0x0000 (size: 0x1)
    FRuntimeFloatCurve Curve;                                                         // 0x0008 (size: 0x88)

}; // Size: 0x90

struct FForceFeedbackEffectOverridenChannelDetails
{
    TArray<FForceFeedbackChannelDetails> ChannelDetails;                              // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FForceFeedbackParameters
{
    FName Tag;                                                                        // 0x0000 (size: 0x8)
    bool bLooping;                                                                    // 0x0008 (size: 0x1)
    bool bIgnoreTimeDilation;                                                         // 0x0009 (size: 0x1)
    bool bPlayWhilePaused;                                                            // 0x000A (size: 0x1)

}; // Size: 0xC

struct FFormatArgumentData
{
    FString ArgumentName;                                                             // 0x0000 (size: 0x10)
    TEnumAsByte<EFormatArgumentType::Type> ArgumentValueType;                         // 0x0010 (size: 0x1)
    FText ArgumentValue;                                                              // 0x0018 (size: 0x10)
    int64 ArgumentValueInt;                                                           // 0x0028 (size: 0x8)
    float ArgumentValueFloat;                                                         // 0x0030 (size: 0x4)
    double ArgumentValueDouble;                                                       // 0x0038 (size: 0x8)
    ETextGender ArgumentValueGender;                                                  // 0x0040 (size: 0x1)

}; // Size: 0x48

struct FFractureEffect
{
    class UParticleSystem* ParticleSystem;                                            // 0x0000 (size: 0x8)
    class USoundBase* Sound;                                                          // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FFrameRateChangedPayload : public FEmptyPayload
{
    FFrameRate PreviousFrameRate;                                                     // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FFreezablePerPlatformInt
{
}; // Size: 0x4

struct FFullyLoadedPackagesInfo
{
    TEnumAsByte<EFullyLoadPackageType> FullyLoadType;                                 // 0x0000 (size: 0x1)
    FString Tag;                                                                      // 0x0008 (size: 0x10)
    TArray<FName> PackagesToLoad;                                                     // 0x0018 (size: 0x10)
    TArray<class UObject*> LoadedObjects;                                             // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FFunctionExpressionInput
{
    class UMaterialExpressionFunctionInput* ExpressionInput;                          // 0x0000 (size: 0x8)
    FGuid ExpressionInputId;                                                          // 0x0008 (size: 0x10)
    FExpressionInput Input;                                                           // 0x0018 (size: 0x28)

}; // Size: 0x40

struct FFunctionExpressionOutput
{
    class UMaterialExpressionFunctionOutput* ExpressionOutput;                        // 0x0000 (size: 0x8)
    FGuid ExpressionOutputId;                                                         // 0x0008 (size: 0x10)
    FExpressionOutput Output;                                                         // 0x0018 (size: 0x1C)

}; // Size: 0x38

struct FGPUSpriteEmitterInfo
{
    class UParticleModuleRequired* RequiredModule;                                    // 0x0000 (size: 0x8)
    class UParticleModuleSpawn* SpawnModule;                                          // 0x0008 (size: 0x8)
    class UParticleModuleSpawnPerUnit* SpawnPerUnitModule;                            // 0x0010 (size: 0x8)
    TArray<class UParticleModule*> SpawnModules;                                      // 0x0018 (size: 0x10)
    FGPUSpriteLocalVectorFieldInfo LocalVectorField;                                  // 0x0030 (size: 0xD0)
    FFloatDistribution VectorFieldScale;                                              // 0x0100 (size: 0x20)
    FFloatDistribution DragCoefficient;                                               // 0x0120 (size: 0x20)
    FFloatDistribution PointAttractorStrength;                                        // 0x0140 (size: 0x20)
    FFloatDistribution Resilience;                                                    // 0x0160 (size: 0x20)
    FVector ConstantAcceleration;                                                     // 0x0180 (size: 0x18)
    FVector PointAttractorPosition;                                                   // 0x0198 (size: 0x18)
    float PointAttractorRadiusSq;                                                     // 0x01B0 (size: 0x4)
    FVector OrbitOffsetBase;                                                          // 0x01B8 (size: 0x18)
    FVector OrbitOffsetRange;                                                         // 0x01D0 (size: 0x18)
    FVector2D InvMaxSize;                                                             // 0x01E8 (size: 0x10)
    float InvRotationRateScale;                                                       // 0x01F8 (size: 0x4)
    float MaxLifetime;                                                                // 0x01FC (size: 0x4)
    int32 MaxParticleCount;                                                           // 0x0200 (size: 0x4)
    TEnumAsByte<EParticleScreenAlignment> ScreenAlignment;                            // 0x0204 (size: 0x1)
    TEnumAsByte<EParticleAxisLock> LockAxisFlag;                                      // 0x0205 (size: 0x1)
    uint8 bEnableCollision;                                                           // 0x0208 (size: 0x1)
    TEnumAsByte<EParticleCollisionMode::Type> CollisionMode;                          // 0x020C (size: 0x1)
    uint8 bUseVelocityForMotionBlur;                                                  // 0x0210 (size: 0x1)
    uint8 bRemoveHMDRoll;                                                             // 0x0210 (size: 0x1)
    float MinFacingCameraBlendDistance;                                               // 0x0214 (size: 0x4)
    float MaxFacingCameraBlendDistance;                                               // 0x0218 (size: 0x4)
    FRawDistributionVector DynamicColor;                                              // 0x0220 (size: 0x60)
    FRawDistributionFloat DynamicAlpha;                                               // 0x0280 (size: 0x30)
    FRawDistributionVector DynamicColorScale;                                         // 0x02B0 (size: 0x60)
    FRawDistributionFloat DynamicAlphaScale;                                          // 0x0310 (size: 0x30)

}; // Size: 0x350

struct FGPUSpriteLocalVectorFieldInfo
{
    class UVectorField* Field;                                                        // 0x0000 (size: 0x8)
    FTransform Transform;                                                             // 0x0010 (size: 0x60)
    FRotator MinInitialRotation;                                                      // 0x0070 (size: 0x18)
    FRotator MaxInitialRotation;                                                      // 0x0088 (size: 0x18)
    FRotator RotationRate;                                                            // 0x00A0 (size: 0x18)
    float Intensity;                                                                  // 0x00B8 (size: 0x4)
    float Tightness;                                                                  // 0x00BC (size: 0x4)
    uint8 bIgnoreComponentTransform;                                                  // 0x00C0 (size: 0x1)
    uint8 bTileX;                                                                     // 0x00C0 (size: 0x1)
    uint8 bTileY;                                                                     // 0x00C0 (size: 0x1)
    uint8 bTileZ;                                                                     // 0x00C0 (size: 0x1)
    uint8 bUseFixDT;                                                                  // 0x00C0 (size: 0x1)

}; // Size: 0xD0

struct FGPUSpriteResourceData
{
    TArray<FColor> QuantizedColorSamples;                                             // 0x0000 (size: 0x10)
    TArray<FColor> QuantizedMiscSamples;                                              // 0x0010 (size: 0x10)
    TArray<FColor> QuantizedSimulationAttrSamples;                                    // 0x0020 (size: 0x10)
    FVector4 ColorScale;                                                              // 0x0030 (size: 0x20)
    FVector4 ColorBias;                                                               // 0x0050 (size: 0x20)
    FVector4 MiscScale;                                                               // 0x0070 (size: 0x20)
    FVector4 MiscBias;                                                                // 0x0090 (size: 0x20)
    FVector4 SimulationAttrCurveScale;                                                // 0x00B0 (size: 0x20)
    FVector4 SimulationAttrCurveBias;                                                 // 0x00D0 (size: 0x20)
    FVector4 SubImageSize;                                                            // 0x00F0 (size: 0x20)
    FVector4 SizeBySpeed;                                                             // 0x0110 (size: 0x20)
    FVector ConstantAcceleration;                                                     // 0x0130 (size: 0x18)
    FVector OrbitOffsetBase;                                                          // 0x0148 (size: 0x18)
    FVector OrbitOffsetRange;                                                         // 0x0160 (size: 0x18)
    FVector OrbitFrequencyBase;                                                       // 0x0178 (size: 0x18)
    FVector OrbitFrequencyRange;                                                      // 0x0190 (size: 0x18)
    FVector OrbitPhaseBase;                                                           // 0x01A8 (size: 0x18)
    FVector OrbitPhaseRange;                                                          // 0x01C0 (size: 0x18)
    float GlobalVectorFieldScale;                                                     // 0x01D8 (size: 0x4)
    float GlobalVectorFieldTightness;                                                 // 0x01DC (size: 0x4)
    float PerParticleVectorFieldScale;                                                // 0x01E0 (size: 0x4)
    float PerParticleVectorFieldBias;                                                 // 0x01E4 (size: 0x4)
    float DragCoefficientScale;                                                       // 0x01E8 (size: 0x4)
    float DragCoefficientBias;                                                        // 0x01EC (size: 0x4)
    float ResilienceScale;                                                            // 0x01F0 (size: 0x4)
    float ResilienceBias;                                                             // 0x01F4 (size: 0x4)
    float CollisionRadiusScale;                                                       // 0x01F8 (size: 0x4)
    float CollisionRadiusBias;                                                        // 0x01FC (size: 0x4)
    float CollisionTimeBias;                                                          // 0x0200 (size: 0x4)
    float CollisionRandomSpread;                                                      // 0x0204 (size: 0x4)
    float CollisionRandomDistribution;                                                // 0x0208 (size: 0x4)
    float OneMinusFriction;                                                           // 0x020C (size: 0x4)
    float RotationRateScale;                                                          // 0x0210 (size: 0x4)
    float CameraMotionBlurAmount;                                                     // 0x0214 (size: 0x4)
    TEnumAsByte<EParticleScreenAlignment> ScreenAlignment;                            // 0x0218 (size: 0x1)
    TEnumAsByte<EParticleAxisLock> LockAxisFlag;                                      // 0x0219 (size: 0x1)
    FVector2D PivotOffset;                                                            // 0x0220 (size: 0x10)
    uint8 bUseVelocityForMotionBlur;                                                  // 0x0230 (size: 0x1)
    uint8 bRemoveHMDRoll;                                                             // 0x0230 (size: 0x1)
    float MinFacingCameraBlendDistance;                                               // 0x0234 (size: 0x4)
    float MaxFacingCameraBlendDistance;                                               // 0x0238 (size: 0x4)

}; // Size: 0x240

struct FGameNameRedirect
{
    FName OldGameName;                                                                // 0x0000 (size: 0x8)
    FName NewGameName;                                                                // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FGaussianSumBloomSettings
{
    float Intensity;                                                                  // 0x0000 (size: 0x4)
    float Threshold;                                                                  // 0x0004 (size: 0x4)
    float SizeScale;                                                                  // 0x0008 (size: 0x4)
    float Filter1Size;                                                                // 0x000C (size: 0x4)
    float Filter2Size;                                                                // 0x0010 (size: 0x4)
    float Filter3Size;                                                                // 0x0014 (size: 0x4)
    float Filter4Size;                                                                // 0x0018 (size: 0x4)
    float Filter5Size;                                                                // 0x001C (size: 0x4)
    float Filter6Size;                                                                // 0x0020 (size: 0x4)
    FLinearColor Filter1Tint;                                                         // 0x0024 (size: 0x10)
    FLinearColor Filter2Tint;                                                         // 0x0034 (size: 0x10)
    FLinearColor Filter3Tint;                                                         // 0x0044 (size: 0x10)
    FLinearColor Filter4Tint;                                                         // 0x0054 (size: 0x10)
    FLinearColor Filter5Tint;                                                         // 0x0064 (size: 0x10)
    FLinearColor Filter6Tint;                                                         // 0x0074 (size: 0x10)

}; // Size: 0x84

struct FGenericStruct
{
    int32 Data;                                                                       // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FGeomSelection
{
    int32 Type;                                                                       // 0x0000 (size: 0x4)
    int32 Index;                                                                      // 0x0004 (size: 0x4)
    int32 SelectionIndex;                                                             // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FGraphAssetPlayerInformation
{
    TArray<int32> PlayerNodeIndices;                                                  // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FGraphReference
{
    class UEdGraph* MacroGraph;                                                       // 0x0000 (size: 0x8)
    class UBlueprint* GraphBlueprint;                                                 // 0x0008 (size: 0x8)
    FGuid GraphGuid;                                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FGridBlendSample
{
    FEditorElement GridElement;                                                       // 0x0000 (size: 0x18)
    float BlendWeight;                                                                // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FHLODISMComponentDesc
{
    class UStaticMesh* StaticMesh;                                                    // 0x0000 (size: 0x8)
    class UMaterialInterface* Material;                                               // 0x0008 (size: 0x8)
    TArray<FTransform> Instances;                                                     // 0x0010 (size: 0x10)
    TArray<FCustomPrimitiveData> InstancesCustomPrimitiveData;                        // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FHLODISMComponentDescriptor : public FISMComponentDescriptor
{
}; // Size: 0x218

struct FHLODInstancingKey
{
    class UStaticMesh* StaticMesh;                                                    // 0x0000 (size: 0x8)
    class UMaterialInterface* Material;                                               // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FHLODProxyMesh
{
    TLazyObjectPtr<class ALODActor> LODActor;                                         // 0x0000 (size: 0x18)
    class UStaticMesh* StaticMesh;                                                    // 0x0018 (size: 0x8)
    FName Key;                                                                        // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FHapticFeedbackDetails_Curve
{
    FRuntimeFloatCurve Frequency;                                                     // 0x0000 (size: 0x88)
    FRuntimeFloatCurve Amplitude;                                                     // 0x0088 (size: 0x88)

}; // Size: 0x110

struct FHardwareCursorReference
{
    FName CursorPath;                                                                 // 0x0000 (size: 0x8)
    FVector2D HotSpot;                                                                // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FHardwareDeviceIdentifier
{
    FName InputClassName;                                                             // 0x0000 (size: 0x8)
    FName HardwareDeviceIdentifier;                                                   // 0x0008 (size: 0x8)
    EHardwareDevicePrimaryType PrimaryDeviceType;                                     // 0x0010 (size: 0x1)
    int32 SupportedFeaturesMask;                                                      // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FHierarchicalSimplification
{
    float TransitionScreenSize;                                                       // 0x0000 (size: 0x4)
    float OverrideDrawDistance;                                                       // 0x0004 (size: 0x4)
    uint8 bUseOverrideDrawDistance;                                                   // 0x0008 (size: 0x1)
    uint8 bAllowSpecificExclusion;                                                    // 0x0008 (size: 0x1)
    uint8 bOnlyGenerateClustersForVolumes;                                            // 0x0008 (size: 0x1)
    uint8 bReusePreviousLevelClusters;                                                // 0x0008 (size: 0x1)
    EHierarchicalSimplificationMethod SimplificationMethod;                           // 0x0009 (size: 0x1)
    FMeshProxySettings ProxySetting;                                                  // 0x0010 (size: 0x100)
    FMeshMergingSettings MergeSetting;                                                // 0x0110 (size: 0x108)
    FMeshApproximationSettings ApproximateSettings;                                   // 0x0218 (size: 0x128)
    float DesiredBoundRadius;                                                         // 0x0340 (size: 0x4)
    float DesiredFillingPercentage;                                                   // 0x0344 (size: 0x4)
    int32 MinNumberOfActorsToBuild;                                                   // 0x0348 (size: 0x4)

}; // Size: 0x350

struct FHitResult
{
    int32 FaceIndex;                                                                  // 0x0000 (size: 0x4)
    float Time;                                                                       // 0x0004 (size: 0x4)
    float Distance;                                                                   // 0x0008 (size: 0x4)
    FVector_NetQuantize Location;                                                     // 0x0010 (size: 0x18)
    FVector_NetQuantize ImpactPoint;                                                  // 0x0028 (size: 0x18)
    FVector_NetQuantizeNormal Normal;                                                 // 0x0040 (size: 0x18)
    FVector_NetQuantizeNormal ImpactNormal;                                           // 0x0058 (size: 0x18)
    FVector_NetQuantize TraceStart;                                                   // 0x0070 (size: 0x18)
    FVector_NetQuantize TraceEnd;                                                     // 0x0088 (size: 0x18)
    float PenetrationDepth;                                                           // 0x00A0 (size: 0x4)
    int32 MyItem;                                                                     // 0x00A4 (size: 0x4)
    int32 Item;                                                                       // 0x00A8 (size: 0x4)
    uint8 ElementIndex;                                                               // 0x00AC (size: 0x1)
    uint8 bBlockingHit;                                                               // 0x00AD (size: 0x1)
    uint8 bStartPenetrating;                                                          // 0x00AD (size: 0x1)
    TWeakObjectPtr<class UPhysicalMaterial> PhysMaterial;                             // 0x00B0 (size: 0x8)
    FActorInstanceHandle HitObjectHandle;                                             // 0x00B8 (size: 0x20)
    TWeakObjectPtr<class UPrimitiveComponent> Component;                              // 0x00D8 (size: 0x8)
    FName BoneName;                                                                   // 0x00E8 (size: 0x8)
    FName MyBoneName;                                                                 // 0x00F0 (size: 0x8)

}; // Size: 0xF8

struct FHitResultNetSerializerConfig : public FNetSerializerConfig
{
}; // Size: 0x10

struct FISMClientData
{
    TArray<FISMClientInstance> Instances;                                             // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FISMClientHandle
{
    int32 Index;                                                                      // 0x0000 (size: 0x4)
    FGuid Guid;                                                                       // 0x0004 (size: 0x10)

}; // Size: 0x14

struct FISMClientInstance
{
    TArray<int32> ComponentIndices;                                                   // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FISMClientInstanceManagerData
{
}; // Size: 0x10

struct FISMComponentData
{
}; // Size: 0x1

struct FISMComponentDescriptor : public FISMComponentDescriptorBase
{
    class UStaticMesh* StaticMesh;                                                    // 0x01E8 (size: 0x8)
    TArray<class UMaterialInterface*> OverrideMaterials;                              // 0x01F0 (size: 0x10)
    class UMaterialInterface* OverlayMaterial;                                        // 0x0200 (size: 0x8)
    TArray<class URuntimeVirtualTexture*> RuntimeVirtualTextures;                     // 0x0208 (size: 0x10)

}; // Size: 0x218

struct FISMComponentDescriptorBase
{
    uint32 Hash;                                                                      // 0x0008 (size: 0x4)
    TSubclassOf<class UInstancedStaticMeshComponent> ComponentClass;                  // 0x0010 (size: 0x8)
    TEnumAsByte<EComponentMobility::Type> Mobility;                                   // 0x0018 (size: 0x1)
    ERuntimeVirtualTextureMainPassType VirtualTextureRenderPassType;                  // 0x0019 (size: 0x1)
    ELightmapType LightmapType;                                                       // 0x001A (size: 0x1)
    FLightingChannels LightingChannels;                                               // 0x001B (size: 0x1)
    int32 RayTracingGroupId;                                                          // 0x001C (size: 0x4)
    ERayTracingGroupCullingPriority RayTracingGroupCullingPriority;                   // 0x0020 (size: 0x1)
    TEnumAsByte<EHasCustomNavigableGeometry::Type> bHasCustomNavigableGeometry;       // 0x0021 (size: 0x1)
    ERendererStencilMask CustomDepthStencilWriteMask;                                 // 0x0022 (size: 0x1)
    FBodyInstance BodyInstance;                                                       // 0x0028 (size: 0x198)
    int32 InstanceStartCullDistance;                                                  // 0x01C0 (size: 0x4)
    int32 InstanceEndCullDistance;                                                    // 0x01C4 (size: 0x4)
    float InstanceLODDistanceScale;                                                   // 0x01C8 (size: 0x4)
    int32 VirtualTextureCullMips;                                                     // 0x01CC (size: 0x4)
    int32 TranslucencySortPriority;                                                   // 0x01D0 (size: 0x4)
    int32 OverriddenLightMapRes;                                                      // 0x01D4 (size: 0x4)
    int32 CustomDepthStencilValue;                                                    // 0x01D8 (size: 0x4)
    uint8 bCastShadow;                                                                // 0x01DC (size: 0x1)
    uint8 bEmissiveLightSource;                                                       // 0x01DC (size: 0x1)
    uint8 bCastDynamicShadow;                                                         // 0x01DC (size: 0x1)
    uint8 bCastStaticShadow;                                                          // 0x01DC (size: 0x1)
    uint8 bCastContactShadow;                                                         // 0x01DC (size: 0x1)
    uint8 bCastShadowAsTwoSided;                                                      // 0x01DC (size: 0x1)
    uint8 bCastHiddenShadow;                                                          // 0x01DC (size: 0x1)
    uint8 bAffectDynamicIndirectLighting;                                             // 0x01DC (size: 0x1)
    uint8 bAffectDynamicIndirectLightingWhileHidden;                                  // 0x01DD (size: 0x1)
    uint8 bAffectDistanceFieldLighting;                                               // 0x01DD (size: 0x1)
    uint8 bReceivesDecals;                                                            // 0x01DD (size: 0x1)
    uint8 bOverrideLightMapRes;                                                       // 0x01DD (size: 0x1)
    uint8 bUseAsOccluder;                                                             // 0x01DD (size: 0x1)
    uint8 bEnableDensityScaling;                                                      // 0x01DD (size: 0x1)
    uint8 bEnableDiscardOnLoad;                                                       // 0x01DD (size: 0x1)
    uint8 bRenderCustomDepth;                                                         // 0x01DD (size: 0x1)
    uint8 bVisibleInRayTracing;                                                       // 0x01DE (size: 0x1)
    uint8 bHiddenInGame;                                                              // 0x01DE (size: 0x1)
    uint8 bIsEditorOnly;                                                              // 0x01DE (size: 0x1)
    uint8 bVisible;                                                                   // 0x01DE (size: 0x1)
    uint8 bEvaluateWorldPositionOffset;                                               // 0x01DE (size: 0x1)
    uint8 bReverseCulling;                                                            // 0x01DE (size: 0x1)
    uint8 bUseGpuLodSelection;                                                        // 0x01DE (size: 0x1)
    uint8 bUseDefaultCollision;                                                       // 0x01DE (size: 0x1)
    uint8 bGenerateOverlapEvents;                                                     // 0x01DF (size: 0x1)
    uint8 bOverrideNavigationExport;                                                  // 0x01DF (size: 0x1)
    uint8 bForceNavigationObstacle;                                                   // 0x01DF (size: 0x1)
    uint8 bFillCollisionUnderneathForNavmesh;                                         // 0x01DF (size: 0x1)
    int32 WorldPositionOffsetDisableDistance;                                         // 0x01E0 (size: 0x4)
    EShadowCacheInvalidationBehavior ShadowCacheInvalidationBehavior;                 // 0x01E4 (size: 0x1)
    TEnumAsByte<EDetailMode> DetailMode;                                              // 0x01E5 (size: 0x1)

}; // Size: 0x1E8

struct FISMComponentInstance
{
    int32 ClientIndex;                                                                // 0x0000 (size: 0x4)
    int32 InstanceIndex;                                                              // 0x0004 (size: 0x4)
    int32 InstanceSubIndex;                                                           // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FImportFactorySettingValues
{
    FString SettingName;                                                              // 0x0000 (size: 0x10)
    FString Value;                                                                    // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FImportanceTexture
{
    FIntPoint Size;                                                                   // 0x0000 (size: 0x8)
    int32 NumMips;                                                                    // 0x0008 (size: 0x4)
    TArray<float> MarginalCDF;                                                        // 0x0010 (size: 0x10)
    TArray<float> ConditionalCDF;                                                     // 0x0020 (size: 0x10)
    TArray<FColor> TextureData;                                                       // 0x0030 (size: 0x10)
    TWeakObjectPtr<class UTexture2D> Texture;                                         // 0x0040 (size: 0x8)
    TEnumAsByte<EImportanceWeight::Type> Weighting;                                   // 0x0048 (size: 0x1)

}; // Size: 0x50

struct FIndexedCurve
{
    FKeyHandleMap KeyHandlesToIndices;                                                // 0x0008 (size: 0x60)

}; // Size: 0x68

struct FInertializationBoneDiff
{
}; // Size: 0x60

struct FInertializationPose
{
}; // Size: 0xC0

struct FInertializationPoseDiff
{
}; // Size: 0x38

struct FInertializationRequest
{
    float Duration;                                                                   // 0x0000 (size: 0x4)
    class UBlendProfile* BlendProfile;                                                // 0x0008 (size: 0x8)
    bool bUseBlendMode;                                                               // 0x0010 (size: 0x1)
    EAlphaBlendOption BlendMode;                                                      // 0x0011 (size: 0x1)
    class UCurveFloat* CustomBlendCurve;                                              // 0x0018 (size: 0x8)
    FText Description;                                                                // 0x0020 (size: 0x10)
    FString DescriptionString;                                                        // 0x0030 (size: 0x10)
    int32 NodeID;                                                                     // 0x0040 (size: 0x4)
    class UObject* AnimInstance;                                                      // 0x0048 (size: 0x8)

}; // Size: 0x50

struct FInputActionKeyMapping
{
    FName ActionName;                                                                 // 0x0000 (size: 0x8)
    uint8 bShift;                                                                     // 0x0008 (size: 0x1)
    uint8 bCtrl;                                                                      // 0x0008 (size: 0x1)
    uint8 bAlt;                                                                       // 0x0008 (size: 0x1)
    uint8 bCmd;                                                                       // 0x0008 (size: 0x1)
    FKey Key;                                                                         // 0x0010 (size: 0x18)

}; // Size: 0x28

struct FInputActionSpeechMapping
{
    FName ActionName;                                                                 // 0x0000 (size: 0x8)
    FName SpeechKeyword;                                                              // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FInputAlphaBoolBlend
{
    float BlendInTime;                                                                // 0x0000 (size: 0x4)
    float BlendOutTime;                                                               // 0x0004 (size: 0x4)
    EAlphaBlendOption BlendOption;                                                    // 0x0008 (size: 0x1)
    bool bInitialized;                                                                // 0x0009 (size: 0x1)
    class UCurveFloat* CustomCurve;                                                   // 0x0010 (size: 0x8)
    FAlphaBlend AlphaBlend;                                                           // 0x0018 (size: 0x30)

}; // Size: 0x48

struct FInputAxisConfigEntry
{
    FName AxisKeyName;                                                                // 0x0000 (size: 0x8)
    FInputAxisProperties AxisProperties;                                              // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FInputAxisKeyMapping
{
    FName AxisName;                                                                   // 0x0000 (size: 0x8)
    float Scale;                                                                      // 0x0008 (size: 0x4)
    FKey Key;                                                                         // 0x0010 (size: 0x18)

}; // Size: 0x28

struct FInputAxisProperties
{
    float DeadZone;                                                                   // 0x0000 (size: 0x4)
    float Sensitivity;                                                                // 0x0004 (size: 0x4)
    float Exponent;                                                                   // 0x0008 (size: 0x4)
    uint8 bInvert;                                                                    // 0x000C (size: 0x1)

}; // Size: 0x10

struct FInputBlendPose
{
    TArray<FBranchFilter> BranchFilters;                                              // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FInputClampConstants
{
    bool bClampResult;                                                                // 0x0000 (size: 0x1)
    bool bInterpResult;                                                               // 0x0001 (size: 0x1)
    float ClampMin;                                                                   // 0x0004 (size: 0x4)
    float ClampMax;                                                                   // 0x0008 (size: 0x4)
    float InterpSpeedIncreasing;                                                      // 0x000C (size: 0x4)
    float InterpSpeedDecreasing;                                                      // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FInputClampState
{
}; // Size: 0x8

struct FInputDevicePropertyHandle
{
    uint32 InternalId;                                                                // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FInputRange
{
    float Min;                                                                        // 0x0000 (size: 0x4)
    float Max;                                                                        // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FInputScaleBias
{
    float Scale;                                                                      // 0x0000 (size: 0x4)
    float Bias;                                                                       // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FInputScaleBiasClamp
{
    bool bMapRange;                                                                   // 0x0000 (size: 0x1)
    bool bClampResult;                                                                // 0x0001 (size: 0x1)
    bool bInterpResult;                                                               // 0x0002 (size: 0x1)
    FInputRange InRange;                                                              // 0x0004 (size: 0x8)
    FInputRange OutRange;                                                             // 0x000C (size: 0x8)
    float Scale;                                                                      // 0x0014 (size: 0x4)
    float Bias;                                                                       // 0x0018 (size: 0x4)
    float ClampMin;                                                                   // 0x001C (size: 0x4)
    float ClampMax;                                                                   // 0x0020 (size: 0x4)
    float InterpSpeedIncreasing;                                                      // 0x0024 (size: 0x4)
    float InterpSpeedDecreasing;                                                      // 0x0028 (size: 0x4)

}; // Size: 0x30

struct FInputScaleBiasClampConstants
{
    bool bMapRange;                                                                   // 0x0000 (size: 0x1)
    bool bClampResult;                                                                // 0x0001 (size: 0x1)
    bool bInterpResult;                                                               // 0x0002 (size: 0x1)
    FInputRange InRange;                                                              // 0x0004 (size: 0x8)
    FInputRange OutRange;                                                             // 0x000C (size: 0x8)
    float Scale;                                                                      // 0x0014 (size: 0x4)
    float Bias;                                                                       // 0x0018 (size: 0x4)
    float ClampMin;                                                                   // 0x001C (size: 0x4)
    float ClampMax;                                                                   // 0x0020 (size: 0x4)
    float InterpSpeedIncreasing;                                                      // 0x0024 (size: 0x4)
    float InterpSpeedDecreasing;                                                      // 0x0028 (size: 0x4)

}; // Size: 0x2C

struct FInputScaleBiasClampState
{
}; // Size: 0x8

struct FInstanceCacheDataBase
{
    TArray<uint8> SavedProperties;                                                    // 0x0008 (size: 0x10)
    FDataCacheDuplicatedObjectData UniqueTransientPackage;                            // 0x0018 (size: 0x10)
    TArray<FDataCacheDuplicatedObjectData> DuplicatedObjects;                         // 0x0028 (size: 0x10)
    TArray<class UObject*> ReferencedObjects;                                         // 0x0038 (size: 0x10)
    TArray<FName> ReferencedNames;                                                    // 0x0048 (size: 0x10)

}; // Size: 0x58

struct FInstancedStaticMeshComponentInstanceData : public FSceneComponentInstanceData
{
    class UStaticMesh* StaticMesh;                                                    // 0x00B8 (size: 0x8)
    FInstancedStaticMeshLightMapInstanceData CachedStaticLighting;                    // 0x00C0 (size: 0x70)
    TArray<FInstancedStaticMeshInstanceData> PerInstanceSMData;                       // 0x0130 (size: 0x10)
    int32 InstancingRandomSeed;                                                       // 0x0160 (size: 0x4)
    TArray<FInstancedStaticMeshRandomSeed> AdditionalRandomSeeds;                     // 0x0168 (size: 0x10)
    bool bHasPerInstanceHitProxies;                                                   // 0x0178 (size: 0x1)

}; // Size: 0x180

struct FInstancedStaticMeshInstanceData
{
    FMatrix Transform;                                                                // 0x0000 (size: 0x80)

}; // Size: 0x80

struct FInstancedStaticMeshLightMapInstanceData
{
    FTransform Transform;                                                             // 0x0000 (size: 0x60)
    TArray<FGuid> MapBuildDataIds;                                                    // 0x0060 (size: 0x10)

}; // Size: 0x70

struct FInstancedStaticMeshMappingInfo
{
}; // Size: 0x8

struct FInstancedStaticMeshRandomSeed
{
    int32 StartInstanceIndex;                                                         // 0x0000 (size: 0x4)
    int32 RandomSeed;                                                                 // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FIntegerAnimationAttribute
{
    int32 Value;                                                                      // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FIntegralCurve : public FIndexedCurve
{
    TArray<FIntegralKey> keys;                                                        // 0x0068 (size: 0x10)
    int32 DefaultValue;                                                               // 0x0078 (size: 0x4)
    bool bUseDefaultValueBeforeFirstKey;                                              // 0x007C (size: 0x1)

}; // Size: 0x80

struct FIntegralKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    int32 Value;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FInteriorSettings
{
    bool bIsWorldSettings;                                                            // 0x0000 (size: 0x1)
    float ExteriorVolume;                                                             // 0x0004 (size: 0x4)
    float ExteriorTime;                                                               // 0x0008 (size: 0x4)
    float ExteriorLPF;                                                                // 0x000C (size: 0x4)
    float ExteriorLPFTime;                                                            // 0x0010 (size: 0x4)
    float InteriorVolume;                                                             // 0x0014 (size: 0x4)
    float InteriorTime;                                                               // 0x0018 (size: 0x4)
    float InteriorLPF;                                                                // 0x001C (size: 0x4)
    float InteriorLPFTime;                                                            // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FInterpControlPoint
{
    FVector PositionControlPoint;                                                     // 0x0000 (size: 0x18)
    bool bPositionIsRelative;                                                         // 0x0018 (size: 0x1)

}; // Size: 0x28

struct FInterpolationParameter
{
    float InterpolationTime;                                                          // 0x0000 (size: 0x4)
    float DampingRatio;                                                               // 0x0004 (size: 0x4)
    float MaxSpeed;                                                                   // 0x0008 (size: 0x4)
    TEnumAsByte<EFilterInterpolationType> InterpolationType;                          // 0x000C (size: 0x1)

}; // Size: 0x10

struct FIrisNetDriverConfig
{
    FName NetDriverDefinition;                                                        // 0x0000 (size: 0x8)
    FName NetDriverName;                                                              // 0x0008 (size: 0x8)
    FString NetDriverWildcardName;                                                    // 0x0010 (size: 0x10)
    bool bCanUseIris;                                                                 // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FKAggregateGeom
{
    TArray<FKSphereElem> SphereElems;                                                 // 0x0000 (size: 0x10)
    TArray<FKBoxElem> BoxElems;                                                       // 0x0010 (size: 0x10)
    TArray<FKSphylElem> SphylElems;                                                   // 0x0020 (size: 0x10)
    TArray<FKConvexElem> ConvexElems;                                                 // 0x0030 (size: 0x10)
    TArray<FKTaperedCapsuleElem> TaperedCapsuleElems;                                 // 0x0040 (size: 0x10)
    TArray<FKLevelSetElem> LevelSetElems;                                             // 0x0050 (size: 0x10)
    TArray<FKSkinnedLevelSetElem> SkinnedLevelSetElems;                               // 0x0060 (size: 0x10)

}; // Size: 0x80

struct FKBoxElem : public FKShapeElem
{
    FVector Center;                                                                   // 0x0030 (size: 0x18)
    FRotator Rotation;                                                                // 0x0048 (size: 0x18)
    float X;                                                                          // 0x0060 (size: 0x4)
    float Y;                                                                          // 0x0064 (size: 0x4)
    float Z;                                                                          // 0x0068 (size: 0x4)

}; // Size: 0x70

struct FKConvexElem : public FKShapeElem
{
    TArray<FVector> VertexData;                                                       // 0x0030 (size: 0x10)
    TArray<int32> IndexData;                                                          // 0x0040 (size: 0x10)
    FBox ElemBox;                                                                     // 0x0050 (size: 0x38)
    FTransform Transform;                                                             // 0x0090 (size: 0x60)

}; // Size: 0x100

struct FKLevelSetElem : public FKShapeElem
{
    FTransform Transform;                                                             // 0x0030 (size: 0x60)

}; // Size: 0xA0

struct FKShapeElem
{
    float RestOffset;                                                                 // 0x0008 (size: 0x4)
    FName Name;                                                                       // 0x000C (size: 0x8)
    uint8 bContributeToMass;                                                          // 0x0018 (size: 0x1)
    TEnumAsByte<ECollisionEnabled::Type> CollisionEnabled;                            // 0x0019 (size: 0x1)

}; // Size: 0x30

struct FKSkinnedLevelSetElem : public FKShapeElem
{
}; // Size: 0x38

struct FKSphereElem : public FKShapeElem
{
    FVector Center;                                                                   // 0x0030 (size: 0x18)
    float Radius;                                                                     // 0x0048 (size: 0x4)

}; // Size: 0x50

struct FKSphylElem : public FKShapeElem
{
    FVector Center;                                                                   // 0x0030 (size: 0x18)
    FRotator Rotation;                                                                // 0x0048 (size: 0x18)
    float Radius;                                                                     // 0x0060 (size: 0x4)
    float Length;                                                                     // 0x0064 (size: 0x4)

}; // Size: 0x68

struct FKTaperedCapsuleElem : public FKShapeElem
{
    FVector Center;                                                                   // 0x0030 (size: 0x18)
    FRotator Rotation;                                                                // 0x0048 (size: 0x18)
    float Radius0;                                                                    // 0x0060 (size: 0x4)
    float Radius1;                                                                    // 0x0064 (size: 0x4)
    float Length;                                                                     // 0x0068 (size: 0x4)

}; // Size: 0x70

struct FKeyBind
{
    FKey Key;                                                                         // 0x0000 (size: 0x18)
    FString Command;                                                                  // 0x0018 (size: 0x10)
    uint8 Control;                                                                    // 0x0028 (size: 0x1)
    uint8 Shift;                                                                      // 0x0028 (size: 0x1)
    uint8 Alt;                                                                        // 0x0028 (size: 0x1)
    uint8 Cmd;                                                                        // 0x0028 (size: 0x1)
    uint8 bIgnoreCtrl;                                                                // 0x0028 (size: 0x1)
    uint8 bIgnoreShift;                                                               // 0x0028 (size: 0x1)
    uint8 bIgnoreAlt;                                                                 // 0x0028 (size: 0x1)
    uint8 bIgnoreCmd;                                                                 // 0x0028 (size: 0x1)
    uint8 bDisabled;                                                                  // 0x0029 (size: 0x1)

}; // Size: 0x30

struct FKeyHandleLookupTable
{
}; // Size: 0x88

struct FKeyHandleMap
{
}; // Size: 0x60

struct FLODMappingData
{
    TArray<int32> Mapping;                                                            // 0x0000 (size: 0x10)
    TArray<int32> InverseMapping;                                                     // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FLODSoloTrack
{
    TArray<uint8> SoloEnableSetting;                                                  // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FLatentActionInfo
{
    int32 Linkage;                                                                    // 0x0000 (size: 0x4)
    int32 UUID;                                                                       // 0x0004 (size: 0x4)
    FName ExecutionFunction;                                                          // 0x0008 (size: 0x8)
    class UObject* CallbackTarget;                                                    // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FLatentActionManager
{
}; // Size: 0x60

struct FLaunchOnTestSettings
{
    FFilePath LaunchOnTestmap;                                                        // 0x0000 (size: 0x10)
    FString DeviceID;                                                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FLayerActorStats
{
    UClass* Type;                                                                     // 0x0000 (size: 0x8)
    int32 Total;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FLensBloomSettings
{
    FGaussianSumBloomSettings GaussianSum;                                            // 0x0000 (size: 0x84)
    FConvolutionBloomSettings Convolution;                                            // 0x0088 (size: 0x30)
    TEnumAsByte<EBloomMethod> Method;                                                 // 0x00B8 (size: 0x1)

}; // Size: 0xC0

struct FLensImperfectionSettings
{
    class UTexture* DirtMask;                                                         // 0x0000 (size: 0x8)
    float DirtMaskIntensity;                                                          // 0x0008 (size: 0x4)
    FLinearColor DirtMaskTint;                                                        // 0x000C (size: 0x10)

}; // Size: 0x20

struct FLensSettings
{
    FLensBloomSettings Bloom;                                                         // 0x0000 (size: 0xC0)
    FLensImperfectionSettings Imperfections;                                          // 0x00C0 (size: 0x20)
    float ChromaticAberration;                                                        // 0x00E0 (size: 0x4)

}; // Size: 0xE8

struct FLevelCollection
{
    class AGameStateBase* GameState;                                                  // 0x0008 (size: 0x8)
    class UNetDriver* NetDriver;                                                      // 0x0010 (size: 0x8)
    class UDemoNetDriver* DemoNetDriver;                                              // 0x0018 (size: 0x8)
    class ULevel* PersistentLevel;                                                    // 0x0020 (size: 0x8)
    TSet<ULevel*> Levels;                                                             // 0x0028 (size: 0x50)

}; // Size: 0x78

struct FLevelNameAndTime
{
    FString LevelName;                                                                // 0x0000 (size: 0x10)
    uint32 LevelChangeTimeInMS;                                                       // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FLevelSimplificationDetails
{
    bool bCreatePackagePerAsset;                                                      // 0x0000 (size: 0x1)
    float DetailsPercentage;                                                          // 0x0004 (size: 0x4)
    FMaterialProxySettings StaticMeshMaterialSettings;                                // 0x0008 (size: 0xA0)
    bool bOverrideLandscapeExportLOD;                                                 // 0x00A8 (size: 0x1)
    int32 LandscapeExportLOD;                                                         // 0x00AC (size: 0x4)
    FMaterialProxySettings LandscapeMaterialSettings;                                 // 0x00B0 (size: 0xA0)
    bool bBakeFoliageToLandscape;                                                     // 0x0150 (size: 0x1)
    bool bBakeGrassToLandscape;                                                       // 0x0151 (size: 0x1)

}; // Size: 0x158

struct FLevelStreamingStatus
{
    FName PackageName;                                                                // 0x0000 (size: 0x8)
    uint8 bShouldBeLoaded;                                                            // 0x0008 (size: 0x1)
    uint8 bShouldBeVisible;                                                           // 0x0008 (size: 0x1)
    uint32 LODIndex;                                                                  // 0x000C (size: 0x4)

}; // Size: 0x10

struct FLevelViewportInfo
{
    FVector CamPosition;                                                              // 0x0000 (size: 0x18)
    FRotator CamRotation;                                                             // 0x0018 (size: 0x18)
    float CamOrthoZoom;                                                               // 0x0030 (size: 0x4)
    bool CamUpdated;                                                                  // 0x0034 (size: 0x1)

}; // Size: 0x38

struct FLightingChannels
{
    uint8 bChannel0;                                                                  // 0x0000 (size: 0x1)
    uint8 bChannel1;                                                                  // 0x0000 (size: 0x1)
    uint8 bChannel2;                                                                  // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FLightmassDebugOptions
{
    uint8 bDebugMode;                                                                 // 0x0000 (size: 0x1)
    uint8 bStatsEnabled;                                                              // 0x0000 (size: 0x1)
    uint8 bGatherBSPSurfacesAcrossComponents;                                         // 0x0000 (size: 0x1)
    float CoplanarTolerance;                                                          // 0x0004 (size: 0x4)
    uint8 bUseImmediateImport;                                                        // 0x0008 (size: 0x1)
    uint8 bImmediateProcessMappings;                                                  // 0x0008 (size: 0x1)
    uint8 bSortMappings;                                                              // 0x0008 (size: 0x1)
    uint8 bDumpBinaryFiles;                                                           // 0x0008 (size: 0x1)
    uint8 bDebugMaterials;                                                            // 0x0008 (size: 0x1)
    uint8 bPadMappings;                                                               // 0x0008 (size: 0x1)
    uint8 bDebugPaddings;                                                             // 0x0008 (size: 0x1)
    uint8 bOnlyCalcDebugTexelMappings;                                                // 0x0008 (size: 0x1)
    uint8 bUseRandomColors;                                                           // 0x0009 (size: 0x1)
    uint8 bColorBordersGreen;                                                         // 0x0009 (size: 0x1)
    uint8 bColorByExecutionTime;                                                      // 0x0009 (size: 0x1)
    float ExecutionTimeDivisor;                                                       // 0x000C (size: 0x4)

}; // Size: 0x10

struct FLightmassDirectionalLightSettings : public FLightmassLightSettings
{
    float LightSourceAngle;                                                           // 0x000C (size: 0x4)

}; // Size: 0x10

struct FLightmassLightSettings
{
    float IndirectLightingSaturation;                                                 // 0x0000 (size: 0x4)
    float ShadowExponent;                                                             // 0x0004 (size: 0x4)
    bool bUseAreaShadowsForStationaryLight;                                           // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FLightmassMaterialInterfaceSettings
{
    float EmissiveBoost;                                                              // 0x0000 (size: 0x4)
    float DiffuseBoost;                                                               // 0x0004 (size: 0x4)
    float ExportResolutionScale;                                                      // 0x0008 (size: 0x4)
    uint8 bCastShadowAsMasked;                                                        // 0x000C (size: 0x1)
    uint8 bOverrideCastShadowAsMasked;                                                // 0x000C (size: 0x1)
    uint8 bOverrideEmissiveBoost;                                                     // 0x000C (size: 0x1)
    uint8 bOverrideDiffuseBoost;                                                      // 0x000C (size: 0x1)
    uint8 bOverrideExportResolutionScale;                                             // 0x000C (size: 0x1)

}; // Size: 0x10

struct FLightmassPointLightSettings : public FLightmassLightSettings
{
}; // Size: 0xC

struct FLightmassPrimitiveSettings
{
    uint8 bUseTwoSidedLighting;                                                       // 0x0000 (size: 0x1)
    uint8 bShadowIndirectOnly;                                                        // 0x0000 (size: 0x1)
    uint8 bUseEmissiveForStaticLighting;                                              // 0x0000 (size: 0x1)
    uint8 bUseVertexNormalForHemisphereGather;                                        // 0x0000 (size: 0x1)
    float EmissiveLightFalloffExponent;                                               // 0x0004 (size: 0x4)
    float EmissiveLightExplicitInfluenceRadius;                                       // 0x0008 (size: 0x4)
    float EmissiveBoost;                                                              // 0x000C (size: 0x4)
    float DiffuseBoost;                                                               // 0x0010 (size: 0x4)
    float FullyOccludedSamplesFraction;                                               // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FLightmassWorldInfoSettings
{
    float StaticLightingLevelScale;                                                   // 0x0000 (size: 0x4)
    int32 NumIndirectLightingBounces;                                                 // 0x0004 (size: 0x4)
    int32 NumSkyLightingBounces;                                                      // 0x0008 (size: 0x4)
    float IndirectLightingQuality;                                                    // 0x000C (size: 0x4)
    float IndirectLightingSmoothness;                                                 // 0x0010 (size: 0x4)
    FColor EnvironmentColor;                                                          // 0x0014 (size: 0x4)
    float EnvironmentIntensity;                                                       // 0x0018 (size: 0x4)
    float EmissiveBoost;                                                              // 0x001C (size: 0x4)
    float DiffuseBoost;                                                               // 0x0020 (size: 0x4)
    TEnumAsByte<EVolumeLightingMethod> VolumeLightingMethod;                          // 0x0024 (size: 0x1)
    uint8 bUseAmbientOcclusion;                                                       // 0x0025 (size: 0x1)
    uint8 bGenerateAmbientOcclusionMaterialMask;                                      // 0x0025 (size: 0x1)
    uint8 bVisualizeMaterialDiffuse;                                                  // 0x0025 (size: 0x1)
    uint8 bVisualizeAmbientOcclusion;                                                 // 0x0025 (size: 0x1)
    uint8 bCompressLightmaps;                                                         // 0x0025 (size: 0x1)
    float VolumetricLightmapDetailCellSize;                                           // 0x0028 (size: 0x4)
    float VolumetricLightmapMaximumBrickMemoryMb;                                     // 0x002C (size: 0x4)
    float VolumetricLightmapSphericalHarmonicSmoothing;                               // 0x0030 (size: 0x4)
    float VolumeLightSamplePlacementScale;                                            // 0x0034 (size: 0x4)
    float DirectIlluminationOcclusionFraction;                                        // 0x0038 (size: 0x4)
    float IndirectIlluminationOcclusionFraction;                                      // 0x003C (size: 0x4)
    float OcclusionExponent;                                                          // 0x0040 (size: 0x4)
    float FullyOccludedSamplesFraction;                                               // 0x0044 (size: 0x4)
    float MaxOcclusionDistance;                                                       // 0x0048 (size: 0x4)

}; // Size: 0x4C

struct FLinearConstraint : public FConstraintBaseParams
{
    float Limit;                                                                      // 0x0014 (size: 0x4)
    TEnumAsByte<ELinearConstraintMotion> XMotion;                                     // 0x0018 (size: 0x1)
    TEnumAsByte<ELinearConstraintMotion> YMotion;                                     // 0x0019 (size: 0x1)
    TEnumAsByte<ELinearConstraintMotion> ZMotion;                                     // 0x001A (size: 0x1)

}; // Size: 0x1C

struct FLinearDriveConstraint
{
    FVector PositionTarget;                                                           // 0x0000 (size: 0x18)
    FVector VelocityTarget;                                                           // 0x0018 (size: 0x18)
    FConstraintDrive XDrive;                                                          // 0x0030 (size: 0x10)
    FConstraintDrive YDrive;                                                          // 0x0040 (size: 0x10)
    FConstraintDrive ZDrive;                                                          // 0x0050 (size: 0x10)

}; // Size: 0x60

struct FLinkedAnimLayerClassData
{
    TArray<FLinkedAnimLayerInstanceData> InstancesData;                               // 0x0008 (size: 0x10)

}; // Size: 0x20

struct FLinkedAnimLayerInstanceData
{
    class UAnimInstance* Instance;                                                    // 0x0000 (size: 0x8)
    TMap<class FName, class TWeakObjectPtr<UAnimInstance>> LinkedFunctions;           // 0x0008 (size: 0x50)

}; // Size: 0x60

struct FLocalSpacePose
{
    TArray<FTransform> Transforms;                                                    // 0x0000 (size: 0x10)
    TArray<FName> Names;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FLocationBoneSocketInfo
{
    FName BoneSocketName;                                                             // 0x0000 (size: 0x8)
    FVector Offset;                                                                   // 0x0008 (size: 0x18)

}; // Size: 0x20

struct FMTDResult
{
    FVector Direction;                                                                // 0x0000 (size: 0x18)
    float Distance;                                                                   // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FMarkerSyncAnimPosition
{
    FName PreviousMarkerName;                                                         // 0x0000 (size: 0x8)
    FName NextMarkerName;                                                             // 0x0008 (size: 0x8)
    float PositionBetweenMarkers;                                                     // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FMarkerSyncData
{
    TArray<FAnimSyncMarker> AuthoredSyncMarkers;                                      // 0x0000 (size: 0x10)

}; // Size: 0x20

struct FMaterialAttributesInput : public FExpressionInput
{
    int64 PropertyConnectedMask;                                                      // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FMaterialCachedExpressionData
{
    FMaterialCachedParameterEntry RuntimeEntries;                                     // 0x0000 (size: 0x280)
    TArray<int32> ScalarPrimitiveDataIndexValues;                                     // 0x0280 (size: 0x10)
    TArray<int32> VectorPrimitiveDataIndexValues;                                     // 0x0290 (size: 0x10)
    TArray<float> ScalarValues;                                                       // 0x02A0 (size: 0x10)
    TArray<bool> StaticSwitchValues;                                                  // 0x02B0 (size: 0x10)
    TArray<bool> DynamicSwitchValues;                                                 // 0x02C0 (size: 0x10)
    TArray<FLinearColor> VectorValues;                                                // 0x02D0 (size: 0x10)
    TArray<FVector4d> DoubleVectorValues;                                             // 0x02E0 (size: 0x10)
    TArray<TSoftObjectPtr<UTexture>> TextureValues;                                   // 0x02F0 (size: 0x10)
    TArray<TSoftObjectPtr<UFont>> FontValues;                                         // 0x0300 (size: 0x10)
    TArray<int32> FontPageValues;                                                     // 0x0310 (size: 0x10)
    TArray<TSoftObjectPtr<URuntimeVirtualTexture>> RuntimeVirtualTextureValues;       // 0x0320 (size: 0x10)
    TArray<TSoftObjectPtr<USparseVolumeTexture>> SparseVolumeTextureValues;           // 0x0330 (size: 0x10)
    TArray<class UObject*> ReferencedTextures;                                        // 0x0340 (size: 0x10)
    TArray<FMaterialFunctionInfo> FunctionInfos;                                      // 0x0350 (size: 0x10)
    uint32 FunctionInfosStateCRC;                                                     // 0x0360 (size: 0x4)
    TArray<FMaterialParameterCollectionInfo> ParameterCollectionInfos;                // 0x0368 (size: 0x10)
    TArray<class ULandscapeGrassType*> GrassTypes;                                    // 0x0378 (size: 0x10)
    FMaterialLayersFunctionsRuntimeData MaterialLayers;                               // 0x0388 (size: 0x20)
    TArray<FName> DynamicParameterNames;                                              // 0x03A8 (size: 0x10)
    TArray<bool> QualityLevelsUsed;                                                   // 0x03B8 (size: 0x10)
    uint8 bHasMaterialLayers;                                                         // 0x03C8 (size: 0x1)
    uint8 bHasRuntimeVirtualTextureOutput;                                            // 0x03C8 (size: 0x1)
    uint8 bHasSceneColor;                                                             // 0x03C8 (size: 0x1)
    uint8 bHasPerInstanceCustomData;                                                  // 0x03C8 (size: 0x1)
    uint8 bHasPerInstanceRandom;                                                      // 0x03C8 (size: 0x1)
    uint8 bHasVertexInterpolator;                                                     // 0x03C8 (size: 0x1)
    uint32 PropertyConnectedBitmask;                                                  // 0x03CC (size: 0x4)
    uint64 PropertyConnectedMask;                                                     // 0x03D0 (size: 0x8)

}; // Size: 0x3D8

struct FMaterialCachedExpressionEditorOnlyData
{
    FMaterialCachedParameterEntry EditorOnlyEntries;                                  // 0x0000 (size: 0x50)
    FMaterialCachedParameterEditorEntry EditorEntries;                                // 0x0050 (size: 0x90)
    TArray<bool> StaticSwitchValues;                                                  // 0x00E0 (size: 0x10)
    TArray<FStaticComponentMaskValue> StaticComponentMaskValues;                      // 0x00F0 (size: 0x10)
    TArray<FVector2D> ScalarMinMaxValues;                                             // 0x0100 (size: 0x10)
    TArray<TSoftObjectPtr<UCurveLinearColor>> ScalarCurveValues;                      // 0x0110 (size: 0x10)
    TArray<TSoftObjectPtr<UCurveLinearColorAtlas>> ScalarCurveAtlasValues;            // 0x0120 (size: 0x10)
    TArray<FParameterChannelNames> VectorChannelNameValues;                           // 0x0130 (size: 0x10)
    TArray<bool> VectorUsedAsChannelMaskValues;                                       // 0x0140 (size: 0x10)
    TArray<FParameterChannelNames> TextureChannelNameValues;                          // 0x0150 (size: 0x10)
    FMaterialLayersFunctionsEditorOnlyData MaterialLayers;                            // 0x0160 (size: 0x70)
    TArray<FString> AssetPaths;                                                       // 0x01D0 (size: 0x10)
    TArray<FName> LandscapeLayerNames;                                                // 0x01E0 (size: 0x10)
    TSet<FString> ExpressionIncludeFilePaths;                                         // 0x01F0 (size: 0x50)

}; // Size: 0x240

struct FMaterialCachedParameterEditorEntry
{
    TArray<FMaterialCachedParameterEditorInfo> EditorInfo;                            // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FMaterialCachedParameterEditorInfo
{
    FString Description;                                                              // 0x0000 (size: 0x10)
    FName Group;                                                                      // 0x0010 (size: 0x8)
    int32 SortPriority;                                                               // 0x0018 (size: 0x4)
    int32 AssetIndex;                                                                 // 0x001C (size: 0x4)
    FGuid ExpressionGUID;                                                             // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FMaterialCachedParameterEntry
{
    TSet<FMaterialParameterInfo> ParameterInfoSet;                                    // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FMaterialEditorPromotionSettings
{
    FFilePath DefaultMaterialAsset;                                                   // 0x0000 (size: 0x10)
    FFilePath DefaultDiffuseTexture;                                                  // 0x0010 (size: 0x10)
    FFilePath DefaultNormalTexture;                                                   // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FMaterialExpressionCollection
{
    TArray<class UMaterialExpression*> Expressions;                                   // 0x0000 (size: 0x10)
    TArray<class UMaterialExpressionComment*> EditorComments;                         // 0x0010 (size: 0x10)
    class UMaterialExpressionExecBegin* ExpressionExecBegin;                          // 0x0020 (size: 0x8)
    class UMaterialExpressionExecEnd* ExpressionExecEnd;                              // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FMaterialFunctionInfo
{
    FGuid StateId;                                                                    // 0x0000 (size: 0x10)
    class UMaterialFunctionInterface* Function;                                       // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FMaterialInput
{
    class UMaterialExpression* Expression;                                            // 0x0000 (size: 0x8)
    int32 OutputIndex;                                                                // 0x0008 (size: 0x4)
    FName InputName;                                                                  // 0x000C (size: 0x8)
    int32 Mask;                                                                       // 0x0014 (size: 0x4)
    int32 MaskR;                                                                      // 0x0018 (size: 0x4)
    int32 MaskG;                                                                      // 0x001C (size: 0x4)
    int32 MaskB;                                                                      // 0x0020 (size: 0x4)
    int32 MaskA;                                                                      // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FMaterialInstanceBasePropertyOverrides
{
    uint8 bOverride_OpacityMaskClipValue;                                             // 0x0000 (size: 0x1)
    uint8 bOverride_BlendMode;                                                        // 0x0000 (size: 0x1)
    uint8 bOverride_ShadingModel;                                                     // 0x0000 (size: 0x1)
    uint8 bOverride_DitheredLODTransition;                                            // 0x0000 (size: 0x1)
    uint8 bOverride_CastDynamicShadowAsMasked;                                        // 0x0000 (size: 0x1)
    uint8 bOverride_TwoSided;                                                         // 0x0000 (size: 0x1)
    uint8 bOverride_bIsThinSurface;                                                   // 0x0000 (size: 0x1)
    uint8 bOverride_OutputTranslucentVelocity;                                        // 0x0000 (size: 0x1)
    uint8 bOverride_bHasPixelAnimation;                                               // 0x0001 (size: 0x1)
    uint8 bOverride_bEnableTessellation;                                              // 0x0001 (size: 0x1)
    uint8 bOverride_DisplacementScaling;                                              // 0x0001 (size: 0x1)
    uint8 bOverride_MaxWorldPositionOffsetDisplacement;                               // 0x0001 (size: 0x1)
    uint8 TwoSided;                                                                   // 0x0001 (size: 0x1)
    uint8 bIsThinSurface;                                                             // 0x0001 (size: 0x1)
    uint8 DitheredLODTransition;                                                      // 0x0001 (size: 0x1)
    uint8 bCastDynamicShadowAsMasked;                                                 // 0x0001 (size: 0x1)
    uint8 bOutputTranslucentVelocity;                                                 // 0x0002 (size: 0x1)
    uint8 bHasPixelAnimation;                                                         // 0x0002 (size: 0x1)
    uint8 bEnableTessellation;                                                        // 0x0002 (size: 0x1)
    TEnumAsByte<EBlendMode> BlendMode;                                                // 0x0003 (size: 0x1)
    TEnumAsByte<EMaterialShadingModel> ShadingModel;                                  // 0x0004 (size: 0x1)
    float OpacityMaskClipValue;                                                       // 0x0008 (size: 0x4)
    FDisplacementScaling DisplacementScaling;                                         // 0x000C (size: 0x8)
    float MaxWorldPositionOffsetDisplacement;                                         // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FMaterialInstanceCachedData
{
    TArray<int32> ParentLayerIndexRemap;                                              // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FMaterialLayersFunctions : public FMaterialLayersFunctionsRuntimeData
{
    FMaterialLayersFunctionsEditorOnlyData EditorOnly;                                // 0x0020 (size: 0x70)
    TArray<bool> LayerStates;                                                         // 0x0090 (size: 0x10)
    TArray<FText> LayerNames;                                                         // 0x00A0 (size: 0x10)
    TArray<bool> RestrictToLayerRelatives;                                            // 0x00B0 (size: 0x10)
    TArray<bool> RestrictToBlendRelatives;                                            // 0x00C0 (size: 0x10)
    TArray<FGuid> LayerGuids;                                                         // 0x00D0 (size: 0x10)
    TArray<EMaterialLayerLinkState> LayerLinkStates;                                  // 0x00E0 (size: 0x10)
    TArray<FGuid> DeletedParentLayerGuids;                                            // 0x00F0 (size: 0x10)

}; // Size: 0x100

struct FMaterialLayersFunctionsEditorOnlyData
{
    TArray<bool> LayerStates;                                                         // 0x0000 (size: 0x10)
    TArray<FText> LayerNames;                                                         // 0x0010 (size: 0x10)
    TArray<bool> RestrictToLayerRelatives;                                            // 0x0020 (size: 0x10)
    TArray<bool> RestrictToBlendRelatives;                                            // 0x0030 (size: 0x10)
    TArray<FGuid> LayerGuids;                                                         // 0x0040 (size: 0x10)
    TArray<EMaterialLayerLinkState> LayerLinkStates;                                  // 0x0050 (size: 0x10)
    TArray<FGuid> DeletedParentLayerGuids;                                            // 0x0060 (size: 0x10)

}; // Size: 0x70

struct FMaterialLayersFunctionsRuntimeData
{
    TArray<class UMaterialFunctionInterface*> Layers;                                 // 0x0000 (size: 0x10)
    TArray<class UMaterialFunctionInterface*> Blends;                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FMaterialOverrideNanite
{
    bool bEnableOverride;                                                             // 0x0000 (size: 0x1)
    class UMaterialInterface* OverrideMaterial;                                       // 0x0008 (size: 0x8)
    TSoftObjectPtr<UMaterialInterface> OverrideMaterialRef;                           // 0x0010 (size: 0x28)

}; // Size: 0x38

struct FMaterialParameterCollectionInfo
{
    FGuid StateId;                                                                    // 0x0000 (size: 0x10)
    class UMaterialParameterCollection* ParameterCollection;                          // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FMaterialParameterInfo
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    TEnumAsByte<EMaterialParameterAssociation> Association;                           // 0x0008 (size: 0x1)
    int32 Index;                                                                      // 0x000C (size: 0x4)

}; // Size: 0x10

struct FMaterialProxySettings
{
    TEnumAsByte<ETextureSizingType> TextureSizingType;                                // 0x0000 (size: 0x1)
    FIntPoint TextureSize;                                                            // 0x0004 (size: 0x8)
    float TargetTexelDensityPerMeter;                                                 // 0x000C (size: 0x4)
    float MeshMaxScreenSizePercent;                                                   // 0x0010 (size: 0x4)
    double MeshMinDrawDistance;                                                       // 0x0018 (size: 0x8)
    float GutterSpace;                                                                // 0x0020 (size: 0x4)
    float MetallicConstant;                                                           // 0x0024 (size: 0x4)
    float RoughnessConstant;                                                          // 0x0028 (size: 0x4)
    float AnisotropyConstant;                                                         // 0x002C (size: 0x4)
    float SpecularConstant;                                                           // 0x0030 (size: 0x4)
    float OpacityConstant;                                                            // 0x0034 (size: 0x4)
    float OpacityMaskConstant;                                                        // 0x0038 (size: 0x4)
    float AmbientOcclusionConstant;                                                   // 0x003C (size: 0x4)
    TEnumAsByte<EMaterialMergeType> MaterialMergeType;                                // 0x0040 (size: 0x1)
    TEnumAsByte<EBlendMode> BlendMode;                                                // 0x0041 (size: 0x1)
    uint8 bAllowTwoSidedMaterial;                                                     // 0x0042 (size: 0x1)
    uint8 bNormalMap;                                                                 // 0x0042 (size: 0x1)
    uint8 bTangentMap;                                                                // 0x0042 (size: 0x1)
    uint8 bMetallicMap;                                                               // 0x0042 (size: 0x1)
    uint8 bRoughnessMap;                                                              // 0x0042 (size: 0x1)
    uint8 bAnisotropyMap;                                                             // 0x0042 (size: 0x1)
    uint8 bSpecularMap;                                                               // 0x0042 (size: 0x1)
    uint8 bEmissiveMap;                                                               // 0x0042 (size: 0x1)
    uint8 bOpacityMap;                                                                // 0x0043 (size: 0x1)
    uint8 bOpacityMaskMap;                                                            // 0x0043 (size: 0x1)
    uint8 bAmbientOcclusionMap;                                                       // 0x0043 (size: 0x1)
    FIntPoint DiffuseTextureSize;                                                     // 0x0044 (size: 0x8)
    FIntPoint NormalTextureSize;                                                      // 0x004C (size: 0x8)
    FIntPoint TangentTextureSize;                                                     // 0x0054 (size: 0x8)
    FIntPoint MetallicTextureSize;                                                    // 0x005C (size: 0x8)
    FIntPoint RoughnessTextureSize;                                                   // 0x0064 (size: 0x8)
    FIntPoint AnisotropyTextureSize;                                                  // 0x006C (size: 0x8)
    FIntPoint SpecularTextureSize;                                                    // 0x0074 (size: 0x8)
    FIntPoint EmissiveTextureSize;                                                    // 0x007C (size: 0x8)
    FIntPoint OpacityTextureSize;                                                     // 0x0084 (size: 0x8)
    FIntPoint OpacityMaskTextureSize;                                                 // 0x008C (size: 0x8)
    FIntPoint AmbientOcclusionTextureSize;                                            // 0x0094 (size: 0x8)

}; // Size: 0xA0

struct FMaterialRemapIndex
{
    uint32 ImportVersionKey;                                                          // 0x0000 (size: 0x4)
    TArray<int32> MaterialRemap;                                                      // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FMaterialShadingModelField
{
    uint16 ShadingModelField;                                                         // 0x0000 (size: 0x2)

}; // Size: 0x2

struct FMaterialSpriteElement
{
    class UMaterialInterface* Material;                                               // 0x0000 (size: 0x8)
    class UCurveFloat* DistanceToOpacityCurve;                                        // 0x0008 (size: 0x8)
    uint8 bSizeIsInScreenSpace;                                                       // 0x0010 (size: 0x1)
    float BaseSizeX;                                                                  // 0x0014 (size: 0x4)
    float BaseSizeY;                                                                  // 0x0018 (size: 0x4)
    class UCurveFloat* DistanceToSizeCurve;                                           // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FMaterialTextureInfo
{
    float SamplingScale;                                                              // 0x0000 (size: 0x4)
    int32 UVChannelIndex;                                                             // 0x0004 (size: 0x4)
    FName TextureName;                                                                // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FMemberReference
{
    class UObject* MemberParent;                                                      // 0x0000 (size: 0x8)
    FString MemberScope;                                                              // 0x0008 (size: 0x10)
    FName MemberName;                                                                 // 0x0018 (size: 0x8)
    FGuid MemberGuid;                                                                 // 0x0020 (size: 0x10)
    bool bSelfContext;                                                                // 0x0030 (size: 0x1)
    bool bWasDeprecated;                                                              // 0x0031 (size: 0x1)

}; // Size: 0x38

struct FMeshApproximationSettings
{
    EMeshApproximationType OutputType;                                                // 0x0000 (size: 0x1)
    float ApproximationAccuracy;                                                      // 0x0004 (size: 0x4)
    int32 ClampVoxelDimension;                                                        // 0x0008 (size: 0x4)
    bool bAttemptAutoThickening;                                                      // 0x000C (size: 0x1)
    float TargetMinThicknessMultiplier;                                               // 0x0010 (size: 0x4)
    bool bIgnoreTinyParts;                                                            // 0x0014 (size: 0x1)
    float TinyPartSizeMultiplier;                                                     // 0x0018 (size: 0x4)
    EMeshApproximationBaseCappingType BaseCapping;                                    // 0x001C (size: 0x1)
    float WindingThreshold;                                                           // 0x0020 (size: 0x4)
    bool bFillGaps;                                                                   // 0x0024 (size: 0x1)
    float GapDistance;                                                                // 0x0028 (size: 0x4)
    EOccludedGeometryFilteringPolicy OcclusionMethod;                                 // 0x002C (size: 0x1)
    bool bOccludeFromBottom;                                                          // 0x002D (size: 0x1)
    EMeshApproximationSimplificationPolicy SimplifyMethod;                            // 0x002E (size: 0x1)
    int32 TargetTriCount;                                                             // 0x0030 (size: 0x4)
    float TrianglesPerM;                                                              // 0x0034 (size: 0x4)
    float GeometricDeviation;                                                         // 0x0038 (size: 0x4)
    EMeshApproximationGroundPlaneClippingPolicy GroundClipping;                       // 0x003C (size: 0x1)
    float GroundClippingZHeight;                                                      // 0x0040 (size: 0x4)
    bool bEstimateHardNormals;                                                        // 0x0044 (size: 0x1)
    float HardNormalAngle;                                                            // 0x0048 (size: 0x4)
    EMeshApproximationUVGenerationPolicy UVGenerationMethod;                          // 0x004C (size: 0x1)
    int32 InitialPatchCount;                                                          // 0x0050 (size: 0x4)
    float CurvatureAlignment;                                                         // 0x0054 (size: 0x4)
    float MergingThreshold;                                                           // 0x0058 (size: 0x4)
    float MaxAngleDeviation;                                                          // 0x005C (size: 0x4)
    bool bGenerateNaniteEnabledMesh;                                                  // 0x0060 (size: 0x1)
    ENaniteFallbackTarget NaniteFallbackTarget;                                       // 0x0061 (size: 0x1)
    float NaniteFallbackPercentTriangles;                                             // 0x0064 (size: 0x4)
    float NaniteFallbackRelativeError;                                                // 0x0068 (size: 0x4)
    bool bSupportRayTracing;                                                          // 0x006C (size: 0x1)
    bool bAllowDistanceField;                                                         // 0x006D (size: 0x1)
    int32 MultiSamplingAA;                                                            // 0x0070 (size: 0x4)
    int32 RenderCaptureResolution;                                                    // 0x0074 (size: 0x4)
    FMaterialProxySettings MaterialSettings;                                          // 0x0078 (size: 0xA0)
    float CaptureFieldOfView;                                                         // 0x0118 (size: 0x4)
    float NearPlaneDist;                                                              // 0x011C (size: 0x4)
    bool bUseRenderLODMeshes;                                                         // 0x0120 (size: 0x1)
    bool bEnableSimplifyPrePass;                                                      // 0x0121 (size: 0x1)
    bool bEnableParallelBaking;                                                       // 0x0122 (size: 0x1)
    bool bPrintDebugMessages;                                                         // 0x0123 (size: 0x1)
    bool bEmitFullDebugMesh;                                                          // 0x0124 (size: 0x1)

}; // Size: 0x128

struct FMeshBuildSettings
{
    uint8 bUseMikkTSpace;                                                             // 0x0000 (size: 0x1)
    uint8 bRecomputeNormals;                                                          // 0x0000 (size: 0x1)
    uint8 bRecomputeTangents;                                                         // 0x0000 (size: 0x1)
    uint8 bComputeWeightedNormals;                                                    // 0x0000 (size: 0x1)
    uint8 bRemoveDegenerates;                                                         // 0x0000 (size: 0x1)
    uint8 bBuildReversedIndexBuffer;                                                  // 0x0000 (size: 0x1)
    uint8 bUseHighPrecisionTangentBasis;                                              // 0x0000 (size: 0x1)
    uint8 bUseFullPrecisionUVs;                                                       // 0x0000 (size: 0x1)
    uint8 bUseBackwardsCompatibleF16TruncUVs;                                         // 0x0001 (size: 0x1)
    uint8 bGenerateLightmapUVs;                                                       // 0x0001 (size: 0x1)
    uint8 bGenerateDistanceFieldAsIfTwoSided;                                         // 0x0001 (size: 0x1)
    uint8 bSupportFaceRemap;                                                          // 0x0001 (size: 0x1)
    int32 MinLightmapResolution;                                                      // 0x0004 (size: 0x4)
    int32 SrcLightmapIndex;                                                           // 0x0008 (size: 0x4)
    int32 DstLightmapIndex;                                                           // 0x000C (size: 0x4)
    float BuildScale;                                                                 // 0x0010 (size: 0x4)
    FVector BuildScale3D;                                                             // 0x0018 (size: 0x18)
    float DistanceFieldResolutionScale;                                               // 0x0030 (size: 0x4)
    class UStaticMesh* DistanceFieldReplacementMesh;                                  // 0x0038 (size: 0x8)
    int32 MaxLumenMeshCards;                                                          // 0x0040 (size: 0x4)

}; // Size: 0x48

struct FMeshDeformerInstanceSet
{
    TArray<class UMeshDeformerInstance*> DeformerInstances;                           // 0x0000 (size: 0x10)

}; // Size: 0x20

struct FMeshDisplacementMap
{
    class UTexture2D* Texture;                                                        // 0x0000 (size: 0x8)
    float Magnitude;                                                                  // 0x0008 (size: 0x4)
    float Center;                                                                     // 0x000C (size: 0x4)

}; // Size: 0x10

struct FMeshDrawCommandStatsBudget
{
    FName CategoryName;                                                               // 0x0000 (size: 0x8)
    TArray<FName> LinkedStatNames;                                                    // 0x0008 (size: 0x10)
    int32 PrimitiveBudget;                                                            // 0x0018 (size: 0x4)
    int32 Collection;                                                                 // 0x001C (size: 0x4)
    TArray<FName> Passes;                                                             // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FMeshDrawCommandStatsBudgetTotals
{
    int32 PrimitiveBudget;                                                            // 0x0000 (size: 0x4)
    int32 Collection;                                                                 // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FMeshInstancingSettings
{
    TSubclassOf<class AActor> ActorClassToUse;                                        // 0x0000 (size: 0x8)
    int32 InstanceReplacementThreshold;                                               // 0x0008 (size: 0x4)
    bool bSkipMeshesWithVertexColors;                                                 // 0x000C (size: 0x1)
    bool bUseHLODVolumes;                                                             // 0x000D (size: 0x1)
    TSubclassOf<class UInstancedStaticMeshComponent> ISMComponentToUse;               // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FMeshMergingSettings
{
    int32 TargetLightMapResolution;                                                   // 0x0000 (size: 0x4)
    EUVOutput OutputUVs;                                                              // 0x0004 (size: 0x8)
    FMaterialProxySettings MaterialSettings;                                          // 0x0010 (size: 0xA0)
    int32 GutterSize;                                                                 // 0x00B0 (size: 0x4)
    EMeshLODSelectionType LODSelectionType;                                           // 0x00B4 (size: 0x1)
    int32 SpecificLOD;                                                                // 0x00B8 (size: 0x4)
    uint8 bGenerateLightMapUV;                                                        // 0x00BC (size: 0x1)
    uint8 bComputedLightMapResolution;                                                // 0x00BC (size: 0x1)
    uint8 bPivotPointAtZero;                                                          // 0x00BC (size: 0x1)
    uint8 bMergePhysicsData;                                                          // 0x00BC (size: 0x1)
    uint8 bMergeMeshSockets;                                                          // 0x00BC (size: 0x1)
    uint8 bMergeMaterials;                                                            // 0x00BC (size: 0x1)
    uint8 bBakeVertexDataToMesh;                                                      // 0x00BC (size: 0x1)
    uint8 bUseVertexDataForBakingMaterial;                                            // 0x00BC (size: 0x1)
    uint8 bUseTextureBinning;                                                         // 0x00BD (size: 0x1)
    uint8 bReuseMeshLightmapUVs;                                                      // 0x00BD (size: 0x1)
    uint8 bMergeEquivalentMaterials;                                                  // 0x00BD (size: 0x1)
    uint8 bUseLandscapeCulling;                                                       // 0x00BD (size: 0x1)
    uint8 bIncludeImposters;                                                          // 0x00BD (size: 0x1)
    uint8 bSupportRayTracing;                                                         // 0x00BD (size: 0x1)
    uint8 bAllowDistanceField;                                                        // 0x00BD (size: 0x1)
    FMeshNaniteSettings NaniteSettings;                                               // 0x00C0 (size: 0x40)

}; // Size: 0x108

struct FMeshNaniteSettings
{
    uint8 bEnabled;                                                                   // 0x0000 (size: 0x1)
    uint8 bPreserveArea;                                                              // 0x0000 (size: 0x1)
    uint8 bExplicitTangents;                                                          // 0x0000 (size: 0x1)
    uint8 bLerpUVs;                                                                   // 0x0000 (size: 0x1)
    int32 PositionPrecision;                                                          // 0x0004 (size: 0x4)
    int32 NormalPrecision;                                                            // 0x0008 (size: 0x4)
    int32 TangentPrecision;                                                           // 0x000C (size: 0x4)
    uint32 TargetMinimumResidencyInKB;                                                // 0x0010 (size: 0x4)
    float KeepPercentTriangles;                                                       // 0x0014 (size: 0x4)
    float TrimRelativeError;                                                          // 0x0018 (size: 0x4)
    ENaniteFallbackTarget FallbackTarget;                                             // 0x001C (size: 0x1)
    float FallbackPercentTriangles;                                                   // 0x0020 (size: 0x4)
    float FallbackRelativeError;                                                      // 0x0024 (size: 0x4)
    float MaxEdgeLengthFactor;                                                        // 0x0028 (size: 0x4)
    int32 DisplacementUVChannel;                                                      // 0x002C (size: 0x4)
    TArray<FMeshDisplacementMap> DisplacementMaps;                                    // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FMeshProxySettings
{
    int32 ScreenSize;                                                                 // 0x0000 (size: 0x4)
    float VoxelSize;                                                                  // 0x0004 (size: 0x4)
    FMaterialProxySettings MaterialSettings;                                          // 0x0008 (size: 0xA0)
    float MergeDistance;                                                              // 0x00A8 (size: 0x4)
    FColor UnresolvedGeometryColor;                                                   // 0x00AC (size: 0x4)
    float MaxRayCastDist;                                                             // 0x00B0 (size: 0x4)
    float HardAngleThreshold;                                                         // 0x00B4 (size: 0x4)
    int32 LightMapResolution;                                                         // 0x00B8 (size: 0x4)
    TEnumAsByte<EProxyNormalComputationMethod::Type> NormalCalculationMethod;         // 0x00BC (size: 0x1)
    TEnumAsByte<ELandscapeCullingPrecision::Type> LandscapeCullingPrecision;          // 0x00BD (size: 0x1)
    uint8 bCalculateCorrectLODModel;                                                  // 0x00BE (size: 0x1)
    uint8 bOverrideVoxelSize;                                                         // 0x00BE (size: 0x1)
    uint8 bOverrideTransferDistance;                                                  // 0x00BE (size: 0x1)
    uint8 bUseHardAngleThreshold;                                                     // 0x00BE (size: 0x1)
    uint8 bComputeLightMapResolution;                                                 // 0x00BE (size: 0x1)
    uint8 bRecalculateNormals;                                                        // 0x00BE (size: 0x1)
    uint8 bUseLandscapeCulling;                                                       // 0x00BE (size: 0x1)
    uint8 bSupportRayTracing;                                                         // 0x00BE (size: 0x1)
    uint8 bAllowDistanceField;                                                        // 0x00BF (size: 0x1)
    uint8 bReuseMeshLightmapUVs;                                                      // 0x00BF (size: 0x1)
    uint8 bGroupIdenticalMeshesForBaking;                                             // 0x00BF (size: 0x1)
    uint8 bCreateCollision;                                                           // 0x00BF (size: 0x1)
    uint8 bAllowVertexColors;                                                         // 0x00BF (size: 0x1)
    uint8 bGenerateLightmapUVs;                                                       // 0x00BF (size: 0x1)
    FMeshNaniteSettings NaniteSettings;                                               // 0x00C0 (size: 0x40)

}; // Size: 0x100

struct FMeshReductionSettings
{
    float PercentTriangles;                                                           // 0x0000 (size: 0x4)
    uint32 MaxNumOfTriangles;                                                         // 0x0004 (size: 0x4)
    float PercentVertices;                                                            // 0x0008 (size: 0x4)
    uint32 MaxNumOfVerts;                                                             // 0x000C (size: 0x4)
    float MaxDeviation;                                                               // 0x0010 (size: 0x4)
    float PixelError;                                                                 // 0x0014 (size: 0x4)
    float WeldingThreshold;                                                           // 0x0018 (size: 0x4)
    float HardAngleThreshold;                                                         // 0x001C (size: 0x4)
    int32 BaseLODModel;                                                               // 0x0020 (size: 0x4)
    TEnumAsByte<EMeshFeatureImportance::Type> SilhouetteImportance;                   // 0x0024 (size: 0x1)
    TEnumAsByte<EMeshFeatureImportance::Type> TextureImportance;                      // 0x0025 (size: 0x1)
    TEnumAsByte<EMeshFeatureImportance::Type> ShadingImportance;                      // 0x0026 (size: 0x1)
    uint8 bRecalculateNormals;                                                        // 0x0027 (size: 0x1)
    uint8 bGenerateUniqueLightmapUVs;                                                 // 0x0027 (size: 0x1)
    uint8 bKeepSymmetry;                                                              // 0x0027 (size: 0x1)
    uint8 bVisibilityAided;                                                           // 0x0027 (size: 0x1)
    uint8 bCullOccluded;                                                              // 0x0027 (size: 0x1)
    EStaticMeshReductionTerimationCriterion TerminationCriterion;                     // 0x0028 (size: 0x1)
    TEnumAsByte<EMeshFeatureImportance::Type> VisibilityAggressiveness;               // 0x0029 (size: 0x1)
    TEnumAsByte<EMeshFeatureImportance::Type> VertexColorImportance;                  // 0x002A (size: 0x1)

}; // Size: 0x2C

struct FMeshSectionInfo
{
    int32 MaterialIndex;                                                              // 0x0000 (size: 0x4)
    bool bEnableCollision;                                                            // 0x0004 (size: 0x1)
    bool bCastShadow;                                                                 // 0x0005 (size: 0x1)
    bool bVisibleInRayTracing;                                                        // 0x0006 (size: 0x1)
    bool bAffectDistanceFieldLighting;                                                // 0x0007 (size: 0x1)
    bool bForceOpaque;                                                                // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FMeshSectionInfoMap
{
    TMap<uint32, FMeshSectionInfo> Map;                                               // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FMeshUVChannelInfo
{
    bool bInitialized;                                                                // 0x0000 (size: 0x1)
    bool bOverrideDensities;                                                          // 0x0001 (size: 0x1)
    float LocalUVDensities;                                                           // 0x0004 (size: 0x10)

}; // Size: 0x14

struct FMinimalViewInfo
{
    FVector Location;                                                                 // 0x0000 (size: 0x18)
    FRotator Rotation;                                                                // 0x0018 (size: 0x18)
    float FOV;                                                                        // 0x0030 (size: 0x4)
    float DesiredFOV;                                                                 // 0x0034 (size: 0x4)
    float OrthoWidth;                                                                 // 0x0038 (size: 0x4)
    bool bAutoCalculateOrthoPlanes;                                                   // 0x003C (size: 0x1)
    float AutoPlaneShift;                                                             // 0x0040 (size: 0x4)
    bool bUpdateOrthoPlanes;                                                          // 0x0044 (size: 0x1)
    bool bUseCameraHeightAsViewTarget;                                                // 0x0045 (size: 0x1)
    float OrthoNearClipPlane;                                                         // 0x0048 (size: 0x4)
    float OrthoFarClipPlane;                                                          // 0x004C (size: 0x4)
    float PerspectiveNearClipPlane;                                                   // 0x0050 (size: 0x4)
    float AspectRatio;                                                                // 0x0054 (size: 0x4)
    uint8 bConstrainAspectRatio;                                                      // 0x0060 (size: 0x1)
    uint8 bUseFieldOfViewForLOD;                                                      // 0x0060 (size: 0x1)
    TEnumAsByte<ECameraProjectionMode::Type> ProjectionMode;                          // 0x0064 (size: 0x1)
    float PostProcessBlendWeight;                                                     // 0x0068 (size: 0x4)
    FPostProcessSettings PostProcessSettings;                                         // 0x0070 (size: 0x6F0)
    FVector2D OffCenterProjectionOffset;                                              // 0x0760 (size: 0x10)

}; // Size: 0x800

struct FMirrorFindReplaceExpression
{
    FName FindExpression;                                                             // 0x0000 (size: 0x8)
    FName ReplaceExpression;                                                          // 0x0008 (size: 0x8)
    TEnumAsByte<EMirrorFindReplaceMethod::Type> FindReplaceMethod;                    // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FMirrorTableRow : public FTableRowBase
{
    FName Name;                                                                       // 0x0008 (size: 0x8)
    FName MirroredName;                                                               // 0x0010 (size: 0x8)
    TEnumAsByte<EMirrorRowType::Type> MirrorEntryType;                                // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FModulatorContinuousParams
{
    FName ParameterName;                                                              // 0x0000 (size: 0x8)
    float Default;                                                                    // 0x0008 (size: 0x4)
    float MinInput;                                                                   // 0x000C (size: 0x4)
    float MaxInput;                                                                   // 0x0010 (size: 0x4)
    float MinOutput;                                                                  // 0x0014 (size: 0x4)
    float MaxOutput;                                                                  // 0x0018 (size: 0x4)
    TEnumAsByte<ModulationParamMode> ParamMode;                                       // 0x001C (size: 0x1)

}; // Size: 0x20

struct FMontageBlendSettings
{
    class UBlendProfile* BlendProfile;                                                // 0x0000 (size: 0x8)
    FAlphaBlendArgs Blend;                                                            // 0x0008 (size: 0x10)
    EMontageBlendMode BlendMode;                                                      // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FMovementProperties
{
    uint8 bCanCrouch;                                                                 // 0x0000 (size: 0x1)
    uint8 bCanJump;                                                                   // 0x0000 (size: 0x1)
    uint8 bCanWalk;                                                                   // 0x0000 (size: 0x1)
    uint8 bCanSwim;                                                                   // 0x0000 (size: 0x1)
    uint8 bCanFly;                                                                    // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FMulticastRecordOptions
{
    FString FuncPathName;                                                             // 0x0000 (size: 0x10)
    bool bServerSkip;                                                                 // 0x0010 (size: 0x1)
    bool bClientSkip;                                                                 // 0x0011 (size: 0x1)

}; // Size: 0x18

struct FNameCurve : public FIndexedCurve
{
    TArray<FNameCurveKey> keys;                                                       // 0x0068 (size: 0x10)

}; // Size: 0x78

struct FNameCurveKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    FName Value;                                                                      // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FNameMapping
{
    FName NodeName;                                                                   // 0x0000 (size: 0x8)
    FName BoneName;                                                                   // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FNamedColor
{
    FColor Value;                                                                     // 0x0000 (size: 0x4)
    FName Name;                                                                       // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FNamedCurveValue
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    float Value;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FNamedEmitterMaterial
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    class UMaterialInterface* Material;                                               // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FNamedFloat
{
    float Value;                                                                      // 0x0000 (size: 0x4)
    FName Name;                                                                       // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FNamedNetDriver
{
    class UNetDriver* NetDriver;                                                      // 0x0000 (size: 0x8)

}; // Size: 0x10

struct FNamedTransform
{
    FTransform Value;                                                                 // 0x0000 (size: 0x60)
    FName Name;                                                                       // 0x0060 (size: 0x8)

}; // Size: 0x70

struct FNamedVector
{
    FVector Value;                                                                    // 0x0000 (size: 0x18)
    FName Name;                                                                       // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FNaniteSettings
{
    bool bAllowMaskedMaterials;                                                       // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FNavAgentProperties : public FMovementProperties
{
    float AgentRadius;                                                                // 0x0004 (size: 0x4)
    float AgentHeight;                                                                // 0x0008 (size: 0x4)
    float AgentStepHeight;                                                            // 0x000C (size: 0x4)
    float NavWalkingSearchHeightScale;                                                // 0x0010 (size: 0x4)
    FSoftClassPath PreferredNavData;                                                  // 0x0018 (size: 0x20)

}; // Size: 0x38

struct FNavAgentSelector
{
    uint8 bSupportsAgent0;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent1;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent2;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent3;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent4;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent5;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent6;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent7;                                                            // 0x0000 (size: 0x1)
    uint8 bSupportsAgent8;                                                            // 0x0001 (size: 0x1)
    uint8 bSupportsAgent9;                                                            // 0x0001 (size: 0x1)
    uint8 bSupportsAgent10;                                                           // 0x0001 (size: 0x1)
    uint8 bSupportsAgent11;                                                           // 0x0001 (size: 0x1)
    uint8 bSupportsAgent12;                                                           // 0x0001 (size: 0x1)
    uint8 bSupportsAgent13;                                                           // 0x0001 (size: 0x1)
    uint8 bSupportsAgent14;                                                           // 0x0001 (size: 0x1)
    uint8 bSupportsAgent15;                                                           // 0x0001 (size: 0x1)

}; // Size: 0x4

struct FNavAvoidanceData
{
}; // Size: 0x58

struct FNavAvoidanceMask
{
    uint8 bGroup0;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup1;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup2;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup3;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup4;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup5;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup6;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup7;                                                                    // 0x0000 (size: 0x1)
    uint8 bGroup8;                                                                    // 0x0001 (size: 0x1)
    uint8 bGroup9;                                                                    // 0x0001 (size: 0x1)
    uint8 bGroup10;                                                                   // 0x0001 (size: 0x1)
    uint8 bGroup11;                                                                   // 0x0001 (size: 0x1)
    uint8 bGroup12;                                                                   // 0x0001 (size: 0x1)
    uint8 bGroup13;                                                                   // 0x0001 (size: 0x1)
    uint8 bGroup14;                                                                   // 0x0001 (size: 0x1)
    uint8 bGroup15;                                                                   // 0x0001 (size: 0x1)
    uint8 bGroup16;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup17;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup18;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup19;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup20;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup21;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup22;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup23;                                                                   // 0x0002 (size: 0x1)
    uint8 bGroup24;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup25;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup26;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup27;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup28;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup29;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup30;                                                                   // 0x0003 (size: 0x1)
    uint8 bGroup31;                                                                   // 0x0003 (size: 0x1)

}; // Size: 0x4

struct FNavDataConfig : public FNavAgentProperties
{
    FName Name;                                                                       // 0x0038 (size: 0x8)
    FColor Color;                                                                     // 0x0040 (size: 0x4)
    FVector DefaultQueryExtent;                                                       // 0x0048 (size: 0x18)
    TSoftClassPtr<AActor> NavDataClass;                                               // 0x0060 (size: 0x28)

}; // Size: 0x88

struct FNavLinkAuxiliaryId
{
    uint64 ID;                                                                        // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FNavLinkId
{
    uint64 ID;                                                                        // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FNavigationLink : public FNavigationLinkBase
{
    FVector Left;                                                                     // 0x0040 (size: 0x18)
    FVector Right;                                                                    // 0x0058 (size: 0x18)

}; // Size: 0x70

struct FNavigationLinkBase
{
    float LeftProjectHeight;                                                          // 0x0000 (size: 0x4)
    float MaxFallDownLength;                                                          // 0x0004 (size: 0x4)
    float SnapRadius;                                                                 // 0x0018 (size: 0x4)
    float SnapHeight;                                                                 // 0x001C (size: 0x4)
    FNavAgentSelector SupportedAgents;                                                // 0x0020 (size: 0x4)
    uint8 bSupportsAgent0;                                                            // 0x0024 (size: 0x1)
    uint8 bSupportsAgent1;                                                            // 0x0024 (size: 0x1)
    uint8 bSupportsAgent2;                                                            // 0x0024 (size: 0x1)
    uint8 bSupportsAgent3;                                                            // 0x0024 (size: 0x1)
    uint8 bSupportsAgent4;                                                            // 0x0024 (size: 0x1)
    uint8 bSupportsAgent5;                                                            // 0x0024 (size: 0x1)
    uint8 bSupportsAgent6;                                                            // 0x0024 (size: 0x1)
    uint8 bSupportsAgent7;                                                            // 0x0024 (size: 0x1)
    uint8 bSupportsAgent8;                                                            // 0x0025 (size: 0x1)
    uint8 bSupportsAgent9;                                                            // 0x0025 (size: 0x1)
    uint8 bSupportsAgent10;                                                           // 0x0025 (size: 0x1)
    uint8 bSupportsAgent11;                                                           // 0x0025 (size: 0x1)
    uint8 bSupportsAgent12;                                                           // 0x0025 (size: 0x1)
    uint8 bSupportsAgent13;                                                           // 0x0025 (size: 0x1)
    uint8 bSupportsAgent14;                                                           // 0x0025 (size: 0x1)
    uint8 bSupportsAgent15;                                                           // 0x0025 (size: 0x1)
    TEnumAsByte<ENavLinkDirection::Type> Direction;                                   // 0x0028 (size: 0x1)
    uint8 bUseSnapHeight;                                                             // 0x0029 (size: 0x1)
    uint8 bSnapToCheapestArea;                                                        // 0x0029 (size: 0x1)
    uint8 bCustomFlag0;                                                               // 0x0029 (size: 0x1)
    uint8 bCustomFlag1;                                                               // 0x0029 (size: 0x1)
    uint8 bCustomFlag2;                                                               // 0x0029 (size: 0x1)
    uint8 bCustomFlag3;                                                               // 0x0029 (size: 0x1)
    uint8 bCustomFlag4;                                                               // 0x0029 (size: 0x1)
    uint8 bCustomFlag5;                                                               // 0x0029 (size: 0x1)
    uint8 bCustomFlag6;                                                               // 0x002A (size: 0x1)
    uint8 bCustomFlag7;                                                               // 0x002A (size: 0x1)
    TSubclassOf<class UNavAreaBase> AreaClass;                                        // 0x0030 (size: 0x8)

}; // Size: 0x40

struct FNavigationSegmentLink : public FNavigationLinkBase
{
    FVector LeftStart;                                                                // 0x0040 (size: 0x18)
    FVector LeftEnd;                                                                  // 0x0058 (size: 0x18)
    FVector RightStart;                                                               // 0x0070 (size: 0x18)
    FVector RightEnd;                                                                 // 0x0088 (size: 0x18)

}; // Size: 0xA0

struct FNetDriverDefinition
{
    FName DefName;                                                                    // 0x0000 (size: 0x8)
    FName DriverClassName;                                                            // 0x0008 (size: 0x8)
    FName DriverClassNameFallback;                                                    // 0x0010 (size: 0x8)
    int32 MaxChannelsOverride;                                                        // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FNetDriverReplicationSystemConfig
{
    uint32 MaxReplicatedObjectClientCount;                                            // 0x0000 (size: 0x4)
    uint32 MaxReplicatedObjectServerCount;                                            // 0x0004 (size: 0x4)
    uint32 PreAllocatedReplicatedObjectClientCount;                                   // 0x0008 (size: 0x4)
    uint32 PreAllocatedReplicatedObjectServerCount;                                   // 0x000C (size: 0x4)
    uint32 MaxReplicatedWriterObjectClientCount;                                      // 0x0010 (size: 0x4)
    uint32 MaxDeltaCompressedObjectCount;                                             // 0x0014 (size: 0x4)
    uint32 MaxNetObjectGroupCount;                                                    // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FNetLevelVisibilityTransactionId
{
    uint32 Data;                                                                      // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FNetViewer
{
    class UNetConnection* Connection;                                                 // 0x0000 (size: 0x8)
    class AActor* InViewer;                                                           // 0x0008 (size: 0x8)
    class AActor* ViewTarget;                                                         // 0x0010 (size: 0x8)
    FVector ViewLocation;                                                             // 0x0018 (size: 0x18)
    FVector ViewDir;                                                                  // 0x0030 (size: 0x18)

}; // Size: 0x48

struct FNetworkEmulationProfileDescription
{
    FString ProfileName;                                                              // 0x0000 (size: 0x10)
    FString ToolTip;                                                                  // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FNetworkMetricConfig
{
    FName MetricName;                                                                 // 0x0000 (size: 0x8)
    TSoftClassPtr<UNetworkMetricsBaseListener> Class;                                 // 0x0008 (size: 0x28)
    ENetworkMetricEnableMode EnableMode;                                              // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FNetworkPhysicsData
{
    int32 ServerFrame;                                                                // 0x0008 (size: 0x4)
    int32 LocalFrame;                                                                 // 0x000C (size: 0x4)
    int32 InputFrame;                                                                 // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FNetworkPhysicsDatas : public FNetworkPhysicsData
{
}; // Size: 0x18

struct FNetworkPhysicsRewindDataInputProxy : public FNetworkPhysicsRewindDataProxy
{
}; // Size: 0x10

struct FNetworkPhysicsRewindDataProxy
{
    class UNetworkPhysicsComponent* Owner;                                            // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FNetworkPhysicsRewindDataStateProxy : public FNetworkPhysicsRewindDataProxy
{
}; // Size: 0x10

struct FNetworkPhysicsSettings
{
    uint8 bOverrideSimProxyRepMode;                                                   // 0x0000 (size: 0x1)
    EPhysicsReplicationMode SimProxyRepMode;                                          // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FNetworkPhysicsSettingsPredictiveInterpolation
{
    uint8 bOverridePosCorrectionTimeBase;                                             // 0x0000 (size: 0x1)
    float PosCorrectionTimeBase;                                                      // 0x0004 (size: 0x4)
    uint8 bOverridePosCorrectionTimeMin;                                              // 0x0008 (size: 0x1)
    float PosCorrectionTimeMin;                                                       // 0x000C (size: 0x4)
    uint8 bOverridePosCorrectionTimeMultiplier;                                       // 0x0010 (size: 0x1)
    float PosCorrectionTimeMultiplier;                                                // 0x0014 (size: 0x4)
    uint8 bOverrideRotCorrectionTimeBase;                                             // 0x0018 (size: 0x1)
    float RotCorrectionTimeBase;                                                      // 0x001C (size: 0x4)
    uint8 bOverrideRotCorrectionTimeMin;                                              // 0x0020 (size: 0x1)
    float RotCorrectionTimeMin;                                                       // 0x0024 (size: 0x4)
    uint8 bOverrideRotCorrectionTimeMultiplier;                                       // 0x0028 (size: 0x1)
    float RotCorrectionTimeMultiplier;                                                // 0x002C (size: 0x4)
    uint8 bOverridePosInterpolationTimeMultiplier;                                    // 0x0030 (size: 0x1)
    float PosInterpolationTimeMultiplier;                                             // 0x0034 (size: 0x4)
    uint8 bOverrideRotInterpolationTimeMultiplier;                                    // 0x0038 (size: 0x1)
    float RotInterpolationTimeMultiplier;                                             // 0x003C (size: 0x4)
    uint8 bOverrideSoftSnapPosStrength;                                               // 0x0040 (size: 0x1)
    float SoftSnapPosStrength;                                                        // 0x0044 (size: 0x4)
    uint8 bOverrideSoftSnapRotStrength;                                               // 0x0048 (size: 0x1)
    float SoftSnapRotStrength;                                                        // 0x004C (size: 0x4)
    uint8 bOverrideSoftSnapToSource;                                                  // 0x0050 (size: 0x1)
    bool bSoftSnapToSource;                                                           // 0x0054 (size: 0x1)
    uint8 bOverrideSkipVelocityRepOnPosEarlyOut;                                      // 0x0058 (size: 0x1)
    bool bSkipVelocityRepOnPosEarlyOut;                                               // 0x005C (size: 0x1)
    uint8 bOverridePostResimWaitForUpdate;                                            // 0x0060 (size: 0x1)
    bool bPostResimWaitForUpdate;                                                     // 0x0064 (size: 0x1)
    uint8 bOverrideDisableSoftSnap;                                                   // 0x0068 (size: 0x1)
    bool bDisableSoftSnap;                                                            // 0x006C (size: 0x1)

}; // Size: 0x70

struct FNetworkPhysicsSettingsResimulation
{
    uint8 bOverrideRedundantInputs;                                                   // 0x0000 (size: 0x1)
    uint8 RedundantInputs;                                                            // 0x0004 (size: 0x1)
    uint8 bOverrideRedundantStates;                                                   // 0x0008 (size: 0x1)
    uint8 RedundantStates;                                                            // 0x000C (size: 0x1)
    uint8 bOverrideRuntimeCorrectionEnabled;                                          // 0x0010 (size: 0x1)
    bool bRuntimeCorrectionEnabled;                                                   // 0x0014 (size: 0x1)
    uint8 bOverrideRuntimeVelocityCorrection;                                         // 0x0018 (size: 0x1)
    bool bRuntimeVelocityCorrection;                                                  // 0x001C (size: 0x1)
    uint8 bOverridePosStabilityMultiplier;                                            // 0x0020 (size: 0x1)
    float PosStabilityMultiplier;                                                     // 0x0024 (size: 0x4)
    uint8 bOverrideRotStabilityMultiplier;                                            // 0x0028 (size: 0x1)
    float RotStabilityMultiplier;                                                     // 0x002C (size: 0x4)
    uint8 bOverrideVelStabilityMultiplier;                                            // 0x0030 (size: 0x1)
    float VelStabilityMultiplier;                                                     // 0x0034 (size: 0x4)
    uint8 bOverrideAngVelStabilityMultiplier;                                         // 0x0038 (size: 0x1)
    float AngVelStabilityMultiplier;                                                  // 0x003C (size: 0x4)
    uint8 bOverrideResimulationErrorThreshold;                                        // 0x0040 (size: 0x1)
    uint32 ResimulationErrorThreshold;                                                // 0x0044 (size: 0x4)
    uint8 bOverrideCompareStateToTriggerRewind;                                       // 0x0048 (size: 0x1)
    bool bCompareStateToTriggerRewind;                                                // 0x004C (size: 0x1)
    uint8 bOverrideCompareInputToTriggerRewind;                                       // 0x0050 (size: 0x1)
    bool bCompareInputToTriggerRewind;                                                // 0x0054 (size: 0x1)

}; // Size: 0x58

struct FNeuralProfileStruct
{
    ENeuralProfileFormat InputFormat;                                                 // 0x0000 (size: 0x1)
    ENeuralProfileFormat OutputFormat;                                                // 0x0001 (size: 0x1)
    ENeuralProfileRuntimeType RuntimeType;                                            // 0x0002 (size: 0x1)
    class UObject* NNEModelData;                                                      // 0x0008 (size: 0x8)
    FIntVector4 InputDimension;                                                       // 0x0010 (size: 0x10)
    FIntVector4 OutputDimension;                                                      // 0x0020 (size: 0x10)
    int32 BatchSizeOverride;                                                          // 0x0030 (size: 0x4)
    ENeuralModelTileType TileSize;                                                    // 0x0034 (size: 0x1)
    FIntPoint TileOverlap;                                                            // 0x0038 (size: 0x8)
    ETileOverlapResolveType TileOverlapResolveType;                                   // 0x0040 (size: 0x1)

}; // Size: 0x48

struct FNewLevelInstanceParams
{
    ELevelInstanceCreationType Type;                                                  // 0x0000 (size: 0x1)
    ELevelInstancePivotType PivotType;                                                // 0x0001 (size: 0x1)
    class AActor* PivotActor;                                                         // 0x0008 (size: 0x8)
    bool bAlwaysShowDialog;                                                           // 0x0010 (size: 0x1)
    class UWorld* TemplateWorld;                                                      // 0x0018 (size: 0x8)
    FString LevelPackageName;                                                         // 0x0020 (size: 0x10)
    bool bPromptForSave;                                                              // 0x0030 (size: 0x1)
    TSubclassOf<class AActor> LevelInstanceClass;                                     // 0x0038 (size: 0x8)
    bool bEnableStreaming;                                                            // 0x0040 (size: 0x1)
    bool bExternalActors;                                                             // 0x0041 (size: 0x1)
    bool bForceExternalActors;                                                        // 0x0042 (size: 0x1)
    bool bHideCreationType;                                                           // 0x0043 (size: 0x1)

}; // Size: 0x48

struct FNodeItem
{
    FName ParentName;                                                                 // 0x0000 (size: 0x8)
    FTransform Transform;                                                             // 0x0010 (size: 0x60)

}; // Size: 0x70

struct FNodeToCodeAssociation
{
}; // Size: 0x14

struct FNonBlendableFloatAnimationAttribute : public FFloatAnimationAttribute
{
}; // Size: 0x4

struct FNonBlendableIntegerAnimationAttribute : public FIntegerAnimationAttribute
{
}; // Size: 0x4

struct FNonBlendableQuaternionAnimationAttribute : public FQuaternionAnimationAttribute
{
}; // Size: 0x20

struct FNonBlendableTransformAnimationAttribute : public FTransformAnimationAttribute
{
}; // Size: 0x60

struct FNonBlendableVectorAnimationAttribute : public FVectorAnimationAttribute
{
}; // Size: 0x18

struct FOrbitOptions
{
    uint8 bProcessDuringSpawn;                                                        // 0x0000 (size: 0x1)
    uint8 bProcessDuringUpdate;                                                       // 0x0000 (size: 0x1)
    uint8 bUseEmitterTime;                                                            // 0x0000 (size: 0x1)

}; // Size: 0x4

struct FOverlapResult
{
    FActorInstanceHandle OverlapObjectHandle;                                         // 0x0000 (size: 0x20)
    TWeakObjectPtr<class UPrimitiveComponent> Component;                              // 0x0020 (size: 0x8)
    uint8 bBlockingHit;                                                               // 0x0038 (size: 0x1)

}; // Size: 0x40

struct FPOV
{
    FVector Location;                                                                 // 0x0000 (size: 0x18)
    FRotator Rotation;                                                                // 0x0018 (size: 0x18)
    float FOV;                                                                        // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FPSCPool
{
    TArray<FPSCPoolElem> FreeElements;                                                // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FPSCPoolElem
{
    class UParticleSystemComponent* PSC;                                              // 0x0000 (size: 0x8)

}; // Size: 0x10

struct FPacketSimulationSettings
{
    int32 PktLoss;                                                                    // 0x0000 (size: 0x4)
    int32 PktLossMaxSize;                                                             // 0x0004 (size: 0x4)
    int32 PktLossMinSize;                                                             // 0x0008 (size: 0x4)
    int32 PktOrder;                                                                   // 0x000C (size: 0x4)
    int32 PktDup;                                                                     // 0x0010 (size: 0x4)
    int32 PktLag;                                                                     // 0x0014 (size: 0x4)
    int32 PktLagVariance;                                                             // 0x0018 (size: 0x4)
    int32 PktLagMin;                                                                  // 0x001C (size: 0x4)
    int32 PktLagMax;                                                                  // 0x0020 (size: 0x4)
    int32 PktIncomingLagMin;                                                          // 0x0024 (size: 0x4)
    int32 PktIncomingLagMax;                                                          // 0x0028 (size: 0x4)
    int32 PktIncomingLoss;                                                            // 0x002C (size: 0x4)
    int32 PktJitter;                                                                  // 0x0030 (size: 0x4)

}; // Size: 0x34

struct FPaintedVertex
{
    FVector Position;                                                                 // 0x0000 (size: 0x18)
    FColor Color;                                                                     // 0x0018 (size: 0x4)
    FVector4 Normal;                                                                  // 0x0020 (size: 0x20)

}; // Size: 0x40

struct FParameterChannelNames
{
    FText R;                                                                          // 0x0000 (size: 0x10)
    FText G;                                                                          // 0x0010 (size: 0x10)
    FText B;                                                                          // 0x0020 (size: 0x10)
    FText A;                                                                          // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FParameterGroupData
{
    FString GroupName;                                                                // 0x0000 (size: 0x10)
    int32 GroupSortPriority;                                                          // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FParticleBurst
{
    int32 Count;                                                                      // 0x0000 (size: 0x4)
    int32 CountLow;                                                                   // 0x0004 (size: 0x4)
    float Time;                                                                       // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FParticleCurvePair
{
    FString CurveName;                                                                // 0x0000 (size: 0x10)
    class UObject* CurveObject;                                                       // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FParticleEditorPromotionSettings
{
    FFilePath DefaultParticleAsset;                                                   // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FParticleEmitterReplayFrame
{
}; // Size: 0x10

struct FParticleEvent_GenerateInfo
{
    TEnumAsByte<EParticleEventType> Type;                                             // 0x0000 (size: 0x1)
    int32 Frequency;                                                                  // 0x0004 (size: 0x4)
    int32 ParticleFrequency;                                                          // 0x0008 (size: 0x4)
    uint8 FirstTimeOnly;                                                              // 0x000C (size: 0x1)
    uint8 LastTimeOnly;                                                               // 0x000C (size: 0x1)
    uint8 UseReflectedImpactVector;                                                   // 0x000C (size: 0x1)
    uint8 bUseOrbitOffset;                                                            // 0x000C (size: 0x1)
    FName CustomName;                                                                 // 0x0010 (size: 0x8)
    TArray<class UParticleModuleEventSendToGame*> ParticleModuleEventsToSendToGame;   // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FParticleRandomSeedInfo
{
    FName ParameterName;                                                              // 0x0000 (size: 0x8)
    uint8 bGetSeedFromInstance;                                                       // 0x0008 (size: 0x1)
    uint8 bInstanceSeedIsIndex;                                                       // 0x0008 (size: 0x1)
    uint8 bResetSeedOnEmitterLooping;                                                 // 0x0008 (size: 0x1)
    uint8 bRandomlySelectSeedArray;                                                   // 0x0008 (size: 0x1)
    TArray<int32> RandomSeeds;                                                        // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FParticleSysParam
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    TEnumAsByte<EParticleSysParamType> ParamType;                                     // 0x0008 (size: 0x1)
    float Scalar;                                                                     // 0x000C (size: 0x4)
    float Scalar_Low;                                                                 // 0x0010 (size: 0x4)
    FVector Vector;                                                                   // 0x0018 (size: 0x18)
    FVector Vector_Low;                                                               // 0x0030 (size: 0x18)
    FColor Color;                                                                     // 0x0048 (size: 0x4)
    class AActor* Actor;                                                              // 0x0050 (size: 0x8)
    class UMaterialInterface* Material;                                               // 0x0058 (size: 0x8)

}; // Size: 0xE0

struct FParticleSystemLOD
{
}; // Size: 0x1

struct FParticleSystemReplayFrame
{
}; // Size: 0x10

struct FParticleSystemWorldManagerTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FPassiveSoundMixModifier
{
    class USoundMix* SoundMix;                                                        // 0x0000 (size: 0x8)
    float MinVolumeThreshold;                                                         // 0x0008 (size: 0x4)
    float MaxVolumeThreshold;                                                         // 0x000C (size: 0x4)

}; // Size: 0x10

struct FPerBoneBlendWeight
{
    int32 SourceIndex;                                                                // 0x0000 (size: 0x4)
    float BlendWeight;                                                                // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FPerBoneBlendWeights
{
    TArray<FPerBoneBlendWeight> BoneBlendWeights;                                     // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FPerBoneInterpolation
{
    FBoneReference BoneReference;                                                     // 0x0000 (size: 0x10)
    float InterpolationSpeedPerSec;                                                   // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FPerPlatformBool
{
    bool Default;                                                                     // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FPerPlatformFloat
{
    float Default;                                                                    // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FPerPlatformFrameRate
{
    FFrameRate Default;                                                               // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FPerPlatformInt
{
    int32 Default;                                                                    // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FPerQualityLevelFloat
{
    float Default;                                                                    // 0x0010 (size: 0x4)
    TMap<int32, float> PerQuality;                                                    // 0x0018 (size: 0x50)

}; // Size: 0x68

struct FPerQualityLevelInt
{
    int32 Default;                                                                    // 0x0010 (size: 0x4)
    TMap<int32, int32> PerQuality;                                                    // 0x0018 (size: 0x50)

}; // Size: 0x68

struct FPhysicalAnimationData
{
    FName BodyName;                                                                   // 0x0000 (size: 0x8)
    uint8 bIsLocalSimulation;                                                         // 0x0008 (size: 0x1)
    float OrientationStrength;                                                        // 0x000C (size: 0x4)
    float AngularVelocityStrength;                                                    // 0x0010 (size: 0x4)
    float PositionStrength;                                                           // 0x0014 (size: 0x4)
    float VelocityStrength;                                                           // 0x0018 (size: 0x4)
    float MaxLinearForce;                                                             // 0x001C (size: 0x4)
    float MaxAngularForce;                                                            // 0x0020 (size: 0x4)

}; // Size: 0x24

struct FPhysicalAnimationProfile
{
    FName ProfileName;                                                                // 0x0000 (size: 0x8)
    FPhysicalAnimationData PhysicalAnimationData;                                     // 0x0008 (size: 0x24)

}; // Size: 0x2C

struct FPhysicalSurfaceName
{
    TEnumAsByte<EPhysicalSurface> Type;                                               // 0x0000 (size: 0x1)
    FName Name;                                                                       // 0x0004 (size: 0x8)

}; // Size: 0xC

struct FPhysicsAssetSolverSettings
{
    int32 PositionIterations;                                                         // 0x0000 (size: 0x4)
    int32 VelocityIterations;                                                         // 0x0004 (size: 0x4)
    int32 ProjectionIterations;                                                       // 0x0008 (size: 0x4)
    float CullDistance;                                                               // 0x000C (size: 0x4)
    float MaxDepenetrationVelocity;                                                   // 0x0010 (size: 0x4)
    float FixedTimeStep;                                                              // 0x0014 (size: 0x4)
    bool bUseLinearJointSolver;                                                       // 0x0018 (size: 0x1)

}; // Size: 0x1C

struct FPhysicsConstraintProfileHandle
{
    FConstraintProfileProperties ProfileProperties;                                   // 0x0000 (size: 0x158)
    FName ProfileName;                                                                // 0x0158 (size: 0x8)

}; // Size: 0x160

struct FPhysicsPredictionSettings
{
    bool bEnablePhysicsPrediction;                                                    // 0x0000 (size: 0x1)
    bool bEnablePhysicsResimulation;                                                  // 0x0001 (size: 0x1)
    float ResimulationErrorThreshold;                                                 // 0x0004 (size: 0x4)
    float MaxSupportedLatencyPrediction;                                              // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FPieFixupStructWithSoftObjectPath
{
    FSoftObjectPath Path;                                                             // 0x0000 (size: 0x20)
    TSoftObjectPtr<AActor> TypedPtr;                                                  // 0x0020 (size: 0x28)

}; // Size: 0x48

struct FPlatformInterfaceData
{
    FName DataName;                                                                   // 0x0000 (size: 0x8)
    TEnumAsByte<EPlatformInterfaceDataType> Type;                                     // 0x0008 (size: 0x1)
    int32 IntValue;                                                                   // 0x000C (size: 0x4)
    float FloatValue;                                                                 // 0x0010 (size: 0x4)
    FString StringValue;                                                              // 0x0018 (size: 0x10)
    class UObject* ObjectValue;                                                       // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FPlatformInterfaceDelegateResult
{
    bool bSuccessful;                                                                 // 0x0000 (size: 0x1)
    FPlatformInterfaceData Data;                                                      // 0x0008 (size: 0x30)

}; // Size: 0x38

struct FPlayerMuteList
{
    bool bHasVoiceHandshakeCompleted;                                                 // 0x0050 (size: 0x1)
    int32 VoiceChannelIdx;                                                            // 0x0054 (size: 0x4)

}; // Size: 0x58

struct FPluginRedirect
{
    FString OldPluginName;                                                            // 0x0000 (size: 0x10)
    FString NewPluginName;                                                            // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FPointDamageEvent : public FDamageEvent
{
    float Damage;                                                                     // 0x0010 (size: 0x4)
    FVector_NetQuantizeNormal ShotDirection;                                          // 0x0018 (size: 0x18)
    FHitResult HitInfo;                                                               // 0x0030 (size: 0xF8)

}; // Size: 0x128

struct FPointerToUberGraphFrame
{
}; // Size: 0x8

struct FPooledCameraShakes
{
    TArray<class UCameraShakeBase*> PooledShakes;                                     // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FPoseAssetInfluence
{
    int32 PoseIndex;                                                                  // 0x0000 (size: 0x4)
    int32 BoneTransformIndex;                                                         // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FPoseAssetInfluences
{
    TArray<FPoseAssetInfluence> Influences;                                           // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FPoseData
{
    TArray<FTransform> LocalSpacePose;                                                // 0x0000 (size: 0x10)
    TArray<float> CurveData;                                                          // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FPoseDataContainer
{
    TArray<FName> PoseFNames;                                                         // 0x0000 (size: 0x10)
    TArray<FName> Tracks;                                                             // 0x0020 (size: 0x10)
    TArray<int32> TrackBoneIndices;                                                   // 0x0030 (size: 0x10)
    TArray<FPoseAssetInfluences> TrackPoseInfluenceIndices;                           // 0x0040 (size: 0x10)
    TArray<FPoseData> Poses;                                                          // 0x0050 (size: 0x10)
    TArray<FAnimCurveBase> Curves;                                                    // 0x0060 (size: 0x10)

}; // Size: 0x70

struct FPoseLink : public FPoseLinkBase
{
}; // Size: 0x10

struct FPoseLinkBase
{
    int32 LinkID;                                                                     // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FPoseSnapshot
{
    TArray<FTransform> LocalTransforms;                                               // 0x0000 (size: 0x10)
    TArray<FName> BoneNames;                                                          // 0x0010 (size: 0x10)
    FName SkeletalMeshName;                                                           // 0x0020 (size: 0x8)
    FName SnapshotName;                                                               // 0x0028 (size: 0x8)
    bool bIsValid;                                                                    // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FPostProcessSettings
{
    uint8 bOverride_TemperatureType;                                                  // 0x0000 (size: 0x1)
    uint8 bOverride_WhiteTemp;                                                        // 0x0000 (size: 0x1)
    uint8 bOverride_WhiteTint;                                                        // 0x0000 (size: 0x1)
    uint8 bOverride_ColorSaturation;                                                  // 0x0000 (size: 0x1)
    uint8 bOverride_ColorContrast;                                                    // 0x0000 (size: 0x1)
    uint8 bOverride_ColorGamma;                                                       // 0x0000 (size: 0x1)
    uint8 bOverride_ColorGain;                                                        // 0x0000 (size: 0x1)
    uint8 bOverride_ColorOffset;                                                      // 0x0000 (size: 0x1)
    uint8 bOverride_ColorSaturationShadows;                                           // 0x0001 (size: 0x1)
    uint8 bOverride_ColorContrastShadows;                                             // 0x0001 (size: 0x1)
    uint8 bOverride_ColorGammaShadows;                                                // 0x0001 (size: 0x1)
    uint8 bOverride_ColorGainShadows;                                                 // 0x0001 (size: 0x1)
    uint8 bOverride_ColorOffsetShadows;                                               // 0x0001 (size: 0x1)
    uint8 bOverride_ColorSaturationMidtones;                                          // 0x0001 (size: 0x1)
    uint8 bOverride_ColorContrastMidtones;                                            // 0x0001 (size: 0x1)
    uint8 bOverride_ColorGammaMidtones;                                               // 0x0001 (size: 0x1)
    uint8 bOverride_ColorGainMidtones;                                                // 0x0002 (size: 0x1)
    uint8 bOverride_ColorOffsetMidtones;                                              // 0x0002 (size: 0x1)
    uint8 bOverride_ColorSaturationHighlights;                                        // 0x0002 (size: 0x1)
    uint8 bOverride_ColorContrastHighlights;                                          // 0x0002 (size: 0x1)
    uint8 bOverride_ColorGammaHighlights;                                             // 0x0002 (size: 0x1)
    uint8 bOverride_ColorGainHighlights;                                              // 0x0002 (size: 0x1)
    uint8 bOverride_ColorOffsetHighlights;                                            // 0x0002 (size: 0x1)
    uint8 bOverride_ColorCorrectionShadowsMax;                                        // 0x0002 (size: 0x1)
    uint8 bOverride_ColorCorrectionHighlightsMin;                                     // 0x0003 (size: 0x1)
    uint8 bOverride_ColorCorrectionHighlightsMax;                                     // 0x0003 (size: 0x1)
    uint8 bOverride_BlueCorrection;                                                   // 0x0003 (size: 0x1)
    uint8 bOverride_ExpandGamut;                                                      // 0x0003 (size: 0x1)
    uint8 bOverride_ToneCurveAmount;                                                  // 0x0003 (size: 0x1)
    uint8 bOverride_FilmSlope;                                                        // 0x0003 (size: 0x1)
    uint8 bOverride_FilmToe;                                                          // 0x0003 (size: 0x1)
    uint8 bOverride_FilmShoulder;                                                     // 0x0003 (size: 0x1)
    uint8 bOverride_FilmBlackClip;                                                    // 0x0004 (size: 0x1)
    uint8 bOverride_FilmWhiteClip;                                                    // 0x0004 (size: 0x1)
    uint8 bOverride_SceneColorTint;                                                   // 0x0004 (size: 0x1)
    uint8 bOverride_SceneFringeIntensity;                                             // 0x0004 (size: 0x1)
    uint8 bOverride_ChromaticAberrationStartOffset;                                   // 0x0004 (size: 0x1)
    uint8 bOverride_AmbientCubemapTint;                                               // 0x0004 (size: 0x1)
    uint8 bOverride_AmbientCubemapIntensity;                                          // 0x0004 (size: 0x1)
    uint8 bOverride_BloomMethod;                                                      // 0x0004 (size: 0x1)
    uint8 bOverride_BloomIntensity;                                                   // 0x0005 (size: 0x1)
    uint8 bOverride_BloomThreshold;                                                   // 0x0005 (size: 0x1)
    uint8 bOverride_Bloom1Tint;                                                       // 0x0005 (size: 0x1)
    uint8 bOverride_Bloom1Size;                                                       // 0x0005 (size: 0x1)
    uint8 bOverride_Bloom2Size;                                                       // 0x0005 (size: 0x1)
    uint8 bOverride_Bloom2Tint;                                                       // 0x0005 (size: 0x1)
    uint8 bOverride_Bloom3Tint;                                                       // 0x0005 (size: 0x1)
    uint8 bOverride_Bloom3Size;                                                       // 0x0005 (size: 0x1)
    uint8 bOverride_Bloom4Tint;                                                       // 0x0006 (size: 0x1)
    uint8 bOverride_Bloom4Size;                                                       // 0x0006 (size: 0x1)
    uint8 bOverride_Bloom5Tint;                                                       // 0x0006 (size: 0x1)
    uint8 bOverride_Bloom5Size;                                                       // 0x0006 (size: 0x1)
    uint8 bOverride_Bloom6Tint;                                                       // 0x0006 (size: 0x1)
    uint8 bOverride_Bloom6Size;                                                       // 0x0006 (size: 0x1)
    uint8 bOverride_BloomSizeScale;                                                   // 0x0006 (size: 0x1)
    uint8 bOverride_BloomConvolutionTexture;                                          // 0x0006 (size: 0x1)
    uint8 bOverride_BloomConvolutionScatterDispersion;                                // 0x0007 (size: 0x1)
    uint8 bOverride_BloomConvolutionSize;                                             // 0x0007 (size: 0x1)
    uint8 bOverride_BloomConvolutionCenterUV;                                         // 0x0007 (size: 0x1)
    uint8 bOverride_BloomConvolutionPreFilter;                                        // 0x0007 (size: 0x1)
    uint8 bOverride_BloomConvolutionPreFilterMin;                                     // 0x0007 (size: 0x1)
    uint8 bOverride_BloomConvolutionPreFilterMax;                                     // 0x0007 (size: 0x1)
    uint8 bOverride_BloomConvolutionPreFilterMult;                                    // 0x0007 (size: 0x1)
    uint8 bOverride_BloomConvolutionBufferScale;                                      // 0x0007 (size: 0x1)
    uint8 bOverride_BloomDirtMaskIntensity;                                           // 0x0008 (size: 0x1)
    uint8 bOverride_BloomDirtMaskTint;                                                // 0x0008 (size: 0x1)
    uint8 bOverride_BloomDirtMask;                                                    // 0x0008 (size: 0x1)
    uint8 bOverride_CameraShutterSpeed;                                               // 0x0008 (size: 0x1)
    uint8 bOverride_CameraISO;                                                        // 0x0008 (size: 0x1)
    uint8 bOverride_AutoExposureMethod;                                               // 0x0008 (size: 0x1)
    uint8 bOverride_AutoExposureLowPercent;                                           // 0x0008 (size: 0x1)
    uint8 bOverride_AutoExposureHighPercent;                                          // 0x0008 (size: 0x1)
    uint8 bOverride_AutoExposureMinBrightness;                                        // 0x0009 (size: 0x1)
    uint8 bOverride_AutoExposureMaxBrightness;                                        // 0x0009 (size: 0x1)
    uint8 bOverride_AutoExposureCalibrationConstant;                                  // 0x0009 (size: 0x1)
    uint8 bOverride_AutoExposureSpeedUp;                                              // 0x0009 (size: 0x1)
    uint8 bOverride_AutoExposureSpeedDown;                                            // 0x0009 (size: 0x1)
    uint8 bOverride_AutoExposureBias;                                                 // 0x0009 (size: 0x1)
    uint8 bOverride_AutoExposureBiasCurve;                                            // 0x0009 (size: 0x1)
    uint8 bOverride_AutoExposureMeterMask;                                            // 0x0009 (size: 0x1)
    uint8 bOverride_AutoExposureApplyPhysicalCameraExposure;                          // 0x000A (size: 0x1)
    uint8 bOverride_HistogramLogMin;                                                  // 0x000A (size: 0x1)
    uint8 bOverride_HistogramLogMax;                                                  // 0x000A (size: 0x1)
    uint8 bOverride_LocalExposureContrastScale;                                       // 0x000A (size: 0x1)
    uint8 bOverride_LocalExposureHighlightContrastScale;                              // 0x000A (size: 0x1)
    uint8 bOverride_LocalExposureShadowContrastScale;                                 // 0x000A (size: 0x1)
    uint8 bOverride_LocalExposureHighlightContrastCurve;                              // 0x000A (size: 0x1)
    uint8 bOverride_LocalExposureShadowContrastCurve;                                 // 0x000A (size: 0x1)
    uint8 bOverride_LocalExposureHighlightThreshold;                                  // 0x000B (size: 0x1)
    uint8 bOverride_LocalExposureShadowThreshold;                                     // 0x000B (size: 0x1)
    uint8 bOverride_LocalExposureDetailStrength;                                      // 0x000B (size: 0x1)
    uint8 bOverride_LocalExposureBlurredLuminanceBlend;                               // 0x000B (size: 0x1)
    uint8 bOverride_LocalExposureBlurredLuminanceKernelSizePercent;                   // 0x000B (size: 0x1)
    uint8 bOverride_LocalExposureMiddleGreyBias;                                      // 0x000B (size: 0x1)
    uint8 bOverride_LensFlareIntensity;                                               // 0x000B (size: 0x1)
    uint8 bOverride_LensFlareTint;                                                    // 0x000B (size: 0x1)
    uint8 bOverride_LensFlareTints;                                                   // 0x000C (size: 0x1)
    uint8 bOverride_LensFlareBokehSize;                                               // 0x000C (size: 0x1)
    uint8 bOverride_LensFlareBokehShape;                                              // 0x000C (size: 0x1)
    uint8 bOverride_LensFlareThreshold;                                               // 0x000C (size: 0x1)
    uint8 bOverride_VignetteIntensity;                                                // 0x000C (size: 0x1)
    uint8 bOverride_Sharpen;                                                          // 0x000C (size: 0x1)
    uint8 bOverride_GrainIntensity;                                                   // 0x000C (size: 0x1)
    uint8 bOverride_GrainJitter;                                                      // 0x000C (size: 0x1)
    uint8 bOverride_FilmGrainIntensity;                                               // 0x000D (size: 0x1)
    uint8 bOverride_FilmGrainIntensityShadows;                                        // 0x000D (size: 0x1)
    uint8 bOverride_FilmGrainIntensityMidtones;                                       // 0x000D (size: 0x1)
    uint8 bOverride_FilmGrainIntensityHighlights;                                     // 0x000D (size: 0x1)
    uint8 bOverride_FilmGrainShadowsMax;                                              // 0x000D (size: 0x1)
    uint8 bOverride_FilmGrainHighlightsMin;                                           // 0x000D (size: 0x1)
    uint8 bOverride_FilmGrainHighlightsMax;                                           // 0x000D (size: 0x1)
    uint8 bOverride_FilmGrainTexelSize;                                               // 0x000D (size: 0x1)
    uint8 bOverride_FilmGrainTexture;                                                 // 0x000E (size: 0x1)
    uint8 bOverride_AmbientOcclusionIntensity;                                        // 0x000E (size: 0x1)
    uint8 bOverride_AmbientOcclusionStaticFraction;                                   // 0x000E (size: 0x1)
    uint8 bOverride_AmbientOcclusionRadius;                                           // 0x000E (size: 0x1)
    uint8 bOverride_AmbientOcclusionFadeDistance;                                     // 0x000E (size: 0x1)
    uint8 bOverride_AmbientOcclusionFadeRadius;                                       // 0x000E (size: 0x1)
    uint8 bOverride_AmbientOcclusionDistance;                                         // 0x000E (size: 0x1)
    uint8 bOverride_AmbientOcclusionRadiusInWS;                                       // 0x000E (size: 0x1)
    uint8 bOverride_AmbientOcclusionPower;                                            // 0x000F (size: 0x1)
    uint8 bOverride_AmbientOcclusionBias;                                             // 0x000F (size: 0x1)
    uint8 bOverride_AmbientOcclusionQuality;                                          // 0x000F (size: 0x1)
    uint8 bOverride_AmbientOcclusionMipBlend;                                         // 0x000F (size: 0x1)
    uint8 bOverride_AmbientOcclusionMipScale;                                         // 0x000F (size: 0x1)
    uint8 bOverride_AmbientOcclusionMipThreshold;                                     // 0x000F (size: 0x1)
    uint8 bOverride_AmbientOcclusionTemporalBlendWeight;                              // 0x000F (size: 0x1)
    uint8 bOverride_RayTracingAO;                                                     // 0x0010 (size: 0x1)
    uint8 bOverride_RayTracingAOSamplesPerPixel;                                      // 0x0010 (size: 0x1)
    uint8 bOverride_RayTracingAOIntensity;                                            // 0x0010 (size: 0x1)
    uint8 bOverride_RayTracingAORadius;                                               // 0x0010 (size: 0x1)
    uint8 bOverride_LPVIntensity;                                                     // 0x0014 (size: 0x1)
    uint8 bOverride_LPVDirectionalOcclusionIntensity;                                 // 0x0014 (size: 0x1)
    uint8 bOverride_LPVDirectionalOcclusionRadius;                                    // 0x0014 (size: 0x1)
    uint8 bOverride_LPVDiffuseOcclusionExponent;                                      // 0x0014 (size: 0x1)
    uint8 bOverride_LPVSpecularOcclusionExponent;                                     // 0x0014 (size: 0x1)
    uint8 bOverride_LPVDiffuseOcclusionIntensity;                                     // 0x0014 (size: 0x1)
    uint8 bOverride_LPVSpecularOcclusionIntensity;                                    // 0x0014 (size: 0x1)
    uint8 bOverride_LPVSize;                                                          // 0x0014 (size: 0x1)
    uint8 bOverride_LPVSecondaryOcclusionIntensity;                                   // 0x0015 (size: 0x1)
    uint8 bOverride_LPVSecondaryBounceIntensity;                                      // 0x0015 (size: 0x1)
    uint8 bOverride_LPVGeometryVolumeBias;                                            // 0x0015 (size: 0x1)
    uint8 bOverride_LPVVplInjectionBias;                                              // 0x0015 (size: 0x1)
    uint8 bOverride_LPVEmissiveInjectionIntensity;                                    // 0x0015 (size: 0x1)
    uint8 bOverride_LPVFadeRange;                                                     // 0x0015 (size: 0x1)
    uint8 bOverride_LPVDirectionalOcclusionFadeRange;                                 // 0x0015 (size: 0x1)
    uint8 bOverride_IndirectLightingColor;                                            // 0x0015 (size: 0x1)
    uint8 bOverride_IndirectLightingIntensity;                                        // 0x0016 (size: 0x1)
    uint8 bOverride_ColorGradingIntensity;                                            // 0x0016 (size: 0x1)
    uint8 bOverride_ColorGradingLUT;                                                  // 0x0016 (size: 0x1)
    uint8 bOverride_DepthOfFieldFocalDistance;                                        // 0x0016 (size: 0x1)
    uint8 bOverride_DepthOfFieldFstop;                                                // 0x0016 (size: 0x1)
    uint8 bOverride_DepthOfFieldMinFstop;                                             // 0x0016 (size: 0x1)
    uint8 bOverride_DepthOfFieldBladeCount;                                           // 0x0016 (size: 0x1)
    uint8 bOverride_DepthOfFieldSensorWidth;                                          // 0x0016 (size: 0x1)
    uint8 bOverride_DepthOfFieldSqueezeFactor;                                        // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldDepthBlurRadius;                                      // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldUseHairDepth;                                         // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldDepthBlurAmount;                                      // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldFocalRegion;                                          // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldNearTransitionRegion;                                 // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldFarTransitionRegion;                                  // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldScale;                                                // 0x0017 (size: 0x1)
    uint8 bOverride_DepthOfFieldNearBlurSize;                                         // 0x0018 (size: 0x1)
    uint8 bOverride_DepthOfFieldFarBlurSize;                                          // 0x0018 (size: 0x1)
    uint8 bOverride_MobileHQGaussian;                                                 // 0x0018 (size: 0x1)
    uint8 bOverride_DepthOfFieldOcclusion;                                            // 0x0018 (size: 0x1)
    uint8 bOverride_DepthOfFieldSkyFocusDistance;                                     // 0x0018 (size: 0x1)
    uint8 bOverride_DepthOfFieldVignetteSize;                                         // 0x0018 (size: 0x1)
    uint8 bOverride_MotionBlurAmount;                                                 // 0x0018 (size: 0x1)
    uint8 bOverride_MotionBlurMax;                                                    // 0x0018 (size: 0x1)
    uint8 bOverride_MotionBlurTargetFPS;                                              // 0x0019 (size: 0x1)
    uint8 bOverride_MotionBlurPerObjectSize;                                          // 0x0019 (size: 0x1)
    uint8 bOverride_ScreenPercentage;                                                 // 0x0019 (size: 0x1)
    uint8 bOverride_ReflectionMethod;                                                 // 0x0019 (size: 0x1)
    uint8 bOverride_LumenReflectionQuality;                                           // 0x0019 (size: 0x1)
    uint8 bOverride_ScreenSpaceReflectionIntensity;                                   // 0x0019 (size: 0x1)
    uint8 bOverride_ScreenSpaceReflectionQuality;                                     // 0x0019 (size: 0x1)
    uint8 bOverride_ScreenSpaceReflectionMaxRoughness;                                // 0x0019 (size: 0x1)
    uint8 bOverride_ScreenSpaceReflectionRoughnessScale;                              // 0x001A (size: 0x1)
    uint8 bOverride_ReflectionsType;                                                  // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingReflectionsMaxRoughness;                                // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingReflectionsMaxBounces;                                  // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingReflectionsSamplesPerPixel;                             // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingReflectionsShadows;                                     // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingReflectionsTranslucency;                                // 0x001C (size: 0x1)
    uint8 bOverride_TranslucencyType;                                                 // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingTranslucencyMaxRoughness;                               // 0x001C (size: 0x1)
    uint8 bOverride_RayTracingTranslucencyRefractionRays;                             // 0x001D (size: 0x1)
    uint8 bOverride_RayTracingTranslucencySamplesPerPixel;                            // 0x001D (size: 0x1)
    uint8 bOverride_RayTracingTranslucencyShadows;                                    // 0x001D (size: 0x1)
    uint8 bOverride_RayTracingTranslucencyRefraction;                                 // 0x001D (size: 0x1)
    uint8 bOverride_DynamicGlobalIlluminationMethod;                                  // 0x001D (size: 0x1)
    uint8 bOverride_LumenSceneLightingQuality;                                        // 0x001D (size: 0x1)
    uint8 bOverride_LumenSceneDetail;                                                 // 0x001D (size: 0x1)
    uint8 bOverride_LumenSceneViewDistance;                                           // 0x001D (size: 0x1)
    uint8 bOverride_LumenSceneLightingUpdateSpeed;                                    // 0x001E (size: 0x1)
    uint8 bOverride_LumenFinalGatherQuality;                                          // 0x001E (size: 0x1)
    uint8 bOverride_LumenFinalGatherLightingUpdateSpeed;                              // 0x001E (size: 0x1)
    uint8 bOverride_LumenFinalGatherScreenTraces;                                     // 0x001E (size: 0x1)
    uint8 bOverride_LumenMaxTraceDistance;                                            // 0x001E (size: 0x1)
    uint8 bOverride_LumenDiffuseColorBoost;                                           // 0x001E (size: 0x1)
    uint8 bOverride_LumenSkylightLeaking;                                             // 0x001E (size: 0x1)
    uint8 bOverride_LumenFullSkylightLeakingDistance;                                 // 0x001E (size: 0x1)
    uint8 bOverride_LumenRayLightingMode;                                             // 0x0020 (size: 0x1)
    uint8 bOverride_LumenReflectionsScreenTraces;                                     // 0x0020 (size: 0x1)
    uint8 bOverride_LumenFrontLayerTranslucencyReflections;                           // 0x0020 (size: 0x1)
    uint8 bOverride_LumenMaxRoughnessToTraceReflections;                              // 0x0024 (size: 0x1)
    uint8 bOverride_LumenMaxReflectionBounces;                                        // 0x0024 (size: 0x1)
    uint8 bOverride_LumenMaxRefractionBounces;                                        // 0x0024 (size: 0x1)
    uint8 bOverride_LumenSurfaceCacheResolution;                                      // 0x0028 (size: 0x1)
    uint8 bOverride_RayTracingGI;                                                     // 0x002C (size: 0x1)
    uint8 bOverride_RayTracingGIMaxBounces;                                           // 0x002C (size: 0x1)
    uint8 bOverride_RayTracingGISamplesPerPixel;                                      // 0x002C (size: 0x1)
    uint8 bOverride_PathTracingMaxBounces;                                            // 0x002C (size: 0x1)
    uint8 bOverride_PathTracingSamplesPerPixel;                                       // 0x002C (size: 0x1)
    uint8 bOverride_PathTracingMaxPathExposure;                                       // 0x002C (size: 0x1)
    uint8 bOverride_PathTracingEnableEmissiveMaterials;                               // 0x002C (size: 0x1)
    uint8 bOverride_PathTracingEnableReferenceDOF;                                    // 0x002C (size: 0x1)
    uint8 bOverride_PathTracingEnableReferenceAtmosphere;                             // 0x002D (size: 0x1)
    uint8 bOverride_PathTracingEnableDenoiser;                                        // 0x002D (size: 0x1)
    uint8 bOverride_PathTracingIncludeEmissive;                                       // 0x002D (size: 0x1)
    uint8 bOverride_PathTracingIncludeDiffuse;                                        // 0x002D (size: 0x1)
    uint8 bOverride_PathTracingIncludeIndirectDiffuse;                                // 0x002D (size: 0x1)
    uint8 bOverride_PathTracingIncludeSpecular;                                       // 0x002D (size: 0x1)
    uint8 bOverride_PathTracingIncludeIndirectSpecular;                               // 0x002D (size: 0x1)
    uint8 bOverride_PathTracingIncludeVolume;                                         // 0x002D (size: 0x1)
    uint8 bOverride_PathTracingIncludeIndirectVolume;                                 // 0x002E (size: 0x1)
    uint8 bMobileHQGaussian;                                                          // 0x0030 (size: 0x1)
    TEnumAsByte<EBloomMethod> BloomMethod;                                            // 0x0031 (size: 0x1)
    TEnumAsByte<EAutoExposureMethod> AutoExposureMethod;                              // 0x0032 (size: 0x1)
    TEnumAsByte<ETemperatureMethod> TemperatureType;                                  // 0x0033 (size: 0x1)
    float WhiteTemp;                                                                  // 0x0034 (size: 0x4)
    float WhiteTint;                                                                  // 0x0038 (size: 0x4)
    FVector4 ColorSaturation;                                                         // 0x0040 (size: 0x20)
    FVector4 ColorContrast;                                                           // 0x0060 (size: 0x20)
    FVector4 ColorGamma;                                                              // 0x0080 (size: 0x20)
    FVector4 ColorGain;                                                               // 0x00A0 (size: 0x20)
    FVector4 ColorOffset;                                                             // 0x00C0 (size: 0x20)
    FVector4 ColorSaturationShadows;                                                  // 0x00E0 (size: 0x20)
    FVector4 ColorContrastShadows;                                                    // 0x0100 (size: 0x20)
    FVector4 ColorGammaShadows;                                                       // 0x0120 (size: 0x20)
    FVector4 ColorGainShadows;                                                        // 0x0140 (size: 0x20)
    FVector4 ColorOffsetShadows;                                                      // 0x0160 (size: 0x20)
    FVector4 ColorSaturationMidtones;                                                 // 0x0180 (size: 0x20)
    FVector4 ColorContrastMidtones;                                                   // 0x01A0 (size: 0x20)
    FVector4 ColorGammaMidtones;                                                      // 0x01C0 (size: 0x20)
    FVector4 ColorGainMidtones;                                                       // 0x01E0 (size: 0x20)
    FVector4 ColorOffsetMidtones;                                                     // 0x0200 (size: 0x20)
    FVector4 ColorSaturationHighlights;                                               // 0x0220 (size: 0x20)
    FVector4 ColorContrastHighlights;                                                 // 0x0240 (size: 0x20)
    FVector4 ColorGammaHighlights;                                                    // 0x0260 (size: 0x20)
    FVector4 ColorGainHighlights;                                                     // 0x0280 (size: 0x20)
    FVector4 ColorOffsetHighlights;                                                   // 0x02A0 (size: 0x20)
    float ColorCorrectionHighlightsMin;                                               // 0x02C0 (size: 0x4)
    float ColorCorrectionHighlightsMax;                                               // 0x02C4 (size: 0x4)
    float ColorCorrectionShadowsMax;                                                  // 0x02C8 (size: 0x4)
    float BlueCorrection;                                                             // 0x02CC (size: 0x4)
    float ExpandGamut;                                                                // 0x02D0 (size: 0x4)
    float ToneCurveAmount;                                                            // 0x02D4 (size: 0x4)
    float FilmSlope;                                                                  // 0x02D8 (size: 0x4)
    float FilmToe;                                                                    // 0x02DC (size: 0x4)
    float FilmShoulder;                                                               // 0x02E0 (size: 0x4)
    float FilmBlackClip;                                                              // 0x02E4 (size: 0x4)
    float FilmWhiteClip;                                                              // 0x02E8 (size: 0x4)
    FLinearColor SceneColorTint;                                                      // 0x02EC (size: 0x10)
    float SceneFringeIntensity;                                                       // 0x02FC (size: 0x4)
    float ChromaticAberrationStartOffset;                                             // 0x0300 (size: 0x4)
    float BloomIntensity;                                                             // 0x0304 (size: 0x4)
    float BloomThreshold;                                                             // 0x0308 (size: 0x4)
    float BloomSizeScale;                                                             // 0x030C (size: 0x4)
    float Bloom1Size;                                                                 // 0x0310 (size: 0x4)
    float Bloom2Size;                                                                 // 0x0314 (size: 0x4)
    float Bloom3Size;                                                                 // 0x0318 (size: 0x4)
    float Bloom4Size;                                                                 // 0x031C (size: 0x4)
    float Bloom5Size;                                                                 // 0x0320 (size: 0x4)
    float Bloom6Size;                                                                 // 0x0324 (size: 0x4)
    FLinearColor Bloom1Tint;                                                          // 0x0328 (size: 0x10)
    FLinearColor Bloom2Tint;                                                          // 0x0338 (size: 0x10)
    FLinearColor Bloom3Tint;                                                          // 0x0348 (size: 0x10)
    FLinearColor Bloom4Tint;                                                          // 0x0358 (size: 0x10)
    FLinearColor Bloom5Tint;                                                          // 0x0368 (size: 0x10)
    FLinearColor Bloom6Tint;                                                          // 0x0378 (size: 0x10)
    float BloomConvolutionScatterDispersion;                                          // 0x0388 (size: 0x4)
    float BloomConvolutionSize;                                                       // 0x038C (size: 0x4)
    class UTexture2D* BloomConvolutionTexture;                                        // 0x0390 (size: 0x8)
    FVector2D BloomConvolutionCenterUV;                                               // 0x0398 (size: 0x10)
    float BloomConvolutionPreFilterMin;                                               // 0x03A8 (size: 0x4)
    float BloomConvolutionPreFilterMax;                                               // 0x03AC (size: 0x4)
    float BloomConvolutionPreFilterMult;                                              // 0x03B0 (size: 0x4)
    float BloomConvolutionBufferScale;                                                // 0x03B4 (size: 0x4)
    class UTexture* BloomDirtMask;                                                    // 0x03B8 (size: 0x8)
    float BloomDirtMaskIntensity;                                                     // 0x03C0 (size: 0x4)
    FLinearColor BloomDirtMaskTint;                                                   // 0x03C4 (size: 0x10)
    TEnumAsByte<EDynamicGlobalIlluminationMethod::Type> DynamicGlobalIlluminationMethod; // 0x03D4 (size: 0x1)
    FLinearColor IndirectLightingColor;                                               // 0x03D8 (size: 0x10)
    float IndirectLightingIntensity;                                                  // 0x03E8 (size: 0x4)
    float LumenSceneLightingQuality;                                                  // 0x03EC (size: 0x4)
    float LumenSceneDetail;                                                           // 0x03F0 (size: 0x4)
    float LumenSceneViewDistance;                                                     // 0x03F4 (size: 0x4)
    float LumenSceneLightingUpdateSpeed;                                              // 0x03F8 (size: 0x4)
    float LumenFinalGatherQuality;                                                    // 0x03FC (size: 0x4)
    float LumenFinalGatherLightingUpdateSpeed;                                        // 0x0400 (size: 0x4)
    uint8 LumenFinalGatherScreenTraces;                                               // 0x0404 (size: 0x1)
    float LumenMaxTraceDistance;                                                      // 0x0408 (size: 0x4)
    float LumenDiffuseColorBoost;                                                     // 0x040C (size: 0x4)
    float LumenSkylightLeaking;                                                       // 0x0410 (size: 0x4)
    float LumenFullSkylightLeakingDistance;                                           // 0x0414 (size: 0x4)
    float LumenSurfaceCacheResolution;                                                // 0x0418 (size: 0x4)
    TEnumAsByte<EReflectionMethod::Type> ReflectionMethod;                            // 0x041C (size: 0x1)
    EReflectionsType ReflectionsType;                                                 // 0x041D (size: 0x1)
    float LumenReflectionQuality;                                                     // 0x0420 (size: 0x4)
    ELumenRayLightingModeOverride LumenRayLightingMode;                               // 0x0424 (size: 0x1)
    uint8 LumenReflectionsScreenTraces;                                               // 0x0425 (size: 0x1)
    uint8 LumenFrontLayerTranslucencyReflections;                                     // 0x0425 (size: 0x1)
    float LumenMaxRoughnessToTraceReflections;                                        // 0x0428 (size: 0x4)
    int32 LumenMaxReflectionBounces;                                                  // 0x042C (size: 0x4)
    int32 LumenMaxRefractionBounces;                                                  // 0x0430 (size: 0x4)
    float ScreenSpaceReflectionIntensity;                                             // 0x0434 (size: 0x4)
    float ScreenSpaceReflectionQuality;                                               // 0x0438 (size: 0x4)
    float ScreenSpaceReflectionMaxRoughness;                                          // 0x043C (size: 0x4)
    FLinearColor AmbientCubemapTint;                                                  // 0x0440 (size: 0x10)
    float AmbientCubemapIntensity;                                                    // 0x0450 (size: 0x4)
    class UTextureCube* AmbientCubemap;                                               // 0x0458 (size: 0x8)
    float CameraShutterSpeed;                                                         // 0x0460 (size: 0x4)
    float CameraISO;                                                                  // 0x0464 (size: 0x4)
    float DepthOfFieldFstop;                                                          // 0x0468 (size: 0x4)
    float DepthOfFieldMinFstop;                                                       // 0x046C (size: 0x4)
    int32 DepthOfFieldBladeCount;                                                     // 0x0470 (size: 0x4)
    float AutoExposureBias;                                                           // 0x0474 (size: 0x4)
    float AutoExposureBiasBackup;                                                     // 0x0478 (size: 0x4)
    uint8 bOverride_AutoExposureBiasBackup;                                           // 0x047C (size: 0x1)
    uint8 AutoExposureApplyPhysicalCameraExposure;                                    // 0x0480 (size: 0x1)
    class UCurveFloat* AutoExposureBiasCurve;                                         // 0x0488 (size: 0x8)
    class UTexture* AutoExposureMeterMask;                                            // 0x0490 (size: 0x8)
    float AutoExposureLowPercent;                                                     // 0x0498 (size: 0x4)
    float AutoExposureHighPercent;                                                    // 0x049C (size: 0x4)
    float AutoExposureMinBrightness;                                                  // 0x04A0 (size: 0x4)
    float AutoExposureMaxBrightness;                                                  // 0x04A4 (size: 0x4)
    float AutoExposureSpeedUp;                                                        // 0x04A8 (size: 0x4)
    float AutoExposureSpeedDown;                                                      // 0x04AC (size: 0x4)
    float HistogramLogMin;                                                            // 0x04B0 (size: 0x4)
    float HistogramLogMax;                                                            // 0x04B4 (size: 0x4)
    float AutoExposureCalibrationConstant;                                            // 0x04B8 (size: 0x4)
    float LocalExposureContrastScale;                                                 // 0x04BC (size: 0x4)
    float LocalExposureHighlightContrastScale;                                        // 0x04C0 (size: 0x4)
    float LocalExposureShadowContrastScale;                                           // 0x04C4 (size: 0x4)
    class UCurveFloat* LocalExposureHighlightContrastCurve;                           // 0x04C8 (size: 0x8)
    class UCurveFloat* LocalExposureShadowContrastCurve;                              // 0x04D0 (size: 0x8)
    float LocalExposureHighlightThreshold;                                            // 0x04D8 (size: 0x4)
    float LocalExposureShadowThreshold;                                               // 0x04DC (size: 0x4)
    float LocalExposureDetailStrength;                                                // 0x04E0 (size: 0x4)
    float LocalExposureBlurredLuminanceBlend;                                         // 0x04E4 (size: 0x4)
    float LocalExposureBlurredLuminanceKernelSizePercent;                             // 0x04E8 (size: 0x4)
    float LocalExposureMiddleGreyBias;                                                // 0x04EC (size: 0x4)
    float LensFlareIntensity;                                                         // 0x04F0 (size: 0x4)
    FLinearColor LensFlareTint;                                                       // 0x04F4 (size: 0x10)
    float LensFlareBokehSize;                                                         // 0x0504 (size: 0x4)
    float LensFlareThreshold;                                                         // 0x0508 (size: 0x4)
    class UTexture* LensFlareBokehShape;                                              // 0x0510 (size: 0x8)
    FLinearColor LensFlareTints;                                                      // 0x0518 (size: 0x80)
    float VignetteIntensity;                                                          // 0x0598 (size: 0x4)
    float Sharpen;                                                                    // 0x059C (size: 0x4)
    float GrainJitter;                                                                // 0x05A0 (size: 0x4)
    float GrainIntensity;                                                             // 0x05A4 (size: 0x4)
    float FilmGrainIntensity;                                                         // 0x05A8 (size: 0x4)
    float FilmGrainIntensityShadows;                                                  // 0x05AC (size: 0x4)
    float FilmGrainIntensityMidtones;                                                 // 0x05B0 (size: 0x4)
    float FilmGrainIntensityHighlights;                                               // 0x05B4 (size: 0x4)
    float FilmGrainShadowsMax;                                                        // 0x05B8 (size: 0x4)
    float FilmGrainHighlightsMin;                                                     // 0x05BC (size: 0x4)
    float FilmGrainHighlightsMax;                                                     // 0x05C0 (size: 0x4)
    float FilmGrainTexelSize;                                                         // 0x05C4 (size: 0x4)
    class UTexture2D* FilmGrainTexture;                                               // 0x05C8 (size: 0x8)
    float AmbientOcclusionIntensity;                                                  // 0x05D0 (size: 0x4)
    float AmbientOcclusionStaticFraction;                                             // 0x05D4 (size: 0x4)
    float AmbientOcclusionRadius;                                                     // 0x05D8 (size: 0x4)
    uint8 AmbientOcclusionRadiusInWS;                                                 // 0x05DC (size: 0x1)
    float AmbientOcclusionFadeDistance;                                               // 0x05E0 (size: 0x4)
    float AmbientOcclusionFadeRadius;                                                 // 0x05E4 (size: 0x4)
    float AmbientOcclusionDistance;                                                   // 0x05E8 (size: 0x4)
    float AmbientOcclusionPower;                                                      // 0x05EC (size: 0x4)
    float AmbientOcclusionBias;                                                       // 0x05F0 (size: 0x4)
    float AmbientOcclusionQuality;                                                    // 0x05F4 (size: 0x4)
    float AmbientOcclusionMipBlend;                                                   // 0x05F8 (size: 0x4)
    float AmbientOcclusionMipScale;                                                   // 0x05FC (size: 0x4)
    float AmbientOcclusionMipThreshold;                                               // 0x0600 (size: 0x4)
    float AmbientOcclusionTemporalBlendWeight;                                        // 0x0604 (size: 0x4)
    uint8 RayTracingAO;                                                               // 0x0608 (size: 0x1)
    int32 RayTracingAOSamplesPerPixel;                                                // 0x060C (size: 0x4)
    float RayTracingAOIntensity;                                                      // 0x0610 (size: 0x4)
    float RayTracingAORadius;                                                         // 0x0614 (size: 0x4)
    float ColorGradingIntensity;                                                      // 0x0618 (size: 0x4)
    class UTexture* ColorGradingLUT;                                                  // 0x0620 (size: 0x8)
    float DepthOfFieldSensorWidth;                                                    // 0x0628 (size: 0x4)
    float DepthOfFieldSqueezeFactor;                                                  // 0x062C (size: 0x4)
    float DepthOfFieldFocalDistance;                                                  // 0x0630 (size: 0x4)
    float DepthOfFieldDepthBlurAmount;                                                // 0x0634 (size: 0x4)
    float DepthOfFieldDepthBlurRadius;                                                // 0x0638 (size: 0x4)
    uint8 DepthOfFieldUseHairDepth;                                                   // 0x063C (size: 0x1)
    float DepthOfFieldFocalRegion;                                                    // 0x0640 (size: 0x4)
    float DepthOfFieldNearTransitionRegion;                                           // 0x0644 (size: 0x4)
    float DepthOfFieldFarTransitionRegion;                                            // 0x0648 (size: 0x4)
    float DepthOfFieldScale;                                                          // 0x064C (size: 0x4)
    float DepthOfFieldNearBlurSize;                                                   // 0x0650 (size: 0x4)
    float DepthOfFieldFarBlurSize;                                                    // 0x0654 (size: 0x4)
    float DepthOfFieldOcclusion;                                                      // 0x0658 (size: 0x4)
    float DepthOfFieldSkyFocusDistance;                                               // 0x065C (size: 0x4)
    float DepthOfFieldVignetteSize;                                                   // 0x0660 (size: 0x4)
    float MotionBlurAmount;                                                           // 0x0664 (size: 0x4)
    float MotionBlurMax;                                                              // 0x0668 (size: 0x4)
    int32 MotionBlurTargetFPS;                                                        // 0x066C (size: 0x4)
    float MotionBlurPerObjectSize;                                                    // 0x0670 (size: 0x4)
    float LPVIntensity;                                                               // 0x0674 (size: 0x4)
    float LPVVplInjectionBias;                                                        // 0x0678 (size: 0x4)
    float LPVSize;                                                                    // 0x067C (size: 0x4)
    float LPVSecondaryOcclusionIntensity;                                             // 0x0680 (size: 0x4)
    float LPVSecondaryBounceIntensity;                                                // 0x0684 (size: 0x4)
    float LPVGeometryVolumeBias;                                                      // 0x0688 (size: 0x4)
    float LPVEmissiveInjectionIntensity;                                              // 0x068C (size: 0x4)
    float LPVDirectionalOcclusionIntensity;                                           // 0x0690 (size: 0x4)
    float LPVDirectionalOcclusionRadius;                                              // 0x0694 (size: 0x4)
    float LPVDiffuseOcclusionExponent;                                                // 0x0698 (size: 0x4)
    float LPVSpecularOcclusionExponent;                                               // 0x069C (size: 0x4)
    float LPVDiffuseOcclusionIntensity;                                               // 0x06A0 (size: 0x4)
    float LPVSpecularOcclusionIntensity;                                              // 0x06A4 (size: 0x4)
    ETranslucencyType TranslucencyType;                                               // 0x06A8 (size: 0x1)
    float RayTracingTranslucencyMaxRoughness;                                         // 0x06AC (size: 0x4)
    int32 RayTracingTranslucencyRefractionRays;                                       // 0x06B0 (size: 0x4)
    int32 RayTracingTranslucencySamplesPerPixel;                                      // 0x06B4 (size: 0x4)
    EReflectedAndRefractedRayTracedShadows RayTracingTranslucencyShadows;             // 0x06B8 (size: 0x1)
    uint8 RayTracingTranslucencyRefraction;                                           // 0x06B9 (size: 0x1)
    int32 PathTracingMaxBounces;                                                      // 0x06BC (size: 0x4)
    int32 PathTracingSamplesPerPixel;                                                 // 0x06C0 (size: 0x4)
    float PathTracingMaxPathExposure;                                                 // 0x06C4 (size: 0x4)
    uint8 PathTracingEnableEmissiveMaterials;                                         // 0x06C8 (size: 0x1)
    uint8 PathTracingEnableReferenceDOF;                                              // 0x06C8 (size: 0x1)
    uint8 PathTracingEnableReferenceAtmosphere;                                       // 0x06C8 (size: 0x1)
    uint8 PathTracingEnableDenoiser;                                                  // 0x06C8 (size: 0x1)
    uint8 PathTracingIncludeEmissive;                                                 // 0x06C8 (size: 0x1)
    uint8 PathTracingIncludeDiffuse;                                                  // 0x06C8 (size: 0x1)
    uint8 PathTracingIncludeIndirectDiffuse;                                          // 0x06C8 (size: 0x1)
    uint8 PathTracingIncludeSpecular;                                                 // 0x06C8 (size: 0x1)
    uint8 PathTracingIncludeIndirectSpecular;                                         // 0x06C9 (size: 0x1)
    uint8 PathTracingIncludeVolume;                                                   // 0x06C9 (size: 0x1)
    uint8 PathTracingIncludeIndirectVolume;                                           // 0x06C9 (size: 0x1)
    float LPVFadeRange;                                                               // 0x06CC (size: 0x4)
    float LPVDirectionalOcclusionFadeRange;                                           // 0x06D0 (size: 0x4)
    float ScreenPercentage;                                                           // 0x06D4 (size: 0x4)
    FWeightedBlendables WeightedBlendables;                                           // 0x06D8 (size: 0x10)

}; // Size: 0x6F0

struct FPrecomputedLightInstanceData : public FSceneComponentInstanceData
{
    FTransform Transform;                                                             // 0x00C0 (size: 0x60)
    FGuid LightGuid;                                                                  // 0x0120 (size: 0x10)
    int32 PreviewShadowMapChannel;                                                    // 0x0130 (size: 0x4)

}; // Size: 0x140

struct FPrecomputedSkyLightInstanceData : public FSceneComponentInstanceData
{
    FGuid LightGuid;                                                                  // 0x00B8 (size: 0x10)
    float AverageBrightness;                                                          // 0x00C8 (size: 0x4)

}; // Size: 0x170

struct FPredictProjectilePathParams
{
    FVector StartLocation;                                                            // 0x0000 (size: 0x18)
    FVector LaunchVelocity;                                                           // 0x0018 (size: 0x18)
    bool bTraceWithCollision;                                                         // 0x0030 (size: 0x1)
    float ProjectileRadius;                                                           // 0x0034 (size: 0x4)
    float MaxSimTime;                                                                 // 0x0038 (size: 0x4)
    bool bTraceWithChannel;                                                           // 0x003C (size: 0x1)
    TEnumAsByte<ECollisionChannel> TraceChannel;                                      // 0x003D (size: 0x1)
    TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypes;                                // 0x0040 (size: 0x10)
    TArray<class AActor*> ActorsToIgnore;                                             // 0x0050 (size: 0x10)
    float SimFrequency;                                                               // 0x0060 (size: 0x4)
    float OverrideGravityZ;                                                           // 0x0064 (size: 0x4)
    TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType;                                 // 0x0068 (size: 0x1)
    float DrawDebugTime;                                                              // 0x006C (size: 0x4)
    bool bTraceComplex;                                                               // 0x0070 (size: 0x1)

}; // Size: 0x78

struct FPredictProjectilePathPointData
{
    FVector Location;                                                                 // 0x0000 (size: 0x18)
    FVector Velocity;                                                                 // 0x0018 (size: 0x18)
    float Time;                                                                       // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FPredictProjectilePathResult
{
    TArray<FPredictProjectilePathPointData> PathData;                                 // 0x0000 (size: 0x10)
    FPredictProjectilePathPointData LastTraceDestination;                             // 0x0010 (size: 0x38)
    FHitResult HitResult;                                                             // 0x0048 (size: 0xF8)

}; // Size: 0x140

struct FPreviewAssetAttachContainer
{
    TArray<FPreviewAttachedObjectPair> AttachedObjects;                               // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FPreviewAttachedObjectPair
{
    TSoftObjectPtr<UObject> AttachedObject;                                           // 0x0000 (size: 0x28)
    FName AttachedTo;                                                                 // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FPreviewMeshCollectionEntry
{
    TSoftObjectPtr<USkeletalMesh> SkeletalMesh;                                       // 0x0000 (size: 0x28)
    TSoftObjectPtr<UAnimBlueprint> AnimBlueprint;                                     // 0x0028 (size: 0x28)

}; // Size: 0x50

struct FPrimaryAssetRules
{
    int32 Priority;                                                                   // 0x0000 (size: 0x4)
    int32 ChunkId;                                                                    // 0x0004 (size: 0x4)
    bool bApplyRecursively;                                                           // 0x0008 (size: 0x1)
    EPrimaryAssetCookRule CookRule;                                                   // 0x0009 (size: 0x1)

}; // Size: 0xC

struct FPrimaryAssetRulesCustomOverride
{
    FPrimaryAssetType PrimaryAssetType;                                               // 0x0000 (size: 0x8)
    FDirectoryPath FilterDirectory;                                                   // 0x0008 (size: 0x10)
    FString FilterString;                                                             // 0x0018 (size: 0x10)
    FPrimaryAssetRules Rules;                                                         // 0x0028 (size: 0xC)

}; // Size: 0x38

struct FPrimaryAssetRulesOverride
{
    FPrimaryAssetId PrimaryAssetId;                                                   // 0x0000 (size: 0x10)
    FPrimaryAssetRules Rules;                                                         // 0x0010 (size: 0xC)

}; // Size: 0x1C

struct FPrimaryAssetTypeInfo
{
    FName PrimaryAssetType;                                                           // 0x0000 (size: 0x8)
    TSoftClassPtr<UObject> AssetBaseClass;                                            // 0x0008 (size: 0x28)
    UClass* AssetBaseClassLoaded;                                                     // 0x0030 (size: 0x8)
    bool bHasBlueprintClasses;                                                        // 0x0038 (size: 0x1)
    bool bIsEditorOnly;                                                               // 0x0039 (size: 0x1)
    TArray<FDirectoryPath> Directories;                                               // 0x0040 (size: 0x10)
    TArray<FSoftObjectPath> SpecificAssets;                                           // 0x0050 (size: 0x10)
    FPrimaryAssetRules Rules;                                                         // 0x0060 (size: 0xC)
    TArray<FString> AssetScanPaths;                                                   // 0x0070 (size: 0x10)
    bool bIsDynamicAsset;                                                             // 0x0080 (size: 0x1)
    int32 NumberOfAssets;                                                             // 0x0084 (size: 0x4)

}; // Size: 0x88

struct FPrimitiveComponentInstanceData : public FSceneComponentInstanceData
{
    FTransform ComponentTransform;                                                    // 0x00C0 (size: 0x60)
    int32 VisibilityId;                                                               // 0x0120 (size: 0x4)
    class UPrimitiveComponent* LODParent;                                             // 0x0128 (size: 0x8)

}; // Size: 0x130

struct FPropertyAccessCopy
{
    int32 AccessIndex;                                                                // 0x0000 (size: 0x4)
    int32 DestAccessStartIndex;                                                       // 0x0004 (size: 0x4)
    int32 DestAccessEndIndex;                                                         // 0x0008 (size: 0x4)
    EPropertyAccessCopyType Type;                                                     // 0x000C (size: 0x1)

}; // Size: 0x10

struct FPropertyAccessCopyBatch
{
    TArray<FPropertyAccessCopy> Copies;                                               // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FPropertyAccessIndirection
{
    TFieldPath<FProperty> Property;                                                   // 0x0000 (size: 0x20)
    class UFunction* Function;                                                        // 0x0020 (size: 0x8)
    int32 ReturnBufferSize;                                                           // 0x0028 (size: 0x4)
    int32 ReturnBufferAlignment;                                                      // 0x002C (size: 0x4)
    int32 ArrayIndex;                                                                 // 0x0030 (size: 0x4)
    uint32 Offset;                                                                    // 0x0034 (size: 0x4)
    EPropertyAccessObjectType ObjectType;                                             // 0x0038 (size: 0x1)
    EPropertyAccessIndirectionType Type;                                              // 0x0039 (size: 0x1)

}; // Size: 0x40

struct FPropertyAccessIndirectionChain
{
    TFieldPath<FProperty> Property;                                                   // 0x0000 (size: 0x20)
    int32 IndirectionStartIndex;                                                      // 0x0020 (size: 0x4)
    int32 IndirectionEndIndex;                                                        // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FPropertyAccessLibrary
{
    TArray<FPropertyAccessSegment> PathSegments;                                      // 0x0000 (size: 0x10)
    TArray<FPropertyAccessPath> SrcPaths;                                             // 0x0010 (size: 0x10)
    TArray<FPropertyAccessPath> DestPaths;                                            // 0x0020 (size: 0x10)
    TArray<FPropertyAccessCopyBatch> CopyBatchArray;                                  // 0x0030 (size: 0x10)

}; // Size: 0x78

struct FPropertyAccessPath
{
    int32 PathSegmentStartIndex;                                                      // 0x0000 (size: 0x4)
    int32 PathSegmentCount;                                                           // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FPropertyAccessSegment
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    class UStruct* Struct;                                                            // 0x0008 (size: 0x8)
    TFieldPath<FProperty> Property;                                                   // 0x0010 (size: 0x20)
    class UFunction* Function;                                                        // 0x0030 (size: 0x8)
    int32 ArrayIndex;                                                                 // 0x0038 (size: 0x4)
    uint16 Flags;                                                                     // 0x003C (size: 0x2)

}; // Size: 0x40

struct FPurchaseInfo
{
    FString Identifier;                                                               // 0x0000 (size: 0x10)
    FString DisplayName;                                                              // 0x0010 (size: 0x10)
    FString DisplayDescription;                                                       // 0x0020 (size: 0x10)
    FString DisplayPrice;                                                             // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FQuartzClockSettings
{
    FQuartzTimeSignature TimeSignature;                                               // 0x0000 (size: 0x18)
    bool bIgnoreLevelChange;                                                          // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FQuartzPulseOverrideStep
{
    int32 NumberOfPulses;                                                             // 0x0000 (size: 0x4)
    EQuartzCommandQuantization PulseDuration;                                         // 0x0004 (size: 0x1)

}; // Size: 0x8

struct FQuartzQuantizationBoundary
{
    EQuartzCommandQuantization Quantization;                                          // 0x0000 (size: 0x1)
    float Multiplier;                                                                 // 0x0004 (size: 0x4)
    EQuarztQuantizationReference CountingReferencePoint;                              // 0x0008 (size: 0x1)
    bool bFireOnClockStart;                                                           // 0x0009 (size: 0x1)
    bool bCancelCommandIfClockIsNotRunning;                                           // 0x000A (size: 0x1)
    bool bResetClockOnQueued;                                                         // 0x000B (size: 0x1)
    bool bResumeClockOnQueued;                                                        // 0x000C (size: 0x1)

}; // Size: 0x20

struct FQuartzTimeSignature
{
    int32 NumBeats;                                                                   // 0x0000 (size: 0x4)
    EQuartzTimeSignatureQuantization BeatType;                                        // 0x0004 (size: 0x1)
    TArray<FQuartzPulseOverrideStep> OptionalPulseOverride;                           // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FQuartzTransportTimeStamp
{
    int32 Bars;                                                                       // 0x0000 (size: 0x4)
    int32 Beat;                                                                       // 0x0004 (size: 0x4)
    float BeatFraction;                                                               // 0x0008 (size: 0x4)
    float Seconds;                                                                    // 0x000C (size: 0x4)

}; // Size: 0x10

struct FQuaternionAnimationAttribute
{
    FQuat Value;                                                                      // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FQuaternionSpringState
{
}; // Size: 0x40

struct FRPCAnalyticsThreshold
{
    FName RPC;                                                                        // 0x0000 (size: 0x8)
    int32 CountPerSec;                                                                // 0x0008 (size: 0x4)
    double TimePerSec;                                                                // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FRPCDoSState
{
    bool bLogEscalate;                                                                // 0x0008 (size: 0x1)
    bool bSendEscalateAnalytics;                                                      // 0x0009 (size: 0x1)
    bool bKickPlayer;                                                                 // 0x000A (size: 0x1)
    bool bTrackRecentRPCs;                                                            // 0x000B (size: 0x1)
    int16 EscalateQuotaRPCsPerFrame;                                                  // 0x000C (size: 0x2)
    int16 EscalateTimeQuotaMSPerFrame;                                                // 0x000E (size: 0x2)
    int16 EscalateQuotaRPCsPerPeriod;                                                 // 0x0010 (size: 0x2)
    int16 EscalateTimeQuotaMSPerPeriod;                                               // 0x0012 (size: 0x2)
    int8 EscalateQuotaTimePeriod;                                                     // 0x0014 (size: 0x1)
    int8 EscalationCountTolerance;                                                    // 0x0015 (size: 0x1)
    int16 EscalationTimeToleranceMS;                                                  // 0x0016 (size: 0x2)
    int16 RPCRepeatLimitPerPeriod;                                                    // 0x0018 (size: 0x2)
    int16 RPCRepeatLimitMSPerPeriod;                                                  // 0x001A (size: 0x2)
    int8 RPCRepeatLimitTimePeriod;                                                    // 0x001C (size: 0x1)
    int16 CooloffTime;                                                                // 0x001E (size: 0x2)
    int16 AutoEscalateTime;                                                           // 0x0020 (size: 0x2)

}; // Size: 0x48

struct FRPCDoSStateConfig : public FRPCDoSState
{
}; // Size: 0x78

struct FRadialDamageEvent : public FDamageEvent
{
    FRadialDamageParams Params;                                                       // 0x0010 (size: 0x14)
    FVector Origin;                                                                   // 0x0028 (size: 0x18)
    TArray<FHitResult> ComponentHits;                                                 // 0x0040 (size: 0x10)

}; // Size: 0x50

struct FRadialDamageParams
{
    float BaseDamage;                                                                 // 0x0000 (size: 0x4)
    float MinimumDamage;                                                              // 0x0004 (size: 0x4)
    float InnerRadius;                                                                // 0x0008 (size: 0x4)
    float OuterRadius;                                                                // 0x000C (size: 0x4)
    float DamageFalloff;                                                              // 0x0010 (size: 0x4)

}; // Size: 0x14

struct FRawAnimSequenceTrack
{
    TArray<FVector3f> PosKeys;                                                        // 0x0000 (size: 0x10)
    TArray<FQuat4f> RotKeys;                                                          // 0x0010 (size: 0x10)
    TArray<FVector3f> ScaleKeys;                                                      // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FRawCurveTracks
{
    TArray<FFloatCurve> FloatCurves;                                                  // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FRawDistribution
{
    FDistributionLookupTable Table;                                                   // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FRawDistributionFloat : public FRawDistribution
{
    float MinValue;                                                                   // 0x0020 (size: 0x4)
    float MaxValue;                                                                   // 0x0024 (size: 0x4)
    class UDistributionFloat* Distribution;                                           // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FRawDistributionVector : public FRawDistribution
{
    float MinValue;                                                                   // 0x0020 (size: 0x4)
    float MaxValue;                                                                   // 0x0024 (size: 0x4)
    FVector MinValueVec;                                                              // 0x0028 (size: 0x18)
    FVector MaxValueVec;                                                              // 0x0040 (size: 0x18)
    class UDistributionVector* Distribution;                                          // 0x0058 (size: 0x8)

}; // Size: 0x60

struct FRealCurve : public FIndexedCurve
{
    float DefaultValue;                                                               // 0x0068 (size: 0x4)
    TEnumAsByte<ERichCurveExtrapolation> PreInfinityExtrap;                           // 0x006C (size: 0x1)
    TEnumAsByte<ERichCurveExtrapolation> PostInfinityExtrap;                          // 0x006D (size: 0x1)

}; // Size: 0x70

struct FRedirector
{
    FName OldName;                                                                    // 0x0000 (size: 0x8)
    FName NewName;                                                                    // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FReferencePose
{
    FName PoseName;                                                                   // 0x0000 (size: 0x8)
    TArray<FTransform> ReferencePose;                                                 // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FRepAttachment
{
    class AActor* AttachParent;                                                       // 0x0000 (size: 0x8)
    FVector_NetQuantize100 LocationOffset;                                            // 0x0008 (size: 0x18)
    FVector_NetQuantize100 RelativeScale3D;                                           // 0x0020 (size: 0x18)
    FRotator RotationOffset;                                                          // 0x0038 (size: 0x18)
    FName AttachSocket;                                                               // 0x0050 (size: 0x8)
    class USceneComponent* AttachComponent;                                           // 0x0058 (size: 0x8)

}; // Size: 0x60

struct FRepMovement
{
    FVector LinearVelocity;                                                           // 0x0000 (size: 0x18)
    FVector AngularVelocity;                                                          // 0x0018 (size: 0x18)
    FVector Location;                                                                 // 0x0030 (size: 0x18)
    FRotator Rotation;                                                                // 0x0048 (size: 0x18)
    uint8 bSimulatedPhysicSleep;                                                      // 0x0060 (size: 0x1)
    uint8 bRepPhysics;                                                                // 0x0060 (size: 0x1)
    int32 ServerFrame;                                                                // 0x0064 (size: 0x4)
    int32 ServerPhysicsHandle;                                                        // 0x0068 (size: 0x4)
    EVectorQuantization LocationQuantizationLevel;                                    // 0x006C (size: 0x1)
    EVectorQuantization VelocityQuantizationLevel;                                    // 0x006D (size: 0x1)
    ERotatorQuantization RotationQuantizationLevel;                                   // 0x006E (size: 0x1)

}; // Size: 0x70

struct FRepMovementNetSerializerConfig : public FNetSerializerConfig
{
}; // Size: 0x10

struct FRepRootMotionMontage
{
    bool bIsActive;                                                                   // 0x0000 (size: 0x1)
    class UAnimSequenceBase* Animation;                                               // 0x0008 (size: 0x8)
    float Position;                                                                   // 0x0010 (size: 0x4)
    FVector_NetQuantize100 Location;                                                  // 0x0018 (size: 0x18)
    FRotator Rotation;                                                                // 0x0030 (size: 0x18)
    class UPrimitiveComponent* MovementBase;                                          // 0x0048 (size: 0x8)
    FName MovementBaseBoneName;                                                       // 0x0050 (size: 0x8)
    bool bRelativePosition;                                                           // 0x0058 (size: 0x1)
    bool bRelativeRotation;                                                           // 0x0059 (size: 0x1)
    FRootMotionSourceGroup AuthoritativeRootMotion;                                   // 0x0060 (size: 0x48)
    FVector_NetQuantize10 Acceleration;                                               // 0x00A8 (size: 0x18)
    FVector_NetQuantize10 LinearVelocity;                                             // 0x00C0 (size: 0x18)

}; // Size: 0xD8

struct FReplicatedStaticActorDestructionInfo
{
    UClass* ObjClass;                                                                 // 0x0038 (size: 0x8)

}; // Size: 0x40

struct FResponseChannel
{
    FName Channel;                                                                    // 0x0000 (size: 0x8)
    TEnumAsByte<ECollisionResponse> Response;                                         // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FReverbSettings
{
    bool bApplyReverb;                                                                // 0x0000 (size: 0x1)
    class UReverbEffect* ReverbEffect;                                                // 0x0008 (size: 0x8)
    class USoundEffectSubmixPreset* ReverbPluginEffect;                               // 0x0010 (size: 0x8)
    float Volume;                                                                     // 0x0018 (size: 0x4)
    float FadeTime;                                                                   // 0x001C (size: 0x4)

}; // Size: 0x20

struct FRichCurve : public FRealCurve
{
    TArray<FRichCurveKey> keys;                                                       // 0x0070 (size: 0x10)

}; // Size: 0x80

struct FRichCurveKey
{
    TEnumAsByte<ERichCurveInterpMode> InterpMode;                                     // 0x0000 (size: 0x1)
    TEnumAsByte<ERichCurveTangentMode> TangentMode;                                   // 0x0001 (size: 0x1)
    TEnumAsByte<ERichCurveTangentWeightMode> TangentWeightMode;                       // 0x0002 (size: 0x1)
    float Time;                                                                       // 0x0004 (size: 0x4)
    float Value;                                                                      // 0x0008 (size: 0x4)
    float ArriveTangent;                                                              // 0x000C (size: 0x4)
    float ArriveTangentWeight;                                                        // 0x0010 (size: 0x4)
    float LeaveTangent;                                                               // 0x0014 (size: 0x4)
    float LeaveTangentWeight;                                                         // 0x0018 (size: 0x4)

}; // Size: 0x1C

struct FRigidBodyContactInfo
{
    FVector ContactPosition;                                                          // 0x0000 (size: 0x18)
    FVector ContactNormal;                                                            // 0x0018 (size: 0x18)
    float ContactPenetration;                                                         // 0x0030 (size: 0x4)
    bool bContactProbe;                                                               // 0x0034 (size: 0x1)
    class UPhysicalMaterial* PhysMaterial;                                            // 0x0038 (size: 0x10)

}; // Size: 0x48

struct FRigidBodyErrorCorrection
{
    float PingExtrapolation;                                                          // 0x0000 (size: 0x4)
    float PingLimit;                                                                  // 0x0004 (size: 0x4)
    float ErrorPerLinearDifference;                                                   // 0x0008 (size: 0x4)
    float ErrorPerAngularDifference;                                                  // 0x000C (size: 0x4)
    float MaxRestoredStateError;                                                      // 0x0010 (size: 0x4)
    float MaxLinearHardSnapDistance;                                                  // 0x0014 (size: 0x4)
    float PositionLerp;                                                               // 0x0018 (size: 0x4)
    float AngleLerp;                                                                  // 0x001C (size: 0x4)
    float LinearVelocityCoefficient;                                                  // 0x0020 (size: 0x4)
    float AngularVelocityCoefficient;                                                 // 0x0024 (size: 0x4)
    float ErrorAccumulationSeconds;                                                   // 0x0028 (size: 0x4)
    float ErrorAccumulationDistanceSq;                                                // 0x002C (size: 0x4)
    float ErrorAccumulationSimilarity;                                                // 0x0030 (size: 0x4)

}; // Size: 0x34

struct FRigidBodyState
{
    FVector_NetQuantize100 Position;                                                  // 0x0000 (size: 0x18)
    FQuat Quaternion;                                                                 // 0x0020 (size: 0x20)
    FVector_NetQuantize100 LinVel;                                                    // 0x0040 (size: 0x18)
    FVector_NetQuantize100 AngVel;                                                    // 0x0058 (size: 0x18)
    uint8 Flags;                                                                      // 0x0070 (size: 0x1)

}; // Size: 0x80

struct FRollbackNetStartupActorInfo
{
    class UObject* Archetype;                                                         // 0x0008 (size: 0x8)
    TArray<class UObject*> ObjReferences;                                             // 0x00C0 (size: 0x10)

}; // Size: 0xD0

struct FRootMotionExtractionStep
{
    class UAnimSequence* AnimSequence;                                                // 0x0000 (size: 0x8)
    float StartPosition;                                                              // 0x0008 (size: 0x4)
    float EndPosition;                                                                // 0x000C (size: 0x4)

}; // Size: 0x10

struct FRootMotionFinishVelocitySettings
{
    ERootMotionFinishVelocityMode Mode;                                               // 0x0000 (size: 0x1)
    FVector SetVelocity;                                                              // 0x0008 (size: 0x18)
    float ClampVelocity;                                                              // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FRootMotionMovementParams
{
    bool bHasRootMotion;                                                              // 0x0000 (size: 0x1)
    float BlendWeight;                                                                // 0x0004 (size: 0x4)
    FTransform RootMotionTransform;                                                   // 0x0010 (size: 0x60)

}; // Size: 0x70

struct FRootMotionSource
{
    uint16 Priority;                                                                  // 0x0010 (size: 0x2)
    uint16 LocalID;                                                                   // 0x0012 (size: 0x2)
    ERootMotionAccumulateMode AccumulateMode;                                         // 0x0014 (size: 0x1)
    FName InstanceName;                                                               // 0x0018 (size: 0x8)
    float StartTime;                                                                  // 0x0020 (size: 0x4)
    float CurrentTime;                                                                // 0x0024 (size: 0x4)
    float PreviousTime;                                                               // 0x0028 (size: 0x4)
    float Duration;                                                                   // 0x002C (size: 0x4)
    FRootMotionSourceStatus Status;                                                   // 0x0030 (size: 0x1)
    FRootMotionSourceSettings Settings;                                               // 0x0031 (size: 0x1)
    bool bInLocalSpace;                                                               // 0x0032 (size: 0x1)
    FRootMotionMovementParams RootMotionParams;                                       // 0x0040 (size: 0x70)
    FRootMotionFinishVelocitySettings FinishVelocityParams;                           // 0x00B0 (size: 0x28)

}; // Size: 0xE0

struct FRootMotionSourceGroup
{
    uint8 bHasAdditiveSources;                                                        // 0x0028 (size: 0x1)
    uint8 bHasOverrideSources;                                                        // 0x0028 (size: 0x1)
    uint8 bHasOverrideSourcesWithIgnoreZAccumulate;                                   // 0x0028 (size: 0x1)
    uint8 bIsAdditiveVelocityApplied;                                                 // 0x0028 (size: 0x1)
    FRootMotionSourceSettings LastAccumulatedSettings;                                // 0x0029 (size: 0x1)
    FVector_NetQuantize10 LastPreAdditiveVelocity;                                    // 0x0030 (size: 0x18)

}; // Size: 0x48

struct FRootMotionSourceGroupNetSerializerConfig : public FPolymorphicArrayStructNetSerializerConfig
{
}; // Size: 0x28

struct FRootMotionSourceSettings
{
    uint8 Flags;                                                                      // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FRootMotionSourceStatus
{
    uint8 Flags;                                                                      // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FRootMotionSource_ConstantForce : public FRootMotionSource
{
    FVector Force;                                                                    // 0x00D8 (size: 0x18)
    class UCurveFloat* StrengthOverTime;                                              // 0x00F0 (size: 0x8)

}; // Size: 0x100

struct FRootMotionSource_JumpForce : public FRootMotionSource
{
    FRotator Rotation;                                                                // 0x00D8 (size: 0x18)
    float Distance;                                                                   // 0x00F0 (size: 0x4)
    float Height;                                                                     // 0x00F4 (size: 0x4)
    bool bDisableTimeout;                                                             // 0x00F8 (size: 0x1)
    class UCurveVector* PathOffsetCurve;                                              // 0x0100 (size: 0x8)
    class UCurveFloat* TimeMappingCurve;                                              // 0x0108 (size: 0x8)

}; // Size: 0x130

struct FRootMotionSource_MoveToDynamicForce : public FRootMotionSource
{
    FVector StartLocation;                                                            // 0x00D8 (size: 0x18)
    FVector InitialTargetLocation;                                                    // 0x00F0 (size: 0x18)
    FVector TargetLocation;                                                           // 0x0108 (size: 0x18)
    bool bRestrictSpeedToExpected;                                                    // 0x0120 (size: 0x1)
    class UCurveVector* PathOffsetCurve;                                              // 0x0128 (size: 0x8)
    class UCurveFloat* TimeMappingCurve;                                              // 0x0130 (size: 0x8)

}; // Size: 0x140

struct FRootMotionSource_MoveToForce : public FRootMotionSource
{
    FVector StartLocation;                                                            // 0x00D8 (size: 0x18)
    FVector TargetLocation;                                                           // 0x00F0 (size: 0x18)
    bool bRestrictSpeedToExpected;                                                    // 0x0108 (size: 0x1)
    class UCurveVector* PathOffsetCurve;                                              // 0x0110 (size: 0x8)

}; // Size: 0x120

struct FRootMotionSource_RadialForce : public FRootMotionSource
{
    FVector Location;                                                                 // 0x00D8 (size: 0x18)
    class AActor* LocationActor;                                                      // 0x00F0 (size: 0x8)
    float Radius;                                                                     // 0x00F8 (size: 0x4)
    float Strength;                                                                   // 0x00FC (size: 0x4)
    bool bIsPush;                                                                     // 0x0100 (size: 0x1)
    bool bNoZForce;                                                                   // 0x0101 (size: 0x1)
    class UCurveFloat* StrengthDistanceFalloff;                                       // 0x0108 (size: 0x8)
    class UCurveFloat* StrengthOverTime;                                              // 0x0110 (size: 0x8)
    bool bUseFixedWorldDirection;                                                     // 0x0118 (size: 0x1)
    FRotator FixedWorldDirection;                                                     // 0x0120 (size: 0x18)

}; // Size: 0x140

struct FRotationTrack
{
    TArray<FQuat4f> RotKeys;                                                          // 0x0000 (size: 0x10)
    TArray<float> Times;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FRuntimeCurveLinearColor
{
    FRichCurve ColorCurves;                                                           // 0x0000 (size: 0x200)
    class UCurveLinearColor* ExternalCurve;                                           // 0x0200 (size: 0x8)

}; // Size: 0x208

struct FRuntimeFloatCurve
{
    FRichCurve EditorCurveData;                                                       // 0x0000 (size: 0x80)
    class UCurveFloat* ExternalCurve;                                                 // 0x0080 (size: 0x8)

}; // Size: 0x88

struct FRuntimePartitionDesc
{
}; // Size: 0x1

struct FRuntimePartitionHLODSetup
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    TArray<class UHLODLayer*> HLODLayers;                                             // 0x0008 (size: 0x10)
    bool bIsSpatiallyLoaded;                                                          // 0x0018 (size: 0x1)
    class URuntimePartition* PartitionLayer;                                          // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FRuntimePartitionStreamingData
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    int32 LoadingRange;                                                               // 0x0008 (size: 0x4)
    TArray<class UWorldPartitionRuntimeCell*> StreamingCells;                         // 0x0010 (size: 0x10)
    TArray<class UWorldPartitionRuntimeCell*> NonStreamingCells;                      // 0x0020 (size: 0x10)

}; // Size: 0x38

struct FRuntimeVectorCurve
{
    FRichCurve VectorCurves;                                                          // 0x0000 (size: 0x180)
    class UCurveVector* ExternalCurve;                                                // 0x0180 (size: 0x8)

}; // Size: 0x188

struct FRuntimeVirtualTextureParameterValue
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    class URuntimeVirtualTexture* ParameterValue;                                     // 0x0010 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FScalarMaterialInput : public FMaterialInput
{
    uint8 UseConstant;                                                                // 0x0028 (size: 0x1)
    float Constant;                                                                   // 0x002C (size: 0x4)

}; // Size: 0x30

struct FScalarParameterAtlasInstanceData
{
    bool bIsUsedAsAtlasPosition;                                                      // 0x0000 (size: 0x1)
    TSoftObjectPtr<UCurveLinearColor> Curve;                                          // 0x0008 (size: 0x28)
    TSoftObjectPtr<UCurveLinearColorAtlas> Atlas;                                     // 0x0030 (size: 0x28)

}; // Size: 0x58

struct FScalarParameterValue
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    float ParameterValue;                                                             // 0x0010 (size: 0x4)
    FGuid ExpressionGUID;                                                             // 0x0014 (size: 0x10)

}; // Size: 0x24

struct FScaleTrack
{
    TArray<FVector3f> ScaleKeys;                                                      // 0x0000 (size: 0x10)
    TArray<float> Times;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSceneComponentInstanceData : public FActorComponentInstanceData
{
    TMap<class USceneComponent*, class FTransform> AttachedInstanceComponents;        // 0x0068 (size: 0x50)

}; // Size: 0xB8

struct FSceneViewExtensionIsActiveFunctor
{
}; // Size: 0x50

struct FScreenMessageString
{
    uint64 Key;                                                                       // 0x0000 (size: 0x8)
    FString ScreenMessage;                                                            // 0x0008 (size: 0x10)
    FColor DisplayColor;                                                              // 0x0018 (size: 0x4)
    float TimeToDisplay;                                                              // 0x001C (size: 0x4)
    float CurrentTimeDisplayed;                                                       // 0x0020 (size: 0x4)
    FVector2D TextScale;                                                              // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FSectionReference
{
    int32 SectionIndex;                                                               // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FSelectedFragmentProperties
{
    FName Tag;                                                                        // 0x0000 (size: 0x8)
    FString Fragment;                                                                 // 0x0008 (size: 0x10)
    bool bEnabled;                                                                    // 0x0018 (size: 0x1)

}; // Size: 0x20

struct FSequenceLengthChangedPayload : public FEmptyPayload
{
    float PreviousLength;                                                             // 0x0000 (size: 0x4)
    float T0;                                                                         // 0x0004 (size: 0x4)
    float T1;                                                                         // 0x0008 (size: 0x4)
    FFrameNumber PreviousNumberOfFrames;                                              // 0x000C (size: 0x4)
    FFrameNumber Frame0;                                                              // 0x0010 (size: 0x4)
    FFrameNumber Frame1;                                                              // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FShadingModelMaterialInput : public FMaterialInput
{
}; // Size: 0x28

struct FSimpleCurve : public FRealCurve
{
    TEnumAsByte<ERichCurveInterpMode> InterpMode;                                     // 0x0070 (size: 0x1)
    TArray<FSimpleCurveKey> keys;                                                     // 0x0078 (size: 0x10)

}; // Size: 0x88

struct FSimpleCurveKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    float Value;                                                                      // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSimpleMemberReference
{
    class UObject* MemberParent;                                                      // 0x0000 (size: 0x8)
    FName MemberName;                                                                 // 0x0008 (size: 0x8)
    FGuid MemberGuid;                                                                 // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSimulatedRootMotionReplicatedMove
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    FRepRootMotionMontage RootMotion;                                                 // 0x0008 (size: 0xD8)

}; // Size: 0xE0

struct FSingleAnimationPlayData
{
    class UAnimationAsset* AnimToPlay;                                                // 0x0000 (size: 0x8)
    uint8 bSavedLooping;                                                              // 0x0008 (size: 0x1)
    uint8 bSavedPlaying;                                                              // 0x0008 (size: 0x1)
    float SavedPosition;                                                              // 0x000C (size: 0x4)
    float SavedPlayRate;                                                              // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSkelMeshComponentLODInfo
{
    TArray<bool> HiddenMaterials;                                                     // 0x0000 (size: 0x10)

}; // Size: 0x28

struct FSkelMeshMergeMeshUVTransforms
{
    TArray<FTransform> UVTransforms;                                                  // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSkelMeshMergeSectionMapping
{
    TArray<int32> SectionIDs;                                                         // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSkelMeshMergeUVTransformMapping
{
    TArray<FSkelMeshMergeMeshUVTransforms> UVTransformsPerMesh;                       // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSkelMeshSkinWeightInfo
{
    int32 Bones;                                                                      // 0x0000 (size: 0x30)
    uint8 Weights;                                                                    // 0x0030 (size: 0xC)

}; // Size: 0x3C

struct FSkeletalMaterial
{
    class UMaterialInterface* MaterialInterface;                                      // 0x0000 (size: 0x8)
    FName MaterialSlotName;                                                           // 0x0008 (size: 0x8)
    FMeshUVChannelInfo UVChannelData;                                                 // 0x0010 (size: 0x14)

}; // Size: 0x28

struct FSkeletalMeshBuildSettings
{
    uint8 bRecomputeNormals;                                                          // 0x0000 (size: 0x1)
    uint8 bRecomputeTangents;                                                         // 0x0000 (size: 0x1)
    uint8 bUseMikkTSpace;                                                             // 0x0000 (size: 0x1)
    uint8 bComputeWeightedNormals;                                                    // 0x0000 (size: 0x1)
    uint8 bRemoveDegenerates;                                                         // 0x0000 (size: 0x1)
    uint8 bUseHighPrecisionTangentBasis;                                              // 0x0000 (size: 0x1)
    uint8 bUseHighPrecisionSkinWeights;                                               // 0x0000 (size: 0x1)
    uint8 bUseFullPrecisionUVs;                                                       // 0x0000 (size: 0x1)
    uint8 bUseBackwardsCompatibleF16TruncUVs;                                         // 0x0001 (size: 0x1)
    float ThresholdPosition;                                                          // 0x0004 (size: 0x4)
    float ThresholdTangentNormal;                                                     // 0x0008 (size: 0x4)
    float ThresholdUV;                                                                // 0x000C (size: 0x4)
    float MorphThresholdPosition;                                                     // 0x0010 (size: 0x4)
    int32 BoneInfluenceLimit;                                                         // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSkeletalMeshClothBuildParams
{
    TWeakObjectPtr<class UClothingAssetBase> TargetAsset;                             // 0x0000 (size: 0x8)
    int32 TargetLod;                                                                  // 0x0008 (size: 0x4)
    bool bRemapParameters;                                                            // 0x000C (size: 0x1)
    FString AssetName;                                                                // 0x0010 (size: 0x10)
    int32 LODIndex;                                                                   // 0x0020 (size: 0x4)
    int32 SourceSection;                                                              // 0x0024 (size: 0x4)
    bool bRemoveFromMesh;                                                             // 0x0028 (size: 0x1)
    TSoftObjectPtr<UPhysicsAsset> PhysicsAsset;                                       // 0x0030 (size: 0x28)

}; // Size: 0x58

struct FSkeletalMeshComponentClothTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FSkeletalMeshComponentEndPhysicsTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FSkeletalMeshLODGroupSettings
{
    FPerPlatformFloat ScreenSize;                                                     // 0x0000 (size: 0x4)
    float LODHysteresis;                                                              // 0x0004 (size: 0x4)
    EBoneFilterActionOption BoneFilterActionOption;                                   // 0x0008 (size: 0x1)
    TArray<FBoneFilter> BoneList;                                                     // 0x0010 (size: 0x10)
    TArray<FName> BonesToPrioritize;                                                  // 0x0020 (size: 0x10)
    TArray<int32> SectionsToPrioritize;                                               // 0x0030 (size: 0x10)
    float WeightOfPrioritization;                                                     // 0x0040 (size: 0x4)
    class UAnimSequence* BakePose;                                                    // 0x0048 (size: 0x8)
    FSkeletalMeshOptimizationSettings ReductionSettings;                              // 0x0050 (size: 0x3C)
    bool bAllowMeshDeformer;                                                          // 0x008C (size: 0x1)

}; // Size: 0x90

struct FSkeletalMeshLODInfo
{
    FPerPlatformFloat ScreenSize;                                                     // 0x0000 (size: 0x4)
    float LODHysteresis;                                                              // 0x0004 (size: 0x4)
    TArray<int32> LODMaterialMap;                                                     // 0x0008 (size: 0x10)
    FSkeletalMeshBuildSettings BuildSettings;                                         // 0x0018 (size: 0x18)
    FSkeletalMeshOptimizationSettings ReductionSettings;                              // 0x0030 (size: 0x3C)
    TArray<FBoneReference> BonesToRemove;                                             // 0x0070 (size: 0x10)
    TArray<FBoneReference> BonesToPrioritize;                                         // 0x0080 (size: 0x10)
    TArray<FSectionReference> SectionsToPrioritize;                                   // 0x0090 (size: 0x10)
    float WeightOfPrioritization;                                                     // 0x00A0 (size: 0x4)
    class UAnimSequence* BakePose;                                                    // 0x00A8 (size: 0x8)
    class UAnimSequence* BakePoseOverride;                                            // 0x00B0 (size: 0x8)
    FString SourceImportFilename;                                                     // 0x00B8 (size: 0x10)
    ESkinCacheUsage SkinCacheUsage;                                                   // 0x00C8 (size: 0x1)
    float MorphTargetPositionErrorTolerance;                                          // 0x00CC (size: 0x4)
    uint8 bHasBeenSimplified;                                                         // 0x00D0 (size: 0x1)
    uint8 bHasPerLODVertexColors;                                                     // 0x00D0 (size: 0x1)
    uint8 bAllowCPUAccess;                                                            // 0x00D0 (size: 0x1)
    uint8 bBuildHalfEdgeBuffers;                                                      // 0x00D0 (size: 0x1)
    uint8 bAllowMeshDeformer;                                                         // 0x00D0 (size: 0x1)
    TArray<FSkeletalMeshVertexAttributeInfo> VertexAttributes;                        // 0x00D8 (size: 0x10)
    uint8 bSupportUniformlyDistributedSampling;                                       // 0x00E8 (size: 0x1)

}; // Size: 0xF0

struct FSkeletalMeshOptimizationSettings
{
    TEnumAsByte<SkeletalMeshTerminationCriterion> TerminationCriterion;               // 0x0000 (size: 0x1)
    float NumOfTrianglesPercentage;                                                   // 0x0004 (size: 0x4)
    float NumOfVertPercentage;                                                        // 0x0008 (size: 0x4)
    uint32 MaxNumOfTriangles;                                                         // 0x000C (size: 0x4)
    uint32 MaxNumOfVerts;                                                             // 0x0010 (size: 0x4)
    float MaxDeviationPercentage;                                                     // 0x0014 (size: 0x4)
    TEnumAsByte<SkeletalMeshOptimizationType> ReductionMethod;                        // 0x0018 (size: 0x1)
    TEnumAsByte<SkeletalMeshOptimizationImportance> SilhouetteImportance;             // 0x0019 (size: 0x1)
    TEnumAsByte<SkeletalMeshOptimizationImportance> TextureImportance;                // 0x001A (size: 0x1)
    TEnumAsByte<SkeletalMeshOptimizationImportance> ShadingImportance;                // 0x001B (size: 0x1)
    TEnumAsByte<SkeletalMeshOptimizationImportance> SkinningImportance;               // 0x001C (size: 0x1)
    uint8 bRemapMorphTargets;                                                         // 0x001D (size: 0x1)
    uint8 bRecalcNormals;                                                             // 0x001D (size: 0x1)
    float WeldingThreshold;                                                           // 0x0020 (size: 0x4)
    float NormalsThreshold;                                                           // 0x0024 (size: 0x4)
    int32 MaxBonesPerVertex;                                                          // 0x0028 (size: 0x4)
    uint8 bEnforceBoneBoundaries;                                                     // 0x002C (size: 0x1)
    uint8 bMergeCoincidentVertBones;                                                  // 0x002C (size: 0x1)
    float VolumeImportance;                                                           // 0x0030 (size: 0x4)
    uint8 bLockEdges;                                                                 // 0x0034 (size: 0x1)
    uint8 bLockColorBounaries;                                                        // 0x0034 (size: 0x1)
    uint8 bImproveTrianglesForCloth;                                                  // 0x0034 (size: 0x1)
    int32 BaseLOD;                                                                    // 0x0038 (size: 0x4)

}; // Size: 0x3C

struct FSkeletalMeshSamplingBuiltData
{
    TArray<FSkeletalMeshSamplingLODBuiltData> WholeMeshBuiltData;                     // 0x0000 (size: 0x10)
    TArray<FSkeletalMeshSamplingRegionBuiltData> RegionBuiltData;                     // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSkeletalMeshSamplingInfo
{
    TArray<FSkeletalMeshSamplingRegion> Regions;                                      // 0x0000 (size: 0x10)
    FSkeletalMeshSamplingBuiltData BuiltData;                                         // 0x0010 (size: 0x20)

}; // Size: 0x30

struct FSkeletalMeshSamplingLODBuiltData
{
}; // Size: 0x48

struct FSkeletalMeshSamplingRegion
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    int32 LODIndex;                                                                   // 0x0008 (size: 0x4)
    uint8 bSupportUniformlyDistributedSampling;                                       // 0x000C (size: 0x1)
    TArray<FSkeletalMeshSamplingRegionMaterialFilter> MaterialFilters;                // 0x0010 (size: 0x10)
    TArray<FSkeletalMeshSamplingRegionBoneFilter> BoneFilters;                        // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FSkeletalMeshSamplingRegionBoneFilter
{
    FName BoneName;                                                                   // 0x0000 (size: 0x8)
    uint8 bIncludeOrExclude;                                                          // 0x0008 (size: 0x1)
    uint8 bApplyToChildren;                                                           // 0x0008 (size: 0x1)

}; // Size: 0xC

struct FSkeletalMeshSamplingRegionBuiltData
{
}; // Size: 0x78

struct FSkeletalMeshSamplingRegionMaterialFilter
{
    FName MaterialName;                                                               // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSkeletalMeshSourceModel
{
    int32 TriangleCount;                                                              // 0x0000 (size: 0x4)
    int32 VertexCount;                                                                // 0x0004 (size: 0x4)
    FBoxSphereBounds Bounds;                                                          // 0x0008 (size: 0x38)

}; // Size: 0x40

struct FSkeletalMeshVertexAttributeInfo
{
    FPerPlatformBool EnabledForRender;                                                // 0x0000 (size: 0x1)
    FName Name;                                                                       // 0x0004 (size: 0x8)
    ESkeletalMeshVertexAttributeDataType DataType;                                    // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSkeletonToMeshLinkup
{
    TArray<int32> SkeletonToMeshTable;                                                // 0x0000 (size: 0x10)
    TArray<int32> MeshToSkeletonTable;                                                // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FSkinWeightProfileInfo
{
    FName Name;                                                                       // 0x0000 (size: 0x8)
    FPerPlatformBool DefaultProfile;                                                  // 0x0008 (size: 0x1)
    FPerPlatformInt DefaultProfileFromLODIndex;                                       // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSkinWeightProfileManagerTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FSlateModifierKeysState
{
    uint8 ModifierKeysStateMask;                                                      // 0x0000 (size: 0x1)

}; // Size: 0x1

struct FSlotAnimationTrack
{
    FName SlotName;                                                                   // 0x0000 (size: 0x8)
    FAnimTrack AnimTrack;                                                             // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FSlotEvaluationPose
{
    TEnumAsByte<EAdditiveAnimationType> AdditiveType;                                 // 0x0000 (size: 0x1)
    float Weight;                                                                     // 0x0004 (size: 0x4)

}; // Size: 0x80

struct FSmartName
{
    FName DisplayName;                                                                // 0x0000 (size: 0x8)

}; // Size: 0xC

struct FSmartNameContainer
{
}; // Size: 0x50

struct FSmartNameMapping
{
}; // Size: 0x70

struct FSocketReference
{
    FName SocketName;                                                                 // 0x0060 (size: 0x8)

}; // Size: 0x70

struct FSoftComponentReference : public FBaseComponentReference
{
    TSoftObjectPtr<AActor> OtherActor;                                                // 0x0020 (size: 0x28)

}; // Size: 0x48

struct FSoftISMComponentDescriptor : public FISMComponentDescriptorBase
{
    TSoftObjectPtr<UStaticMesh> StaticMesh;                                           // 0x01E8 (size: 0x28)
    TArray<TSoftObjectPtr<UMaterialInterface>> OverrideMaterials;                     // 0x0210 (size: 0x10)
    TSoftObjectPtr<UMaterialInterface> OverlayMaterial;                               // 0x0220 (size: 0x28)
    TArray<TSoftObjectPtr<URuntimeVirtualTexture>> RuntimeVirtualTextures;            // 0x0248 (size: 0x10)

}; // Size: 0x258

struct FSoftWorldReference
{
    TSoftObjectPtr<UWorld> WorldAsset;                                                // 0x0000 (size: 0x28)

}; // Size: 0x28

struct FSolverIterations
{
    int32 SolverIterations;                                                           // 0x0000 (size: 0x4)
    int32 JointIterations;                                                            // 0x0004 (size: 0x4)
    int32 CollisionIterations;                                                        // 0x0008 (size: 0x4)
    int32 SolverPushOutIterations;                                                    // 0x000C (size: 0x4)
    int32 JointPushOutIterations;                                                     // 0x0010 (size: 0x4)
    int32 CollisionPushOutIterations;                                                 // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FSoundAttenuationPluginSettings
{
    TArray<class USpatializationPluginSourceSettingsBase*> SpatializationPluginSettingsArray; // 0x0000 (size: 0x10)
    TArray<class UOcclusionPluginSourceSettingsBase*> OcclusionPluginSettingsArray;   // 0x0010 (size: 0x10)
    TArray<class UReverbPluginSourceSettingsBase*> ReverbPluginSettingsArray;         // 0x0020 (size: 0x10)
    TArray<class USourceDataOverridePluginSourceSettingsBase*> SourceDataOverridePluginSettingsArray; // 0x0030 (size: 0x10)

}; // Size: 0x40

struct FSoundAttenuationSettings : public FBaseAttenuationSettings
{
    uint8 bAttenuate;                                                                 // 0x00C0 (size: 0x1)
    uint8 bSpatialize;                                                                // 0x00C0 (size: 0x1)
    uint8 bAttenuateWithLPF;                                                          // 0x00C0 (size: 0x1)
    uint8 bEnableListenerFocus;                                                       // 0x00C0 (size: 0x1)
    uint8 bEnableFocusInterpolation;                                                  // 0x00C0 (size: 0x1)
    uint8 bEnableOcclusion;                                                           // 0x00C0 (size: 0x1)
    uint8 bUseComplexCollisionForOcclusion;                                           // 0x00C0 (size: 0x1)
    uint8 bEnableReverbSend;                                                          // 0x00C0 (size: 0x1)
    uint8 bEnablePriorityAttenuation;                                                 // 0x00C1 (size: 0x1)
    uint8 bApplyNormalizationToStereoSounds;                                          // 0x00C1 (size: 0x1)
    uint8 bEnableLogFrequencyScaling;                                                 // 0x00C1 (size: 0x1)
    uint8 bEnableSubmixSends;                                                         // 0x00C1 (size: 0x1)
    uint8 bEnableSourceDataOverride;                                                  // 0x00C1 (size: 0x1)
    uint8 bEnableSendToAudioLink;                                                     // 0x00C1 (size: 0x1)
    TEnumAsByte<ESoundSpatializationAlgorithm> SpatializationAlgorithm;               // 0x00C2 (size: 0x1)
    class UAudioLinkSettingsAbstract* AudioLinkSettingsOverride;                      // 0x00C8 (size: 0x8)
    float BinauralRadius;                                                             // 0x00D0 (size: 0x4)
    FRuntimeFloatCurve CustomLowpassAirAbsorptionCurve;                               // 0x00D8 (size: 0x88)
    FRuntimeFloatCurve CustomHighpassAirAbsorptionCurve;                              // 0x0160 (size: 0x88)
    EAirAbsorptionMethod AbsorptionMethod;                                            // 0x01E8 (size: 0x1)
    TEnumAsByte<ECollisionChannel> OcclusionTraceChannel;                             // 0x01E9 (size: 0x1)
    EReverbSendMethod ReverbSendMethod;                                               // 0x01EA (size: 0x1)
    EPriorityAttenuationMethod PriorityAttenuationMethod;                             // 0x01EB (size: 0x1)
    float NonSpatializedRadiusStart;                                                  // 0x01EC (size: 0x4)
    float NonSpatializedRadiusEnd;                                                    // 0x01F0 (size: 0x4)
    ENonSpatializedRadiusSpeakerMapMode NonSpatializedRadiusMode;                     // 0x01F4 (size: 0x1)
    float StereoSpread;                                                               // 0x01F8 (size: 0x4)
    float LPFRadiusMin;                                                               // 0x01FC (size: 0x4)
    float LPFRadiusMax;                                                               // 0x0200 (size: 0x4)
    float LPFFrequencyAtMin;                                                          // 0x0204 (size: 0x4)
    float LPFFrequencyAtMax;                                                          // 0x0208 (size: 0x4)
    float HPFFrequencyAtMin;                                                          // 0x020C (size: 0x4)
    float HPFFrequencyAtMax;                                                          // 0x0210 (size: 0x4)
    float FocusAzimuth;                                                               // 0x0214 (size: 0x4)
    float NonFocusAzimuth;                                                            // 0x0218 (size: 0x4)
    float FocusDistanceScale;                                                         // 0x021C (size: 0x4)
    float NonFocusDistanceScale;                                                      // 0x0220 (size: 0x4)
    float FocusPriorityScale;                                                         // 0x0224 (size: 0x4)
    float NonFocusPriorityScale;                                                      // 0x0228 (size: 0x4)
    float FocusVolumeAttenuation;                                                     // 0x022C (size: 0x4)
    float NonFocusVolumeAttenuation;                                                  // 0x0230 (size: 0x4)
    float FocusAttackInterpSpeed;                                                     // 0x0234 (size: 0x4)
    float FocusReleaseInterpSpeed;                                                    // 0x0238 (size: 0x4)
    float OcclusionLowPassFilterFrequency;                                            // 0x023C (size: 0x4)
    float OcclusionVolumeAttenuation;                                                 // 0x0240 (size: 0x4)
    float OcclusionInterpolationTime;                                                 // 0x0244 (size: 0x4)
    float ReverbWetLevelMin;                                                          // 0x0248 (size: 0x4)
    float ReverbWetLevelMax;                                                          // 0x024C (size: 0x4)
    float ReverbDistanceMin;                                                          // 0x0250 (size: 0x4)
    float ReverbDistanceMax;                                                          // 0x0254 (size: 0x4)
    float ManualReverbSendLevel;                                                      // 0x0258 (size: 0x4)
    float PriorityAttenuationMin;                                                     // 0x025C (size: 0x4)
    float PriorityAttenuationMax;                                                     // 0x0260 (size: 0x4)
    float PriorityAttenuationDistanceMin;                                             // 0x0264 (size: 0x4)
    float PriorityAttenuationDistanceMax;                                             // 0x0268 (size: 0x4)
    float ManualPriorityAttenuation;                                                  // 0x026C (size: 0x4)
    FRuntimeFloatCurve CustomReverbSendCurve;                                         // 0x0270 (size: 0x88)
    TArray<FAttenuationSubmixSendSettings> SubmixSendSettings;                        // 0x02F8 (size: 0x10)
    FRuntimeFloatCurve CustomPriorityAttenuationCurve;                                // 0x0308 (size: 0x88)
    FSoundAttenuationPluginSettings PluginSettings;                                   // 0x0390 (size: 0x40)

}; // Size: 0x3D0

struct FSoundClassAdjuster
{
    class USoundClass* SoundClassObject;                                              // 0x0000 (size: 0x8)
    float VolumeAdjuster;                                                             // 0x0008 (size: 0x4)
    float PitchAdjuster;                                                              // 0x000C (size: 0x4)
    float LowPassFilterFrequency;                                                     // 0x0010 (size: 0x4)
    uint8 bApplyToChildren;                                                           // 0x0014 (size: 0x1)
    float VoiceCenterChannelVolumeAdjuster;                                           // 0x0018 (size: 0x4)

}; // Size: 0x20

struct FSoundClassEditorData
{
}; // Size: 0x8

struct FSoundClassProperties
{
    float Volume;                                                                     // 0x0000 (size: 0x4)
    float Pitch;                                                                      // 0x0004 (size: 0x4)
    float LowPassFilterFrequency;                                                     // 0x0008 (size: 0x4)
    float AttenuationDistanceScale;                                                   // 0x000C (size: 0x4)
    float LFEBleed;                                                                   // 0x0010 (size: 0x4)
    float VoiceCenterChannelVolume;                                                   // 0x0014 (size: 0x4)
    float RadioFilterVolume;                                                          // 0x0018 (size: 0x4)
    float RadioFilterVolumeThreshold;                                                 // 0x001C (size: 0x4)
    uint8 bApplyEffects;                                                              // 0x0020 (size: 0x1)
    uint8 bAlwaysPlay;                                                                // 0x0020 (size: 0x1)
    uint8 bIsUISound;                                                                 // 0x0020 (size: 0x1)
    uint8 bIsMusic;                                                                   // 0x0020 (size: 0x1)
    uint8 bCenterChannelOnly;                                                         // 0x0020 (size: 0x1)
    uint8 bApplyAmbientVolumes;                                                       // 0x0020 (size: 0x1)
    uint8 bReverb;                                                                    // 0x0020 (size: 0x1)
    float Default2DReverbSendAmount;                                                  // 0x0024 (size: 0x4)
    FSoundModulationDefaultSettings ModulationSettings;                               // 0x0028 (size: 0x160)
    TEnumAsByte<EAudioOutputTarget::Type> OutputTarget;                               // 0x0188 (size: 0x1)
    ESoundWaveLoadingBehavior LoadingBehavior;                                        // 0x0189 (size: 0x1)
    class USoundSubmix* DefaultSubmix;                                                // 0x0190 (size: 0x8)

}; // Size: 0x198

struct FSoundConcurrencySettings
{
    int32 MaxCount;                                                                   // 0x0000 (size: 0x4)
    uint8 bLimitToOwner;                                                              // 0x0004 (size: 0x1)
    uint8 bVolumeScaleCanRelease;                                                     // 0x0004 (size: 0x1)
    TEnumAsByte<EMaxConcurrentResolutionRule::Type> ResolutionRule;                   // 0x0005 (size: 0x1)
    float RetriggerTime;                                                              // 0x0008 (size: 0x4)
    float VolumeScale;                                                                // 0x000C (size: 0x4)
    EConcurrencyVolumeScaleMode VolumeScaleMode;                                      // 0x0010 (size: 0x4)
    float VolumeScaleAttackTime;                                                      // 0x0014 (size: 0x4)
    float VolumeScaleReleaseTime;                                                     // 0x0018 (size: 0x4)
    float VoiceStealReleaseTime;                                                      // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSoundDebugEntry
{
    FName DebugName;                                                                  // 0x0000 (size: 0x8)
    FSoftObjectPath Sound;                                                            // 0x0008 (size: 0x20)

}; // Size: 0x28

struct FSoundGroup
{
    TEnumAsByte<ESoundGroup> SoundGroup;                                              // 0x0000 (size: 0x1)
    FString DisplayName;                                                              // 0x0008 (size: 0x10)
    uint8 bAlwaysDecompressOnLoad;                                                    // 0x0018 (size: 0x1)
    float DecompressedDuration;                                                       // 0x001C (size: 0x4)

}; // Size: 0x20

struct FSoundModulationDefaultRoutingSettings : public FSoundModulationDefaultSettings
{
    EModulationRouting VolumeRouting;                                                 // 0x0160 (size: 0x1)
    EModulationRouting PitchRouting;                                                  // 0x0161 (size: 0x1)
    EModulationRouting HighpassRouting;                                               // 0x0162 (size: 0x1)
    EModulationRouting LowpassRouting;                                                // 0x0163 (size: 0x1)

}; // Size: 0x168

struct FSoundModulationDefaultSettings
{
    FSoundModulationDestinationSettings VolumeModulationDestination;                  // 0x0000 (size: 0x58)
    FSoundModulationDestinationSettings PitchModulationDestination;                   // 0x0058 (size: 0x58)
    FSoundModulationDestinationSettings HighpassModulationDestination;                // 0x00B0 (size: 0x58)
    FSoundModulationDestinationSettings LowpassModulationDestination;                 // 0x0108 (size: 0x58)

}; // Size: 0x160

struct FSoundModulationDestinationSettings
{
    float Value;                                                                      // 0x0000 (size: 0x4)
    TSet<USoundModulatorBase*> Modulators;                                            // 0x0008 (size: 0x50)

}; // Size: 0x58

struct FSoundNodeEditorData
{
}; // Size: 0x8

struct FSoundSourceBusSendInfo
{
    ESourceBusSendLevelControlMethod SourceBusSendLevelControlMethod;                 // 0x0000 (size: 0x1)
    class USoundSourceBus* SoundSourceBus;                                            // 0x0008 (size: 0x8)
    class UAudioBus* AudioBus;                                                        // 0x0010 (size: 0x8)
    float SendLevel;                                                                  // 0x0018 (size: 0x4)
    float MinSendLevel;                                                               // 0x001C (size: 0x4)
    float MaxSendLevel;                                                               // 0x0020 (size: 0x4)
    float MinSendDistance;                                                            // 0x0024 (size: 0x4)
    float MaxSendDistance;                                                            // 0x0028 (size: 0x4)
    FRuntimeFloatCurve CustomSendLevelCurve;                                          // 0x0030 (size: 0x88)

}; // Size: 0xB8

struct FSoundSubmixSendInfo : public FSoundSubmixSendInfoBase
{
    ESubmixSendStage SendStage;                                                       // 0x00B0 (size: 0x1)

}; // Size: 0xB8

struct FSoundSubmixSendInfoBase
{
    ESendLevelControlMethod SendLevelControlMethod;                                   // 0x0000 (size: 0x1)
    class USoundSubmixBase* SoundSubmix;                                              // 0x0008 (size: 0x8)
    float SendLevel;                                                                  // 0x0010 (size: 0x4)
    bool DisableManualSendClamp;                                                      // 0x0014 (size: 0x1)
    float MinSendLevel;                                                               // 0x0018 (size: 0x4)
    float MaxSendLevel;                                                               // 0x001C (size: 0x4)
    float MinSendDistance;                                                            // 0x0020 (size: 0x4)
    float MaxSendDistance;                                                            // 0x0024 (size: 0x4)
    FRuntimeFloatCurve CustomSendLevelCurve;                                          // 0x0028 (size: 0x88)

}; // Size: 0xB0

struct FSoundSubmixSpectralAnalysisBandSettings
{
    float BandFrequency;                                                              // 0x0000 (size: 0x4)
    int32 AttackTimeMsec;                                                             // 0x0004 (size: 0x4)
    int32 ReleaseTimeMsec;                                                            // 0x0008 (size: 0x4)
    float QFactor;                                                                    // 0x000C (size: 0x4)

}; // Size: 0x10

struct FSoundTimecodeOffset
{
    double NumOfSecondsSinceMidnight;                                                 // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FSoundWaveCuePoint
{
    int32 CuePointID;                                                                 // 0x0000 (size: 0x4)
    FString Label;                                                                    // 0x0008 (size: 0x10)
    int32 FramePosition;                                                              // 0x0018 (size: 0x4)
    int32 FrameLength;                                                                // 0x001C (size: 0x4)
    bool bIsLoopRegion;                                                               // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FSoundWaveEnvelopeDataPerSound
{
    float Envelope;                                                                   // 0x0000 (size: 0x4)
    float PlaybackTime;                                                               // 0x0004 (size: 0x4)
    class USoundWave* SoundWave;                                                      // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSoundWaveEnvelopeTimeData
{
    float Amplitude;                                                                  // 0x0000 (size: 0x4)
    float TimeSec;                                                                    // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSoundWaveSpectralData
{
    float FrequencyHz;                                                                // 0x0000 (size: 0x4)
    float Magnitude;                                                                  // 0x0004 (size: 0x4)
    float NormalizedMagnitude;                                                        // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FSoundWaveSpectralDataEntry
{
    float Magnitude;                                                                  // 0x0000 (size: 0x4)
    float NormalizedMagnitude;                                                        // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FSoundWaveSpectralDataPerSound
{
    TArray<FSoundWaveSpectralData> SpectralData;                                      // 0x0000 (size: 0x10)
    float PlaybackTime;                                                               // 0x0010 (size: 0x4)
    class USoundWave* SoundWave;                                                      // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FSoundWaveSpectralTimeData
{
    TArray<FSoundWaveSpectralDataEntry> Data;                                         // 0x0000 (size: 0x10)
    float TimeSec;                                                                    // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSoundWaveTimecodeInfo
{
    uint64 NumSamplesSinceMidnight;                                                   // 0x0000 (size: 0x8)
    uint32 NumSamplesPerSecond;                                                       // 0x0008 (size: 0x4)
    FString Description;                                                              // 0x0010 (size: 0x10)
    FString OriginatorTime;                                                           // 0x0020 (size: 0x10)
    FString OriginatorDate;                                                           // 0x0030 (size: 0x10)
    FString OriginatorDescription;                                                    // 0x0040 (size: 0x10)
    FString OriginatorReference;                                                      // 0x0050 (size: 0x10)
    FFrameRate TimecodeRate;                                                          // 0x0060 (size: 0x8)
    bool bTimecodeIsDropFrame;                                                        // 0x0068 (size: 0x1)

}; // Size: 0x70

struct FSourceEffectChainEntry
{
    class USoundEffectSourcePreset* Preset;                                           // 0x0000 (size: 0x8)
    uint8 bBypass;                                                                    // 0x0008 (size: 0x1)

}; // Size: 0x10

struct FSparseVolumeTextureParameterValue
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    class USparseVolumeTexture* ParameterValue;                                       // 0x0010 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FSpatialHashRuntimeGrid
{
}; // Size: 0x1

struct FSpatialHashSettings
{
    bool bUseAlignedGridLevels;                                                       // 0x0000 (size: 0x1)
    bool bSnapNonAlignedGridLevelsToLowerLevels;                                      // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FSpatialHashStreamingGrid
{
    FName GridName;                                                                   // 0x0000 (size: 0x8)
    FVector Origin;                                                                   // 0x0008 (size: 0x18)
    int32 CellSize;                                                                   // 0x0020 (size: 0x4)
    float LoadingRange;                                                               // 0x0024 (size: 0x4)
    bool bBlockOnSlowStreaming;                                                       // 0x0028 (size: 0x1)
    FLinearColor DebugColor;                                                          // 0x002C (size: 0x10)
    TArray<FSpatialHashStreamingGridLevel> GridLevels;                                // 0x0040 (size: 0x10)
    FBox WorldBounds;                                                                 // 0x0050 (size: 0x38)
    bool bClientOnlyVisible;                                                          // 0x0088 (size: 0x1)
    class UHLODLayer* HLODLayer;                                                      // 0x0090 (size: 0x8)
    int32 GridIndex;                                                                  // 0x0098 (size: 0x4)
    FSpatialHashSettings Settings;                                                    // 0x009C (size: 0x2)
    TArray<FSpatialHashStreamingGridLevel> InjectedGridLevels;                        // 0x00A8 (size: 0x10)

}; // Size: 0xB8

struct FSpatialHashStreamingGridLayerCell
{
    TArray<class UWorldPartitionRuntimeCell*> GridCells;                              // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FSpatialHashStreamingGridLevel
{
    TArray<FSpatialHashStreamingGridLayerCell> LayerCells;                            // 0x0000 (size: 0x10)
    TMap<int64, int32> LayerCellsMapping;                                             // 0x0010 (size: 0x50)

}; // Size: 0x60

struct FSpecularProfileStruct
{
    ESpecularProfileFormat Format;                                                    // 0x0000 (size: 0x1)
    FRuntimeCurveLinearColor ViewColor;                                               // 0x0008 (size: 0x208)
    FRuntimeCurveLinearColor LightColor;                                              // 0x0210 (size: 0x208)
    class UTexture2D* Texture;                                                        // 0x0418 (size: 0x8)

}; // Size: 0x420

struct FSplineCurves
{
    FInterpCurveVector Position;                                                      // 0x0000 (size: 0x18)
    FInterpCurveQuat Rotation;                                                        // 0x0018 (size: 0x18)
    FInterpCurveVector Scale;                                                         // 0x0030 (size: 0x18)
    FInterpCurveFloat ReparamTable;                                                   // 0x0048 (size: 0x18)
    class USplineMetadata* MetaData;                                                  // 0x0060 (size: 0x8)
    uint32 Version;                                                                   // 0x0068 (size: 0x4)

}; // Size: 0x70

struct FSplineInstanceData : public FSceneComponentInstanceData
{
    bool bSplineHasBeenEdited;                                                        // 0x00B8 (size: 0x1)
    FSplineCurves SplineCurves;                                                       // 0x00C0 (size: 0x70)
    FSplineCurves SplineCurvesPreUCS;                                                 // 0x0130 (size: 0x70)

}; // Size: 0x1A0

struct FSplineMeshInstanceData : public FStaticMeshComponentInstanceData
{
    FVector StartPos;                                                                 // 0x0168 (size: 0x18)
    FVector EndPos;                                                                   // 0x0180 (size: 0x18)
    FVector StartTangent;                                                             // 0x0198 (size: 0x18)
    FVector EndTangent;                                                               // 0x01B0 (size: 0x18)

}; // Size: 0x1D0

struct FSplineMeshParams
{
    FVector StartPos;                                                                 // 0x0000 (size: 0x18)
    FVector StartTangent;                                                             // 0x0018 (size: 0x18)
    FVector2D StartScale;                                                             // 0x0030 (size: 0x10)
    float StartRoll;                                                                  // 0x0040 (size: 0x4)
    FVector2D StartOffset;                                                            // 0x0048 (size: 0x10)
    FVector EndPos;                                                                   // 0x0058 (size: 0x18)
    FVector2D EndScale;                                                               // 0x0070 (size: 0x10)
    FVector EndTangent;                                                               // 0x0080 (size: 0x18)
    float EndRoll;                                                                    // 0x0098 (size: 0x4)
    FVector2D EndOffset;                                                              // 0x00A0 (size: 0x10)
    float NaniteClusterBoundsScale;                                                   // 0x00B0 (size: 0x4)

}; // Size: 0xB8

struct FSplinePoint
{
    float InputKey;                                                                   // 0x0000 (size: 0x4)
    FVector Position;                                                                 // 0x0008 (size: 0x18)
    FVector ArriveTangent;                                                            // 0x0020 (size: 0x18)
    FVector LeaveTangent;                                                             // 0x0038 (size: 0x18)
    FRotator Rotation;                                                                // 0x0050 (size: 0x18)
    FVector Scale;                                                                    // 0x0068 (size: 0x18)
    TEnumAsByte<ESplinePointType::Type> Type;                                         // 0x0080 (size: 0x1)

}; // Size: 0x88

struct FSpriteCategoryInfo
{
    FName Category;                                                                   // 0x0000 (size: 0x8)
    FText DisplayName;                                                                // 0x0008 (size: 0x10)
    FText Description;                                                                // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FStartPhysicsTickFunction : public FTickFunction
{
}; // Size: 0x30

struct FStatColorMapEntry
{
    float In;                                                                         // 0x0000 (size: 0x4)
    FColor Out;                                                                       // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FStatColorMapping
{
    FString StatName;                                                                 // 0x0000 (size: 0x10)
    TArray<FStatColorMapEntry> ColorMap;                                              // 0x0010 (size: 0x10)
    uint8 DisableBlend;                                                               // 0x0020 (size: 0x1)

}; // Size: 0x28

struct FStateMachineDebugData
{
}; // Size: 0x150

struct FStateMachineStateDebugData
{
}; // Size: 0x10

struct FStaticComponentMaskParameter : public FStaticParameterBase
{
    bool R;                                                                           // 0x0024 (size: 0x1)
    bool G;                                                                           // 0x0025 (size: 0x1)
    bool B;                                                                           // 0x0026 (size: 0x1)
    bool A;                                                                           // 0x0027 (size: 0x1)

}; // Size: 0x28

struct FStaticComponentMaskValue
{
    bool R;                                                                           // 0x0000 (size: 0x1)
    bool G;                                                                           // 0x0001 (size: 0x1)
    bool B;                                                                           // 0x0002 (size: 0x1)
    bool A;                                                                           // 0x0003 (size: 0x1)

}; // Size: 0x4

struct FStaticMaterial
{
    class UMaterialInterface* MaterialInterface;                                      // 0x0000 (size: 0x8)
    FName MaterialSlotName;                                                           // 0x0008 (size: 0x8)
    FName ImportedMaterialSlotName;                                                   // 0x0010 (size: 0x8)
    FMeshUVChannelInfo UVChannelData;                                                 // 0x0018 (size: 0x14)

}; // Size: 0x30

struct FStaticMaterialLayersParameter : public FStaticParameterBase
{
    FMaterialLayersFunctions Value;                                                   // 0x0028 (size: 0x100)

}; // Size: 0x128

struct FStaticMeshBudgetInfo
{
    FName LodGroupName;                                                               // 0x0000 (size: 0x8)
    double MinimumExtent;                                                             // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FStaticMeshComponentInstanceData : public FPrimitiveComponentInstanceData
{
    class UStaticMesh* StaticMesh;                                                    // 0x0130 (size: 0x8)
    TArray<FStaticMeshVertexColorLODData> VertexColorLODs;                            // 0x0138 (size: 0x10)
    TArray<FGuid> CachedStaticLighting;                                               // 0x0148 (size: 0x10)
    TArray<FStreamingTextureBuildInfo> StreamingTextureData;                          // 0x0158 (size: 0x10)

}; // Size: 0x170

struct FStaticMeshComponentLODInfo
{
}; // Size: 0x90

struct FStaticMeshOptimizationSettings
{
    TEnumAsByte<EOptimizationType> ReductionMethod;                                   // 0x0000 (size: 0x1)
    float NumOfTrianglesPercentage;                                                   // 0x0004 (size: 0x4)
    float MaxDeviationPercentage;                                                     // 0x0008 (size: 0x4)
    float WeldingThreshold;                                                           // 0x000C (size: 0x4)
    bool bRecalcNormals;                                                              // 0x0010 (size: 0x1)
    float NormalsThreshold;                                                           // 0x0014 (size: 0x4)
    uint8 SilhouetteImportance;                                                       // 0x0018 (size: 0x1)
    uint8 TextureImportance;                                                          // 0x0019 (size: 0x1)
    uint8 ShadingImportance;                                                          // 0x001A (size: 0x1)

}; // Size: 0x1C

struct FStaticMeshSourceModel
{
    FMeshBuildSettings BuildSettings;                                                 // 0x0000 (size: 0x48)
    FMeshReductionSettings ReductionSettings;                                         // 0x0048 (size: 0x2C)
    uint32 CacheMeshDescriptionTrianglesCount;                                        // 0x0074 (size: 0x4)
    uint32 CacheMeshDescriptionVerticesCount;                                         // 0x0078 (size: 0x4)
    float LODDistance;                                                                // 0x007C (size: 0x4)
    FPerPlatformFloat ScreenSize;                                                     // 0x0080 (size: 0x4)
    FString SourceImportFilename;                                                     // 0x0088 (size: 0x10)

}; // Size: 0x98

struct FStaticMeshVertexColorLODData
{
    TArray<FPaintedVertex> PaintedVertices;                                           // 0x0000 (size: 0x10)
    TArray<FColor> VertexBufferColors;                                                // 0x0010 (size: 0x10)
    uint32 LODIndex;                                                                  // 0x0020 (size: 0x4)

}; // Size: 0x28

struct FStaticParameterBase
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    bool bOverride;                                                                   // 0x0010 (size: 0x1)
    FGuid ExpressionGUID;                                                             // 0x0014 (size: 0x10)

}; // Size: 0x24

struct FStaticParameterSet : public FStaticParameterSetRuntimeData
{
}; // Size: 0x38

struct FStaticParameterSetEditorOnlyData
{
    TArray<FStaticSwitchParameter> StaticSwitchParameters;                            // 0x0000 (size: 0x10)
    TArray<FStaticComponentMaskParameter> StaticComponentMaskParameters;              // 0x0010 (size: 0x10)
    TArray<FStaticTerrainLayerWeightParameter> TerrainLayerWeightParameters;          // 0x0020 (size: 0x10)
    FMaterialLayersFunctionsEditorOnlyData MaterialLayers;                            // 0x0030 (size: 0x70)

}; // Size: 0xA0

struct FStaticParameterSetRuntimeData
{
    TArray<FStaticSwitchParameter> StaticSwitchParameters;                            // 0x0000 (size: 0x10)
    FMaterialLayersFunctionsRuntimeData MaterialLayers;                               // 0x0010 (size: 0x20)
    uint8 bHasMaterialLayers;                                                         // 0x0030 (size: 0x1)

}; // Size: 0x38

struct FStaticSwitchParameter : public FStaticParameterBase
{
    bool Value;                                                                       // 0x0024 (size: 0x1)

}; // Size: 0x28

struct FStaticTerrainLayerWeightParameter
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    FGuid ExpressionGUID;                                                             // 0x0010 (size: 0x10)
    bool bOverride;                                                                   // 0x0020 (size: 0x1)
    FName LayerName;                                                                  // 0x0024 (size: 0x8)
    int32 WeightmapIndex;                                                             // 0x002C (size: 0x4)
    bool bIsRepeatedLayer;                                                            // 0x0030 (size: 0x1)
    bool bWeightBasedBlend;                                                           // 0x0031 (size: 0x1)

}; // Size: 0x34

struct FStreamableTexture
{
}; // Size: 0x1

struct FStreamableTextureInstance
{
}; // Size: 0x48

struct FStreamedAudioPlatformData
{
}; // Size: 0x18

struct FStreamingLevelsToConsider
{
    TArray<class ULevelStreaming*> StreamingLevels;                                   // 0x0000 (size: 0x10)

}; // Size: 0x28

struct FStreamingRenderAssetPrimitiveInfo
{
    class UStreamableRenderAsset* RenderAsset;                                        // 0x0000 (size: 0x8)
    FBoxSphereBounds Bounds;                                                          // 0x0008 (size: 0x38)
    float TexelFactor;                                                                // 0x0040 (size: 0x4)
    uint32 PackedRelativeBox;                                                         // 0x0044 (size: 0x4)
    uint8 bAllowInvalidTexelFactorWhenUnregistered;                                   // 0x0048 (size: 0x1)
    uint8 bAffectedByComponentScale;                                                  // 0x0048 (size: 0x1)

}; // Size: 0x50

struct FStreamingSourceShape
{
    bool bUseGridLoadingRange;                                                        // 0x0000 (size: 0x1)
    float LoadingRangeScale;                                                          // 0x0004 (size: 0x4)
    float Radius;                                                                     // 0x0008 (size: 0x4)
    bool bIsSector;                                                                   // 0x000C (size: 0x1)
    float SectorAngle;                                                                // 0x0010 (size: 0x4)
    FVector Location;                                                                 // 0x0018 (size: 0x18)
    FRotator Rotation;                                                                // 0x0030 (size: 0x18)

}; // Size: 0x48

struct FStreamingTextureBuildInfo
{
    uint32 PackedRelativeBox;                                                         // 0x0000 (size: 0x4)
    int32 TextureLevelIndex;                                                          // 0x0004 (size: 0x4)
    float TexelFactor;                                                                // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FStringAnimationAttribute
{
    FString Value;                                                                    // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FStringCurve : public FIndexedCurve
{
    FString DefaultValue;                                                             // 0x0068 (size: 0x10)
    TArray<FStringCurveKey> keys;                                                     // 0x0078 (size: 0x10)

}; // Size: 0x88

struct FStringCurveKey
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    FString Value;                                                                    // 0x0008 (size: 0x10)

}; // Size: 0x18

struct FStructRedirect
{
    FName OldStructName;                                                              // 0x0000 (size: 0x8)
    FName NewStructName;                                                              // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FSubstrateMaterialInput : public FMaterialInput
{
}; // Size: 0x28

struct FSubsurfaceProfileStruct
{
    FLinearColor SurfaceAlbedo;                                                       // 0x0000 (size: 0x10)
    FLinearColor MeanFreePathColor;                                                   // 0x0010 (size: 0x10)
    float MeanFreePathDistance;                                                       // 0x0020 (size: 0x4)
    float WorldUnitScale;                                                             // 0x0024 (size: 0x4)
    bool bEnableBurley;                                                               // 0x0028 (size: 0x1)
    bool bEnableMeanFreePath;                                                         // 0x0029 (size: 0x1)
    FLinearColor Tint;                                                                // 0x002C (size: 0x10)
    float ScatterRadius;                                                              // 0x003C (size: 0x4)
    FLinearColor SubsurfaceColor;                                                     // 0x0040 (size: 0x10)
    FLinearColor FalloffColor;                                                        // 0x0050 (size: 0x10)
    FLinearColor BoundaryColorBleed;                                                  // 0x0060 (size: 0x10)
    float ExtinctionScale;                                                            // 0x0070 (size: 0x4)
    float NormalScale;                                                                // 0x0074 (size: 0x4)
    float ScatteringDistribution;                                                     // 0x0078 (size: 0x4)
    float IOR;                                                                        // 0x007C (size: 0x4)
    float Roughness0;                                                                 // 0x0080 (size: 0x4)
    float Roughness1;                                                                 // 0x0084 (size: 0x4)
    float LobeMix;                                                                    // 0x0088 (size: 0x4)
    FLinearColor TransmissionTintColor;                                               // 0x008C (size: 0x10)

}; // Size: 0x9C

struct FSubtitleCue
{
    FText Text;                                                                       // 0x0000 (size: 0x10)
    float Time;                                                                       // 0x0010 (size: 0x4)

}; // Size: 0x18

struct FSwarmDebugOptions
{
    uint8 bDistributionEnabled;                                                       // 0x0000 (size: 0x1)
    uint8 bForceContentExport;                                                        // 0x0000 (size: 0x1)
    uint8 bInitialized;                                                               // 0x0000 (size: 0x1)

}; // Size: 0x4

struct FSwitchCustomInput
{
    FName InputName;                                                                  // 0x0000 (size: 0x8)
    FExpressionInput Input;                                                           // 0x0008 (size: 0x28)

}; // Size: 0x30

struct FTTEventTrack : public FTTTrackBase
{
    FName FunctionName;                                                               // 0x0018 (size: 0x8)
    class UCurveFloat* CurveKeys;                                                     // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FTTFloatTrack : public FTTPropertyTrack
{
    class UCurveFloat* CurveFloat;                                                    // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FTTLinearColorTrack : public FTTPropertyTrack
{
    class UCurveLinearColor* CurveLinearColor;                                        // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FTTPropertyTrack : public FTTTrackBase
{
    FName PropertyName;                                                               // 0x0018 (size: 0x8)

}; // Size: 0x20

struct FTTTrackBase
{
    FName TrackName;                                                                  // 0x0008 (size: 0x8)
    bool bIsExternalCurve;                                                            // 0x0010 (size: 0x1)

}; // Size: 0x18

struct FTTTrackId
{
    int32 TrackType;                                                                  // 0x0000 (size: 0x4)
    int32 TrackIndex;                                                                 // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FTTVectorTrack : public FTTPropertyTrack
{
    class UCurveVector* CurveVector;                                                  // 0x0020 (size: 0x8)

}; // Size: 0x28

struct FTViewTarget
{
    class AActor* Target;                                                             // 0x0000 (size: 0x8)
    FMinimalViewInfo POV;                                                             // 0x0010 (size: 0x800)
    class APlayerState* PlayerState;                                                  // 0x0810 (size: 0x8)

}; // Size: 0x820

struct FTableRowBase
{
}; // Size: 0x8

struct FTentDistribution
{
    float TipAltitude;                                                                // 0x0000 (size: 0x4)
    float TipValue;                                                                   // 0x0004 (size: 0x4)
    float Width;                                                                      // 0x0008 (size: 0x4)

}; // Size: 0xC

struct FTextSizingParameters
{
    float DrawX;                                                                      // 0x0000 (size: 0x4)
    float DrawY;                                                                      // 0x0004 (size: 0x4)
    float DrawXL;                                                                     // 0x0008 (size: 0x4)
    float DrawYL;                                                                     // 0x000C (size: 0x4)
    FVector2D Scaling;                                                                // 0x0010 (size: 0x10)
    class UFont* DrawFont;                                                            // 0x0020 (size: 0x8)
    FVector2D SpacingAdjust;                                                          // 0x0028 (size: 0x10)

}; // Size: 0x38

struct FTextureFormatSettings
{
    TEnumAsByte<TextureCompressionSettings> CompressionSettings;                      // 0x0000 (size: 0x1)
    uint8 CompressionNoAlpha;                                                         // 0x0001 (size: 0x1)
    uint8 CompressionForceAlpha;                                                      // 0x0001 (size: 0x1)
    uint8 CompressionNone;                                                            // 0x0001 (size: 0x1)
    uint8 CompressionYCoCg;                                                           // 0x0001 (size: 0x1)
    uint8 SRGB;                                                                       // 0x0001 (size: 0x1)

}; // Size: 0x2

struct FTextureLODGroup
{
    TEnumAsByte<TextureGroup> Group;                                                  // 0x0000 (size: 0x1)
    int32 LODBias;                                                                    // 0x0008 (size: 0x4)
    int32 LODBias_Smaller;                                                            // 0x000C (size: 0x4)
    int32 LODBias_Smallest;                                                           // 0x0010 (size: 0x4)
    int32 NumStreamedMips;                                                            // 0x0018 (size: 0x4)
    TEnumAsByte<TextureMipGenSettings> MipGenSettings;                                // 0x001C (size: 0x1)
    int32 MinLODSize;                                                                 // 0x0020 (size: 0x4)
    int32 MaxLODSize;                                                                 // 0x0024 (size: 0x4)
    int32 MaxLODSize_Smaller;                                                         // 0x0028 (size: 0x4)
    int32 MaxLODSize_Smallest;                                                        // 0x002C (size: 0x4)
    int32 MaxLODSize_VT;                                                              // 0x0030 (size: 0x4)
    int32 OptionalLODBias;                                                            // 0x0034 (size: 0x4)
    int32 OptionalMaxLODSize;                                                         // 0x0038 (size: 0x4)
    FName MinMagFilter;                                                               // 0x003C (size: 0x8)
    FName MipFilter;                                                                  // 0x0044 (size: 0x8)
    ETextureMipLoadOptions MipLoadOptions;                                            // 0x004C (size: 0x1)
    bool HighPriorityLoad;                                                            // 0x004D (size: 0x1)
    bool DuplicateNonOptionalMips;                                                    // 0x004E (size: 0x1)
    float Downscale;                                                                  // 0x0050 (size: 0x4)
    ETextureDownscaleOptions DownscaleOptions;                                        // 0x0054 (size: 0x1)
    int32 VirtualTextureTileCountBias;                                                // 0x0058 (size: 0x4)
    int32 VirtualTextureTileSizeBias;                                                 // 0x005C (size: 0x4)
    TEnumAsByte<ETextureLossyCompressionAmount> LossyCompressionAmount;               // 0x0060 (size: 0x1)
    bool CookPlatformTilingDisabled;                                                  // 0x0061 (size: 0x1)
    int32 MaxAniso;                                                                   // 0x0064 (size: 0x4)

}; // Size: 0x68

struct FTextureParameterValue
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    class UTexture* ParameterValue;                                                   // 0x0010 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x0018 (size: 0x10)

}; // Size: 0x28

struct FTexturePlatformData
{
}; // Size: 0x38

struct FTextureSource
{
}; // Size: 0x70

struct FTextureSourceBlock
{
    int32 BlockX;                                                                     // 0x0000 (size: 0x4)
    int32 BlockY;                                                                     // 0x0004 (size: 0x4)
    int32 SizeX;                                                                      // 0x0008 (size: 0x4)
    int32 SizeY;                                                                      // 0x000C (size: 0x4)
    int32 NumSlices;                                                                  // 0x0010 (size: 0x4)
    int32 NumMips;                                                                    // 0x0014 (size: 0x4)

}; // Size: 0x18

struct FTextureSourceColorSettings
{
    ETextureSourceEncoding EncodingOverride;                                          // 0x0000 (size: 0x1)
    ETextureColorSpace ColorSpace;                                                    // 0x0001 (size: 0x1)
    FVector2D RedChromaticityCoordinate;                                              // 0x0008 (size: 0x10)
    FVector2D GreenChromaticityCoordinate;                                            // 0x0018 (size: 0x10)
    FVector2D BlueChromaticityCoordinate;                                             // 0x0028 (size: 0x10)
    FVector2D WhiteChromaticityCoordinate;                                            // 0x0038 (size: 0x10)
    ETextureChromaticAdaptationMethod ChromaticAdaptationMethod;                      // 0x0048 (size: 0x1)

}; // Size: 0x50

struct FTextureSourceLayerColorInfo
{
    FLinearColor ColorMin;                                                            // 0x0000 (size: 0x10)
    FLinearColor ColorMax;                                                            // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FTickFunction
{
    TEnumAsByte<ETickingGroup> TickGroup;                                             // 0x0008 (size: 0x1)
    TEnumAsByte<ETickingGroup> EndTickGroup;                                          // 0x0009 (size: 0x1)
    uint8 bTickEvenWhenPaused;                                                        // 0x000A (size: 0x1)
    uint8 bCanEverTick;                                                               // 0x000A (size: 0x1)
    uint8 bStartWithTickEnabled;                                                      // 0x000A (size: 0x1)
    uint8 bAllowTickOnDedicatedServer;                                                // 0x000A (size: 0x1)
    float TickInterval;                                                               // 0x000C (size: 0x4)

}; // Size: 0x28

struct FTickPrerequisite
{
}; // Size: 0x10

struct FTimeStretchCurve
{
    float SamplingRate;                                                               // 0x0000 (size: 0x4)
    float CurveValueMinPrecision;                                                     // 0x0004 (size: 0x4)
    TArray<FTimeStretchCurveMarker> Markers;                                          // 0x0008 (size: 0x10)
    float Sum_dT_i_by_C_i;                                                            // 0x0018 (size: 0xC)

}; // Size: 0x28

struct FTimeStretchCurveInstance
{
    bool bHasValidData;                                                               // 0x0000 (size: 0x1)

}; // Size: 0x30

struct FTimeStretchCurveMarker
{
    float Time;                                                                       // 0x0000 (size: 0xC)
    float Alpha;                                                                      // 0x000C (size: 0x4)

}; // Size: 0x10

struct FTimecodeCustomAttributeNameSettings
{
    FName HourAttributeName;                                                          // 0x0000 (size: 0x8)
    FName MinuteAttributeName;                                                        // 0x0008 (size: 0x8)
    FName SecondAttributeName;                                                        // 0x0010 (size: 0x8)
    FName FrameAttributeName;                                                         // 0x0018 (size: 0x8)
    FName SubframeAttributeName;                                                      // 0x0020 (size: 0x8)
    FName RateAttributeName;                                                          // 0x0028 (size: 0x8)
    FName TakenameAttributeName;                                                      // 0x0030 (size: 0x8)

}; // Size: 0x38

struct FTimeline
{
    TEnumAsByte<ETimelineLengthMode> LengthMode;                                      // 0x0000 (size: 0x1)
    uint8 bLooping;                                                                   // 0x0001 (size: 0x1)
    uint8 bReversePlayback;                                                           // 0x0001 (size: 0x1)
    uint8 bPlaying;                                                                   // 0x0001 (size: 0x1)
    float Length;                                                                     // 0x0004 (size: 0x4)
    float PlayRate;                                                                   // 0x0008 (size: 0x4)
    float Position;                                                                   // 0x000C (size: 0x4)
    TArray<FTimelineEventEntry> Events;                                               // 0x0010 (size: 0x10)
    TArray<FTimelineVectorTrack> InterpVectors;                                       // 0x0020 (size: 0x10)
    TArray<FTimelineFloatTrack> InterpFloats;                                         // 0x0030 (size: 0x10)
    TArray<FTimelineLinearColorTrack> InterpLinearColors;                             // 0x0040 (size: 0x10)
    FTimelineTimelinePostUpdateFunc TimelinePostUpdateFunc;                           // 0x0050 (size: 0x10)
    void OnTimelineEvent();
    FTimelineTimelineFinishedFunc TimelineFinishedFunc;                               // 0x0060 (size: 0x10)
    void OnTimelineEvent();
    TWeakObjectPtr<class UObject> PropertySetObject;                                  // 0x0070 (size: 0x8)
    FName DirectionPropertyName;                                                      // 0x0078 (size: 0x8)

}; // Size: 0x98

struct FTimelineEventEntry
{
    float Time;                                                                       // 0x0000 (size: 0x4)
    FTimelineEventEntryEventFunc EventFunc;                                           // 0x0004 (size: 0x10)
    void OnTimelineEvent();

}; // Size: 0x14

struct FTimelineFloatTrack
{
    class UCurveFloat* FloatCurve;                                                    // 0x0000 (size: 0x8)
    FTimelineFloatTrackInterpFunc InterpFunc;                                         // 0x0008 (size: 0x10)
    void OnTimelineFloat(float Output);
    FName TrackName;                                                                  // 0x0018 (size: 0x8)
    FName FloatPropertyName;                                                          // 0x0020 (size: 0x8)

}; // Size: 0x40

struct FTimelineLinearColorTrack
{
    class UCurveLinearColor* LinearColorCurve;                                        // 0x0000 (size: 0x8)
    FTimelineLinearColorTrackInterpFunc InterpFunc;                                   // 0x0008 (size: 0x10)
    void OnTimelineLinearColor(FLinearColor Output);
    FName TrackName;                                                                  // 0x0018 (size: 0x8)
    FName LinearColorPropertyName;                                                    // 0x0020 (size: 0x8)

}; // Size: 0x40

struct FTimelineVectorTrack
{
    class UCurveVector* VectorCurve;                                                  // 0x0000 (size: 0x8)
    FTimelineVectorTrackInterpFunc InterpFunc;                                        // 0x0008 (size: 0x10)
    void OnTimelineVector(FVector Output);
    FName TrackName;                                                                  // 0x0018 (size: 0x8)
    FName VectorPropertyName;                                                         // 0x0020 (size: 0x8)

}; // Size: 0x40

struct FTimerHandle
{
    uint64 Handle;                                                                    // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FTouchInputControl
{
    bool bTreatAsButton;                                                              // 0x0000 (size: 0x1)
    class UTexture2D* Image1;                                                         // 0x0008 (size: 0x8)
    class UTexture2D* Image2;                                                         // 0x0010 (size: 0x8)
    FVector2D Center;                                                                 // 0x0018 (size: 0x10)
    FVector2D VisualSize;                                                             // 0x0028 (size: 0x10)
    FVector2D ThumbSize;                                                              // 0x0038 (size: 0x10)
    FVector2D InteractionSize;                                                        // 0x0048 (size: 0x10)
    FVector2D InputScale;                                                             // 0x0058 (size: 0x10)
    FKey MainInputKey;                                                                // 0x0068 (size: 0x18)
    FKey AltInputKey;                                                                 // 0x0080 (size: 0x18)

}; // Size: 0x98

struct FTrackToSkeletonMap
{
    int32 BoneTreeIndex;                                                              // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FTrajectorySample
{
    float AccumulatedSeconds;                                                         // 0x0000 (size: 0x4)
    FTransform Transform;                                                             // 0x0010 (size: 0x60)
    FVector LinearVelocity;                                                           // 0x0070 (size: 0x18)

}; // Size: 0x90

struct FTrajectorySampleRange
{
    TArray<FTrajectorySample> Samples;                                                // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FTransformAnimationAttribute
{
    FTransform Value;                                                                 // 0x0000 (size: 0x60)

}; // Size: 0x60

struct FTransformCurve : public FAnimCurveBase
{
    FVectorCurve TranslationCurve;                                                    // 0x0010 (size: 0x190)
    FVectorCurve RotationCurve;                                                       // 0x01A0 (size: 0x190)
    FVectorCurve ScaleCurve;                                                          // 0x0330 (size: 0x190)

}; // Size: 0x4C0

struct FTranslationTrack
{
    TArray<FVector3f> PosKeys;                                                        // 0x0000 (size: 0x10)
    TArray<float> Times;                                                              // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FTwistConstraint : public FConstraintBaseParams
{
    float TwistLimitDegrees;                                                          // 0x0014 (size: 0x4)
    TEnumAsByte<EAngularConstraintMotion> TwistMotion;                                // 0x0018 (size: 0x1)

}; // Size: 0x1C

struct FTypedElementDeletionOptions
{
    bool bVerifyDeletionCanHappen;                                                    // 0x0000 (size: 0x1)
    bool bWarnAboutReferences;                                                        // 0x0001 (size: 0x1)
    bool bWarnAboutSoftReferences;                                                    // 0x0002 (size: 0x1)

}; // Size: 0x3

struct FTypedElementPasteOptions
{
    class UTypedElementSelectionSet* SelectionSetToModify;                            // 0x0000 (size: 0x8)
    bool bPasteAtLocation;                                                            // 0x0008 (size: 0x1)
    FVector PasteLocation;                                                            // 0x0010 (size: 0x18)

}; // Size: 0x78

struct FURL
{
    FString Protocol;                                                                 // 0x0000 (size: 0x10)
    FString Host;                                                                     // 0x0010 (size: 0x10)
    int32 Port;                                                                       // 0x0020 (size: 0x4)
    int32 Valid;                                                                      // 0x0024 (size: 0x4)
    FString Map;                                                                      // 0x0028 (size: 0x10)
    FString RedirectURL;                                                              // 0x0038 (size: 0x10)
    TArray<FString> Op;                                                               // 0x0048 (size: 0x10)
    FString Portal;                                                                   // 0x0058 (size: 0x10)

}; // Size: 0x68

struct FUniqueNetIdRepl : public FUniqueNetIdWrapper
{
    TArray<uint8> ReplicationBytes;                                                   // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FUniqueNetIdReplNetSerializerConfig : public FNetSerializerConfig
{
}; // Size: 0x10

struct FUniqueNetIdReplNetSerializerNameStruct
{
    FName Name;                                                                       // 0x0000 (size: 0x8)

}; // Size: 0x8

struct FUniqueNetIdReplNetSerializerStringStruct
{
    FString String;                                                                   // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FUpdateLevelStreamingLevelStatus
{
    FName PackageName;                                                                // 0x0000 (size: 0x8)
    int32 LODIndex;                                                                   // 0x0008 (size: 0x4)
    bool bNewShouldBeLoaded;                                                          // 0x000C (size: 0x1)
    bool bNewShouldBeVisible;                                                         // 0x000D (size: 0x1)
    bool bNewShouldBlockOnLoad;                                                       // 0x000E (size: 0x1)
    bool bNewShouldBlockOnUnload;                                                     // 0x000F (size: 0x1)

}; // Size: 0x10

struct FUpdateLevelVisibilityLevelInfo
{
    FName PackageName;                                                                // 0x0000 (size: 0x8)
    FName Filename;                                                                   // 0x0008 (size: 0x8)
    FNetLevelVisibilityTransactionId VisibilityRequestId;                             // 0x0010 (size: 0x4)
    uint8 bIsVisible;                                                                 // 0x0014 (size: 0x1)
    uint8 bTryMakeVisible;                                                            // 0x0014 (size: 0x1)
    uint8 bSkipCloseOnError;                                                          // 0x0014 (size: 0x1)

}; // Size: 0x18

struct FUserActivity
{
    FString ActionName;                                                               // 0x0000 (size: 0x10)

}; // Size: 0x18

struct FVector2MaterialInput : public FMaterialInput
{
    uint8 UseConstant;                                                                // 0x0028 (size: 0x1)
    float ConstantX;                                                                  // 0x002C (size: 0x4)
    float ConstantY;                                                                  // 0x0030 (size: 0x4)

}; // Size: 0x38

struct FVector4Distribution
{
    FDistributionLookupTable Table;                                                   // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FVectorAnimationAttribute
{
    FVector Value;                                                                    // 0x0000 (size: 0x18)

}; // Size: 0x18

struct FVectorCurve : public FAnimCurveBase
{
    FRichCurve FloatCurves;                                                           // 0x0010 (size: 0x180)

}; // Size: 0x190

struct FVectorDistribution
{
    FDistributionLookupTable Table;                                                   // 0x0000 (size: 0x20)

}; // Size: 0x20

struct FVectorMaterialInput : public FMaterialInput
{
    uint8 UseConstant;                                                                // 0x0028 (size: 0x1)
    FVector3f Constant;                                                               // 0x002C (size: 0xC)

}; // Size: 0x38

struct FVectorParameterValue
{
    FMaterialParameterInfo ParameterInfo;                                             // 0x0000 (size: 0x10)
    FLinearColor ParameterValue;                                                      // 0x0010 (size: 0x10)
    FGuid ExpressionGUID;                                                             // 0x0020 (size: 0x10)

}; // Size: 0x30

struct FVectorRK4SpringInterpolator
{
    float StiffnessConstant;                                                          // 0x0000 (size: 0x4)
    float DampeningRatio;                                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FVectorSpringState
{
}; // Size: 0x38

struct FVector_NetQuantize : public FVector
{
}; // Size: 0x18

struct FVector_NetQuantize10 : public FVector
{
}; // Size: 0x18

struct FVector_NetQuantize100 : public FVector
{
}; // Size: 0x18

struct FVector_NetQuantizeNormal : public FVector
{
}; // Size: 0x18

struct FVertexOffsetUsage
{
    int32 Usage;                                                                      // 0x0000 (size: 0x4)

}; // Size: 0x4

struct FViewTargetTransitionParams
{
    float BlendTime;                                                                  // 0x0000 (size: 0x4)
    TEnumAsByte<EViewTargetBlendFunction> BlendFunction;                              // 0x0004 (size: 0x1)
    float BlendExp;                                                                   // 0x0008 (size: 0x4)
    uint8 bLockOutgoing;                                                              // 0x000C (size: 0x1)

}; // Size: 0x10

struct FVirtualBone
{
    FName SourceBoneName;                                                             // 0x0000 (size: 0x8)
    FName TargetBoneName;                                                             // 0x0008 (size: 0x8)
    FName VirtualBoneName;                                                            // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FVirtualTextureBuildSettings
{
    int32 TileSize;                                                                   // 0x0000 (size: 0x4)
    int32 TileBorderSize;                                                             // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FVirtualTextureSpacePoolConfig
{
    TArray<TEnumAsByte<EPixelFormat>> Formats;                                        // 0x0000 (size: 0x10)
    int32 MinTileSize;                                                                // 0x0010 (size: 0x4)
    int32 MaxTileSize;                                                                // 0x0014 (size: 0x4)
    int32 SizeInMegabyte;                                                             // 0x0018 (size: 0x4)
    bool bEnableResidencyMipMapBias;                                                  // 0x001C (size: 0x1)
    bool bAllowSizeScale;                                                             // 0x001D (size: 0x1)
    int32 MinScaledSizeInMegabyte;                                                    // 0x0020 (size: 0x4)
    int32 MaxScaledSizeInMegabyte;                                                    // 0x0024 (size: 0x4)

}; // Size: 0x28

struct FVoiceSettings
{
    class USceneComponent* ComponentToAttachTo;                                       // 0x0000 (size: 0x8)
    class USoundAttenuation* AttenuationSettings;                                     // 0x0008 (size: 0x8)
    class USoundEffectSourcePresetChain* SourceEffectChain;                           // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FWalkableSlopeOverride
{
    TEnumAsByte<EWalkableSlopeBehavior> WalkableSlopeBehavior;                        // 0x0000 (size: 0x1)
    float WalkableSlopeAngle;                                                         // 0x0004 (size: 0x4)

}; // Size: 0x10

struct FWeightedBlendSample
{
    int32 SampleIndex;                                                                // 0x0000 (size: 0x4)
    float SampleWeight;                                                               // 0x0004 (size: 0x4)

}; // Size: 0x8

struct FWeightedBlendable
{
    float Weight;                                                                     // 0x0000 (size: 0x4)
    class UObject* Object;                                                            // 0x0008 (size: 0x8)

}; // Size: 0x10

struct FWeightedBlendables
{
    TArray<FWeightedBlendable> Array;                                                 // 0x0000 (size: 0x10)

}; // Size: 0x10

struct FWorldContext
{
    FURL LastURL;                                                                     // 0x00C0 (size: 0x68)
    FURL LastRemoteURL;                                                               // 0x0128 (size: 0x68)
    class UPendingNetGame* PendingNetGame;                                            // 0x0190 (size: 0x8)
    TArray<FFullyLoadedPackagesInfo> PackagesToFullyLoad;                             // 0x0198 (size: 0x10)
    TArray<class ULevel*> LoadedLevelsForPendingMapChange;                            // 0x01B8 (size: 0x10)
    TArray<class UObjectReferencer*> ObjectReferencers;                               // 0x01E0 (size: 0x10)
    TArray<FLevelStreamingStatus> PendingLevelStreamingStatusUpdates;                 // 0x01F0 (size: 0x10)
    class UGameViewportClient* GameViewport;                                          // 0x0200 (size: 0x8)
    class UGameInstance* OwningGameInstance;                                          // 0x0208 (size: 0x8)
    TArray<FNamedNetDriver> ActiveNetDrivers;                                         // 0x0210 (size: 0x10)

}; // Size: 0x2C8

struct FWorldPSCPool
{
    TMap<class UParticleSystem*, class FPSCPool> WorldParticleSystemPools;            // 0x0000 (size: 0x50)

}; // Size: 0x58

struct FWorldPartitionActorFilter
{
}; // Size: 0x1

struct FWorldPartitionDestructibleHLODDamagedActorState : public FFastArraySerializerItem
{
    int32 ActorIndex;                                                                 // 0x000C (size: 0x4)
    uint8 ActorHealth;                                                                // 0x0010 (size: 0x1)

}; // Size: 0x14

struct FWorldPartitionDestructibleHLODState : public FFastArraySerializer
{
    TArray<FWorldPartitionDestructibleHLODDamagedActorState> DamagedActors;           // 0x0108 (size: 0x10)
    class UWorldPartitionDestructibleHLODComponent* OwnerComponent;                   // 0x0118 (size: 0x8)

}; // Size: 0x148

struct FWorldPartitionHLODDestructionTag
{
    class UWorldPartitionDestructibleHLODComponent* HLODDestructionComponent;         // 0x0000 (size: 0x8)
    int32 ActorIndex;                                                                 // 0x0008 (size: 0x4)

}; // Size: 0x10

struct FWorldPartitionPerWorldSettings
{
}; // Size: 0x1

struct FWorldPartitionResolveData
{
    FActorContainerID ContainerID;                                                    // 0x0000 (size: 0x10)
    FTopLevelAssetPath SourceWorldAssetPath;                                          // 0x0010 (size: 0x10)

}; // Size: 0x20

struct FWorldPartitionRuntimeCellDebugInfo
{
    FString Name;                                                                     // 0x0000 (size: 0x10)
    FName GridName;                                                                   // 0x0010 (size: 0x8)
    int64 CoordX;                                                                     // 0x0018 (size: 0x8)
    int64 CoordY;                                                                     // 0x0020 (size: 0x8)
    int64 CoordZ;                                                                     // 0x0028 (size: 0x8)

}; // Size: 0x30

struct FWorldPartitionRuntimeCellObjectMapping
{
}; // Size: 0x1

struct FWorldPartitionRuntimeCellStreamingData
{
    FString PackageName;                                                              // 0x0000 (size: 0x10)
    FSoftObjectPath WorldAsset;                                                       // 0x0010 (size: 0x20)

}; // Size: 0x30

struct FWorldPartitionRuntimeContainer
{
    TMap<class FName, class FWorldPartitionRuntimeContainerInstance> ContainerInstances; // 0x0000 (size: 0x50)

}; // Size: 0x50

struct FWorldPartitionRuntimeContainerInstance
{
    FGuid ActorGuid;                                                                  // 0x0000 (size: 0x10)
    FName ContainerPackage;                                                           // 0x0010 (size: 0x8)

}; // Size: 0x18

struct FWorldPartitionRuntimeContainerResolver
{
    TMap<class FName, class FWorldPartitionRuntimeContainer> Containers;              // 0x0000 (size: 0x50)
    FName MainContainerPackage;                                                       // 0x0050 (size: 0x8)

}; // Size: 0x58

struct FWorldPartitionRuntimeSpatialHashGridPreviewer
{
}; // Size: 0x1

struct FWorldPartitionStreamingQuerySource
{
    FVector Location;                                                                 // 0x0000 (size: 0x18)
    float Radius;                                                                     // 0x0018 (size: 0x4)
    bool bUseGridLoadingRange;                                                        // 0x001C (size: 0x1)
    TArray<FName> DataLayers;                                                         // 0x0020 (size: 0x10)
    bool bDataLayersOnly;                                                             // 0x0030 (size: 0x1)
    bool bSpatialQuery;                                                               // 0x0031 (size: 0x1)

}; // Size: 0x108

struct FWrappedStringElement
{
    FString Value;                                                                    // 0x0000 (size: 0x10)
    FVector2D LineExtent;                                                             // 0x0010 (size: 0x10)

}; // Size: 0x20

class AActor : public UObject
{
    FActorTickFunction PrimaryActorTick;                                              // 0x0028 (size: 0x30)
    uint8 bNetTemporary;                                                              // 0x0058 (size: 0x1)
    uint8 bOnlyRelevantToOwner;                                                       // 0x0058 (size: 0x1)
    uint8 bAlwaysRelevant;                                                            // 0x0058 (size: 0x1)
    uint8 bReplicateMovement;                                                         // 0x0058 (size: 0x1)
    uint8 bCallPreReplication;                                                        // 0x0058 (size: 0x1)
    uint8 bCallPreReplicationForReplay;                                               // 0x0058 (size: 0x1)
    uint8 bHidden;                                                                    // 0x0058 (size: 0x1)
    uint8 bTearOff;                                                                   // 0x0059 (size: 0x1)
    uint8 bForceNetAddressable;                                                       // 0x0059 (size: 0x1)
    uint8 bExchangedRoles;                                                            // 0x0059 (size: 0x1)
    uint8 bNetLoadOnClient;                                                           // 0x0059 (size: 0x1)
    uint8 bNetUseOwnerRelevancy;                                                      // 0x0059 (size: 0x1)
    uint8 bRelevantForNetworkReplays;                                                 // 0x0059 (size: 0x1)
    uint8 bRelevantForLevelBounds;                                                    // 0x0059 (size: 0x1)
    uint8 bReplayRewindable;                                                          // 0x0059 (size: 0x1)
    uint8 bAllowTickBeforeBeginPlay;                                                  // 0x005A (size: 0x1)
    uint8 bAutoDestroyWhenFinished;                                                   // 0x005A (size: 0x1)
    uint8 bCanBeDamaged;                                                              // 0x005A (size: 0x1)
    uint8 bBlockInput;                                                                // 0x005A (size: 0x1)
    uint8 bCollideWhenPlacing;                                                        // 0x005A (size: 0x1)
    uint8 bFindCameraComponentWhenViewTarget;                                         // 0x005A (size: 0x1)
    uint8 bGenerateOverlapEventsDuringLevelStreaming;                                 // 0x005A (size: 0x1)
    uint8 bIgnoresOriginShifting;                                                     // 0x005A (size: 0x1)
    uint8 bEnableAutoLODGeneration;                                                   // 0x005B (size: 0x1)
    uint8 bIsEditorOnlyActor;                                                         // 0x005B (size: 0x1)
    uint8 bActorSeamlessTraveled;                                                     // 0x005B (size: 0x1)
    uint8 bReplicates;                                                                // 0x005B (size: 0x1)
    uint8 bCanBeInCluster;                                                            // 0x005B (size: 0x1)
    uint8 bAllowReceiveTickEventOnDedicatedServer;                                    // 0x005B (size: 0x1)
    uint8 bReplicateUsingRegisteredSubObjectList;                                     // 0x005B (size: 0x1)
    uint8 bActorEnableCollision;                                                      // 0x005C (size: 0x1)
    uint8 bActorIsBeingDestroyed;                                                     // 0x005D (size: 0x1)
    uint8 bAsyncPhysicsTickEnabled;                                                   // 0x005D (size: 0x1)
    EActorUpdateOverlapsMethod UpdateOverlapsMethodDuringLevelStreaming;              // 0x005E (size: 0x1)
    EActorUpdateOverlapsMethod DefaultUpdateOverlapsMethodDuringLevelStreaming;       // 0x005F (size: 0x1)
    TEnumAsByte<ENetRole> RemoteRole;                                                 // 0x0060 (size: 0x1)
    float InitialLifeSpan;                                                            // 0x0064 (size: 0x4)
    float CustomTimeDilation;                                                         // 0x0068 (size: 0x4)
    int32 RayTracingGroupId;                                                          // 0x006C (size: 0x4)
    FRepAttachment AttachmentReplication;                                             // 0x0070 (size: 0x60)
    FRepMovement ReplicatedMovement;                                                  // 0x00D0 (size: 0x70)
    class AActor* Owner;                                                              // 0x0140 (size: 0x8)
    FName NetDriverName;                                                              // 0x0148 (size: 0x8)
    TEnumAsByte<ENetRole> Role;                                                       // 0x0150 (size: 0x1)
    TEnumAsByte<ENetDormancy> NetDormancy;                                            // 0x0151 (size: 0x1)
    ESpawnActorCollisionHandlingMethod SpawnCollisionHandlingMethod;                  // 0x0152 (size: 0x1)
    TEnumAsByte<EAutoReceiveInput::Type> AutoReceiveInput;                            // 0x0153 (size: 0x1)
    int32 InputPriority;                                                              // 0x0154 (size: 0x4)
    class UInputComponent* InputComponent;                                            // 0x0160 (size: 0x8)
    float NetCullDistanceSquared;                                                     // 0x0168 (size: 0x4)
    int32 NetTag;                                                                     // 0x016C (size: 0x4)
    float NetUpdateFrequency;                                                         // 0x0170 (size: 0x4)
    float MinNetUpdateFrequency;                                                      // 0x0174 (size: 0x4)
    float NetPriority;                                                                // 0x0178 (size: 0x4)
    EPhysicsReplicationMode PhysicsReplicationMode;                                   // 0x017C (size: 0x1)
    class APawn* Instigator;                                                          // 0x0188 (size: 0x8)
    TArray<class AActor*> Children;                                                   // 0x0190 (size: 0x10)
    class USceneComponent* RootComponent;                                             // 0x01A0 (size: 0x8)
    TArray<FName> Layers;                                                             // 0x01B0 (size: 0x10)
    TWeakObjectPtr<class UChildActorComponent> ParentComponent;                       // 0x01C0 (size: 0x8)
    TArray<FName> Tags;                                                               // 0x01C8 (size: 0x10)
    FActorOnTakeAnyDamage OnTakeAnyDamage;                                            // 0x01D8 (size: 0x1)
    void TakeAnyDamageSignature(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
    FActorOnTakePointDamage OnTakePointDamage;                                        // 0x01D9 (size: 0x1)
    void TakePointDamageSignature(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, FVector HitLocation, class UPrimitiveComponent* FHitComponent, FName BoneName, FVector ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser);
    FActorOnTakeRadialDamage OnTakeRadialDamage;                                      // 0x01DA (size: 0x1)
    void TakeRadialDamageSignature(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, FVector Origin, const FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser);
    FActorOnActorBeginOverlap OnActorBeginOverlap;                                    // 0x01DB (size: 0x1)
    void ActorBeginOverlapSignature(class AActor* OverlappedActor, class AActor* OtherActor);
    FActorOnActorEndOverlap OnActorEndOverlap;                                        // 0x01DC (size: 0x1)
    void ActorEndOverlapSignature(class AActor* OverlappedActor, class AActor* OtherActor);
    FActorOnBeginCursorOver OnBeginCursorOver;                                        // 0x01DD (size: 0x1)
    void ActorBeginCursorOverSignature(class AActor* TouchedActor);
    FActorOnEndCursorOver OnEndCursorOver;                                            // 0x01DE (size: 0x1)
    void ActorEndCursorOverSignature(class AActor* TouchedActor);
    FActorOnClicked OnClicked;                                                        // 0x01DF (size: 0x1)
    void ActorOnClickedSignature(class AActor* TouchedActor, FKey ButtonPressed);
    FActorOnReleased OnReleased;                                                      // 0x01E0 (size: 0x1)
    void ActorOnReleasedSignature(class AActor* TouchedActor, FKey ButtonReleased);
    FActorOnInputTouchBegin OnInputTouchBegin;                                        // 0x01E1 (size: 0x1)
    void ActorOnInputTouchBeginSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class AActor* TouchedActor);
    FActorOnInputTouchEnd OnInputTouchEnd;                                            // 0x01E2 (size: 0x1)
    void ActorOnInputTouchEndSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class AActor* TouchedActor);
    FActorOnInputTouchEnter OnInputTouchEnter;                                        // 0x01E3 (size: 0x1)
    void ActorBeginTouchOverSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class AActor* TouchedActor);
    FActorOnInputTouchLeave OnInputTouchLeave;                                        // 0x01E4 (size: 0x1)
    void ActorEndTouchOverSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class AActor* TouchedActor);
    FActorOnActorHit OnActorHit;                                                      // 0x01E5 (size: 0x1)
    void ActorHitSignature(class AActor* SelfActor, class AActor* OtherActor, FVector NormalImpulse, const FHitResult& hit);
    FActorOnDestroyed OnDestroyed;                                                    // 0x01E6 (size: 0x1)
    void ActorDestroyedSignature(class AActor* DestroyedActor);
    FActorOnEndPlay OnEndPlay;                                                        // 0x01E7 (size: 0x1)
    void ActorEndPlaySignature(class AActor* Actor, TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
    TArray<class UActorComponent*> InstanceComponents;                                // 0x0268 (size: 0x10)
    TArray<class UActorComponent*> BlueprintCreatedComponents;                        // 0x0278 (size: 0x10)

    bool WasRecentlyRendered(float Tolerance);
    void UserConstructionScript();
    void TearOff();
    void SetTickGroup(TEnumAsByte<ETickingGroup> NewTickGroup);
    void SetTickableWhenPaused(bool bTickableWhenPaused);
    void SetReplicates(bool bInReplicates);
    void SetReplicateMovement(bool bInReplicateMovement);
    void SetRayTracingGroupId(int32 InRaytracingGroupId);
    void SetPhysicsReplicationMode(const EPhysicsReplicationMode ReplicationMode);
    void SetOwner(class AActor* NewOwner);
    void SetNetDormancy(TEnumAsByte<ENetDormancy> NewDormancy);
    void SetLifeSpan(float InLifespan);
    void SetAutoDestroyWhenFinished(bool bVal);
    void SetActorTickInterval(float TickInterval);
    void SetActorTickEnabled(bool bEnabled);
    void SetActorScale3D(FVector NewScale3D);
    void SetActorRelativeScale3D(FVector NewRelativeScale);
    void SetActorHiddenInGame(bool bNewHidden);
    void SetActorEnableCollision(bool bNewActorEnableCollision);
    void RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent);
    void RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor);
    void ReceiveTick(float DeltaSeconds);
    void ReceiveRadialDamage(float DamageReceived, const class UDamageType* DamageType, FVector Origin, const FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser);
    void ReceivePointDamage(float Damage, const class UDamageType* DamageType, FVector HitLocation, FVector HitNormal, class UPrimitiveComponent* HitComponent, FName BoneName, FVector ShotFromDirection, class AController* InstigatedBy, class AActor* DamageCauser, const FHitResult& HitInfo);
    void ReceiveHit(class UPrimitiveComponent* MyComp, class AActor* Other, class UPrimitiveComponent* OtherComp, bool bSelfMoved, FVector HitLocation, FVector HitNormal, FVector NormalImpulse, const FHitResult& hit);
    void ReceiveEndPlay(TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
    void ReceiveDestroyed();
    void ReceiveBeginPlay();
    void ReceiveAsyncPhysicsTick(float DeltaSeconds, float SimSeconds);
    void ReceiveAnyDamage(float Damage, const class UDamageType* DamageType, class AController* InstigatedBy, class AActor* DamageCauser);
    void ReceiveActorOnReleased(FKey ButtonReleased);
    void ReceiveActorOnInputTouchLeave(const TEnumAsByte<ETouchIndex::Type> FingerIndex);
    void ReceiveActorOnInputTouchEnter(const TEnumAsByte<ETouchIndex::Type> FingerIndex);
    void ReceiveActorOnInputTouchEnd(const TEnumAsByte<ETouchIndex::Type> FingerIndex);
    void ReceiveActorOnInputTouchBegin(const TEnumAsByte<ETouchIndex::Type> FingerIndex);
    void ReceiveActorOnClicked(FKey ButtonPressed);
    void ReceiveActorEndOverlap(class AActor* OtherActor);
    void ReceiveActorEndCursorOver();
    void ReceiveActorBeginOverlap(class AActor* OtherActor);
    void ReceiveActorBeginCursorOver();
    void PrestreamTextures(float Seconds, bool bEnableStreaming, int32 CinematicTextureGroups);
    void OnRep_ReplicateMovement();
    void OnRep_ReplicatedMovement();
    void OnRep_Owner();
    void OnRep_Instigator();
    void OnRep_AttachmentReplication();
    void MakeNoise(float Loudness, class APawn* NoiseInstigator, FVector NoiseLocation, float MaxRange, FName Tag);
    bool K2_TeleportTo(FVector DestLocation, FRotator DestRotation);
    bool K2_SetActorTransform(const FTransform& NewTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool K2_SetActorRotation(FRotator NewRotation, bool bTeleportPhysics);
    void K2_SetActorRelativeTransform(const FTransform& NewRelativeTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetActorRelativeRotation(FRotator NewRelativeRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetActorRelativeLocation(FVector NewRelativeLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool K2_SetActorLocationAndRotation(FVector NewLocation, FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool K2_SetActorLocation(FVector NewLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_OnReset();
    void K2_OnEndViewTarget(class APlayerController* PC);
    void K2_OnBecomeViewTarget(class APlayerController* PC);
    class USceneComponent* K2_GetRootComponent();
    TArray<class UActorComponent*> K2_GetComponentsByClass(TSubclassOf<class UActorComponent> ComponentClass);
    FRotator K2_GetActorRotation();
    FVector K2_GetActorLocation();
    void K2_DetachFromActor(EDetachmentRule LocationRule, EDetachmentRule RotationRule, EDetachmentRule ScaleRule);
    void K2_DestroyActor();
    bool K2_AttachToComponent(class USceneComponent* Parent, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
    bool K2_AttachToActor(class AActor* ParentActor, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
    void K2_AttachRootComponentToActor(class AActor* InParentActor, FName InSocketName, TEnumAsByte<EAttachLocation::Type> AttachLocationType, bool bWeldSimulatedBodies);
    void K2_AttachRootComponentTo(class USceneComponent* InParent, FName InSocketName, TEnumAsByte<EAttachLocation::Type> AttachLocationType, bool bWeldSimulatedBodies);
    void K2_AddActorWorldTransformKeepScale(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorWorldTransform(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorWorldRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorWorldOffset(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorLocalTransform(const FTransform& NewTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorLocalRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddActorLocalOffset(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool IsOverlappingActor(const class AActor* Other);
    bool IsChildActor();
    bool IsActorTickEnabled();
    bool IsActorBeingDestroyed();
    bool HasAuthority();
    float GetVerticalDistanceTo(const class AActor* OtherActor);
    FVector GetVelocity();
    FTransform GetTransform();
    bool GetTickableWhenPaused();
    float GetSquaredHorizontalDistanceTo(const class AActor* OtherActor);
    float GetSquaredDistanceTo(const class AActor* OtherActor);
    float GetResimulationThreshold();
    TEnumAsByte<ENetRole> GetRemoteRole();
    int32 GetRayTracingGroupId();
    EPhysicsReplicationMode GetPhysicsReplicationMode();
    class UChildActorComponent* GetParentComponent();
    class AActor* GetParentActor();
    class AActor* GetOwner();
    void GetOverlappingComponents(TArray<class UPrimitiveComponent*>& OverlappingComponents);
    void GetOverlappingActors(TArray<class AActor*>& OverlappingActors, TSubclassOf<class AActor> ClassFilter);
    TEnumAsByte<ENetRole> GetLocalRole();
    float GetLifeSpan();
    FTransform GetLevelTransform();
    class ULevel* GetLevel();
    class AController* GetInstigatorController();
    class APawn* GetInstigator();
    FVector GetInputVectorAxisValue(const FKey InputAxisKey);
    float GetInputAxisValue(const FName InputAxisName);
    float GetInputAxisKeyValue(const FKey InputAxisKey);
    float GetHorizontalDotProductTo(const class AActor* OtherActor);
    float GetHorizontalDistanceTo(const class AActor* OtherActor);
    float GetGameTimeSinceCreation();
    float GetDotProductTo(const class AActor* OtherActor);
    float GetDistanceTo(const class AActor* OtherActor);
    TArray<class UActorComponent*> GetComponentsByTag(TSubclassOf<class UActorComponent> ComponentClass, FName Tag);
    TArray<class UActorComponent*> GetComponentsByInterface(TSubclassOf<class UInterface> Interface);
    class UActorComponent* GetComponentByClass(TSubclassOf<class UActorComponent> ComponentClass);
    FName GetAttachParentSocketName();
    class AActor* GetAttachParentActor();
    void GetAttachedActors(TArray<class AActor*>& OutActors, bool bResetArray, bool bRecursivelyIncludeAttachedActors);
    void GetAllChildActors(TArray<class AActor*>& ChildActors, bool bIncludeDescendants);
    FVector GetActorUpVector();
    float GetActorTimeDilation();
    float GetActorTickInterval();
    FVector GetActorScale3D();
    FVector GetActorRightVector();
    FVector GetActorRelativeScale3D();
    FVector GetActorForwardVector();
    void GetActorEyesViewPoint(FVector& OutLocation, FRotator& OutRotation);
    bool GetActorEnableCollision();
    void GetActorBounds(bool bOnlyCollidingComponents, FVector& Origin, FVector& BoxExtent, bool bIncludeFromChildActors);
    void ForceNetUpdate();
    void FlushNetDormancy();
    void FinishAddComponent(class UActorComponent* Component, bool bManualAttachment, const FTransform& RelativeTransform);
    class UActorComponent* FindComponentByTag(TSubclassOf<class UActorComponent> ComponentClass, FName Tag);
    void EnableInput(class APlayerController* PlayerController);
    void DisableInput(class APlayerController* PlayerController);
    void DetachRootComponentFromParent(bool bMaintainWorldPosition);
    void CreateInputComponent(TSubclassOf<class UInputComponent> InputComponentToCreate);
    bool CanTriggerResimulation();
    void AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent);
    void AddTickPrerequisiteActor(class AActor* PrerequisiteActor);
    class UActorComponent* AddComponentByClass(TSubclassOf<class UActorComponent> Class, bool bManualAttachment, const FTransform& RelativeTransform, bool bDeferredFinish);
    class UActorComponent* AddComponent(FName TemplateName, bool bManualAttachment, const FTransform& RelativeTransform, const class UObject* ComponentTemplateContext, bool bDeferredFinish);
    bool ActorHasTag(FName Tag);
}; // Size: 0x290

class AAmbientSound : public AActor
{
    class UAudioComponent* AudioComponent;                                            // 0x0290 (size: 0x8)

    void Stop();
    void Play(float StartTime);
    void FadeOut(float FadeOutDuration, float FadeVolumeLevel);
    void FadeIn(float FadeInDuration, float FadeVolumeLevel);
    void AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel);
}; // Size: 0x298

class AAtmosphericFog : public AInfo
{
    class UAtmosphericFogComponent* AtmosphericFogComponent;                          // 0x0290 (size: 0x8)

}; // Size: 0x298

class AAudioVolume : public AVolume
{
    float Priority;                                                                   // 0x02C8 (size: 0x4)
    uint8 bEnabled;                                                                   // 0x02CC (size: 0x1)
    FReverbSettings Settings;                                                         // 0x02D0 (size: 0x20)
    FInteriorSettings AmbientZoneSettings;                                            // 0x02F0 (size: 0x24)
    TArray<FAudioVolumeSubmixSendSettings> SubmixSendSettings;                        // 0x0318 (size: 0x10)
    TArray<FAudioVolumeSubmixOverrideSettings> SubmixOverrideSettings;                // 0x0328 (size: 0x10)

    void SetSubmixSendSettings(const TArray<FAudioVolumeSubmixSendSettings>& NewSubmixSendSettings);
    void SetSubmixOverrideSettings(const TArray<FAudioVolumeSubmixOverrideSettings>& NewSubmixOverrideSettings);
    void SetReverbSettings(const FReverbSettings& NewReverbSettings);
    void SetPriority(float NewPriority);
    void SetInteriorSettings(const FInteriorSettings& NewInteriorSettings);
    void SetEnabled(bool bNewEnabled);
    void OnRep_bEnabled();
}; // Size: 0x338

class ABandwidthTestActor : public AActor
{
    FBandwidthTestGenerator BandwidthGenerator;                                       // 0x0290 (size: 0x20)

}; // Size: 0x2B0

class ABlockingVolume : public AVolume
{
}; // Size: 0x2C8

class ABoxReflectionCapture : public AReflectionCapture
{
}; // Size: 0x298

class ABrush : public AActor
{
    TEnumAsByte<EBrushType> BrushType;                                                // 0x0290 (size: 0x1)
    FColor BrushColor;                                                                // 0x0294 (size: 0x4)
    int32 PolyFlags;                                                                  // 0x0298 (size: 0x4)
    uint8 bColored;                                                                   // 0x029C (size: 0x1)
    uint8 bSolidWhenSelected;                                                         // 0x029C (size: 0x1)
    uint8 bPlaceableFromClassBrowser;                                                 // 0x029C (size: 0x1)
    uint8 bNotForClientOrServer;                                                      // 0x029C (size: 0x1)
    class UModel* Brush;                                                              // 0x02A0 (size: 0x8)
    class UBrushComponent* BrushComponent;                                            // 0x02A8 (size: 0x8)
    uint8 bInManipulation;                                                            // 0x02B0 (size: 0x1)
    TArray<FGeomSelection> SavedSelections;                                           // 0x02B8 (size: 0x10)

}; // Size: 0x2C8

class ABrushShape : public ABrush
{
}; // Size: 0x2C8

class ACameraActor : public AActor
{
    TEnumAsByte<EAutoReceiveInput::Type> AutoActivateForPlayer;                       // 0x0290 (size: 0x1)
    class UCameraComponent* CameraComponent;                                          // 0x0298 (size: 0x8)
    class USceneComponent* SceneComponent;                                            // 0x02A0 (size: 0x8)
    uint8 bConstrainAspectRatio;                                                      // 0x02A8 (size: 0x1)
    float AspectRatio;                                                                // 0x02AC (size: 0x4)
    float FOVAngle;                                                                   // 0x02B0 (size: 0x4)
    float PostProcessBlendWeight;                                                     // 0x02B4 (size: 0x4)
    FPostProcessSettings PostProcessSettings;                                         // 0x02C0 (size: 0x6F0)

    int32 GetAutoActivatePlayerIndex();
}; // Size: 0x9B0

class ACameraBlockingVolume : public AVolume
{
}; // Size: 0x2C8

class ACameraShakeSourceActor : public AActor
{
    class UCameraShakeSourceComponent* CameraShakeSourceComponent;                    // 0x0290 (size: 0x8)

}; // Size: 0x298

class ACharacter : public APawn
{
    class USkeletalMeshComponent* Mesh;                                               // 0x0318 (size: 0x8)
    class UCharacterMovementComponent* CharacterMovement;                             // 0x0320 (size: 0x8)
    class UCapsuleComponent* CapsuleComponent;                                        // 0x0328 (size: 0x8)
    FBasedMovementInfo BasedMovement;                                                 // 0x0330 (size: 0x50)
    FBasedMovementInfo ReplicatedBasedMovement;                                       // 0x0380 (size: 0x50)
    float AnimRootMotionTranslationScale;                                             // 0x03D0 (size: 0x4)
    FVector BaseTranslationOffset;                                                    // 0x03D8 (size: 0x18)
    FQuat BaseRotationOffset;                                                         // 0x03F0 (size: 0x20)
    float ReplicatedServerLastTransformUpdateTimeStamp;                               // 0x0410 (size: 0x4)
    float ReplayLastTransformUpdateTimeStamp;                                         // 0x0414 (size: 0x4)
    uint8 ReplicatedMovementMode;                                                     // 0x0418 (size: 0x1)
    FVector_NetQuantizeNormal ReplicatedGravityDirection;                             // 0x0420 (size: 0x18)
    bool bInBaseReplication;                                                          // 0x0438 (size: 0x1)
    float CrouchedEyeHeight;                                                          // 0x0458 (size: 0x4)
    uint8 bIsCrouched;                                                                // 0x045C (size: 0x1)
    uint8 bProxyIsJumpForceApplied;                                                   // 0x045C (size: 0x1)
    uint8 bPressedJump;                                                               // 0x045C (size: 0x1)
    uint8 bClientUpdating;                                                            // 0x045C (size: 0x1)
    uint8 bClientWasFalling;                                                          // 0x045C (size: 0x1)
    uint8 bClientResimulateRootMotion;                                                // 0x045C (size: 0x1)
    uint8 bClientResimulateRootMotionSources;                                         // 0x045C (size: 0x1)
    uint8 bSimGravityDisabled;                                                        // 0x045C (size: 0x1)
    uint8 bClientCheckEncroachmentOnNetUpdate;                                        // 0x045D (size: 0x1)
    uint8 bServerMoveIgnoreRootMotion;                                                // 0x045D (size: 0x1)
    uint8 bWasJumping;                                                                // 0x045D (size: 0x1)
    float JumpKeyHoldTime;                                                            // 0x0460 (size: 0x4)
    float JumpForceTimeRemaining;                                                     // 0x0464 (size: 0x4)
    float ProxyJumpForceStartedTime;                                                  // 0x0468 (size: 0x4)
    float JumpMaxHoldTime;                                                            // 0x046C (size: 0x4)
    int32 JumpMaxCount;                                                               // 0x0470 (size: 0x4)
    int32 JumpCurrentCount;                                                           // 0x0474 (size: 0x4)
    int32 JumpCurrentCountPreJump;                                                    // 0x0478 (size: 0x4)
    FCharacterOnReachedJumpApex OnReachedJumpApex;                                    // 0x0480 (size: 0x10)
    void CharacterReachedApexSignature();
    FCharacterLandedDelegate LandedDelegate;                                          // 0x0490 (size: 0x10)
    void LandedSignature(const FHitResult& hit);
    FCharacterMovementModeChangedDelegate MovementModeChangedDelegate;                // 0x04A0 (size: 0x10)
    void MovementModeChangedSignature(class ACharacter* Character, TEnumAsByte<EMovementMode> PrevMovementMode, uint8 PreviousCustomMode);
    FCharacterOnCharacterMovementUpdated OnCharacterMovementUpdated;                  // 0x04B0 (size: 0x10)
    void CharacterMovementUpdatedSignature(float DeltaSeconds, FVector OldLocation, FVector OldVelocity);
    FRootMotionSourceGroup SavedRootMotion;                                           // 0x04C0 (size: 0x48)
    FRootMotionMovementParams ClientRootMotionParams;                                 // 0x0510 (size: 0x70)
    TArray<FSimulatedRootMotionReplicatedMove> RootMotionRepMoves;                    // 0x0580 (size: 0x10)
    FRepRootMotionMontage RepRootMotion;                                              // 0x0590 (size: 0xD8)

    void UnCrouch(bool bClientSimulation);
    void StopJumping();
    void StopAnimMontage(class UAnimMontage* AnimMontage);
    void ServerMovePacked(const FCharacterServerMovePackedBits& PackedBits);
    void ServerMoveOld(float OldTimeStamp, FVector_NetQuantize10 OldAccel, uint8 OldMoveFlags);
    void ServerMoveNoBase(float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, uint8 ClientMovementMode);
    void ServerMoveDualNoBase(float TimeStamp0, FVector_NetQuantize10 InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, uint8 ClientMovementMode);
    void ServerMoveDualHybridRootMotion(float TimeStamp0, FVector_NetQuantize10 InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8 ClientMovementMode);
    void ServerMoveDual(float TimeStamp0, FVector_NetQuantize10 InAccel0, uint8 PendingFlags, uint32 View0, float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8 NewFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8 ClientMovementMode);
    void ServerMove(float Timestamp, FVector_NetQuantize10 InAccel, FVector_NetQuantize100 ClientLoc, uint8 CompressedMoveFlags, uint8 ClientRoll, uint32 View, class UPrimitiveComponent* ClientMovementBase, FName ClientBaseBoneName, uint8 ClientMovementMode);
    void RootMotionDebugClientPrintOnScreen(FString InString);
    float PlayAnimMontage(class UAnimMontage* AnimMontage, float InPlayRate, FName StartSectionName);
    void OnWalkingOffLedge(const FVector& PreviousFloorImpactNormal, const FVector& PreviousFloorContactNormal, const FVector& PreviousLocation, float TimeDelta);
    void OnRep_RootMotion();
    void OnRep_ReplicatedBasedMovement();
    void OnRep_ReplayLastTransformUpdateTimeStamp();
    void OnRep_IsCrouched();
    void OnLaunched(FVector LaunchVelocity, bool bXYOverride, bool bZOverride);
    void OnLanded(const FHitResult& hit);
    void OnJumped();
    void LaunchCharacter(FVector LaunchVelocity, bool bXYOverride, bool bZOverride);
    void K2_UpdateCustomMovement(float DeltaTime);
    void K2_OnStartCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
    void K2_OnMovementModeChanged(TEnumAsByte<EMovementMode> PrevMovementMode, TEnumAsByte<EMovementMode> NewMovementMode, uint8 PrevCustomMode, uint8 NewCustomMode);
    void K2_OnEndCrouch(float HalfHeightAdjust, float ScaledHalfHeightAdjust);
    void Jump();
    bool IsPlayingRootMotion();
    bool IsPlayingNetworkedRootMotionMontage();
    bool IsJumpProvidingForce();
    bool HasAnyRootMotion();
    class UAnimMontage* GetCurrentMontage();
    FVector GetBaseTranslationOffset();
    FRotator GetBaseRotationOffsetRotator();
    float GetAnimRootMotionTranslationScale();
    void Crouch(bool bClientSimulation);
    void ClientVeryShortAdjustPosition(float Timestamp, FVector NewLoc, class UPrimitiveComponent* NewBase, FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode);
    void ClientMoveResponsePacked(const FCharacterMoveResponsePackedBits& PackedBits);
    void ClientCheatWalk();
    void ClientCheatGhost();
    void ClientCheatFly();
    void ClientAdjustRootMotionSourcePosition(float Timestamp, FRootMotionSourceGroup ServerRootMotion, bool bHasAnimRootMotion, float ServerMontageTrackPosition, FVector ServerLoc, FVector_NetQuantizeNormal ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode);
    void ClientAdjustRootMotionPosition(float Timestamp, float ServerMontageTrackPosition, FVector ServerLoc, FVector_NetQuantizeNormal ServerRotation, float ServerVelZ, class UPrimitiveComponent* ServerBase, FName ServerBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode);
    void ClientAdjustPosition(float Timestamp, FVector NewLoc, FVector NewVel, class UPrimitiveComponent* NewBase, FName NewBaseBoneName, bool bHasBase, bool bBaseRelativePosition, uint8 ServerMovementMode);
    void ClientAckGoodMove(float Timestamp);
    bool CanJumpInternal();
    bool CanJump();
    bool CanCrouch();
    void CacheInitialMeshOffset(FVector MeshRelativeLocation, FRotator MeshRelativeRotation);
}; // Size: 0x670

class AClusterUnionActor : public AActor
{
    class UClusterUnionComponent* ClusterUnion;                                       // 0x0290 (size: 0x8)

    class UClusterUnionComponent* GetClusterUnionComponent();
}; // Size: 0x298

class AController : public AActor
{
    class APlayerState* PlayerState;                                                  // 0x0298 (size: 0x8)
    FControllerOnInstigatedAnyDamage OnInstigatedAnyDamage;                           // 0x02A8 (size: 0x10)
    void InstigatedAnyDamageSignature(float Damage, const class UDamageType* DamageType, class AActor* DamagedActor, class AActor* DamageCauser);
    FControllerOnPossessedPawnChanged OnPossessedPawnChanged;                         // 0x02B8 (size: 0x10)
    void OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn);
    FName StateName;                                                                  // 0x02C8 (size: 0x8)
    class APawn* Pawn;                                                                // 0x02D0 (size: 0x8)
    class ACharacter* Character;                                                      // 0x02E0 (size: 0x8)
    class USceneComponent* TransformComponent;                                        // 0x02E8 (size: 0x8)
    FRotator ControlRotation;                                                         // 0x0308 (size: 0x18)
    uint8 bAttachToPawn;                                                              // 0x0320 (size: 0x1)

    void UnPossess();
    void StopMovement();
    void SetInitialLocationAndRotation(const FVector& NewLocation, const FRotator& NewRotation);
    void SetIgnoreMoveInput(bool bNewMoveInput);
    void SetIgnoreLookInput(bool bNewLookInput);
    void SetControlRotation(const FRotator& NewRotation);
    void ResetIgnoreMoveInput();
    void ResetIgnoreLookInput();
    void ResetIgnoreInputFlags();
    void ReceiveUnPossess(class APawn* UnpossessedPawn);
    void ReceivePossess(class APawn* PossessedPawn);
    void ReceiveInstigatedAnyDamage(float Damage, const class UDamageType* DamageType, class AActor* DamagedActor, class AActor* DamageCauser);
    void Possess(class APawn* InPawn);
    void OnRep_PlayerState();
    void OnRep_Pawn();
    bool LineOfSightTo(const class AActor* Other, FVector ViewPoint, bool bAlternateChecks);
    class APawn* K2_GetPawn();
    bool IsPlayerController();
    bool IsMoveInputIgnored();
    bool IsLookInputIgnored();
    bool IsLocalPlayerController();
    bool IsLocalController();
    class AActor* GetViewTarget();
    void GetPlayerViewPoint(FVector& Location, FRotator& Rotation);
    FRotator GetDesiredRotation();
    FRotator GetControlRotation();
    void ClientSetRotation(FRotator NewRotation, bool bResetCamera);
    void ClientSetLocation(FVector NewLocation, FRotator NewRotation);
}; // Size: 0x328

class ACullDistanceVolume : public AVolume
{
    TArray<FCullDistanceSizePair> cullDistances;                                      // 0x02C8 (size: 0x10)
    uint8 bEnabled;                                                                   // 0x02D8 (size: 0x1)

}; // Size: 0x2E0

class ADEPRECATED_WorldPartitionVolume : public AVolume
{
}; // Size: 0x2C8

class ADebugCameraController : public APlayerController
{
    uint8 bShowSelectedInfo;                                                          // 0x0858 (size: 0x1)
    uint8 bIsFrozenRendering;                                                         // 0x0858 (size: 0x1)
    uint8 bIsOrbitingSelectedActor;                                                   // 0x0858 (size: 0x1)
    uint8 bOrbitPivotUseCenter;                                                       // 0x0858 (size: 0x1)
    uint8 bEnableBufferVisualization;                                                 // 0x0858 (size: 0x1)
    uint8 bEnableBufferVisualizationFullMode;                                         // 0x0858 (size: 0x1)
    uint8 bIsBufferVisualizationInputSetup;                                           // 0x0858 (size: 0x1)
    uint8 bLastDisplayEnabled;                                                        // 0x0858 (size: 0x1)
    class UDrawFrustumComponent* DrawFrustum;                                         // 0x0860 (size: 0x8)
    TWeakObjectPtr<class AActor> SelectedActor;                                       // 0x0868 (size: 0x8)
    TWeakObjectPtr<class UPrimitiveComponent> SelectedComponent;                      // 0x0870 (size: 0x8)
    FHitResult SelectedHitPoint;                                                      // 0x0878 (size: 0xF8)
    class APlayerController* OriginalControllerRef;                                   // 0x0970 (size: 0x8)
    class UPlayer* OriginalPlayer;                                                    // 0x0978 (size: 0x8)
    float SpeedScale;                                                                 // 0x0980 (size: 0x4)
    float InitialMaxSpeed;                                                            // 0x0984 (size: 0x4)
    float InitialAccel;                                                               // 0x0988 (size: 0x4)
    float InitialDecel;                                                               // 0x098C (size: 0x4)

    void ToggleDisplay();
    void ShowDebugSelectedInfo();
    void SetPawnMovementSpeedScale(float NewSpeedScale);
    void ReceiveOnDeactivate(class APlayerController* RestoredPC);
    void ReceiveOnActorSelected(class AActor* NewSelectedActor, const FVector& SelectHitLocation, const FVector& SelectHitNormal, const FHitResult& hit);
    void ReceiveOnActivate(class APlayerController* OriginalPC);
    class AActor* GetSelectedActor();
}; // Size: 0x9E8

class ADebugCameraHUD : public AHUD
{
}; // Size: 0x380

class ADecalActor : public AActor
{
    class UDecalComponent* Decal;                                                     // 0x0290 (size: 0x8)

    void SetDecalMaterial(class UMaterialInterface* NewDecalMaterial);
    class UMaterialInterface* GetDecalMaterial();
    class UMaterialInstanceDynamic* CreateDynamicMaterialInstance();
}; // Size: 0x298

class ADefaultPawn : public APawn
{
    float BaseTurnRate;                                                               // 0x0318 (size: 0x4)
    float BaseLookUpRate;                                                             // 0x031C (size: 0x4)
    class UPawnMovementComponent* MovementComponent;                                  // 0x0320 (size: 0x8)
    class USphereComponent* CollisionComponent;                                       // 0x0328 (size: 0x8)
    class UStaticMeshComponent* MeshComponent;                                        // 0x0330 (size: 0x8)
    uint8 bAddDefaultMovementBindings;                                                // 0x0338 (size: 0x1)

    void TurnAtRate(float Rate);
    void MoveUp_World(float Val);
    void MoveRight(float Val);
    void MoveForward(float Val);
    void LookUpAtRate(float Rate);
}; // Size: 0x340

class ADefaultPhysicsVolume : public APhysicsVolume
{
}; // Size: 0x2D8

class ADirectionalLight : public ALight
{
}; // Size: 0x2A0

class ADocumentationActor : public AActor
{
}; // Size: 0x298

class AEmitter : public AActor
{
    class UParticleSystemComponent* ParticleSystemComponent;                          // 0x0290 (size: 0x8)
    uint8 bDestroyOnSystemFinish;                                                     // 0x0298 (size: 0x1)
    uint8 bPostUpdateTickGroup;                                                       // 0x0298 (size: 0x1)
    uint8 bCurrentlyActive;                                                           // 0x0298 (size: 0x1)
    FEmitterOnParticleSpawn OnParticleSpawn;                                          // 0x02A0 (size: 0x10)
    void ParticleSpawnSignature(FName EventName, float EmitterTime, FVector Location, FVector Velocity);
    FEmitterOnParticleBurst OnParticleBurst;                                          // 0x02B0 (size: 0x10)
    void ParticleBurstSignature(FName EventName, float EmitterTime, int32 ParticleCount);
    FEmitterOnParticleDeath OnParticleDeath;                                          // 0x02C0 (size: 0x10)
    void ParticleDeathSignature(FName EventName, float EmitterTime, int32 ParticleTime, FVector Location, FVector Velocity, FVector Direction);
    FEmitterOnParticleCollide OnParticleCollide;                                      // 0x02D0 (size: 0x10)
    void ParticleCollisionSignature(FName EventName, float EmitterTime, int32 ParticleTime, FVector Location, FVector Velocity, FVector Direction, FVector Normal, FName BoneName, class UPhysicalMaterial* PhysMat);

    void ToggleActive();
    void SetVectorParameter(FName ParameterName, FVector Param);
    void SetTemplate(class UParticleSystem* NewTemplate);
    void SetMaterialParameter(FName ParameterName, class UMaterialInterface* Param);
    void SetFloatParameter(FName ParameterName, float Param);
    void SetColorParameter(FName ParameterName, FLinearColor Param);
    void SetActorParameter(FName ParameterName, class AActor* Param);
    void OnRep_bCurrentlyActive();
    void OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent);
    bool IsActive();
    void Deactivate();
    void Activate();
}; // Size: 0x2E0

class AEmitterCameraLensEffectBase : public AEmitter
{
    class UParticleSystem* PS_CameraEffect;                                           // 0x02E8 (size: 0x8)
    class APlayerCameraManager* BaseCamera;                                           // 0x02F0 (size: 0x8)
    FTransform RelativeTransform;                                                     // 0x0300 (size: 0x60)
    float BaseFOV;                                                                    // 0x0360 (size: 0x4)
    uint8 bAllowMultipleInstances;                                                    // 0x0364 (size: 0x1)
    uint8 bResetWhenRetriggered;                                                      // 0x0364 (size: 0x1)
    TArray<class TSubclassOf<AActor>> EmittersToTreatAsSame;                          // 0x0368 (size: 0x10)
    float DistFromCamera;                                                             // 0x0378 (size: 0x4)

}; // Size: 0x380

class AExponentialHeightFog : public AInfo
{
    class UExponentialHeightFogComponent* Component;                                  // 0x0290 (size: 0x8)
    uint8 bEnabled;                                                                   // 0x0298 (size: 0x1)

    void OnRep_bEnabled();
}; // Size: 0x2A0

class AGameMode : public AGameModeBase
{
    FName MatchState;                                                                 // 0x0328 (size: 0x8)
    uint8 bDelayedStart;                                                              // 0x0330 (size: 0x1)
    int32 NumSpectators;                                                              // 0x0334 (size: 0x4)
    int32 NumPlayers;                                                                 // 0x0338 (size: 0x4)
    int32 NumBots;                                                                    // 0x033C (size: 0x4)
    float MinRespawnDelay;                                                            // 0x0340 (size: 0x4)
    int32 NumTravellingPlayers;                                                       // 0x0344 (size: 0x4)
    TSubclassOf<class ULocalMessage> EngineMessageClass;                              // 0x0348 (size: 0x8)
    TArray<class APlayerState*> InactivePlayerArray;                                  // 0x0350 (size: 0x10)
    float InactivePlayerStateLifeSpan;                                                // 0x0360 (size: 0x4)
    int32 MaxInactivePlayers;                                                         // 0x0364 (size: 0x4)
    bool bHandleDedicatedServerReplays;                                               // 0x0368 (size: 0x1)

    void StartMatch();
    void Say(FString Msg);
    void RestartGame();
    bool ReadyToStartMatch();
    bool ReadyToEndMatch();
    void K2_OnSetMatchState(FName NewState);
    bool IsMatchInProgress();
    FName GetMatchState();
    void EndMatch();
    void AbortMatch();
}; // Size: 0x370

class AGameModeBase : public AInfo
{
    FString OptionsString;                                                            // 0x0290 (size: 0x10)
    TSubclassOf<class AGameSession> GameSessionClass;                                 // 0x02A0 (size: 0x8)
    TSubclassOf<class AGameStateBase> GameStateClass;                                 // 0x02A8 (size: 0x8)
    TSubclassOf<class APlayerController> PlayerControllerClass;                       // 0x02B0 (size: 0x8)
    TSubclassOf<class APlayerState> PlayerStateClass;                                 // 0x02B8 (size: 0x8)
    TSubclassOf<class AHUD> HUDClass;                                                 // 0x02C0 (size: 0x8)
    TSubclassOf<class APawn> DefaultPawnClass;                                        // 0x02C8 (size: 0x8)
    TSubclassOf<class ASpectatorPawn> SpectatorClass;                                 // 0x02D0 (size: 0x8)
    TSubclassOf<class APlayerController> ReplaySpectatorPlayerControllerClass;        // 0x02D8 (size: 0x8)
    TSubclassOf<class AServerStatReplicator> ServerStatReplicatorClass;               // 0x02E0 (size: 0x8)
    class AGameSession* GameSession;                                                  // 0x02E8 (size: 0x8)
    class AGameStateBase* GameState;                                                  // 0x02F0 (size: 0x8)
    class AServerStatReplicator* ServerStatReplicator;                                // 0x02F8 (size: 0x8)
    FText DefaultPlayerName;                                                          // 0x0300 (size: 0x10)
    uint8 bUseSeamlessTravel;                                                         // 0x0310 (size: 0x1)
    uint8 bStartPlayersAsSpectators;                                                  // 0x0310 (size: 0x1)
    uint8 bPauseable;                                                                 // 0x0310 (size: 0x1)
    EReplicationSystem GameNetDriverReplicationSystem;                                // 0x0314 (size: 0x1)

    void StartPlay();
    class APawn* SpawnDefaultPawnFor(class AController* NewPlayer, class AActor* StartSpot);
    class APawn* SpawnDefaultPawnAtTransform(class AController* NewPlayer, const FTransform& SpawnTransform);
    bool ShouldReset(class AActor* ActorToReset);
    void ReturnToMainMenuHost();
    void RestartPlayerAtTransform(class AController* NewPlayer, const FTransform& SpawnTransform);
    void RestartPlayerAtPlayerStart(class AController* NewPlayer, class AActor* StartSpot);
    void RestartPlayer(class AController* NewPlayer);
    void ResetLevel();
    bool PlayerCanRestart(class APlayerController* Player);
    bool MustSpectate(class APlayerController* NewPlayerController);
    void K2_PostLogin(class APlayerController* NewPlayer);
    void K2_OnSwapPlayerControllers(class APlayerController* OldPC, class APlayerController* NewPC);
    void K2_OnRestartPlayer(class AController* NewPlayer);
    void K2_OnLogout(class AController* ExitingController);
    void K2_OnChangeName(class AController* Other, FString NewName, bool bNameChange);
    class AActor* K2_FindPlayerStart(class AController* Player, FString IncomingName);
    void InitStartSpot(class AActor* StartSpot, class AController* NewPlayer);
    void InitializeHUDForPlayer(class APlayerController* NewPlayer);
    bool HasMatchStarted();
    bool HasMatchEnded();
    void HandleStartingNewPlayer(class APlayerController* NewPlayer);
    int32 GetNumSpectators();
    int32 GetNumPlayers();
    UClass* GetDefaultPawnClassForController(class AController* InController);
    class AActor* FindPlayerStart(class AController* Player, FString IncomingName);
    class AActor* ChoosePlayerStart(class AController* Player);
    void ChangeName(class AController* Controller, FString NewName, bool bNameChange);
    bool CanSpectate(class APlayerController* Viewer, class APlayerState* ViewTarget);
}; // Size: 0x328

class AGameNetworkManager : public AInfo
{
    float BadPacketLossThreshold;                                                     // 0x0290 (size: 0x4)
    float SeverePacketLossThreshold;                                                  // 0x0294 (size: 0x4)
    int32 BadPingThreshold;                                                           // 0x0298 (size: 0x4)
    int32 SeverePingThreshold;                                                        // 0x029C (size: 0x4)
    int32 AdjustedNetSpeed;                                                           // 0x02A0 (size: 0x4)
    float LastNetSpeedUpdateTime;                                                     // 0x02A4 (size: 0x4)
    int32 TotalNetBandwidth;                                                          // 0x02A8 (size: 0x4)
    int32 MinDynamicBandwidth;                                                        // 0x02AC (size: 0x4)
    int32 MaxDynamicBandwidth;                                                        // 0x02B0 (size: 0x4)
    uint8 bIsStandbyCheckingEnabled;                                                  // 0x02B4 (size: 0x1)
    uint8 bHasStandbyCheatTriggered;                                                  // 0x02B4 (size: 0x1)
    float StandbyRxCheatTime;                                                         // 0x02B8 (size: 0x4)
    float StandbyTxCheatTime;                                                         // 0x02BC (size: 0x4)
    float PercentMissingForRxStandby;                                                 // 0x02C0 (size: 0x4)
    float PercentMissingForTxStandby;                                                 // 0x02C4 (size: 0x4)
    float PercentForBadPing;                                                          // 0x02C8 (size: 0x4)
    float JoinInProgressStandbyWaitTime;                                              // 0x02CC (size: 0x4)
    float MoveRepSize;                                                                // 0x02D0 (size: 0x4)
    float MAXPOSITIONERRORSQUARED;                                                    // 0x02D4 (size: 0x4)
    float MAXNEARZEROVELOCITYSQUARED;                                                 // 0x02D8 (size: 0x4)
    float CLIENTADJUSTUPDATECOST;                                                     // 0x02DC (size: 0x4)
    float MAXCLIENTUPDATEINTERVAL;                                                    // 0x02E0 (size: 0x4)
    float MaxClientForcedUpdateDuration;                                              // 0x02E4 (size: 0x4)
    float ServerForcedUpdateHitchThreshold;                                           // 0x02E8 (size: 0x4)
    float ServerForcedUpdateHitchCooldown;                                            // 0x02EC (size: 0x4)
    float MaxMoveDeltaTime;                                                           // 0x02F0 (size: 0x4)
    float MaxClientSmoothingDeltaTime;                                                // 0x02F4 (size: 0x4)
    float ClientNetSendMoveDeltaTime;                                                 // 0x02F8 (size: 0x4)
    float ClientNetSendMoveDeltaTimeThrottled;                                        // 0x02FC (size: 0x4)
    float ClientNetSendMoveDeltaTimeStationary;                                       // 0x0300 (size: 0x4)
    int32 ClientNetSendMoveThrottleAtNetSpeed;                                        // 0x0304 (size: 0x4)
    int32 ClientNetSendMoveThrottleOverPlayerCount;                                   // 0x0308 (size: 0x4)
    float ClientErrorUpdateRateLimit;                                                 // 0x030C (size: 0x4)
    float ClientNetCamUpdateDeltaTime;                                                // 0x0310 (size: 0x4)
    float ClientNetCamUpdatePositionLimit;                                            // 0x0314 (size: 0x4)
    bool ClientAuthorativePosition;                                                   // 0x0318 (size: 0x1)
    bool bMovementTimeDiscrepancyDetection;                                           // 0x0319 (size: 0x1)
    bool bMovementTimeDiscrepancyResolution;                                          // 0x031A (size: 0x1)
    float MovementTimeDiscrepancyMaxTimeMargin;                                       // 0x031C (size: 0x4)
    float MovementTimeDiscrepancyMinTimeMargin;                                       // 0x0320 (size: 0x4)
    float MovementTimeDiscrepancyResolutionRate;                                      // 0x0324 (size: 0x4)
    float MovementTimeDiscrepancyDriftAllowance;                                      // 0x0328 (size: 0x4)
    bool bMovementTimeDiscrepancyForceCorrectionsDuringResolution;                    // 0x032C (size: 0x1)
    bool bUseDistanceBasedRelevancy;                                                  // 0x032D (size: 0x1)

}; // Size: 0x338

class AGameSession : public AInfo
{
    int32 MaxSpectators;                                                              // 0x0290 (size: 0x4)
    int32 MaxPlayers;                                                                 // 0x0294 (size: 0x4)
    int32 MaxPartySize;                                                               // 0x0298 (size: 0x4)
    uint8 MaxSplitscreensPerConnection;                                               // 0x029C (size: 0x1)
    bool bRequiresPushToTalk;                                                         // 0x029D (size: 0x1)
    FName SessionName;                                                                // 0x02A0 (size: 0x8)

}; // Size: 0x2B8

class AGameState : public AGameStateBase
{
    FName MatchState;                                                                 // 0x02E8 (size: 0x8)
    FName PreviousMatchState;                                                         // 0x02F0 (size: 0x8)
    int32 ElapsedTime;                                                                // 0x02F8 (size: 0x4)

    void OnRep_MatchState();
    void OnRep_ElapsedTime();
}; // Size: 0x308

class AGameStateBase : public AInfo
{
    TSubclassOf<class AGameModeBase> GameModeClass;                                   // 0x0290 (size: 0x8)
    class AGameModeBase* AuthorityGameMode;                                           // 0x0298 (size: 0x8)
    TSubclassOf<class ASpectatorPawn> SpectatorClass;                                 // 0x02A0 (size: 0x8)
    TArray<class APlayerState*> PlayerArray;                                          // 0x02A8 (size: 0x10)
    bool bReplicatedHasBegunPlay;                                                     // 0x02B8 (size: 0x1)
    float ReplicatedWorldTimeSeconds;                                                 // 0x02BC (size: 0x4)
    double ReplicatedWorldTimeSecondsDouble;                                          // 0x02C0 (size: 0x8)
    float ServerWorldTimeSecondsDelta;                                                // 0x02C8 (size: 0x4)
    float ServerWorldTimeSecondsUpdateFrequency;                                      // 0x02CC (size: 0x4)

    void OnRep_SpectatorClass();
    void OnRep_ReplicatedWorldTimeSecondsDouble();
    void OnRep_ReplicatedWorldTimeSeconds();
    void OnRep_ReplicatedHasBegunPlay();
    void OnRep_GameModeClass();
    bool HasMatchStarted();
    bool HasMatchEnded();
    bool HasBegunPlay();
    double GetServerWorldTimeSeconds();
    float GetPlayerStartTime(class AController* Controller);
    float GetPlayerRespawnDelay(class AController* Controller);
}; // Size: 0x2E8

class AGeneratedMeshAreaLight : public ASpotLight
{
}; // Size: 0x2A8

class AHUD : public AActor
{
    class APlayerController* PlayerOwner;                                             // 0x0290 (size: 0x8)
    uint8 bLostFocusPaused;                                                           // 0x0298 (size: 0x1)
    uint8 bShowHUD;                                                                   // 0x0298 (size: 0x1)
    uint8 bShowDebugInfo;                                                             // 0x0298 (size: 0x1)
    int32 CurrentTargetIndex;                                                         // 0x029C (size: 0x4)
    uint8 bShowHitBoxDebugInfo;                                                       // 0x02A0 (size: 0x1)
    uint8 bShowOverlays;                                                              // 0x02A0 (size: 0x1)
    uint8 bEnableDebugTextShadow;                                                     // 0x02A0 (size: 0x1)
    TArray<class AActor*> PostRenderedActors;                                         // 0x02A8 (size: 0x10)
    TArray<FName> DebugDisplay;                                                       // 0x02C0 (size: 0x10)
    TArray<FName> ToggledDebugCategories;                                             // 0x02D0 (size: 0x10)
    class UCanvas* Canvas;                                                            // 0x02E0 (size: 0x8)
    class UCanvas* DebugCanvas;                                                       // 0x02E8 (size: 0x8)
    TArray<FDebugTextInfo> DebugTextList;                                             // 0x02F0 (size: 0x10)
    TSubclassOf<class AActor> ShowDebugTargetDesiredClass;                            // 0x0300 (size: 0x8)
    class AActor* ShowDebugTargetActor;                                               // 0x0308 (size: 0x8)

    void ShowHUD();
    void ShowDebugToggleSubCategory(FName Category);
    void ShowDebugForReticleTargetToggle(TSubclassOf<class AActor> DesiredClass);
    void ShowDebug(FName DebugType);
    void RemoveDebugText(class AActor* SrcActor, bool bLeaveDurationText);
    void RemoveAllDebugStrings();
    void ReceiveHitBoxRelease(const FName BoxName);
    void ReceiveHitBoxEndCursorOver(const FName BoxName);
    void ReceiveHitBoxClick(const FName BoxName);
    void ReceiveHitBoxBeginCursorOver(const FName BoxName);
    void ReceiveDrawHUD(int32 SizeX, int32 SizeY);
    FVector Project(FVector Location, bool bClampToZeroPlane);
    void PreviousDebugTarget();
    void NextDebugTarget();
    void GetTextSize(FString Text, float& OutWidth, float& OutHeight, class UFont* Font, float Scale);
    class APlayerController* GetOwningPlayerController();
    class APawn* GetOwningPawn();
    void GetActorsInSelectionRectangle(TSubclassOf<class AActor> ClassFilter, const FVector2D& FirstPoint, const FVector2D& SecondPoint, TArray<class AActor*>& OutActors, bool bIncludeNonCollidingComponents, bool bActorMustBeFullyEnclosed);
    void DrawTextureSimple(class UTexture* Texture, float ScreenX, float ScreenY, float Scale, bool bScalePosition);
    void DrawTexture(class UTexture* Texture, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float TextureU, float TextureV, float TextureUWidth, float TextureVHeight, FLinearColor TintColor, TEnumAsByte<EBlendMode> BlendMode, float Scale, bool bScalePosition, float Rotation, FVector2D RotPivot);
    void DrawText(FString Text, FLinearColor TextColor, float ScreenX, float ScreenY, class UFont* Font, float Scale, bool bScalePosition);
    void DrawRect(FLinearColor RectColor, float ScreenX, float ScreenY, float ScreenW, float ScreenH);
    void DrawMaterialTriangle(class UMaterialInterface* Material, FVector2D V0_Pos, FVector2D V1_Pos, FVector2D V2_Pos, FVector2D V0_UV, FVector2D V1_UV, FVector2D V2_UV, FLinearColor V0_Color, FLinearColor V1_Color, FLinearColor V2_Color);
    void DrawMaterialSimple(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float Scale, bool bScalePosition);
    void DrawMaterial(class UMaterialInterface* Material, float ScreenX, float ScreenY, float ScreenW, float ScreenH, float MaterialU, float MaterialV, float MaterialUWidth, float MaterialVHeight, float Scale, bool bScalePosition, float Rotation, FVector2D RotPivot);
    void DrawLine(float StartScreenX, float StartScreenY, float EndScreenX, float EndScreenY, FLinearColor LineColor, float LineThickness);
    void Deproject(float ScreenX, float ScreenY, FVector& WorldPosition, FVector& WorldDirection);
    void AddHitBox(FVector2D Position, FVector2D Size, FName InName, bool bConsumesInput, int32 Priority);
    void AddDebugText(FString DebugText, class AActor* SrcActor, float Duration, FVector Offset, FVector DesiredOffset, FColor TextColor, bool bSkipOverwriteCheck, bool bAbsoluteLocation, bool bKeepAttachedToActor, class UFont* InFont, float FontScale, bool bDrawShadow);
}; // Size: 0x380

class AHeterogeneousVolume : public AInfo
{
    class UHeterogeneousVolumeComponent* HeterogeneousVolumeComponent;                // 0x0290 (size: 0x8)

}; // Size: 0x298

class AISMPartitionActor : public APartitionActor
{
}; // Size: 0x2A0

class AInfo : public AActor
{
}; // Size: 0x290

class AInstancedPlacementPartitionActor : public AISMPartitionActor
{
}; // Size: 0x2A0

class AKillZVolume : public APhysicsVolume
{
}; // Size: 0x2D8

class ALODActor : public AActor
{
    class UStaticMeshComponent* StaticMeshComponent;                                  // 0x0290 (size: 0x8)
    TMap<class FHLODInstancingKey, class UInstancedStaticMeshComponent*> InstancedStaticMeshComponents; // 0x0298 (size: 0x50)
    class UHLODProxy* Proxy;                                                          // 0x02E8 (size: 0x8)
    FName Key;                                                                        // 0x02F0 (size: 0x8)
    float LODDrawDistance;                                                            // 0x02F8 (size: 0x4)
    int32 LODLevel;                                                                   // 0x02FC (size: 0x4)
    TArray<class AActor*> SubActors;                                                  // 0x0300 (size: 0x10)
    uint8 CachedNumHLODLevels;                                                        // 0x0310 (size: 0x1)

    void OnSubActorEndPlay(class AActor* Actor, TEnumAsByte<EEndPlayReason::Type> Reason);
}; // Size: 0x318

class ALevelBounds : public AActor
{
    class UBoxComponent* BoxComponent;                                                // 0x0290 (size: 0x8)
    bool bAutoUpdateBounds;                                                           // 0x0298 (size: 0x1)

}; // Size: 0x2A0

class ALevelInstance : public AActor
{
    class ULevelInstanceComponent* LevelInstanceComponent;                            // 0x0298 (size: 0x8)
    TSoftObjectPtr<UWorld> CookedWorldAsset;                                          // 0x02A0 (size: 0x28)
    FGuid LevelInstanceSpawnGuid;                                                     // 0x02C8 (size: 0x10)

    void OnRep_LevelInstanceSpawnGuid();
}; // Size: 0x330

class ALevelInstanceEditorInstanceActor : public AActor
{
}; // Size: 0x290

class ALevelInstancePivot : public AActor
{
}; // Size: 0x298

class ALevelScriptActor : public AActor
{
    uint8 bInputEnabled;                                                              // 0x0290 (size: 0x1)

    void WorldOriginLocationChanged(FIntVector OldOriginLocation, FIntVector NewOriginLocation);
    void setCinematicMode(bool bCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning);
    bool RemoteEvent(FName EventName);
    void LevelReset();
}; // Size: 0x298

class ALevelStreamingVolume : public AVolume
{
    TArray<FName> StreamingLevelNames;                                                // 0x02C8 (size: 0x10)
    uint8 bEditorPreVisOnly;                                                          // 0x02D8 (size: 0x1)
    uint8 bDisabled;                                                                  // 0x02D8 (size: 0x1)
    TEnumAsByte<EStreamingVolumeUsage> StreamingUsage;                                // 0x02DC (size: 0x1)

}; // Size: 0x2E0

class ALight : public AActor
{
    class ULightComponent* LightComponent;                                            // 0x0290 (size: 0x8)
    uint8 bEnabled;                                                                   // 0x0298 (size: 0x1)

    void ToggleEnabled();
    void SetLightFunctionScale(FVector NewLightFunctionScale);
    void SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial);
    void SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance);
    void SetLightColor(FLinearColor NewLightColor);
    void SetEnabled(bool bSetEnabled);
    void SetCastShadows(bool bNewValue);
    void SetBrightness(float NewBrightness);
    void SetAffectTranslucentLighting(bool bNewValue);
    void OnRep_bEnabled();
    bool IsEnabled();
    FLinearColor GetLightColor();
    float GetBrightness();
}; // Size: 0x2A0

class ALightWeightInstanceManager : public AActor
{
    TSubclassOf<class AActor> RepresentedClass;                                       // 0x02A8 (size: 0x8)
    TSubclassOf<class AActor> AcceptedClass;                                          // 0x02B0 (size: 0x8)
    TArray<FTransform> InstanceTransforms;                                            // 0x02B8 (size: 0x10)
    TMap<int32, AActor*> Actors;                                                      // 0x02C8 (size: 0x50)
    TArray<int32> FreeIndices;                                                        // 0x0328 (size: 0x10)
    TArray<bool> ValidIndices;                                                        // 0x0338 (size: 0x10)

    void OnSpawnedActorDestroyed(class AActor* DestroyedActor);
    void OnRep_Transforms();
}; // Size: 0x348

class ALightWeightInstanceStaticMeshManager : public ALightWeightInstanceManager
{
    TSoftObjectPtr<UStaticMesh> StaticMesh;                                           // 0x0350 (size: 0x28)
    class UInstancedStaticMeshComponent* ISMComponent;                                // 0x0378 (size: 0x8)
    TArray<int32> RenderingIndicesToDataIndices;                                      // 0x0380 (size: 0x10)
    TArray<int32> DataIndicesToRenderingIndices;                                      // 0x0390 (size: 0x10)

    void OnRep_StaticMesh();
}; // Size: 0x3B0

class ALightmassCharacterIndirectDetailVolume : public AVolume
{
}; // Size: 0x2C8

class ALightmassImportanceVolume : public AVolume
{
}; // Size: 0x2C8

class ALightmassPortal : public AActor
{
    class ULightmassPortalComponent* PortalComponent;                                 // 0x0290 (size: 0x8)

}; // Size: 0x298

class ALocalFogVolume : public AInfo
{
    class ULocalFogVolumeComponent* LocalFogVolumeVolume;                             // 0x0290 (size: 0x8)

}; // Size: 0x298

class ALocationVolume : public AVolume
{
    FColor DebugColor;                                                                // 0x02D0 (size: 0x4)

    void Unload();
    void Load();
    bool IsLoaded();
}; // Size: 0x2D8

class AMaterialInstanceActor : public AActor
{
    TArray<class AActor*> TargetActors;                                               // 0x0290 (size: 0x10)

}; // Size: 0x2A0

class AMeshMergeCullingVolume : public AVolume
{
}; // Size: 0x2C8

class ANavigationDataChunkActor : public APartitionActor
{
    TArray<class UNavigationDataChunk*> NavDataChunks;                                // 0x0290 (size: 0x10)
    FBox DataChunkActorBounds;                                                        // 0x02A0 (size: 0x38)

}; // Size: 0x2D8

class ANavigationObjectBase : public AActor
{
    class UCapsuleComponent* CapsuleComponent;                                        // 0x0298 (size: 0x8)
    class UBillboardComponent* GoodSprite;                                            // 0x02A0 (size: 0x8)
    class UBillboardComponent* BadSprite;                                             // 0x02A8 (size: 0x8)
    uint8 bIsPIEPlayerStart;                                                          // 0x02B0 (size: 0x1)

}; // Size: 0x2B8

class ANote : public AActor
{
}; // Size: 0x290

class APackedLevelActor : public ALevelInstance
{
}; // Size: 0x330

class APainCausingVolume : public APhysicsVolume
{
    uint8 bPainCausing;                                                               // 0x02D8 (size: 0x1)
    float DamagePerSec;                                                               // 0x02DC (size: 0x4)
    TSubclassOf<class UDamageType> DamageType;                                        // 0x02E0 (size: 0x8)
    float PainInterval;                                                               // 0x02E8 (size: 0x4)
    uint8 bEntryPain;                                                                 // 0x02EC (size: 0x1)
    uint8 BACKUP_bPainCausing;                                                        // 0x02EC (size: 0x1)
    class AController* DamageInstigator;                                              // 0x02F0 (size: 0x8)

}; // Size: 0x300

class AParticleEventManager : public AActor
{
}; // Size: 0x290

class APartitionActor : public AActor
{
}; // Size: 0x290

class APawn : public AActor
{
    uint8 bUseControllerRotationPitch;                                                // 0x0298 (size: 0x1)
    uint8 bUseControllerRotationYaw;                                                  // 0x0298 (size: 0x1)
    uint8 bUseControllerRotationRoll;                                                 // 0x0298 (size: 0x1)
    uint8 bCanAffectNavigationGeneration;                                             // 0x0298 (size: 0x1)
    uint8 bIsLocalViewTarget;                                                         // 0x0298 (size: 0x1)
    float BaseEyeHeight;                                                              // 0x029C (size: 0x4)
    TEnumAsByte<EAutoReceiveInput::Type> AutoPossessPlayer;                           // 0x02A0 (size: 0x1)
    EAutoPossessAI AutoPossessAI;                                                     // 0x02A1 (size: 0x1)
    uint8 RemoteViewPitch;                                                            // 0x02A2 (size: 0x1)
    TSubclassOf<class AController> AIControllerClass;                                 // 0x02A8 (size: 0x8)
    class APlayerState* PlayerState;                                                  // 0x02B0 (size: 0x8)
    class AController* LastHitBy;                                                     // 0x02C0 (size: 0x8)
    class AController* Controller;                                                    // 0x02C8 (size: 0x8)
    class AController* PreviousController;                                            // 0x02D0 (size: 0x8)
    FPawnReceiveControllerChangedDelegate ReceiveControllerChangedDelegate;           // 0x02DC (size: 0x1)
    void PawnControllerChangedSignature(class APawn* Pawn, class AController* OldController, class AController* NewController);
    FPawnReceiveRestartedDelegate ReceiveRestartedDelegate;                           // 0x02DD (size: 0x1)
    void PawnRestartedSignature(class APawn* Pawn);
    FVector ControlInputVector;                                                       // 0x02E0 (size: 0x18)
    FVector LastControlInputVector;                                                   // 0x02F8 (size: 0x18)
    TSubclassOf<class UInputComponent> OverrideInputComponentClass;                   // 0x0310 (size: 0x8)

    void SpawnDefaultController();
    void SetCanAffectNavigationGeneration(bool bNewValue, bool bForceUpdate);
    void ReceiveUnpossessed(class AController* OldController);
    void ReceiveRestarted();
    void ReceivePossessed(class AController* NewController);
    void ReceiveControllerChanged(class AController* OldController, class AController* NewController);
    void PawnMakeNoise(float Loudness, FVector NoiseLocation, bool bUseNoiseMakerLocation, class AActor* NoiseMaker);
    void OnRep_PlayerState();
    void OnRep_Controller();
    bool IsPlayerControlled();
    bool IsPawnControlled();
    bool IsMoveInputIgnored();
    bool IsLocallyViewed();
    bool IsLocallyControlled();
    bool IsControlled();
    bool IsBotControlled();
    FPlatformUserId GetPlatformUserId();
    FVector GetPendingMovementInputVector();
    TSubclassOf<class UInputComponent> GetOverrideInputComponentClass();
    FVector GetNavAgentLocation();
    class UPawnMovementComponent* GetMovementComponent();
    class AActor* GetMovementBaseActor(const class APawn* Pawn);
    class APlayerController* GetLocalViewingPlayerController();
    FVector GetLastMovementInputVector();
    FRotator GetControlRotation();
    class AController* GetController();
    FRotator GetBaseAimRotation();
    void DetachFromControllerPendingDestroy();
    FVector ConsumeMovementInputVector();
    void AddMovementInput(FVector WorldDirection, float ScaleValue, bool bForce);
    void AddControllerYawInput(float Val);
    void AddControllerRollInput(float Val);
    void AddControllerPitchInput(float Val);
}; // Size: 0x318

class APhysicsConstraintActor : public ARigidBodyBase
{
    class UPhysicsConstraintComponent* ConstraintComp;                                // 0x0290 (size: 0x8)
    class AActor* ConstraintActor1;                                                   // 0x0298 (size: 0x8)
    class AActor* ConstraintActor2;                                                   // 0x02A0 (size: 0x8)
    uint8 bDisableCollision;                                                          // 0x02A8 (size: 0x1)

}; // Size: 0x2B0

class APhysicsThruster : public ARigidBodyBase
{
    class UPhysicsThrusterComponent* ThrusterComponent;                               // 0x0290 (size: 0x8)

}; // Size: 0x298

class APhysicsVolume : public AVolume
{
    float TerminalVelocity;                                                           // 0x02C8 (size: 0x4)
    int32 Priority;                                                                   // 0x02CC (size: 0x4)
    float FluidFriction;                                                              // 0x02D0 (size: 0x4)
    uint8 bWaterVolume;                                                               // 0x02D4 (size: 0x1)
    uint8 bPhysicsOnContact;                                                          // 0x02D4 (size: 0x1)

}; // Size: 0x2D8

class APlanarReflection : public ASceneCapture
{
    class UPlanarReflectionComponent* PlanarReflectionComponent;                      // 0x02A0 (size: 0x8)
    bool bShowPreviewPlane;                                                           // 0x02A8 (size: 0x1)

    void OnInterpToggle(bool bEnable);
}; // Size: 0x2B0

class APlaneReflectionCapture : public AReflectionCapture
{
}; // Size: 0x298

class APlayerCameraManager : public AActor
{
    class APlayerController* PCOwner;                                                 // 0x0290 (size: 0x8)
    class USceneComponent* TransformComponent;                                        // 0x0298 (size: 0x8)
    float DefaultFOV;                                                                 // 0x02A8 (size: 0x4)
    float DefaultOrthoWidth;                                                          // 0x02B0 (size: 0x4)
    float DefaultAspectRatio;                                                         // 0x02B8 (size: 0x4)
    FTViewTarget ViewTarget;                                                          // 0x0320 (size: 0x820)
    FTViewTarget PendingViewTarget;                                                   // 0x0B40 (size: 0x820)
    FCameraCacheEntry CameraCachePrivate;                                             // 0x1390 (size: 0x810)
    FCameraCacheEntry LastFrameCameraCachePrivate;                                    // 0x1BA0 (size: 0x810)
    TArray<class UCameraModifier*> ModifierList;                                      // 0x23B0 (size: 0x10)
    TArray<class TSubclassOf<UCameraModifier>> DefaultModifiers;                      // 0x23C0 (size: 0x10)
    float FreeCamDistance;                                                            // 0x23D0 (size: 0x4)
    FVector FreeCamOffset;                                                            // 0x23D8 (size: 0x18)
    FVector ViewTargetOffset;                                                         // 0x23F0 (size: 0x18)
    FPlayerCameraManagerOnAudioFadeChangeEvent OnAudioFadeChangeEvent;                // 0x2408 (size: 0x10)
    void OnAudioFadeChangeSignature(bool bFadeOut, float FadeTime);
    TArray<TScriptInterface<ICameraLensEffectInterface>> CameraLensEffects;           // 0x2430 (size: 0x10)
    class UCameraModifier_CameraShake* CachedCameraShakeMod;                          // 0x2440 (size: 0x8)
    TArray<FPostProcessSettings> PostProcessBlendCache;                               // 0x2448 (size: 0x10)
    class ACameraActor* AnimCameraActor;                                              // 0x2478 (size: 0x8)
    uint8 bIsOrthographic;                                                            // 0x2480 (size: 0x1)
    uint8 bAutoCalculateOrthoPlanes;                                                  // 0x2480 (size: 0x1)
    float AutoPlaneShift;                                                             // 0x2484 (size: 0x4)
    uint8 bUpdateOrthoPlanes;                                                         // 0x2488 (size: 0x1)
    uint8 bUseCameraHeightAsViewTarget;                                               // 0x2488 (size: 0x1)
    uint8 bDefaultConstrainAspectRatio;                                               // 0x2488 (size: 0x1)
    uint8 bClientSimulatingViewTarget;                                                // 0x2488 (size: 0x1)
    uint8 bUseClientSideCameraUpdates;                                                // 0x2489 (size: 0x1)
    uint8 bGameCameraCutThisFrame;                                                    // 0x2489 (size: 0x1)
    float ViewPitchMin;                                                               // 0x248C (size: 0x4)
    float ViewPitchMax;                                                               // 0x2490 (size: 0x4)
    float ViewYawMin;                                                                 // 0x2494 (size: 0x4)
    float ViewYawMax;                                                                 // 0x2498 (size: 0x4)
    float ViewRollMin;                                                                // 0x249C (size: 0x4)
    float ViewRollMax;                                                                // 0x24A0 (size: 0x4)
    float ServerUpdateCameraTimeout;                                                  // 0x24A8 (size: 0x4)

    void SwapPendingViewTargetWhenUsingClientSideCameraUpdates();
    void StopCameraShake(class UCameraShakeBase* ShakeInstance, bool bImmediately);
    void StopCameraFade();
    void StopAllInstancesOfCameraShakeFromSource(TSubclassOf<class UCameraShakeBase> Shake, class UCameraShakeSourceComponent* SourceComponent, bool bImmediately);
    void StopAllInstancesOfCameraShake(TSubclassOf<class UCameraShakeBase> Shake, bool bImmediately);
    void StopAllCameraShakesFromSource(class UCameraShakeSourceComponent* SourceComponent, bool bImmediately);
    void StopAllCameraShakes(bool bImmediately);
    class UCameraShakeBase* StartCameraShakeFromSource(TSubclassOf<class UCameraShakeBase> ShakeClass, class UCameraShakeSourceComponent* SourceComponent, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    class UCameraShakeBase* StartCameraShake(TSubclassOf<class UCameraShakeBase> ShakeClass, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    void StartCameraFade(float FromAlpha, float ToAlpha, float Duration, FLinearColor Color, bool bShouldFadeAudio, bool bHoldWhenFinished);
    void SetManualCameraFade(float InFadeAmount, FLinearColor Color, bool bInFadeAudio);
    void SetGameCameraCutThisFrame();
    void RemoveGenericCameraLensEffect(TScriptInterface<class ICameraLensEffectInterface> Emitter);
    bool RemoveCameraModifier(class UCameraModifier* ModifierToRemove);
    void RemoveCameraLensEffect(class AEmitterCameraLensEffectBase* Emitter);
    void PhotographyCameraModify(const FVector NewCameraLocation, const FVector PreviousCameraLocation, const FVector OriginalCameraLocation, FVector& ResultCameraLocation);
    void OnPhotographySessionStart();
    void OnPhotographySessionEnd();
    void OnPhotographyMultiPartCaptureStart();
    void OnPhotographyMultiPartCaptureEnd();
    class APlayerController* GetOwningPlayerController();
    float GetFOVAngle();
    FRotator GetCameraRotation();
    FVector GetCameraLocation();
    class UCameraModifier* FindCameraModifierByClass(TSubclassOf<class UCameraModifier> ModifierClass);
    void ClearCameraLensEffects();
    bool BlueprintUpdateCamera(class AActor* CameraTarget, FVector& NewCameraLocation, FRotator& NewCameraRotation, float& NewCameraFOV);
    class UCameraModifier* AddNewCameraModifier(TSubclassOf<class UCameraModifier> ModifierClass);
    TScriptInterface<class ICameraLensEffectInterface> AddGenericCameraLensEffect(TSubclassOf<class AActor> LensEffectEmitterClass);
    class AEmitterCameraLensEffectBase* AddCameraLensEffect(TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass);
}; // Size: 0x24C0

class APlayerController : public AController
{
    class UPlayer* Player;                                                            // 0x0330 (size: 0x8)
    class APawn* AcknowledgedPawn;                                                    // 0x0338 (size: 0x8)
    class AHUD* MyHUD;                                                                // 0x0340 (size: 0x8)
    class APlayerCameraManager* PlayerCameraManager;                                  // 0x0348 (size: 0x8)
    TSubclassOf<class APlayerCameraManager> PlayerCameraManagerClass;                 // 0x0350 (size: 0x8)
    bool bAutoManageActiveCameraTarget;                                               // 0x0358 (size: 0x1)
    FRotator TargetViewRotation;                                                      // 0x0360 (size: 0x18)
    float SmoothTargetViewRotationSpeed;                                              // 0x0390 (size: 0x4)
    TArray<class AActor*> HiddenActors;                                               // 0x0398 (size: 0x10)
    TArray<TWeakObjectPtr<UPrimitiveComponent>> HiddenPrimitiveComponents;            // 0x03A8 (size: 0x10)
    float LastSpectatorStateSynchTime;                                                // 0x03BC (size: 0x4)
    FVector LastSpectatorSyncLocation;                                                // 0x03C0 (size: 0x18)
    FRotator LastSpectatorSyncRotation;                                               // 0x03D8 (size: 0x18)
    int32 ClientCap;                                                                  // 0x03F0 (size: 0x4)
    class UCheatManager* CheatManager;                                                // 0x03F8 (size: 0x8)
    TSubclassOf<class UCheatManager> CheatClass;                                      // 0x0400 (size: 0x8)
    class UPlayerInput* PlayerInput;                                                  // 0x0408 (size: 0x8)
    TArray<FActiveForceFeedbackEffect> ActiveForceFeedbackEffects;                    // 0x0410 (size: 0x10)
    TSubclassOf<class UAsyncPhysicsData> AsyncPhysicsDataClass;                       // 0x0420 (size: 0x8)
    class UAsyncPhysicsInputComponent* AsyncPhysicsDataComponent_DEPRECARED;          // 0x0428 (size: 0x8)
    uint8 bPlayerIsWaiting;                                                           // 0x04B0 (size: 0x1)
    uint8 NetPlayerIndex;                                                             // 0x04B4 (size: 0x1)
    class UNetConnection* PendingSwapConnection;                                      // 0x0510 (size: 0x8)
    class UNetConnection* NetConnection;                                              // 0x0518 (size: 0x8)
    float InputYawScale;                                                              // 0x0538 (size: 0x4)
    float InputPitchScale;                                                            // 0x053C (size: 0x4)
    float InputRollScale;                                                             // 0x0540 (size: 0x4)
    uint8 bShowMouseCursor;                                                           // 0x0544 (size: 0x1)
    uint8 bEnableClickEvents;                                                         // 0x0544 (size: 0x1)
    uint8 bEnableTouchEvents;                                                         // 0x0544 (size: 0x1)
    uint8 bEnableMouseOverEvents;                                                     // 0x0544 (size: 0x1)
    uint8 bEnableTouchOverEvents;                                                     // 0x0544 (size: 0x1)
    uint8 bForceFeedbackEnabled;                                                      // 0x0544 (size: 0x1)
    uint8 bEnableMotionControls;                                                      // 0x0544 (size: 0x1)
    uint8 bEnableStreamingSource;                                                     // 0x0544 (size: 0x1)
    uint8 bStreamingSourceShouldActivate;                                             // 0x0545 (size: 0x1)
    uint8 bStreamingSourceShouldBlockOnSlowStreaming;                                 // 0x0545 (size: 0x1)
    EStreamingSourcePriority StreamingSourcePriority;                                 // 0x0548 (size: 0x1)
    FColor StreamingSourceDebugColor;                                                 // 0x054C (size: 0x4)
    TArray<FStreamingSourceShape> StreamingSourceShapes;                              // 0x0550 (size: 0x10)
    float ForceFeedbackScale;                                                         // 0x0560 (size: 0x4)
    TArray<FKey> ClickEventKeys;                                                      // 0x0568 (size: 0x10)
    TEnumAsByte<EMouseCursor::Type> DefaultMouseCursor;                               // 0x0578 (size: 0x1)
    TEnumAsByte<EMouseCursor::Type> CurrentMouseCursor;                               // 0x0579 (size: 0x1)
    TEnumAsByte<ECollisionChannel> DefaultClickTraceChannel;                          // 0x057A (size: 0x1)
    TEnumAsByte<ECollisionChannel> CurrentClickTraceChannel;                          // 0x057B (size: 0x1)
    float HitResultTraceDistance;                                                     // 0x057C (size: 0x4)
    uint16 SeamlessTravelCount;                                                       // 0x0580 (size: 0x2)
    uint16 LastCompletedSeamlessTravelCount;                                          // 0x0582 (size: 0x2)
    class UInputComponent* InactiveStateInputComponent;                               // 0x0608 (size: 0x8)
    uint8 bShouldPerformFullTickWhenPaused;                                           // 0x0610 (size: 0x1)
    class UTouchInterface* CurrentTouchInterface;                                     // 0x0628 (size: 0x8)
    TSubclassOf<class UPlayerInput> OverridePlayerInputClass;                         // 0x0630 (size: 0x8)
    class ASpectatorPawn* SpectatorPawn;                                              // 0x06B0 (size: 0x8)
    bool bIsLocalPlayerController;                                                    // 0x06BC (size: 0x1)
    FVector SpawnLocation;                                                            // 0x06C0 (size: 0x18)

    bool WasInputKeyJustReleased(FKey Key);
    bool WasInputKeyJustPressed(FKey Key);
    void ToggleSpeaking(bool bInSpeaking);
    void TestServerLevelVisibilityChange(const FName PackageName, const FName Filename);
    void SwitchLevel(FString URL);
    bool StreamingSourceShouldBlockOnSlowStreaming();
    bool StreamingSourceShouldActivate();
    void StopHapticEffect(EControllerHand hand);
    void StartFire(uint8 FireModeNum);
    void SetVirtualJoystickVisibility(bool bVisible);
    void SetViewTargetWithBlend(class AActor* NewViewTarget, float BlendTime, TEnumAsByte<EViewTargetBlendFunction> BlendFunc, float BlendExp, bool bLockOutgoing);
    void SetName(FString S);
    void SetMouseLocation(const int32 X, const int32 Y);
    void SetMouseCursorWidget(TEnumAsByte<EMouseCursor::Type> Cursor, class UUserWidget* CursorWidget);
    void SetMotionControlsEnabled(bool bEnabled);
    void SetHapticsByValue(const float Frequency, const float Amplitude, EControllerHand hand);
    void SetDisableHaptics(bool bNewDisabled);
    void SetDeprecatedInputYawScale(float NewValue);
    void SetDeprecatedInputRollScale(float NewValue);
    void SetDeprecatedInputPitchScale(float NewValue);
    void SetControllerLightColor(FColor Color);
    void setCinematicMode(bool bInCinematicMode, bool bHidePlayer, bool bAffectsHUD, bool bAffectsMovement, bool bAffectsTurning);
    void SetAudioListenerOverride(class USceneComponent* AttachToComponent, FVector Location, FRotator Rotation);
    void SetAudioListenerAttenuationOverride(class USceneComponent* AttachToComponent, FVector AttenuationLocationOVerride);
    void ServerViewSelf(FViewTargetTransitionParams TransitionParams);
    void ServerViewPrevPlayer();
    void ServerViewNextPlayer();
    void ServerVerifyViewTarget();
    void ServerUpdateMultipleLevelsVisibility(const TArray<FUpdateLevelVisibilityLevelInfo>& LevelVisibilities);
    void ServerUpdateLevelVisibility(const FUpdateLevelVisibilityLevelInfo& LevelVisibility);
    void ServerUpdateCamera(FVector_NetQuantize CamLoc, int32 CamPitchAndYaw);
    void ServerUnmutePlayer(FUniqueNetIdRepl PlayerId);
    void ServerUnblockPlayer(FUniqueNetIdRepl PlayerId);
    void ServerToggleAILogging();
    void ServerShortTimeout();
    void ServerSetSpectatorWaiting(bool bWaiting);
    void ServerSetSpectatorLocation(FVector NewLoc, FRotator NewRot);
    void ServerSendLatestAsyncPhysicsTimestamp(FAsyncPhysicsTimestamp Timestamp);
    void ServerRestartPlayer();
    void ServerRecvClientInputFrame(int32 RecvClientInputFrame, const TArray<uint8>& Data);
    void ServerPause();
    void ServerNotifyLoadedWorld(FName WorldPackageName);
    void ServerMutePlayer(FUniqueNetIdRepl PlayerId);
    void ServerExecRPC(FString Msg);
    void ServerExec(FString Msg);
    void ServerCheckClientPossessionReliable();
    void ServerCheckClientPossession();
    void ServerChangeName(FString S);
    void ServerCamera(FName NewMode);
    void ServerBlockPlayer(FUniqueNetIdRepl PlayerId);
    void ServerAcknowledgePossession(class APawn* P);
    void SendToConsole(FString Command);
    void RestartLevel();
    void ResetControllerLightColor();
    bool ProjectWorldLocationToScreen(FVector WorldLocation, FVector2D& ScreenLocation, bool bPlayerViewportRelative);
    void PlayHapticEffect(class UHapticFeedbackEffect_Base* HapticEffect, EControllerHand hand, float Scale, bool bLoop);
    void PlayDynamicForceFeedback(float Intensity, float Duration, bool bAffectsLeftLarge, bool bAffectsLeftSmall, bool bAffectsRightLarge, bool bAffectsRightSmall, TEnumAsByte<EDynamicForceFeedbackAction::Type> Action, FLatentActionInfo LatentInfo);
    void Pause();
    void OnServerStartedVisualLogger(bool bIsLogging);
    void OnRep_AsyncPhysicsDataComponent();
    void LocalTravel(FString URL);
    void K2_ClientPlayForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, FName Tag, bool bLooping, bool bIgnoreTimeDilation, bool bPlayWhilePaused);
    bool IsStreamingSourceEnabled();
    bool IsInputKeyDown(FKey Key);
    void GetViewportSize(int32& SizeX, int32& SizeY);
    void GetStreamingSourceShapes(TArray<FStreamingSourceShape>& OutShapes);
    EStreamingSourcePriority GetStreamingSourcePriority();
    void GetStreamingSourceLocationAndRotation(FVector& OutLocation, FRotator& OutRotation);
    class ASpectatorPawn* GetSpectatorPawn();
    FPlatformUserId GetPlatformUserId();
    TSubclassOf<class UPlayerInput> GetOverridePlayerInputClass();
    bool GetMousePosition(float& LocationX, float& LocationY);
    FVector GetInputVectorKeyState(FKey Key);
    void GetInputTouchState(TEnumAsByte<ETouchIndex::Type> FingerIndex, float& LocationX, float& LocationY, bool& bIsCurrentlyPressed);
    void GetInputMouseDelta(float& DeltaX, float& DeltaY);
    void GetInputMotionState(FVector& Tilt, FVector& RotationRate, FVector& Gravity, FVector& Acceleration);
    float GetInputKeyTimeDown(FKey Key);
    void GetInputAnalogStickState(TEnumAsByte<EControllerAnalogStick::Type> WhichStick, float& StickX, float& StickY);
    float GetInputAnalogKeyState(FKey Key);
    class AHUD* GetHUD();
    bool GetHitResultUnderFingerForObjects(TEnumAsByte<ETouchIndex::Type> FingerIndex, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, FHitResult& HitResult);
    bool GetHitResultUnderFingerByChannel(TEnumAsByte<ETouchIndex::Type> FingerIndex, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, FHitResult& HitResult);
    bool GetHitResultUnderFinger(TEnumAsByte<ETouchIndex::Type> FingerIndex, TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, FHitResult& HitResult);
    bool GetHitResultUnderCursorForObjects(const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, FHitResult& HitResult);
    bool GetHitResultUnderCursorByChannel(TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, FHitResult& HitResult);
    bool GetHitResultUnderCursor(TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, FHitResult& HitResult);
    FVector GetFocalLocation();
    float GetDeprecatedInputYawScale();
    float GetDeprecatedInputRollScale();
    float GetDeprecatedInputPitchScale();
    class UAsyncPhysicsData* GetAsyncPhysicsDataToWrite();
    class UAsyncPhysicsData* GetAsyncPhysicsDataToConsume();
    void FOV(float NewFOV);
    void EnableCheats();
    bool DeprojectScreenPositionToWorld(float ScreenX, float ScreenY, FVector& WorldLocation, FVector& WorldDirection);
    bool DeprojectMousePositionToWorld(FVector& WorldLocation, FVector& WorldDirection);
    void ConsoleKey(FKey Key);
    void ClientWasKicked(const FText& KickReason);
    void ClientVoiceHandshakeComplete();
    void ClientUpdateMultipleLevelsStreamingStatus(const TArray<FUpdateLevelStreamingLevelStatus>& LevelStatuses);
    void ClientUpdateLevelStreamingStatus(FName PackageName, bool bNewShouldBeLoaded, bool bNewShouldBeVisible, bool bNewShouldBlockOnLoad, int32 LODIndex, FNetLevelVisibilityTransactionId TransactionId, bool bNewShouldBlockOnUnload);
    void ClientUnmutePlayers(const TArray<FUniqueNetIdRepl>& PlayerIds);
    void ClientUnmutePlayer(FUniqueNetIdRepl PlayerId);
    void ClientTravelInternal(FString URL, TEnumAsByte<ETravelType> TravelType, bool bSeamless, FGuid MapPackageGuid);
    void ClientTravel(FString URL, TEnumAsByte<ETravelType> TravelType, bool bSeamless, FGuid MapPackageGuid);
    void ClientTeamMessage(class APlayerState* SenderPlayerState, FString S, FName Type, float MsgLifeTime);
    void ClientStopForceFeedback(class UForceFeedbackEffect* ForceFeedbackEffect, FName Tag);
    void ClientStopCameraShakesFromSource(class UCameraShakeSourceComponent* SourceComponent, bool bImmediately);
    void ClientStopCameraShake(TSubclassOf<class UCameraShakeBase> Shake, bool bImmediately);
    void ClientStartOnlineSession();
    void ClientStartCameraShakeFromSource(TSubclassOf<class UCameraShakeBase> Shake, class UCameraShakeSourceComponent* SourceComponent);
    void ClientStartCameraShake(TSubclassOf<class UCameraShakeBase> Shake, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    void ClientSpawnGenericCameraLensEffect(TSubclassOf<class AActor> LensEffectEmitterClass);
    void ClientSpawnCameraLensEffect(TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass);
    void ClientSetViewTarget(class AActor* A, FViewTargetTransitionParams TransitionParams);
    void ClientSetupNetworkPhysicsTimestamp(FAsyncPhysicsTimestamp Timestamp);
    void ClientSetSpectatorWaiting(bool bWaiting);
    void ClientSetHUD(TSubclassOf<class AHUD> NewHUDClass);
    void ClientSetForceMipLevelsToBeResident(class UMaterialInterface* Material, float ForceDuration, int32 CinematicTextureGroups);
    void ClientSetCinematicMode(bool bInCinematicMode, bool bAffectsMovement, bool bAffectsTurning, bool bAffectsHUD);
    void ClientSetCameraMode(FName NewCamMode);
    void ClientSetCameraFade(bool bEnableFading, FColor FadeColor, FVector2D FadeAlpha, float FadeTime, bool bFadeAudio, bool bHoldWhenFinished);
    void ClientSetBlockOnAsyncLoading();
    void ClientReturnToMainMenuWithTextReason(const FText& ReturnReason);
    void ClientRetryClientRestart(class APawn* NewPawn);
    void ClientRestart(class APawn* NewPawn);
    void ClientReset();
    void ClientRepObjRef(class UObject* Object);
    void ClientRecvServerAckFrameDebug(uint8 NumBuffered, float TargetNumBufferedCmds);
    void ClientRecvServerAckFrame(int32 LastProcessedInputFrame, int32 RecvServerFrameNumber, int8 TimeDilation);
    void ClientReceiveLocalizedMessage(TSubclassOf<class ULocalMessage> Message, int32 SWITCH, class APlayerState* RelatedPlayerState_1, class APlayerState* RelatedPlayerState_2, class UObject* OptionalObject);
    void ClientPrestreamTextures(class AActor* ForcedActor, float ForceDuration, bool bEnableStreaming, int32 CinematicTextureGroups);
    void ClientPrepareMapChange(FName LevelName, bool bFirst, bool bLast);
    void ClientPlaySoundAtLocation(class USoundBase* Sound, FVector Location, float VolumeMultiplier, float PitchMultiplier);
    void ClientPlaySound(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier);
    void ClientPlayForceFeedback_Internal(class UForceFeedbackEffect* ForceFeedbackEffect, FForceFeedbackParameters Params);
    void ClientMutePlayer(FUniqueNetIdRepl PlayerId);
    void ClientMessage(FString S, FName Type, float MsgLifeTime);
    void ClientIgnoreMoveInput(bool bIgnore);
    void ClientIgnoreLookInput(bool bIgnore);
    void ClientGotoState(FName NewState);
    void ClientGameEnded(class AActor* EndGameFocus, bool bIsWinner);
    void ClientForceGarbageCollection();
    void ClientFlushLevelStreaming();
    void ClientEndOnlineSession();
    void ClientEnableNetworkVoice(bool bEnable);
    void ClientCorrectionAsyncPhysicsTimestamp(FAsyncPhysicsTimestamp Timestamp);
    void ClientCommitMapChange();
    void ClientClearCameraLensEffects();
    void ClientCapBandwidth(int32 Cap);
    void ClientCancelPendingMapChange();
    void ClientAddTextureStreamingLoc(FVector InLoc, float Duration, bool bOverrideLocation);
    void ClientAckUpdateLevelVisibility(FName PackageName, FNetLevelVisibilityTransactionId TransactionId, bool bClientAckCanMakeVisible);
    void ClientAckTimeDilation(float TimeDilation, int32 ServerStep);
    void ClearAudioListenerOverride();
    void ClearAudioListenerAttenuationOverride();
    bool CanRestartPlayer();
    void Camera(FName NewMode);
    void AddYawInput(float Val);
    void AddRollInput(float Val);
    void AddPitchInput(float Val);
    void ActivateTouchInterface(class UTouchInterface* NewTouchInterface);
}; // Size: 0x858

class APlayerStart : public ANavigationObjectBase
{
    FName PlayerStartTag;                                                             // 0x02B8 (size: 0x8)

}; // Size: 0x2C0

class APlayerStartPIE : public APlayerStart
{
}; // Size: 0x2C0

class APlayerState : public AInfo
{
    float score;                                                                      // 0x0290 (size: 0x4)
    int32 PlayerId;                                                                   // 0x0294 (size: 0x4)
    uint8 CompressedPing;                                                             // 0x0298 (size: 0x1)
    uint8 bShouldUpdateReplicatedPing;                                                // 0x029A (size: 0x1)
    uint8 bIsSpectator;                                                               // 0x029A (size: 0x1)
    uint8 bOnlySpectator;                                                             // 0x029A (size: 0x1)
    uint8 bIsABot;                                                                    // 0x029A (size: 0x1)
    uint8 bIsInactive;                                                                // 0x029A (size: 0x1)
    uint8 bFromPreviousLevel;                                                         // 0x029A (size: 0x1)
    int32 StartTime;                                                                  // 0x029C (size: 0x4)
    TSubclassOf<class ULocalMessage> EngineMessageClass;                              // 0x02A0 (size: 0x8)
    FString SavedNetworkAddress;                                                      // 0x02B0 (size: 0x10)
    FUniqueNetIdRepl UniqueID;                                                        // 0x02C0 (size: 0x30)
    FPlayerStateOnPawnSet OnPawnSet;                                                  // 0x02F8 (size: 0x10)
    void OnPlayerStatePawnSet(class APlayerState* Player, class APawn* NewPawn, class APawn* OldPawn);
    class APawn* PawnPrivate;                                                         // 0x0308 (size: 0x8)
    FString PlayerNamePrivate;                                                        // 0x0328 (size: 0x10)

    void ReceiveOverrideWith(class APlayerState* OldPlayerState);
    void ReceiveCopyProperties(class APlayerState* NewPlayerState);
    void OnRep_UniqueId();
    void OnRep_Score();
    void OnRep_PlayerName();
    void OnRep_PlayerId();
    void OnRep_bIsInactive();
    void OnPawnPrivateDestroyed(class AActor* InActor);
    bool IsSpectator();
    bool IsOnlyASpectator();
    bool IsABot();
    float GetScore();
    FString GetPlayerName();
    int32 GetPlayerId();
    class APlayerController* GetPlayerController();
    float GetPingInMilliseconds();
    class APawn* GetPawn();
    uint8 GetCompressedPing();
    FUniqueNetIdRepl BP_GetUniqueId();
}; // Size: 0x348

class APointLight : public ALight
{
    class UPointLightComponent* PointLightComponent;                                  // 0x02A0 (size: 0x8)

    void SetRadius(float NewRadius);
    void SetLightFalloffExponent(float NewLightFalloffExponent);
}; // Size: 0x2A8

class APostProcessVolume : public AVolume
{
    FPostProcessSettings Settings;                                                    // 0x02D0 (size: 0x6F0)
    float Priority;                                                                   // 0x09C0 (size: 0x4)
    float BlendRadius;                                                                // 0x09C4 (size: 0x4)
    float BlendWeight;                                                                // 0x09C8 (size: 0x4)
    uint8 bEnabled;                                                                   // 0x09CC (size: 0x1)
    uint8 bUnbound;                                                                   // 0x09CC (size: 0x1)

    void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
}; // Size: 0x9D0

class APrecomputedVisibilityOverrideVolume : public AVolume
{
    TArray<class AActor*> OverrideVisibleActors;                                      // 0x02C8 (size: 0x10)
    TArray<class AActor*> OverrideInvisibleActors;                                    // 0x02D8 (size: 0x10)
    TArray<FName> OverrideInvisibleLevels;                                            // 0x02E8 (size: 0x10)

}; // Size: 0x2F8

class APrecomputedVisibilityVolume : public AVolume
{
}; // Size: 0x2C8

class ARadialForceActor : public ARigidBodyBase
{
    class URadialForceComponent* ForceComponent;                                      // 0x0290 (size: 0x8)

    void ToggleForce();
    void FireImpulse();
    void EnableForce();
    void DisableForce();
}; // Size: 0x298

class ARectLight : public ALight
{
    class URectLightComponent* RectLightComponent;                                    // 0x02A0 (size: 0x8)

}; // Size: 0x2A8

class AReflectionCapture : public AActor
{
    class UReflectionCaptureComponent* CaptureComponent;                              // 0x0290 (size: 0x8)

}; // Size: 0x298

class ARigidBodyBase : public AActor
{
}; // Size: 0x290

class ARuntimeVirtualTextureVolume : public AActor
{
    class URuntimeVirtualTextureComponent* VirtualTextureComponent;                   // 0x0290 (size: 0x8)

}; // Size: 0x298

class ASceneCapture : public AActor
{
    class UStaticMeshComponent* MeshComp;                                             // 0x0290 (size: 0x8)
    class USceneComponent* SceneComponent;                                            // 0x0298 (size: 0x8)

}; // Size: 0x2A0

class ASceneCapture2D : public ASceneCapture
{
    class USceneCaptureComponent2D* CaptureComponent2D;                               // 0x02A0 (size: 0x8)

    void OnInterpToggle(bool bEnable);
}; // Size: 0x2A8

class ASceneCaptureCube : public ASceneCapture
{
    class USceneCaptureComponentCube* CaptureComponentCube;                           // 0x02A0 (size: 0x8)

    void OnInterpToggle(bool bEnable);
}; // Size: 0x2A8

class AServerStatReplicator : public AInfo
{
    bool bUpdateStatNet;                                                              // 0x0290 (size: 0x1)
    bool bOverwriteClientStats;                                                       // 0x0291 (size: 0x1)
    uint32 Channels;                                                                  // 0x0294 (size: 0x4)
    uint32 InRate;                                                                    // 0x0298 (size: 0x4)
    uint32 OutRate;                                                                   // 0x029C (size: 0x4)
    uint32 MaxPacketOverhead;                                                         // 0x02A4 (size: 0x4)
    uint32 InRateClientMax;                                                           // 0x02A8 (size: 0x4)
    uint32 InRateClientMin;                                                           // 0x02AC (size: 0x4)
    uint32 InRateClientAvg;                                                           // 0x02B0 (size: 0x4)
    uint32 InPacketsClientMax;                                                        // 0x02B4 (size: 0x4)
    uint32 InPacketsClientMin;                                                        // 0x02B8 (size: 0x4)
    uint32 InPacketsClientAvg;                                                        // 0x02BC (size: 0x4)
    uint32 OutRateClientMax;                                                          // 0x02C0 (size: 0x4)
    uint32 OutRateClientMin;                                                          // 0x02C4 (size: 0x4)
    uint32 OutRateClientAvg;                                                          // 0x02C8 (size: 0x4)
    uint32 OutPacketsClientMax;                                                       // 0x02CC (size: 0x4)
    uint32 OutPacketsClientMin;                                                       // 0x02D0 (size: 0x4)
    uint32 OutPacketsClientAvg;                                                       // 0x02D4 (size: 0x4)
    uint32 NetNumClients;                                                             // 0x02D8 (size: 0x4)
    uint32 InPackets;                                                                 // 0x02DC (size: 0x4)
    uint32 OutPackets;                                                                // 0x02E0 (size: 0x4)
    uint32 InBunches;                                                                 // 0x02E4 (size: 0x4)
    uint32 OutBunches;                                                                // 0x02E8 (size: 0x4)
    uint32 OutLoss;                                                                   // 0x02EC (size: 0x4)
    uint32 InLoss;                                                                    // 0x02F0 (size: 0x4)
    uint32 VoiceBytesSent;                                                            // 0x02F4 (size: 0x4)
    uint32 VoiceBytesRecv;                                                            // 0x02F8 (size: 0x4)
    uint32 VoicePacketsSent;                                                          // 0x02FC (size: 0x4)
    uint32 VoicePacketsRecv;                                                          // 0x0300 (size: 0x4)
    uint32 PercentInVoice;                                                            // 0x0304 (size: 0x4)
    uint32 PercentOutVoice;                                                           // 0x0308 (size: 0x4)
    uint32 NumActorChannels;                                                          // 0x030C (size: 0x4)
    uint32 NumConsideredActors;                                                       // 0x0310 (size: 0x4)
    uint32 PrioritizedActors;                                                         // 0x0314 (size: 0x4)
    uint32 NumRelevantActors;                                                         // 0x0318 (size: 0x4)
    uint32 NumRelevantDeletedActors;                                                  // 0x031C (size: 0x4)
    uint32 NumReplicatedActorAttempts;                                                // 0x0320 (size: 0x4)
    uint32 NumReplicatedActors;                                                       // 0x0324 (size: 0x4)
    uint32 NumActors;                                                                 // 0x0328 (size: 0x4)
    uint32 NumNetActors;                                                              // 0x032C (size: 0x4)
    uint32 NumDormantActors;                                                          // 0x0330 (size: 0x4)
    uint32 NumInitiallyDormantActors;                                                 // 0x0334 (size: 0x4)
    uint32 NumNetGUIDsAckd;                                                           // 0x0338 (size: 0x4)
    uint32 NumNetGUIDsPending;                                                        // 0x033C (size: 0x4)
    uint32 NumNetGUIDsUnAckd;                                                         // 0x0340 (size: 0x4)
    uint32 ObjPathBytes;                                                              // 0x0344 (size: 0x4)
    uint32 NetGUIDOutRate;                                                            // 0x0348 (size: 0x4)
    uint32 NetGUIDInRate;                                                             // 0x034C (size: 0x4)
    uint32 NetSaturated;                                                              // 0x0350 (size: 0x4)

}; // Size: 0x358

class AServerStreamingLevelsVisibility : public AActor
{
}; // Size: 0x2E0

class ASkeletalMeshActor : public AActor
{
    uint8 bShouldDoAnimNotifies;                                                      // 0x0290 (size: 0x1)
    class USkeletalMeshComponent* SkeletalMeshComponent;                              // 0x0298 (size: 0x8)
    class USkeletalMesh* ReplicatedMesh;                                              // 0x02A0 (size: 0x8)
    class UPhysicsAsset* ReplicatedPhysAsset;                                         // 0x02A8 (size: 0x8)
    class UMaterialInterface* ReplicatedMaterial0;                                    // 0x02B0 (size: 0x8)
    class UMaterialInterface* ReplicatedMaterial1;                                    // 0x02B8 (size: 0x8)

    void OnRep_ReplicatedPhysAsset();
    void OnRep_ReplicatedMesh();
    void OnRep_ReplicatedMaterial1();
    void OnRep_ReplicatedMaterial0();
}; // Size: 0x310

class ASkyAtmosphere : public AInfo
{
    class USkyAtmosphereComponent* SkyAtmosphereComponent;                            // 0x0290 (size: 0x8)

}; // Size: 0x298

class ASkyLight : public AInfo
{
    class USkyLightComponent* LightComponent;                                         // 0x0290 (size: 0x8)
    uint8 bEnabled;                                                                   // 0x0298 (size: 0x1)

    void OnRep_bEnabled();
}; // Size: 0x2A0

class ASpatialHashRuntimeGridInfo : public AInfo
{
    FSpatialHashRuntimeGrid GridSettings;                                             // 0x0290 (size: 0x1)

}; // Size: 0x298

class ASpectatorPawn : public ADefaultPawn
{
}; // Size: 0x340

class ASphereReflectionCapture : public AReflectionCapture
{
    class UDrawSphereComponent* DrawCaptureRadius;                                    // 0x0298 (size: 0x8)

}; // Size: 0x2A0

class ASplineMeshActor : public AActor
{
    class USplineMeshComponent* SplineMeshComponent;                                  // 0x0290 (size: 0x8)

}; // Size: 0x298

class ASpotLight : public ALight
{
    class USpotLightComponent* SpotLightComponent;                                    // 0x02A0 (size: 0x8)

    void SetOuterConeAngle(float NewOuterConeAngle);
    void SetInnerConeAngle(float NewInnerConeAngle);
}; // Size: 0x2A8

class AStaticMeshActor : public AActor
{
    class UStaticMeshComponent* StaticMeshComponent;                                  // 0x0290 (size: 0x8)
    bool bStaticMeshReplicateMovement;                                                // 0x0298 (size: 0x1)
    EPhysicsReplicationMode StaticMeshPhysicsReplicationMode;                         // 0x0299 (size: 0x1)
    ENavDataGatheringMode NavigationGeometryGatheringMode;                            // 0x029A (size: 0x1)

    void SetMobility(TEnumAsByte<EComponentMobility::Type> InMobility);
}; // Size: 0x2A0

class ATargetPoint : public AActor
{
}; // Size: 0x290

class ATextRenderActor : public AActor
{
    class UTextRenderComponent* TextRender;                                           // 0x0290 (size: 0x8)

}; // Size: 0x298

class ATriggerBase : public AActor
{
    class UShapeComponent* CollisionComponent;                                        // 0x0290 (size: 0x8)

}; // Size: 0x298

class ATriggerBox : public ATriggerBase
{
}; // Size: 0x298

class ATriggerCapsule : public ATriggerBase
{
}; // Size: 0x298

class ATriggerSphere : public ATriggerBase
{
}; // Size: 0x298

class ATriggerVolume : public AVolume
{
}; // Size: 0x2C8

class AVectorFieldVolume : public AActor
{
    class UVectorFieldComponent* VectorFieldComponent;                                // 0x0290 (size: 0x8)

}; // Size: 0x298

class AVisualLoggerFilterVolume : public AVolume
{
}; // Size: 0x2C8

class AVolume : public ABrush
{
}; // Size: 0x2C8

class AVolumetricCloud : public AInfo
{
    class UVolumetricCloudComponent* VolumetricCloudComponent;                        // 0x0290 (size: 0x8)

}; // Size: 0x298

class AVolumetricLightmapDensityVolume : public AVolume
{
    FInt32Interval AllowedMipLevelRange;                                              // 0x02C8 (size: 0x8)

}; // Size: 0x2D0

class AWindDirectionalSource : public AInfo
{
    class UWindDirectionalSourceComponent* Component;                                 // 0x0290 (size: 0x8)

}; // Size: 0x298

class AWorldDataLayers : public AInfo
{
    class UExternalDataLayerInstance* RootExternalDataLayerInstance;                  // 0x0338 (size: 0x8)
    TSet<UDataLayerInstance*> DataLayerInstances;                                     // 0x0340 (size: 0x50)
    TSet<UDataLayerInstance*> ExternalPackageDataLayerInstances;                      // 0x0390 (size: 0x50)
    TArray<class UDataLayerInstance*> LoadedExternalPackageDataLayerInstances;        // 0x03E0 (size: 0x10)
    TArray<class UDataLayerInstance*> TransientDataLayerInstances;                    // 0x03F0 (size: 0x10)
    TMap<class FName, class TWeakObjectPtr<UDataLayerInstance>> DeprecatedDataLayerNameToDataLayerInstance; // 0x0400 (size: 0x50)
    TSet<UDEPRECATED_DataLayer*> WorldDataLayers;                                     // 0x0450 (size: 0x50)
    TArray<FName> RepActiveDataLayerNames;                                            // 0x04A0 (size: 0x10)
    TArray<FName> RepLoadedDataLayerNames;                                            // 0x04B0 (size: 0x10)
    TArray<FName> RepEffectiveActiveDataLayerNames;                                   // 0x0600 (size: 0x10)
    TArray<FName> RepEffectiveLoadedDataLayerNames;                                   // 0x0610 (size: 0x10)

    void OnRep_LoadedDataLayerNames();
    void OnRep_EffectiveLoadedDataLayerNames();
    void OnRep_EffectiveActiveDataLayerNames();
    void OnRep_ActiveDataLayerNames();
    void OnDataLayerRuntimeStateChanged(const class UDataLayerInstance* InDataLayer, EDataLayerRuntimeState InState);
}; // Size: 0x828

class AWorldPartitionHLOD : public AActor
{
    uint32 LODLevel;                                                                  // 0x0290 (size: 0x4)
    bool bRequireWarmup;                                                              // 0x0294 (size: 0x1)
    FGuid SourceCellGuid;                                                             // 0x0298 (size: 0x10)

}; // Size: 0x2A8

class AWorldPartitionMiniMap : public AInfo
{
    FBox MiniMapWorldBounds;                                                          // 0x0290 (size: 0x38)
    FBox2D UVOffset;                                                                  // 0x02C8 (size: 0x28)
    class UTexture2D* MiniMapTexture;                                                 // 0x02F0 (size: 0x8)
    TSet<FActorDataLayer> ExcludedDataLayers;                                         // 0x02F8 (size: 0x50)
    int32 WorldUnitsPerPixel;                                                         // 0x0348 (size: 0x4)
    int32 BuilderCellSize;                                                            // 0x034C (size: 0x4)
    TEnumAsByte<ESceneCaptureSource> CaptureSource;                                   // 0x0350 (size: 0x1)
    uint32 CaptureWarmupFrames;                                                       // 0x0354 (size: 0x4)
    int32 MiniMapTileSize;                                                            // 0x0358 (size: 0x4)

}; // Size: 0x360

class AWorldPartitionMiniMapVolume : public AVolume
{
}; // Size: 0x2C8

class AWorldPartitionReplay : public AActor
{
    TArray<FName> StreamingSourceNames;                                               // 0x0290 (size: 0x10)

}; // Size: 0x2B0

class AWorldSettings : public AInfo
{
    int32 VisibilityCellSize;                                                         // 0x0298 (size: 0x4)
    TEnumAsByte<EVisibilityAggressiveness> VisibilityAggressiveness;                  // 0x029C (size: 0x1)
    uint8 bPrecomputeVisibility;                                                      // 0x029D (size: 0x1)
    uint8 bPlaceCellsOnlyAlongCameraTracks;                                           // 0x029D (size: 0x1)
    uint8 bEnableWorldBoundsChecks;                                                   // 0x029D (size: 0x1)
    uint8 bEnableNavigationSystem;                                                    // 0x029D (size: 0x1)
    uint8 bEnableAISystem;                                                            // 0x029D (size: 0x1)
    uint8 bEnableWorldComposition;                                                    // 0x029D (size: 0x1)
    uint8 bUseClientSideLevelStreamingVolumes;                                        // 0x029D (size: 0x1)
    uint8 bEnableWorldOriginRebasing;                                                 // 0x029D (size: 0x1)
    uint8 bWorldGravitySet;                                                           // 0x029E (size: 0x1)
    uint8 bGlobalGravitySet;                                                          // 0x029E (size: 0x1)
    uint8 bMinimizeBSPSections;                                                       // 0x029E (size: 0x1)
    uint8 bForceNoPrecomputedLighting;                                                // 0x029E (size: 0x1)
    uint8 bHighPriorityLoading;                                                       // 0x029E (size: 0x1)
    uint8 bHighPriorityLoadingLocal;                                                  // 0x029E (size: 0x1)
    uint8 bOverrideDefaultBroadphaseSettings;                                         // 0x029E (size: 0x1)
    uint8 bGenerateSingleClusterForLevel;                                             // 0x029E (size: 0x1)
    uint8 bReuseAddressAndPort;                                                       // 0x029F (size: 0x1)
    TSoftClassPtr<UAISystemBase> AISystemClass;                                       // 0x02A0 (size: 0x28)
    FVector LevelInstancePivotOffset;                                                 // 0x02C8 (size: 0x18)
    class UNavigationSystemConfig* NavigationSystemConfig;                            // 0x02E0 (size: 0x8)
    class UNavigationSystemConfig* NavigationSystemConfigOverride;                    // 0x02E8 (size: 0x8)
    class UWorldPartition* WorldPartition;                                            // 0x02F0 (size: 0x8)
    TArray<class UDataLayerAsset*> BaseNavmeshDataLayers;                             // 0x02F8 (size: 0x10)
    float WorldToMeters;                                                              // 0x0308 (size: 0x4)
    float KillZ;                                                                      // 0x030C (size: 0x4)
    TSubclassOf<class UDamageType> KillZDamageType;                                   // 0x0310 (size: 0x8)
    float WorldGravityZ;                                                              // 0x0318 (size: 0x4)
    float GlobalGravityZ;                                                             // 0x031C (size: 0x4)
    TSubclassOf<class ADefaultPhysicsVolume> DefaultPhysicsVolumeClass;               // 0x0320 (size: 0x8)
    TSubclassOf<class UPhysicsCollisionHandler> PhysicsCollisionHandlerClass;         // 0x0328 (size: 0x8)
    TSubclassOf<class AGameModeBase> DefaultGameMode;                                 // 0x0330 (size: 0x8)
    TSubclassOf<class AGameNetworkManager> GameNetworkManagerClass;                   // 0x0338 (size: 0x8)
    int32 PackedLightAndShadowMapTextureSize;                                         // 0x0340 (size: 0x4)
    FVector DefaultColorScale;                                                        // 0x0348 (size: 0x18)
    float DefaultMaxDistanceFieldOcclusionDistance;                                   // 0x0360 (size: 0x4)
    float GlobalDistanceFieldViewDistance;                                            // 0x0364 (size: 0x4)
    float DynamicIndirectShadowsSelfShadowingIntensity;                               // 0x0368 (size: 0x4)
    FNaniteSettings NaniteSettings;                                                   // 0x036C (size: 0x1)
    FReverbSettings DefaultReverbSettings;                                            // 0x0370 (size: 0x20)
    FInteriorSettings DefaultAmbientZoneSettings;                                     // 0x0390 (size: 0x24)
    class USoundMix* DefaultBaseSoundMix;                                             // 0x03B8 (size: 0x8)
    float TimeDilation;                                                               // 0x03C0 (size: 0x4)
    float CinematicTimeDilation;                                                      // 0x03C4 (size: 0x4)
    float DemoPlayTimeDilation;                                                       // 0x03C8 (size: 0x4)
    float MinGlobalTimeDilation;                                                      // 0x03CC (size: 0x4)
    float MaxGlobalTimeDilation;                                                      // 0x03D0 (size: 0x4)
    float MinUndilatedFrameTime;                                                      // 0x03D4 (size: 0x4)
    float MaxUndilatedFrameTime;                                                      // 0x03D8 (size: 0x4)
    FBroadphaseSettings BroadphaseSettings;                                           // 0x03E0 (size: 0x80)
    TArray<FNetViewer> ReplicationViewers;                                            // 0x0460 (size: 0x10)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0470 (size: 0x10)
    class APlayerState* PauserPlayerState;                                            // 0x0480 (size: 0x8)
    int32 MaxNumberOfBookmarks;                                                       // 0x0488 (size: 0x4)
    TSubclassOf<class UBookmarkBase> DefaultBookmarkClass;                            // 0x0490 (size: 0x8)
    TArray<class UBookmarkBase*> BookmarkArray;                                       // 0x0498 (size: 0x10)
    TSubclassOf<class UBookmarkBase> LastBookmarkClass;                               // 0x04A8 (size: 0x8)

    void OnRep_WorldGravityZ();
    void OnRep_NaniteSettings();
}; // Size: 0x4B0

class IActiveSoundUpdateInterface : public IInterface
{
}; // Size: 0x28

class IActorInstanceManagerInterface : public IInterface
{
}; // Size: 0x28

class IActorSoundParameterInterface : public IInterface
{

    void GetActorSoundParams(TArray<FAudioParameter>& Params);
}; // Size: 0x28

class IAnimClassInterface : public IInterface
{
}; // Size: 0x28

class IAnimLayerInterface : public IInterface
{
}; // Size: 0x28

class IAnimationDataController : public IInterface
{

    void UpdateCurveNamesFromSkeleton(const class USkeleton* Skeleton, ERawCurveTrackTypes SupportedCurveType, bool bShouldTransact);
    bool SetTransformCurveKeys(const FAnimationCurveIdentifier& CurveId, const TArray<FTransform>& TransformValues, const TArray<float>& TimeKeys, bool bShouldTransact);
    bool SetTransformCurveKey(const FAnimationCurveIdentifier& CurveId, float Time, const FTransform& Value, bool bShouldTransact);
    void SetPlayLength(float Length, bool bShouldTransact);
    void SetNumberOfFrames(FFrameNumber NewLengthInFrames, bool bShouldTransact);
    void SetModel(TScriptInterface<class IAnimationDataModel> InModel);
    void SetFrameRate(FFrameRate FrameRate, bool bShouldTransact);
    bool SetCurveKeys(const FAnimationCurveIdentifier& CurveId, const TArray<FRichCurveKey>& CurveKeys, bool bShouldTransact);
    bool SetCurveKey(const FAnimationCurveIdentifier& CurveId, const FRichCurveKey& Key, bool bShouldTransact);
    bool SetCurveFlags(const FAnimationCurveIdentifier& CurveId, int32 Flags, bool bShouldTransact);
    bool SetCurveFlag(const FAnimationCurveIdentifier& CurveId, TEnumAsByte<EAnimAssetCurveFlags> flag, bool bState, bool bShouldTransact);
    bool SetCurveComment(const FAnimationCurveIdentifier& CurveId, FString Comment, bool bShouldTransact);
    bool SetCurveColor(const FAnimationCurveIdentifier& CurveId, FLinearColor Color, bool bShouldTransact);
    bool SetBoneTrackKeys(FName BoneName, const TArray<FVector>& PositionalKeys, const TArray<FQuat>& RotationalKeys, const TArray<FVector>& ScalingKeys, bool bShouldTransact);
    bool ScaleCurve(const FAnimationCurveIdentifier& CurveId, float Origin, float Factor, bool bShouldTransact);
    void ResizePlayLength(float NewLength, float T0, float T1, bool bShouldTransact);
    void ResizeNumberOfFrames(FFrameNumber NewLengthInFrames, FFrameNumber T0, FFrameNumber T1, bool bShouldTransact);
    void ResizeInFrames(FFrameNumber NewLengthInFrames, FFrameNumber T0, FFrameNumber T1, bool bShouldTransact);
    void Resize(float Length, float T0, float T1, bool bShouldTransact);
    bool RenameCurve(const FAnimationCurveIdentifier& CurveToRenameId, const FAnimationCurveIdentifier& NewCurveId, bool bShouldTransact);
    bool RemoveTransformCurveKey(const FAnimationCurveIdentifier& CurveId, float Time, bool bShouldTransact);
    bool RemoveCurveKey(const FAnimationCurveIdentifier& CurveId, float Time, bool bShouldTransact);
    bool RemoveCurve(const FAnimationCurveIdentifier& CurveId, bool bShouldTransact);
    bool RemoveBoneTrack(FName BoneName, bool bShouldTransact);
    bool RemoveAttributeKey(const FAnimationAttributeIdentifier& AttributeIdentifier, float Time, bool bShouldTransact);
    bool RemoveAttribute(const FAnimationAttributeIdentifier& AttributeIdentifier, bool bShouldTransact);
    void RemoveAllCurvesOfType(ERawCurveTrackTypes SupportedCurveType, bool bShouldTransact);
    void RemoveAllBoneTracks(bool bShouldTransact);
    int32 RemoveAllAttributesForBone(const FName& BoneName, bool bShouldTransact);
    int32 RemoveAllAttributes(bool bShouldTransact);
    void OpenBracket(const FText& InTitle, bool bShouldTransact);
    int32 InsertBoneTrack(FName BoneName, int32 DesiredIndex, bool bShouldTransact);
    TScriptInterface<class IAnimationDataModel> GetModelInterface();
    void FindOrAddCurveNamesOnSkeleton(class USkeleton* Skeleton, ERawCurveTrackTypes SupportedCurveType, bool bShouldTransact);
    bool DuplicateCurve(const FAnimationCurveIdentifier& CopyCurveId, const FAnimationCurveIdentifier& NewCurveId, bool bShouldTransact);
    bool DuplicateAttribute(const FAnimationAttributeIdentifier& AttributeIdentifier, const FAnimationAttributeIdentifier& NewAttributeIdentifier, bool bShouldTransact);
    void CloseBracket(bool bShouldTransact);
    bool AddCurve(const FAnimationCurveIdentifier& CurveId, int32 CurveFlags, bool bShouldTransact);
    int32 AddBoneTrack(FName BoneName, bool bShouldTransact);
    bool AddBoneCurve(FName BoneName, bool bShouldTransact);
    bool AddAttribute(const FAnimationAttributeIdentifier& AttributeIdentifier, bool bShouldTransact);
}; // Size: 0x28

class IAnimationDataModel : public IInterface
{

    bool IsValidBoneTrackName(const FName& TrackName);
    bool IsValidBoneTrackIndex(int32 TrackIndex);
    double GetPlayLength();
    int32 GetNumBoneTracks();
    int32 GetNumberOfTransformCurves();
    int32 GetNumberOfKeys();
    int32 GetNumberOfFrames();
    int32 GetNumberOfFloatCurves();
    FFrameRate GetFrameRate();
    void GetBoneTrackNames(TArray<FName>& OutNames);
    int32 GetBoneTrackIndexByName(FName TrackName);
    int32 GetBoneTrackIndex(const FBoneAnimationTrack& Track);
    FBoneAnimationTrack GetBoneTrackByName(FName TrackName);
    FBoneAnimationTrack GetBoneTrackByIndex(int32 TrackIndex);
    TArray<FBoneAnimationTrack> GetBoneAnimationTracks();
    class UAnimSequence* GetAnimationSequence();
}; // Size: 0x28

class IAssetRegistryTagProviderInterface : public IInterface
{
}; // Size: 0x28

class IAudioPanelWidgetInterface : public IInterface
{

    FName GetIconBrushName();
    FText GetEditorName();
}; // Size: 0x28

class IBlendableInterface : public IInterface
{
}; // Size: 0x28

class IBoneReferenceSkeletonProvider : public IInterface
{
}; // Size: 0x28

class ICameraLensEffectInterface : public IInterface
{

    class UFXSystemComponent* GetPrimaryParticleComponent();
    TArray<class UFXSystemComponent*> GetParticleComponents();
}; // Size: 0x28

class ICurveSourceInterface : public IInterface
{

    float GetCurveValue(FName CurveName);
    void GetCurves(TArray<FNamedCurveValue>& OutValues);
    FName GetBindingName();
}; // Size: 0x28

class IDataLayerInstanceProvider : public IInterface
{
}; // Size: 0x28

class IDeformableInterface : public IInterface
{
}; // Size: 0x28

class IDestructibleInterface : public IInterface
{
}; // Size: 0x28

class IISMPartitionInstanceManager : public IInterface
{
}; // Size: 0x28

class IISMPartitionInstanceManagerProvider : public IInterface
{
}; // Size: 0x28

class IImportantToggleSettingInterface : public IInterface
{
}; // Size: 0x28

class IInterface_ActorSubobject : public IInterface
{
}; // Size: 0x28

class IInterface_AnimCurveMetaData : public IInterface
{
}; // Size: 0x28

class IInterface_AssetUserData : public IInterface
{

    bool HasAssetUserDataOfClass(TSubclassOf<class UAssetUserData> InUserDataClass);
    class UAssetUserData* GetAssetUserDataOfClass(TSubclassOf<class UAssetUserData> InUserDataClass);
    bool AddAssetUserDataOfClass(TSubclassOf<class UAssetUserData> InUserDataClass);
}; // Size: 0x28

class IInterface_AsyncCompilation : public IInterface
{
}; // Size: 0x28

class IInterface_CollisionDataProvider : public IInterface
{
}; // Size: 0x28

class IInterface_PostProcessVolume : public IInterface
{
}; // Size: 0x28

class IInterface_PreviewMeshProvider : public IInterface
{
}; // Size: 0x28

class ILODSyncInterface : public IInterface
{
}; // Size: 0x28

class ILevelInstanceEditorPivotInterface : public IInterface
{
}; // Size: 0x28

class ILevelInstanceInterface : public IInterface
{

    void UnloadLevelInstance();
    bool SetWorldAsset(TSoftObjectPtr<UWorld> WorldAsset);
    void LoadLevelInstance();
    bool IsLoaded();
    TSoftObjectPtr<UWorld> GetWorldAsset();
    class ULevel* GetLoadedLevel();
}; // Size: 0x28

class INavAgentInterface : public IInterface
{
}; // Size: 0x28

class INavEdgeProviderInterface : public IInterface
{
}; // Size: 0x28

class INavPathObserverInterface : public IInterface
{
}; // Size: 0x28

class INavRelevantInterface : public IInterface
{
}; // Size: 0x28

class INavigationDataInterface : public IInterface
{
}; // Size: 0x28

class INavigationInvokerInterface : public IInterface
{
}; // Size: 0x28

class INetworkPredictionInterface : public IInterface
{
}; // Size: 0x28

class INodeMappingProviderInterface : public IInterface
{
}; // Size: 0x28

class IPathFollowingAgentInterface : public IInterface
{
}; // Size: 0x28

class IPhysicsComponent : public IInterface
{
}; // Size: 0x28

class IPreviewCollectionInterface : public IInterface
{
}; // Size: 0x28

class IRVOAvoidanceInterface : public IInterface
{
}; // Size: 0x28

class ISMInstanceManager : public IInterface
{
}; // Size: 0x28

class ISMInstanceManagerProvider : public IInterface
{
}; // Size: 0x28

class ISlateTextureAtlasInterface : public IInterface
{
}; // Size: 0x28

class ISoundEffectPresetWidgetInterface : public IAudioPanelWidgetInterface
{

    void OnPropertyChanged(class USoundEffectPreset* Preset, FName PropertyName);
    void OnConstructed(class USoundEffectPreset* Preset);
    TSubclassOf<class USoundEffectPreset> GetClass();
}; // Size: 0x28

class ISoundParameterControllerInterface : public IAudioParameterControllerInterface
{
}; // Size: 0x28

class ISoundSubmixWidgetInterface : public IInterface
{

    void OnConstructed(class USoundSubmixBase* SoundSubmix);
}; // Size: 0x28

class ITypedElementWorldInterface : public IInterface
{

    bool SetWorldTransform(const FScriptTypedElementHandle& InElementHandle, const FTransform& InTransform);
    bool SetRelativeTransform(const FScriptTypedElementHandle& InElementHandle, const FTransform& InTransform);
    bool SetPivotOffset(const FScriptTypedElementHandle& InElementHandle, const FVector& InPivotOffset);
    FScriptTypedElementHandle PromoteElement(const FScriptTypedElementHandle& InElementHandle, class UWorld* OverrideWorld);
    void NotifyMovementStarted(const FScriptTypedElementHandle& InElementHandle);
    void NotifyMovementOngoing(const FScriptTypedElementHandle& InElementHandle);
    void NotifyMovementEnded(const FScriptTypedElementHandle& InElementHandle);
    bool IsTemplateElement(const FScriptTypedElementHandle& InElementHandle);
    bool GetWorldTransform(const FScriptTypedElementHandle& InElementHandle, FTransform& OutTransform);
    bool GetRelativeTransform(const FScriptTypedElementHandle& InElementHandle, FTransform& OutTransform);
    bool GetPivotOffset(const FScriptTypedElementHandle& InElementHandle, FVector& OutPivotOffset);
    class UWorld* GetOwnerWorld(const FScriptTypedElementHandle& InElementHandle);
    class ULevel* GetOwnerLevel(const FScriptTypedElementHandle& InElementHandle);
    bool GetBounds(const FScriptTypedElementHandle& InElementHandle, FBoxSphereBounds& OutBounds);
    FScriptTypedElementHandle DuplicateElement(const FScriptTypedElementHandle& InElementHandle, class UWorld* InWorld, const FVector& InLocationOffset);
    bool DeleteElement(const FScriptTypedElementHandle& InElementHandle, class UWorld* InWorld, class UTypedElementSelectionSet* InSelectionSet, const FTypedElementDeletionOptions& InDeletionOptions);
    bool CanScaleElement(const FScriptTypedElementHandle& InElementHandle);
    bool CanPromoteElement(const FScriptTypedElementHandle& InElementHandle);
    bool CanMoveElement(const FScriptTypedElementHandle& InElementHandle, const ETypedElementWorldType InWorldType);
    bool CanEditElement(const FScriptTypedElementHandle& InElementHandle);
    bool CanDuplicateElement(const FScriptTypedElementHandle& InElementHandle);
    bool CanDeleteElement(const FScriptTypedElementHandle& InElementHandle);
}; // Size: 0x28

class IVisualLoggerDebugSnapshotInterface : public IInterface
{
}; // Size: 0x28

class IWorldPartitionActorLoaderInterface : public IInterface
{
}; // Size: 0x28

class IWorldPartitionCell : public IInterface
{
}; // Size: 0x28

class IWorldPartitionCookPackageObject : public IInterface
{
}; // Size: 0x28

class IWorldPartitionDestructibleInHLODInterface : public IInterface
{

    void SetHLODDestructionTag(const FWorldPartitionHLODDestructionTag& InDestructionTag);
    FWorldPartitionHLODDestructionTag GetHLODDestructionTag();
}; // Size: 0x28

class IWorldPartitionHLODProvider : public IInterface
{
}; // Size: 0x28

class IWorldPartitionObjectResolver : public IInterface
{
}; // Size: 0x28

class UAISystemBase : public UObject
{
    FSoftClassPath AISystemClassName;                                                 // 0x0028 (size: 0x20)
    FName AISystemModuleName;                                                         // 0x0048 (size: 0x8)
    bool bInstantiateAISystemOnClient;                                                // 0x0058 (size: 0x1)

}; // Size: 0x60

class UActorChannel : public UChannel
{
    class AActor* Actor;                                                              // 0x0068 (size: 0x8)
    TArray<class UObject*> CreateSubObjects;                                          // 0x0160 (size: 0x10)

}; // Size: 0x298

class UActorComponent : public UObject
{
    FActorComponentTickFunction PrimaryComponentTick;                                 // 0x0030 (size: 0x30)
    TArray<FName> ComponentTags;                                                      // 0x0060 (size: 0x10)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0070 (size: 0x10)
    int32 UCSSerializationIndex;                                                      // 0x0084 (size: 0x4)
    uint8 bNetAddressable;                                                            // 0x0088 (size: 0x1)
    uint8 bReplicateUsingRegisteredSubObjectList;                                     // 0x0088 (size: 0x1)
    uint8 bReplicates;                                                                // 0x0088 (size: 0x1)
    uint8 bAutoActivate;                                                              // 0x008A (size: 0x1)
    uint8 bIsActive;                                                                  // 0x008A (size: 0x1)
    uint8 bEditableWhenInherited;                                                     // 0x008A (size: 0x1)
    uint8 bCanEverAffectNavigation;                                                   // 0x008A (size: 0x1)
    uint8 bIsEditorOnly;                                                              // 0x008B (size: 0x1)
    EComponentCreationMethod CreationMethod;                                          // 0x008D (size: 0x1)
    FActorComponentOnComponentActivated OnComponentActivated;                         // 0x008E (size: 0x1)
    void ActorComponentActivatedSignature(class UActorComponent* Component, bool bReset);
    FActorComponentOnComponentDeactivated OnComponentDeactivated;                     // 0x008F (size: 0x1)
    void ActorComponentDeactivateSignature(class UActorComponent* Component);

    void ToggleActive();
    void SetTickGroup(TEnumAsByte<ETickingGroup> NewTickGroup);
    void SetTickableWhenPaused(bool bTickableWhenPaused);
    void SetIsReplicated(bool ShouldReplicate);
    void SetComponentTickIntervalAndCooldown(float TickInterval);
    void SetComponentTickInterval(float TickInterval);
    void SetComponentTickEnabled(bool bEnabled);
    void SetAutoActivate(bool bNewAutoActivate);
    void SetActive(bool bNewActive, bool bReset);
    void RemoveTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent);
    void RemoveTickPrerequisiteActor(class AActor* PrerequisiteActor);
    void ReceiveTick(float DeltaSeconds);
    void ReceiveEndPlay(TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
    void ReceiveBeginPlay();
    void ReceiveAsyncPhysicsTick(float DeltaSeconds, float SimSeconds);
    void OnRep_IsActive();
    void K2_DestroyComponent(class UObject* Object);
    bool IsComponentTickEnabled();
    bool IsBeingDestroyed();
    bool IsActive();
    class AActor* GetOwner();
    float GetComponentTickInterval();
    void Deactivate();
    bool ComponentHasTag(FName Tag);
    void AddTickPrerequisiteComponent(class UActorComponent* PrerequisiteComponent);
    void AddTickPrerequisiteActor(class AActor* PrerequisiteActor);
    void Activate(bool bReset);
}; // Size: 0xA0

class UActorContainer : public UObject
{
    TMap<class FName, class AActor*> Actors;                                          // 0x0028 (size: 0x50)

}; // Size: 0x78

class UActorDescContainer : public UObject
{
}; // Size: 0x28

class UActorDescContainerInstance : public UObject
{
}; // Size: 0x28

class UActorDescContainerSubsystem : public UEngineSubsystem
{
}; // Size: 0x30

class UActorElementAssetDataInterface : public UObject
{
}; // Size: 0x30

class UActorElementCounterInterface : public UObject
{
}; // Size: 0x30

class UActorElementHierarchyInterface : public UObject
{
}; // Size: 0x30

class UActorElementObjectInterface : public UObject
{
}; // Size: 0x30

class UActorElementSelectionInterface : public UObject
{
}; // Size: 0x30

class UActorElementWorldInterface : public UObject
{
}; // Size: 0x30

class UActorFolder : public UObject
{
}; // Size: 0x28

class UActorPartitionSubsystem : public UWorldSubsystem
{
}; // Size: 0x30

class UActorReplicationBridge : public UObjectReplicationBridge
{
}; // Size: 0x570

class UActorTextureStreamingBuildDataComponent : public UActorComponent
{
}; // Size: 0xA0

class UAimOffsetBlendSpace : public UBlendSpace
{
}; // Size: 0x1C0

class UAimOffsetBlendSpace1D : public UBlendSpace1D
{
}; // Size: 0x1C8

class UAnalysisProperties : public UObject
{
    FString Function;                                                                 // 0x0028 (size: 0x10)

}; // Size: 0x38

class UAnimBlueprint : public UBlueprint
{
    class USkeleton* TargetSkeleton;                                                  // 0x00B0 (size: 0x8)
    TArray<FAnimGroupInfo> Groups;                                                    // 0x00B8 (size: 0x10)
    bool bIsTemplate;                                                                 // 0x00C8 (size: 0x1)
    bool bUseMultiThreadedAnimationUpdate;                                            // 0x00C9 (size: 0x1)
    bool bWarnAboutBlueprintUsage;                                                    // 0x00CA (size: 0x1)
    uint8 bEnableLinkedAnimLayerInstanceSharing;                                      // 0x00CB (size: 0x1)

}; // Size: 0xD0

class UAnimBlueprintClassSubsystem_PropertyAccess : public UObject
{
}; // Size: 0x28

class UAnimBlueprintGeneratedClass : public UBlueprintGeneratedClass
{
    TArray<FBakedAnimationStateMachine> BakedStateMachines;                           // 0x0368 (size: 0x10)
    class USkeleton* TargetSkeleton;                                                  // 0x0378 (size: 0x8)
    TArray<FAnimNotifyEvent> AnimNotifies;                                            // 0x0380 (size: 0x10)
    TMap<class FName, class FCachedPoseIndices> OrderedSavedPoseIndicesMap;           // 0x0390 (size: 0x50)
    TArray<FName> SyncGroupNames;                                                     // 0x0460 (size: 0x10)
    TMap<class FName, class FGraphAssetPlayerInformation> GraphAssetPlayerInformation; // 0x0470 (size: 0x50)
    TMap<class FName, class FAnimGraphBlendOptions> GraphBlendOptions;                // 0x04C0 (size: 0x50)
    TArray<FAnimNodeData> AnimNodeData;                                               // 0x0510 (size: 0x10)
    TMap<class UScriptStruct*, class FAnimNodeStructData> NodeTypeMap;                // 0x0520 (size: 0x50)

}; // Size: 0x5C8

class UAnimBlueprintGeneratedStruct : public UScriptStruct
{
}; // Size: 0xC0

class UAnimBoneCompressionCodec : public UObject
{
    FString Description;                                                              // 0x0028 (size: 0x10)

}; // Size: 0x38

class UAnimBoneCompressionSettings : public UObject
{
    TArray<class UAnimBoneCompressionCodec*> Codecs;                                  // 0x0028 (size: 0x10)

}; // Size: 0x38

class UAnimComposite : public UAnimCompositeBase
{
    FAnimTrack AnimationTrack;                                                        // 0x00B8 (size: 0x10)

}; // Size: 0xC8

class UAnimCompositeBase : public UAnimSequenceBase
{
    FFrameRate CommonTargetFrameRate;                                                 // 0x00B0 (size: 0x8)

}; // Size: 0xB8

class UAnimCompress : public UAnimBoneCompressionCodec
{
    uint8 bNeedsSkeleton;                                                             // 0x0038 (size: 0x1)
    TEnumAsByte<AnimationCompressionFormat> TranslationCompressionFormat;             // 0x003C (size: 0x1)
    TEnumAsByte<AnimationCompressionFormat> RotationCompressionFormat;                // 0x003D (size: 0x1)
    TEnumAsByte<AnimationCompressionFormat> ScaleCompressionFormat;                   // 0x003E (size: 0x1)

}; // Size: 0x40

class UAnimCompress_BitwiseCompressOnly : public UAnimCompress
{
}; // Size: 0x40

class UAnimCompress_LeastDestructive : public UAnimCompress_BitwiseCompressOnly
{
}; // Size: 0x40

class UAnimCompress_PerTrackCompression : public UAnimCompress_RemoveLinearKeys
{
    float MaxZeroingThreshold;                                                        // 0x0060 (size: 0x4)
    float MaxPosDiffBitwise;                                                          // 0x0064 (size: 0x4)
    float MaxAngleDiffBitwise;                                                        // 0x0068 (size: 0x4)
    float MaxScaleDiffBitwise;                                                        // 0x006C (size: 0x4)
    TArray<TEnumAsByte<AnimationCompressionFormat>> AllowedRotationFormats;           // 0x0070 (size: 0x10)
    TArray<TEnumAsByte<AnimationCompressionFormat>> AllowedTranslationFormats;        // 0x0080 (size: 0x10)
    TArray<TEnumAsByte<AnimationCompressionFormat>> AllowedScaleFormats;              // 0x0090 (size: 0x10)
    uint8 bResampleAnimation;                                                         // 0x00A0 (size: 0x1)
    float ResampledFramerate;                                                         // 0x00A4 (size: 0x4)
    int32 MinKeysForResampling;                                                       // 0x00A8 (size: 0x4)
    uint8 bUseAdaptiveError;                                                          // 0x00AC (size: 0x1)
    uint8 bUseOverrideForEndEffectors;                                                // 0x00AC (size: 0x1)
    int32 TrackHeightBias;                                                            // 0x00B0 (size: 0x4)
    float ParentingDivisor;                                                           // 0x00B4 (size: 0x4)
    float ParentingDivisorExponent;                                                   // 0x00B8 (size: 0x4)
    uint8 bUseAdaptiveError2;                                                         // 0x00BC (size: 0x1)
    float RotationErrorSourceRatio;                                                   // 0x00C0 (size: 0x4)
    float TranslationErrorSourceRatio;                                                // 0x00C4 (size: 0x4)
    float ScaleErrorSourceRatio;                                                      // 0x00C8 (size: 0x4)
    float MaxErrorPerTrackRatio;                                                      // 0x00CC (size: 0x4)
    float PerturbationProbeSize;                                                      // 0x00D0 (size: 0x4)

}; // Size: 0xD8

class UAnimCompress_RemoveEverySecondKey : public UAnimCompress
{
    int32 MinKeys;                                                                    // 0x0040 (size: 0x4)
    uint8 bStartAtSecondKey;                                                          // 0x0044 (size: 0x1)

}; // Size: 0x48

class UAnimCompress_RemoveLinearKeys : public UAnimCompress
{
    float MaxPosDiff;                                                                 // 0x0040 (size: 0x4)
    float MaxAngleDiff;                                                               // 0x0044 (size: 0x4)
    float MaxScaleDiff;                                                               // 0x0048 (size: 0x4)
    float MaxEffectorDiff;                                                            // 0x004C (size: 0x4)
    float MinEffectorDiff;                                                            // 0x0050 (size: 0x4)
    float EffectorDiffSocket;                                                         // 0x0054 (size: 0x4)
    float ParentKeyScale;                                                             // 0x0058 (size: 0x4)
    uint8 bRetarget;                                                                  // 0x005C (size: 0x1)
    uint8 bActuallyFilterLinearKeys;                                                  // 0x005C (size: 0x1)

}; // Size: 0x60

class UAnimCompress_RemoveTrivialKeys : public UAnimCompress
{
    float MaxPosDiff;                                                                 // 0x0040 (size: 0x4)
    float MaxAngleDiff;                                                               // 0x0044 (size: 0x4)
    float MaxScaleDiff;                                                               // 0x0048 (size: 0x4)

}; // Size: 0x50

class UAnimCurveCompressionCodec : public UObject
{
}; // Size: 0x28

class UAnimCurveCompressionCodec_CompressedRichCurve : public UAnimCurveCompressionCodec
{
}; // Size: 0x28

class UAnimCurveCompressionCodec_UniformIndexable : public UAnimCurveCompressionCodec
{
}; // Size: 0x28

class UAnimCurveCompressionCodec_UniformlySampled : public UAnimCurveCompressionCodec
{
}; // Size: 0x28

class UAnimCurveCompressionSettings : public UObject
{
    class UAnimCurveCompressionCodec* Codec;                                          // 0x0028 (size: 0x8)

}; // Size: 0x30

class UAnimCurveMetaData : public UAssetUserData
{
    TMap<class FName, class FCurveMetaData> CurveMetaData;                            // 0x0030 (size: 0x50)

}; // Size: 0xA0

class UAnimDataModel : public UObject
{
    int32 BracketCounter;                                                             // 0x0030 (size: 0x4)
    FAnimDataModelModifiedEventDynamic ModifiedEventDynamic;                          // 0x0038 (size: 0x10)
    void AnimDataModelModifiedDynamicEvent(EAnimDataModelNotifyType NotifType, TScriptInterface<class IAnimationDataModel> Model, const FAnimDataModelNotifPayload& Payload);
    TArray<FBoneAnimationTrack> BoneAnimationTracks;                                  // 0x0060 (size: 0x10)
    float PlayLength;                                                                 // 0x0070 (size: 0x4)
    FFrameRate FrameRate;                                                             // 0x0074 (size: 0x8)
    int32 NumberOfFrames;                                                             // 0x007C (size: 0x4)
    int32 NumberOfKeys;                                                               // 0x0080 (size: 0x4)
    FAnimationCurveData CurveData;                                                    // 0x0088 (size: 0x20)
    TArray<FAnimatedBoneAttribute> AnimatedBoneAttributes;                            // 0x00A8 (size: 0x10)
    bool bPopulated;                                                                  // 0x00B8 (size: 0x1)

}; // Size: 0xC8

class UAnimInstance : public UObject
{
    class USkeleton* CurrentSkeleton;                                                 // 0x0028 (size: 0x8)
    TEnumAsByte<ERootMotionMode::Type> RootMotionMode;                                // 0x0030 (size: 0x1)
    uint8 bUseMultiThreadedAnimationUpdate;                                           // 0x0031 (size: 0x1)
    uint8 bUsingCopyPoseFromMesh;                                                     // 0x0031 (size: 0x1)
    uint8 bReceiveNotifiesFromLinkedInstances;                                        // 0x0031 (size: 0x1)
    uint8 bPropagateNotifiesToLinkedInstances;                                        // 0x0031 (size: 0x1)
    uint8 bUseMainInstanceMontageEvaluationData;                                      // 0x0031 (size: 0x1)
    uint8 bQueueMontageEvents;                                                        // 0x0031 (size: 0x1)
    FAnimInstanceOnMontageBlendingOut OnMontageBlendingOut;                           // 0x0038 (size: 0x10)
    void OnMontageBlendingOutStartedMCDelegate(class UAnimMontage* Montage, bool bInterrupted);
    FAnimInstanceOnMontageBlendedIn OnMontageBlendedIn;                               // 0x0048 (size: 0x10)
    void OnMontageBlendedInEndedMCDelegate(class UAnimMontage* Montage);
    FAnimInstanceOnMontageStarted OnMontageStarted;                                   // 0x0058 (size: 0x10)
    void OnMontageStartedMCDelegate(class UAnimMontage* Montage);
    FAnimInstanceOnMontageEnded OnMontageEnded;                                       // 0x0068 (size: 0x10)
    void OnMontageEndedMCDelegate(class UAnimMontage* Montage, bool bInterrupted);
    FAnimInstanceOnAllMontageInstancesEnded OnAllMontageInstancesEnded;               // 0x0078 (size: 0x10)
    void OnAllMontageInstancesEndedMCDelegate();
    FAnimNotifyQueue NotifyQueue;                                                     // 0x0170 (size: 0x70)
    TArray<FAnimNotifyEvent> ActiveAnimNotifyState;                                   // 0x01E0 (size: 0x10)
    TArray<FAnimNotifyEventReference> ActiveAnimNotifyEventReference;                 // 0x01F0 (size: 0x10)

    bool WasAnimNotifyTriggeredInStateMachine(int32 MachineIndex, TSubclassOf<class UAnimNotify> AnimNotifyType);
    bool WasAnimNotifyTriggeredInSourceState(int32 MachineIndex, int32 StateIndex, TSubclassOf<class UAnimNotify> AnimNotifyType);
    bool WasAnimNotifyTriggeredInAnyState(TSubclassOf<class UAnimNotify> AnimNotifyType);
    bool WasAnimNotifyStateActiveInStateMachine(int32 MachineIndex, TSubclassOf<class UAnimNotifyState> AnimNotifyStateType);
    bool WasAnimNotifyStateActiveInSourceState(int32 MachineIndex, int32 StateIndex, TSubclassOf<class UAnimNotifyState> AnimNotifyStateType);
    bool WasAnimNotifyStateActiveInAnyState(TSubclassOf<class UAnimNotifyState> AnimNotifyStateType);
    bool WasAnimNotifyNameTriggeredInStateMachine(int32 MachineIndex, FName NotifyName);
    bool WasAnimNotifyNameTriggeredInSourceState(int32 MachineIndex, int32 StateIndex, FName NotifyName);
    bool WasAnimNotifyNameTriggeredInAnyState(FName NotifyName);
    void UnlockAIResources(bool bUnlockMovement, bool UnlockAILogic);
    void UnlinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass);
    class APawn* TryGetPawnOwner();
    void StopSlotAnimation(float InBlendOutTime, FName SlotNodeName);
    void SnapshotPose(FPoseSnapshot& Snapshot);
    void SetUseMainInstanceMontageEvaluationData(bool bSet);
    void SetRootMotionMode(TEnumAsByte<ERootMotionMode::Type> Value);
    void SetReceiveNotifiesFromLinkedInstances(bool bSet);
    void SetPropagateNotifiesToLinkedInstances(bool bSet);
    void SetMorphTarget(FName MorphTargetName, float Value);
    void SavePoseSnapshot(FName SnapshotName);
    void ResetDynamics(ETeleportType InTeleportType);
    bool RequestTransitionEvent(const FName EventName, const double RequestTimeout, const ETransitionRequestQueueMode QueueMode, const ETransitionRequestOverwriteMode OverwriteMode);
    void RequestSlotGroupInertialization(FName InSlotGroupName, float Duration, const class UBlendProfile* BlendProfile);
    void RemovePoseSnapshot(FName SnapshotName);
    bool QueryTransitionEvent(int32 MachineIndex, int32 TransitionIndex, FName EventName);
    bool QueryAndMarkTransitionEvent(int32 MachineIndex, int32 TransitionIndex, FName EventName);
    class UAnimMontage* PlaySlotAnimationAsDynamicMontage_WithBlendSettings(class UAnimSequenceBase* Asset, FName SlotNodeName, const FMontageBlendSettings& BlendInSettings, const FMontageBlendSettings& BlendOutSettings, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
    class UAnimMontage* PlaySlotAnimationAsDynamicMontage_WithBlendArgs(class UAnimSequenceBase* Asset, FName SlotNodeName, const FAlphaBlendArgs& BlendIn, const FAlphaBlendArgs& BlendOut, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
    class UAnimMontage* PlaySlotAnimationAsDynamicMontage(class UAnimSequenceBase* Asset, FName SlotNodeName, float BlendInTime, float BlendOutTime, float InPlayRate, int32 LoopCount, float BlendOutTriggerTime, float InTimeToStartMontageAt);
    void MontageSync_StopFollowing(const class UAnimMontage* MontageFollower);
    void MontageSync_Follow(const class UAnimMontage* MontageFollower, const class UAnimInstance* OtherAnimInstance, const class UAnimMontage* MontageLeader);
    void Montage_StopWithBlendSettings(const FMontageBlendSettings& BlendOutSettings, const class UAnimMontage* Montage);
    void Montage_StopWithBlendOut(const FAlphaBlendArgs& BlendOut, const class UAnimMontage* Montage);
    void Montage_StopGroupByName(float InBlendOutTime, FName GroupName);
    void Montage_Stop(float InBlendOutTime, const class UAnimMontage* Montage);
    void Montage_SetPosition(const class UAnimMontage* Montage, float NewPosition);
    void Montage_SetPlayRate(const class UAnimMontage* Montage, float NewPlayRate);
    void Montage_SetNextSection(FName SectionNameToChange, FName NextSection, const class UAnimMontage* Montage);
    void Montage_Resume(const class UAnimMontage* Montage);
    float Montage_PlayWithBlendSettings(class UAnimMontage* MontageToPlay, const FMontageBlendSettings& BlendInSettings, float InPlayRate, EMontagePlayReturnType ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages);
    float Montage_PlayWithBlendIn(class UAnimMontage* MontageToPlay, const FAlphaBlendArgs& BlendIn, float InPlayRate, EMontagePlayReturnType ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages);
    float Montage_Play(class UAnimMontage* MontageToPlay, float InPlayRate, EMontagePlayReturnType ReturnValueType, float InTimeToStartMontageAt, bool bStopAllMontages);
    void Montage_Pause(const class UAnimMontage* Montage);
    void Montage_JumpToSectionsEnd(FName SectionName, const class UAnimMontage* Montage);
    void Montage_JumpToSection(FName SectionName, const class UAnimMontage* Montage);
    bool Montage_IsPlaying(const class UAnimMontage* Montage);
    bool Montage_IsActive(const class UAnimMontage* Montage);
    float Montage_GetPosition(const class UAnimMontage* Montage);
    float Montage_GetPlayRate(const class UAnimMontage* Montage);
    bool Montage_GetIsStopped(const class UAnimMontage* Montage);
    float Montage_GetEffectivePlayRate(const class UAnimMontage* Montage);
    FName Montage_GetCurrentSection(const class UAnimMontage* Montage);
    float Montage_GetBlendTime(const class UAnimMontage* Montage);
    void LockAIResources(bool bLockMovement, bool LockAILogic);
    void LinkAnimGraphByTag(FName InTag, TSubclassOf<class UAnimInstance> InClass);
    void LinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass);
    bool IsUsingMainInstanceMontageEvaluationData();
    bool IsSyncGroupBetweenMarkers(FName InSyncGroupName, FName PreviousMarker, FName NextMarker, bool bRespectMarkerOrder);
    bool IsSlotActive(FName SlotNodeName);
    bool IsPlayingSlotAnimation(const class UAnimSequenceBase* Asset, FName SlotNodeName);
    bool IsAnyMontagePlaying();
    bool HasMarkerBeenHitThisFrame(FName SyncGroup, FName MarkerName);
    bool GetTimeToClosestMarker(FName SyncGroup, FName MarkerName, float& OutMarkerTime);
    FMarkerSyncAnimPosition GetSyncGroupPosition(FName InSyncGroupName);
    float GetRelevantAnimTimeRemainingFraction(int32 MachineIndex, int32 StateIndex);
    float GetRelevantAnimTimeRemaining(int32 MachineIndex, int32 StateIndex);
    float GetRelevantAnimTimeFraction(int32 MachineIndex, int32 StateIndex);
    float GetRelevantAnimTime(int32 MachineIndex, int32 StateIndex);
    float GetRelevantAnimLength(int32 MachineIndex, int32 StateIndex);
    bool GetReceiveNotifiesFromLinkedInstances();
    bool GetPropagateNotifiesToLinkedInstances();
    class USkeletalMeshComponent* GetOwningComponent();
    class AActor* GetOwningActor();
    void GetLinkedAnimLayerInstancesByGroup(FName InGroup, TArray<class UAnimInstance*>& OutLinkedInstances);
    class UAnimInstance* GetLinkedAnimLayerInstanceByGroupAndClass(FName InGroup, TSubclassOf<class UAnimInstance> InClass);
    class UAnimInstance* GetLinkedAnimLayerInstanceByGroup(FName InGroup);
    class UAnimInstance* GetLinkedAnimLayerInstanceByClass(TSubclassOf<class UAnimInstance> InClass, bool bCheckForChildClass);
    void GetLinkedAnimGraphInstancesByTag(FName InTag, TArray<class UAnimInstance*>& OutLinkedInstances);
    class UAnimInstance* GetLinkedAnimGraphInstanceByTag(FName InTag);
    float GetInstanceTransitionTimeElapsedFraction(int32 MachineIndex, int32 TransitionIndex);
    float GetInstanceTransitionTimeElapsed(int32 MachineIndex, int32 TransitionIndex);
    float GetInstanceTransitionCrossfadeDuration(int32 MachineIndex, int32 TransitionIndex);
    float GetInstanceStateWeight(int32 MachineIndex, int32 StateIndex);
    float GetInstanceMachineWeight(int32 MachineIndex);
    float GetInstanceCurrentStateElapsedTime(int32 MachineIndex);
    float GetInstanceAssetPlayerTimeFromEndFraction(int32 AssetPlayerIndex);
    float GetInstanceAssetPlayerTimeFromEnd(int32 AssetPlayerIndex);
    float GetInstanceAssetPlayerTimeFraction(int32 AssetPlayerIndex);
    float GetInstanceAssetPlayerTime(int32 AssetPlayerIndex);
    float GetInstanceAssetPlayerLength(int32 AssetPlayerIndex);
    float GetDeltaSeconds();
    bool GetCurveValueWithDefault(FName CurveName, float DefaultValue, float& OutValue);
    float GetCurveValue(FName CurveName);
    FName GetCurrentStateName(int32 MachineIndex);
    class UAnimMontage* GetCurrentActiveMontage();
    void GetAllCurveNames(TArray<FName>& OutNames);
    void GetActiveCurveNames(EAnimCurveType CurveType, TArray<FName>& OutNames);
    bool DynamicMontage_IsPlayingFrom(const class UAnimSequenceBase* Animation);
    void ClearTransitionEvents(const FName EventName);
    void ClearMorphTargets();
    void ClearAllTransitionEvents();
    float CalculateDirection(const FVector& Velocity, const FRotator& BaseRotation);
    void BlueprintUpdateAnimation(float DeltaTimeX);
    void BlueprintThreadSafeUpdateAnimation(float DeltaTime);
    void BlueprintPostEvaluateAnimation();
    void BlueprintLinkedAnimationLayersInitialized();
    void BlueprintInitializeAnimation();
    void BlueprintBeginPlay();
    float Blueprint_GetSlotMontageLocalWeight(FName SlotNodeName);
    class UAnimInstance* Blueprint_GetMainAnimInstance();
}; // Size: 0x370

class UAnimMetaData : public UObject
{
}; // Size: 0x28

class UAnimMontage : public UAnimCompositeBase
{
    EMontageBlendMode BlendModeIn;                                                    // 0x00B8 (size: 0x1)
    EMontageBlendMode BlendModeOut;                                                   // 0x00B9 (size: 0x1)
    FAlphaBlend BlendIn;                                                              // 0x00C0 (size: 0x30)
    FAlphaBlend BlendOut;                                                             // 0x00F0 (size: 0x30)
    float BlendOutTriggerTime;                                                        // 0x0120 (size: 0x4)
    FName SyncGroup;                                                                  // 0x0124 (size: 0x8)
    int32 SyncSlotIndex;                                                              // 0x012C (size: 0x4)
    FMarkerSyncData MarkerData;                                                       // 0x0130 (size: 0x20)
    TArray<FCompositeSection> CompositeSections;                                      // 0x0150 (size: 0x10)
    TArray<FSlotAnimationTrack> SlotAnimTracks;                                       // 0x0160 (size: 0x10)
    bool bEnableRootMotionTranslation;                                                // 0x0170 (size: 0x1)
    bool bEnableRootMotionRotation;                                                   // 0x0171 (size: 0x1)
    bool bEnableAutoBlendOut;                                                         // 0x0172 (size: 0x1)
    class UBlendProfile* BlendProfileIn;                                              // 0x0178 (size: 0x8)
    class UBlendProfile* BlendProfileOut;                                             // 0x0180 (size: 0x8)
    TEnumAsByte<ERootMotionRootLock::Type> RootMotionRootLock;                        // 0x0188 (size: 0x1)
    TArray<FBranchingPointMarker> BranchingPointMarkers;                              // 0x0190 (size: 0x10)
    TArray<int32> BranchingPointStateNotifyIndices;                                   // 0x01A0 (size: 0x10)
    FTimeStretchCurve TimeStretchCurve;                                               // 0x01B0 (size: 0x28)
    FName TimeStretchCurveName;                                                       // 0x01D8 (size: 0x8)

    bool IsValidSectionName(FName InSectionName);
    bool IsValidAdditiveSlot(const FName& SlotNodeName);
    bool IsDynamicMontage();
    FName GetSectionName(int32 SectionIndex);
    int32 GetSectionIndex(FName InSectionName);
    int32 GetNumSections();
    FName GetGroupName();
    class UAnimSequenceBase* GetFirstAnimReference();
    float GetDefaultBlendOutTime();
    float GetDefaultBlendInTime();
    FAlphaBlendArgs GetBlendOutArgs();
    FAlphaBlendArgs GetBlendInArgs();
    class UAnimMontage* CreateSlotAnimationAsDynamicMontage_WithBlendSettings(class UAnimSequenceBase* Asset, FName SlotNodeName, const FMontageBlendSettings& BlendInSettings, const FMontageBlendSettings& BlendOutSettings, float InPlayRate, int32 LoopCount, float InBlendOutTriggerTime);
}; // Size: 0x1E0

class UAnimNotify : public UObject
{

    bool Received_Notify(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference);
    FString GetNotifyName();
    float GetDefaultTriggerWeightThreshold();
}; // Size: 0x38

class UAnimNotifyLibrary : public UBlueprintFunctionLibrary
{

    bool NotifyStateReachedEnd(const FAnimNotifyEventReference& EventReference);
    float GetCurrentAnimationTimeRatio(const FAnimNotifyEventReference& EventReference);
    float GetCurrentAnimationTime(const FAnimNotifyEventReference& EventReference);
    float GetCurrentAnimationNotifyStateTimeRatio(const FAnimNotifyEventReference& EventReference);
    float GetCurrentAnimationNotifyStateTime(const FAnimNotifyEventReference& EventReference);
}; // Size: 0x28

class UAnimNotifyMirrorInspectionLibrary : public UBlueprintFunctionLibrary
{

    bool IsTriggeredByMirroredAnimation(const FAnimNotifyEventReference& EventReference);
    class UMirrorDataTable* GetMirrorDataTable(const FAnimNotifyEventReference& EventReference);
}; // Size: 0x28

class UAnimNotifyState : public UObject
{

    bool Received_NotifyTick(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float FrameDeltaTime, const FAnimNotifyEventReference& EventReference);
    bool Received_NotifyEnd(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, const FAnimNotifyEventReference& EventReference);
    bool Received_NotifyBegin(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration, const FAnimNotifyEventReference& EventReference);
    FString GetNotifyName();
    float GetDefaultTriggerWeightThreshold();
}; // Size: 0x30

class UAnimNotifyStateMachineInspectionLibrary : public UBlueprintFunctionLibrary
{

    bool IsTriggeredByStateMachine(const FAnimNotifyEventReference& EventReference, class UAnimInstance* AnimInstance, FName StateMachineName);
    bool IsTriggeredByStateInStateMachine(const FAnimNotifyEventReference& EventReference, class UAnimInstance* AnimInstance, FName StateMachineName, FName StateName);
    bool IsTriggeredByState(const FAnimNotifyEventReference& EventReference, class UAnimInstance* AnimInstance, FName StateName);
}; // Size: 0x28

class UAnimNotifyState_DisableRootMotion : public UAnimNotifyState
{
}; // Size: 0x30

class UAnimNotifyState_TimedParticleEffect : public UAnimNotifyState
{
    class UParticleSystem* PSTemplate;                                                // 0x0030 (size: 0x8)
    FName SocketName;                                                                 // 0x0038 (size: 0x8)
    FVector LocationOffset;                                                           // 0x0040 (size: 0x18)
    FRotator RotationOffset;                                                          // 0x0058 (size: 0x18)
    bool bDestroyAtEnd;                                                               // 0x0070 (size: 0x1)

}; // Size: 0x78

class UAnimNotifyState_Trail : public UAnimNotifyState
{
    class UParticleSystem* PSTemplate;                                                // 0x0030 (size: 0x8)
    FName FirstSocketName;                                                            // 0x0038 (size: 0x8)
    FName SecondSocketName;                                                           // 0x0040 (size: 0x8)
    TEnumAsByte<ETrailWidthMode> WidthScaleMode;                                      // 0x0048 (size: 0x1)
    FName WidthScaleCurve;                                                            // 0x004C (size: 0x8)
    uint8 bRecycleSpawnedSystems;                                                     // 0x0054 (size: 0x1)

    class UParticleSystem* OverridePSTemplate(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation);
}; // Size: 0x58

class UAnimNotify_PauseClothingSimulation : public UAnimNotify
{
}; // Size: 0x38

class UAnimNotify_PlayParticleEffect : public UAnimNotify
{
    class UParticleSystem* PSTemplate;                                                // 0x0038 (size: 0x8)
    FVector LocationOffset;                                                           // 0x0040 (size: 0x18)
    FRotator RotationOffset;                                                          // 0x0058 (size: 0x18)
    FVector Scale;                                                                    // 0x0070 (size: 0x18)
    uint8 Attached;                                                                   // 0x00B0 (size: 0x1)
    FName SocketName;                                                                 // 0x00B4 (size: 0x8)

}; // Size: 0xC0

class UAnimNotify_PlaySound : public UAnimNotify
{
    class USoundBase* Sound;                                                          // 0x0038 (size: 0x8)
    float VolumeMultiplier;                                                           // 0x0040 (size: 0x4)
    float PitchMultiplier;                                                            // 0x0044 (size: 0x4)
    uint8 bFollow;                                                                    // 0x0048 (size: 0x1)
    FName AttachName;                                                                 // 0x004C (size: 0x8)

}; // Size: 0x58

class UAnimNotify_ResetClothingSimulation : public UAnimNotify
{
}; // Size: 0x38

class UAnimNotify_ResetDynamics : public UAnimNotify
{
}; // Size: 0x38

class UAnimNotify_ResumeClothingSimulation : public UAnimNotify
{
}; // Size: 0x38

class UAnimSequence : public UAnimSequenceBase
{
    class UAnimBoneCompressionSettings* BoneCompressionSettings;                      // 0x00B0 (size: 0x8)
    class UAnimCurveCompressionSettings* CurveCompressionSettings;                    // 0x00B8 (size: 0x8)
    class UVariableFrameStrippingSettings* VariableFrameStrippingSettings;            // 0x0140 (size: 0x8)
    TEnumAsByte<EAdditiveAnimationType> AdditiveAnimType;                             // 0x0148 (size: 0x1)
    TEnumAsByte<EAdditiveBasePoseType> RefPoseType;                                   // 0x0149 (size: 0x1)
    int32 RefFrameIndex;                                                              // 0x014C (size: 0x4)
    class UAnimSequence* RefPoseSeq;                                                  // 0x0150 (size: 0x8)
    FName RetargetSource;                                                             // 0x0158 (size: 0x8)
    TArray<FTransform> RetargetSourceAssetReferencePose;                              // 0x0160 (size: 0x10)
    EAnimInterpolationType Interpolation;                                             // 0x0170 (size: 0x1)
    bool bEnableRootMotion;                                                           // 0x0171 (size: 0x1)
    TEnumAsByte<ERootMotionRootLock::Type> RootMotionRootLock;                        // 0x0172 (size: 0x1)
    bool bForceRootLock;                                                              // 0x0173 (size: 0x1)
    bool bUseNormalizedRootMotionScale;                                               // 0x0174 (size: 0x1)
    bool bRootMotionSettingsCopiedFromMontage;                                        // 0x0175 (size: 0x1)
    EStripAnimDataOnDedicatedServerSettings StripAnimDataOnDedicatedServer;           // 0x0176 (size: 0x1)
    TArray<FAnimSyncMarker> AuthoredSyncMarkers;                                      // 0x0178 (size: 0x10)
    FFrameRate TargetFrameRate;                                                       // 0x0198 (size: 0x8)
    FPerPlatformFrameRate PlatformTargetFrameRate;                                    // 0x01A0 (size: 0x8)
    TMap<class FAnimationAttributeIdentifier, class FAttributeCurve> AttributeCurves; // 0x01A8 (size: 0x50)

}; // Size: 0x1F8

class UAnimSequenceBase : public UAnimationAsset
{
    TArray<FAnimNotifyEvent> Notifies;                                                // 0x0080 (size: 0x10)
    float SequenceLength;                                                             // 0x0090 (size: 0x4)
    FRawCurveTracks RawCurveData;                                                     // 0x0098 (size: 0x10)
    float RateScale;                                                                  // 0x00A8 (size: 0x4)
    bool bLoop;                                                                       // 0x00AC (size: 0x1)

}; // Size: 0xB0

class UAnimSet : public UObject
{
    uint8 bAnimRotationOnly;                                                          // 0x0028 (size: 0x1)
    TArray<FName> TrackBoneNames;                                                     // 0x0030 (size: 0x10)
    TArray<FAnimSetMeshLinkup> LinkupCache;                                           // 0x0040 (size: 0x10)
    TArray<uint8> BoneUseAnimTranslation;                                             // 0x0050 (size: 0x10)
    TArray<uint8> ForceUseMeshTranslation;                                            // 0x0060 (size: 0x10)
    TArray<FName> UseTranslationBoneNames;                                            // 0x0070 (size: 0x10)
    TArray<FName> ForceMeshTranslationBoneNames;                                      // 0x0080 (size: 0x10)
    FName PreviewSkelMeshName;                                                        // 0x0090 (size: 0x8)
    FName BestRatioSkelMeshName;                                                      // 0x0098 (size: 0x8)

}; // Size: 0xF0

class UAnimSingleNodeInstance : public UAnimInstance
{
    class UAnimationAsset* CurrentAsset;                                              // 0x0368 (size: 0x8)
    FAnimSingleNodeInstancePostEvaluateAnimEvent PostEvaluateAnimEvent;               // 0x0370 (size: 0x10)
    void PostEvaluateAnimEvent();

    void StopAnim();
    void SetReverse(bool bInReverse);
    void SetPreviewCurveOverride(const FName& PoseName, float Value, bool bRemoveIfZero);
    void SetPositionWithPreviousTime(float InPosition, float InPreviousTime, bool bFireNotifies);
    void SetPosition(float InPosition, bool bFireNotifies);
    void SetPlayRate(float InPlayRate);
    void SetPlaying(bool bIsPlaying);
    void SetMirrorDataTable(const class UMirrorDataTable* MirrorDataTable);
    void SetLooping(bool bIsLooping);
    void SetBlendSpacePosition(const FVector& InPosition);
    void SetAnimationAsset(class UAnimationAsset* NewAsset, bool bIsLooping, float InPlayRate);
    void PlayAnim(bool bIsLooping, float InPlayRate, float InStartPosition);
    class UMirrorDataTable* GetMirrorDataTable();
    float GetLength();
    class UAnimationAsset* GetAnimationAsset();
}; // Size: 0x380

class UAnimStateMachineTypes : public UObject
{
}; // Size: 0x28

class UAnimStreamable : public UAnimSequenceBase
{
    int32 NumberOfKeys;                                                               // 0x00B0 (size: 0x4)
    EAnimInterpolationType Interpolation;                                             // 0x00B4 (size: 0x1)
    FName RetargetSource;                                                             // 0x00B8 (size: 0x8)
    FFrameRate SamplingFrameRate;                                                     // 0x00C0 (size: 0x8)
    class UAnimBoneCompressionSettings* BoneCompressionSettings;                      // 0x00D8 (size: 0x8)
    class UAnimCurveCompressionSettings* CurveCompressionSettings;                    // 0x00E0 (size: 0x8)
    class UVariableFrameStrippingSettings* VariableFrameStrippingSettings;            // 0x00E8 (size: 0x8)
    bool bEnableRootMotion;                                                           // 0x00F0 (size: 0x1)
    TEnumAsByte<ERootMotionRootLock::Type> RootMotionRootLock;                        // 0x00F1 (size: 0x1)
    bool bForceRootLock;                                                              // 0x00F2 (size: 0x1)
    bool bUseNormalizedRootMotionScale;                                               // 0x00F3 (size: 0x1)

}; // Size: 0xF8

class UAnimatedSparseVolumeTexture : public UStreamableSparseVolumeTexture
{
}; // Size: 0xB0

class UAnimatedSparseVolumeTextureController : public UObject
{
    class USparseVolumeTexture* SparseVolumeTexture;                                  // 0x0028 (size: 0x8)
    float Time;                                                                       // 0x0030 (size: 0x4)
    bool bIsPlaying;                                                                  // 0x0034 (size: 0x1)
    float FrameRate;                                                                  // 0x0038 (size: 0x4)
    int32 MipLevel;                                                                   // 0x003C (size: 0x4)
    bool bBlockingStreamingRequests;                                                  // 0x0040 (size: 0x1)

    void Update(float DeltaTime);
    void Stop();
    void Play();
    void Pause();
    class USparseVolumeTextureFrame* GetFrameByIndex(int32 FrameIndex);
    float GetFractionalFrameIndex();
    float GetDuration();
    void GetCurrentFramesForInterpolation(class USparseVolumeTextureFrame*& Frame0, class USparseVolumeTextureFrame*& Frame1, float& LerpAlpha);
    class USparseVolumeTextureFrame* GetCurrentFrame();
}; // Size: 0x48

class UAnimationAsset : public UObject
{
    class USkeleton* Skeleton;                                                        // 0x0038 (size: 0x8)
    TArray<class UAnimMetaData*> MetaData;                                            // 0x0060 (size: 0x10)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0070 (size: 0x10)

    float GetPlayLength();
    class UAnimMetaData* FindMetaDataByClass(const TSubclassOf<class UAnimMetaData> MetaDataClass);
}; // Size: 0x80

class UAnimationAssetExtensions : public UBlueprintFunctionLibrary
{
}; // Size: 0x28

class UAnimationAttributeIdentifierExtensions : public UBlueprintFunctionLibrary
{

    bool IsValid(FAnimationAttributeIdentifier& Identifier);
}; // Size: 0x28

class UAnimationCurveIdentifierExtensions : public UBlueprintFunctionLibrary
{

    bool IsValid(FAnimationCurveIdentifier& Identifier);
    ERawCurveTrackTypes GetType(FAnimationCurveIdentifier& Identifier);
    FName GetName(FAnimationCurveIdentifier& Identifier);
}; // Size: 0x28

class UAnimationDataModelNotifiesExtensions : public UBlueprintFunctionLibrary
{
}; // Size: 0x28

class UAnimationSettings : public UDeveloperSettings
{
    int32 CompressCommandletVersion;                                                  // 0x0038 (size: 0x4)
    TArray<FString> KeyEndEffectorsMatchNameArray;                                    // 0x0040 (size: 0x10)
    bool ForceRecompression;                                                          // 0x0050 (size: 0x1)
    bool bForceBelowThreshold;                                                        // 0x0051 (size: 0x1)
    bool bFirstRecompressUsingCurrentOrDefault;                                       // 0x0052 (size: 0x1)
    bool bRaiseMaxErrorToExisting;                                                    // 0x0053 (size: 0x1)
    bool bEnablePerformanceLog;                                                       // 0x0054 (size: 0x1)
    bool bStripAnimationDataOnDedicatedServer;                                        // 0x0055 (size: 0x1)
    bool bTickAnimationOnSkeletalMeshInit;                                            // 0x0056 (size: 0x1)
    FTimecodeCustomAttributeNameSettings BoneTimecodeCustomAttributeNameSettings;     // 0x0058 (size: 0x38)
    TArray<FCustomAttributeSetting> BoneCustomAttributesNames;                        // 0x0090 (size: 0x10)
    TArray<FString> BoneNamesWithCustomAttributes;                                    // 0x00A0 (size: 0x10)
    TMap<class FName, class ECustomAttributeBlendType> AttributeBlendModes;           // 0x00B0 (size: 0x50)
    ECustomAttributeBlendType DefaultAttributeBlendMode;                              // 0x0100 (size: 0x1)
    TArray<FString> TransformAttributeNames;                                          // 0x0108 (size: 0x10)
    TArray<TSoftObjectPtr<UUserDefinedStruct>> UserDefinedStructAttributes;           // 0x0118 (size: 0x10)
    TArray<FMirrorFindReplaceExpression> MirrorFindReplaceExpressions;                // 0x0128 (size: 0x10)
    FFrameRate DefaultFrameRate;                                                      // 0x0138 (size: 0x8)
    bool bEnforceSupportedFrameRates;                                                 // 0x0140 (size: 0x1)

    TArray<FString> GetBoneCustomAttributeNamesToImport();
}; // Size: 0x148

class UApplicationLifecycleComponent : public UActorComponent
{
    FApplicationLifecycleComponentApplicationWillDeactivateDelegate ApplicationWillDeactivateDelegate; // 0x00A0 (size: 0x10)
    void ApplicationLifetimeDelegate();
    FApplicationLifecycleComponentApplicationHasReactivatedDelegate ApplicationHasReactivatedDelegate; // 0x00B0 (size: 0x10)
    void ApplicationLifetimeDelegate();
    FApplicationLifecycleComponentApplicationWillEnterBackgroundDelegate ApplicationWillEnterBackgroundDelegate; // 0x00C0 (size: 0x10)
    void ApplicationLifetimeDelegate();
    FApplicationLifecycleComponentApplicationHasEnteredForegroundDelegate ApplicationHasEnteredForegroundDelegate; // 0x00D0 (size: 0x10)
    void ApplicationLifetimeDelegate();
    FApplicationLifecycleComponentApplicationWillTerminateDelegate ApplicationWillTerminateDelegate; // 0x00E0 (size: 0x10)
    void ApplicationLifetimeDelegate();
    FApplicationLifecycleComponentApplicationShouldUnloadResourcesDelegate ApplicationShouldUnloadResourcesDelegate; // 0x00F0 (size: 0x10)
    void ApplicationLifetimeDelegate();
    FApplicationLifecycleComponentApplicationReceivedStartupArgumentsDelegate ApplicationReceivedStartupArgumentsDelegate; // 0x0100 (size: 0x10)
    void ApplicationStartupArgumentsDelegate(const TArray<FString>& StartupArguments);
    FApplicationLifecycleComponentOnTemperatureChangeDelegate OnTemperatureChangeDelegate; // 0x0110 (size: 0x10)
    void OnTemperatureChangeDelegate(ETemperatureSeverityType Severity);
    FApplicationLifecycleComponentOnLowPowerModeDelegate OnLowPowerModeDelegate;      // 0x0120 (size: 0x10)
    void OnLowPowerModeDelegate(bool bInLowPowerMode);

    void OnTemperatureChangeDelegate__DelegateSignature(ETemperatureSeverityType Severity);
    void OnLowPowerModeDelegate__DelegateSignature(bool bInLowPowerMode);
    void ApplicationStartupArgumentsDelegate__DelegateSignature(const TArray<FString>& StartupArguments);
    void ApplicationLifetimeDelegate__DelegateSignature();
}; // Size: 0x130

class UArrowComponent : public UPrimitiveComponent
{
    FColor ArrowColor;                                                                // 0x0518 (size: 0x4)
    float ArrowSize;                                                                  // 0x051C (size: 0x4)
    float ArrowLength;                                                                // 0x0520 (size: 0x4)
    float ScreenSize;                                                                 // 0x0524 (size: 0x4)
    uint8 bIsScreenSizeScaled;                                                        // 0x0528 (size: 0x1)
    uint8 bTreatAsASprite;                                                            // 0x0528 (size: 0x1)

    void SetUseInEditorScaling(bool bNewValue);
    void SetTreatAsASprite(bool bNewValue);
    void SetScreenSize(float NewScreenSize);
    void SetIsScreenSizeScaled(bool bNewValue);
    void SetArrowSize(float NewSize);
    void SetArrowLength(float NewLength);
    void SetArrowFColor(FColor NewColor);
    void SetArrowColor(FLinearColor NewColor);
}; // Size: 0x530

class UAssetExportTask : public UObject
{
    class UObject* Object;                                                            // 0x0028 (size: 0x8)
    class UExporter* Exporter;                                                        // 0x0030 (size: 0x8)
    FString Filename;                                                                 // 0x0038 (size: 0x10)
    bool bSelected;                                                                   // 0x0048 (size: 0x1)
    bool bReplaceIdentical;                                                           // 0x0049 (size: 0x1)
    bool bPrompt;                                                                     // 0x004A (size: 0x1)
    bool bAutomated;                                                                  // 0x004B (size: 0x1)
    bool bUseFileArchive;                                                             // 0x004C (size: 0x1)
    bool bWriteEmptyFiles;                                                            // 0x004D (size: 0x1)
    TArray<class UObject*> IgnoreObjectList;                                          // 0x0050 (size: 0x10)
    class UObject* Options;                                                           // 0x0060 (size: 0x8)
    TArray<FString> Errors;                                                           // 0x0068 (size: 0x10)

}; // Size: 0x78

class UAssetImportData : public UObject
{
}; // Size: 0x28

class UAssetManager : public UObject
{
    TArray<class UObject*> ObjectReferenceList;                                       // 0x0330 (size: 0x10)
    bool bIsGlobalAsyncScanEnvironment;                                               // 0x0340 (size: 0x1)
    bool bShouldGuessTypeAndName;                                                     // 0x0341 (size: 0x1)
    bool bShouldUseSynchronousLoad;                                                   // 0x0342 (size: 0x1)
    bool bIsLoadingFromPakFiles;                                                      // 0x0343 (size: 0x1)
    bool bShouldAcquireMissingChunksOnLoad;                                           // 0x0344 (size: 0x1)
    bool bOnlyCookProductionAssets;                                                   // 0x0345 (size: 0x1)
    int32 NumBulkScanRequests;                                                        // 0x0348 (size: 0x4)
    bool bIsPrimaryAssetDirectoryCurrent;                                             // 0x034C (size: 0x1)
    bool bIsManagementDatabaseCurrent;                                                // 0x034D (size: 0x1)
    bool bUpdateManagementDatabaseAfterScan;                                          // 0x034E (size: 0x1)
    bool bIncludeOnlyOnDiskAssets;                                                    // 0x034F (size: 0x1)
    bool bHasCompletedInitialScan;                                                    // 0x0350 (size: 0x1)
    int32 NumberOfSpawnedNotifications;                                               // 0x0354 (size: 0x4)

}; // Size: 0x4D0

class UAssetManagerSettings : public UDeveloperSettings
{
    TArray<FPrimaryAssetTypeInfo> PrimaryAssetTypesToScan;                            // 0x0038 (size: 0x10)
    TArray<FDirectoryPath> DirectoriesToExclude;                                      // 0x0048 (size: 0x10)
    TArray<FPrimaryAssetRulesOverride> PrimaryAssetRules;                             // 0x0058 (size: 0x10)
    TArray<FPrimaryAssetRulesCustomOverride> CustomPrimaryAssetRules;                 // 0x0068 (size: 0x10)
    bool bOnlyCookProductionAssets;                                                   // 0x0078 (size: 0x1)
    bool bShouldManagerDetermineTypeAndName;                                          // 0x0079 (size: 0x1)
    bool bShouldGuessTypeAndNameInEditor;                                             // 0x007A (size: 0x1)
    bool bShouldAcquireMissingChunksOnLoad;                                           // 0x007B (size: 0x1)
    bool bShouldWarnAboutInvalidAssets;                                               // 0x007C (size: 0x1)
    TArray<FAssetManagerRedirect> PrimaryAssetIdRedirects;                            // 0x0080 (size: 0x10)
    TArray<FAssetManagerRedirect> PrimaryAssetTypeRedirects;                          // 0x0090 (size: 0x10)
    TArray<FAssetManagerRedirect> AssetPathRedirects;                                 // 0x00A0 (size: 0x10)
    TSet<FName> MetaDataTagsForAssetRegistry;                                         // 0x00B0 (size: 0x50)

}; // Size: 0x100

class UAssetMappingTable : public UObject
{
    TArray<FAssetMapping> MappedAssets;                                               // 0x0028 (size: 0x10)

}; // Size: 0x38

class UAssetUserData : public UObject
{
}; // Size: 0x28

class UAsyncActionChangePrimaryAssetBundles : public UAsyncActionLoadPrimaryAssetBase
{
    FAsyncActionChangePrimaryAssetBundlesCompleted Completed;                         // 0x0078 (size: 0x10)
    void OnPrimaryAssetBundlesChanged();

    class UAsyncActionChangePrimaryAssetBundles* AsyncChangeBundleStateForPrimaryAssetList(class UObject* WorldContextObject, const TArray<FPrimaryAssetId>& PrimaryAssetList, const TArray<FName>& AddBundles, const TArray<FName>& RemoveBundles);
    class UAsyncActionChangePrimaryAssetBundles* AsyncChangeBundleStateForMatchingPrimaryAssets(class UObject* WorldContextObject, const TArray<FName>& NewBundles, const TArray<FName>& OldBundles);
}; // Size: 0x88

class UAsyncActionHandleSaveGame : public UBlueprintAsyncActionBase
{
    FAsyncActionHandleSaveGameCompleted Completed;                                    // 0x0030 (size: 0x10)
    void OnAsyncHandleSaveGame(class USaveGame* SaveGame, bool bSuccess);
    class USaveGame* SaveGameObject;                                                  // 0x0060 (size: 0x8)

    class UAsyncActionHandleSaveGame* AsyncSaveGameToSlot(class UObject* WorldContextObject, class USaveGame* SaveGameObject, FString SlotName, const int32 UserIndex);
    class UAsyncActionHandleSaveGame* AsyncLoadGameFromSlot(class UObject* WorldContextObject, FString SlotName, const int32 UserIndex);
}; // Size: 0x68

class UAsyncActionLoadPrimaryAsset : public UAsyncActionLoadPrimaryAssetBase
{
    FAsyncActionLoadPrimaryAssetCompleted Completed;                                  // 0x0078 (size: 0x10)
    void OnPrimaryAssetLoaded(class UObject* Loaded);

    class UAsyncActionLoadPrimaryAsset* AsyncLoadPrimaryAsset(class UObject* WorldContextObject, FPrimaryAssetId PrimaryAsset, const TArray<FName>& LoadBundles);
}; // Size: 0x88

class UAsyncActionLoadPrimaryAssetBase : public UBlueprintAsyncActionBase
{
}; // Size: 0x78

class UAsyncActionLoadPrimaryAssetClass : public UAsyncActionLoadPrimaryAssetBase
{
    FAsyncActionLoadPrimaryAssetClassCompleted Completed;                             // 0x0078 (size: 0x10)
    void OnPrimaryAssetClassLoaded(UClass* Loaded);

    class UAsyncActionLoadPrimaryAssetClass* AsyncLoadPrimaryAssetClass(class UObject* WorldContextObject, FPrimaryAssetId PrimaryAsset, const TArray<FName>& LoadBundles);
}; // Size: 0x88

class UAsyncActionLoadPrimaryAssetClassList : public UAsyncActionLoadPrimaryAssetBase
{
    FAsyncActionLoadPrimaryAssetClassListCompleted Completed;                         // 0x0078 (size: 0x10)
    void OnPrimaryAssetClassListLoaded(const TArray<class UClass*>& Loaded);

    class UAsyncActionLoadPrimaryAssetClassList* AsyncLoadPrimaryAssetClassList(class UObject* WorldContextObject, const TArray<FPrimaryAssetId>& PrimaryAssetList, const TArray<FName>& LoadBundles);
}; // Size: 0x88

class UAsyncActionLoadPrimaryAssetList : public UAsyncActionLoadPrimaryAssetBase
{
    FAsyncActionLoadPrimaryAssetListCompleted Completed;                              // 0x0078 (size: 0x10)
    void OnPrimaryAssetListLoaded(const TArray<class UObject*>& Loaded);

    class UAsyncActionLoadPrimaryAssetList* AsyncLoadPrimaryAssetList(class UObject* WorldContextObject, const TArray<FPrimaryAssetId>& PrimaryAssetList, const TArray<FName>& LoadBundles);
}; // Size: 0x88

class UAsyncLoadingTests_ConvertFromType_V1 : public UObject
{
    TSoftObjectPtr<UObject> Reference;                                                // 0x0028 (size: 0x28)

}; // Size: 0x50

class UAsyncLoadingTests_ConvertFromType_V2 : public UObject
{
    class UObject* Reference;                                                         // 0x0028 (size: 0x8)

}; // Size: 0x30

class UAsyncLoadingTests_Shared : public UObject
{
    TSoftObjectPtr<UObject> SoftReference;                                            // 0x0028 (size: 0x28)
    class UObject* HardReference;                                                     // 0x0050 (size: 0x8)

}; // Size: 0x58

class UAsyncPhysicsData : public UObject
{
    int32 ServerFrame;                                                                // 0x0028 (size: 0x4)
    int32 ReplicationRedundancy;                                                      // 0x002C (size: 0x4)

}; // Size: 0x30

class UAsyncPhysicsInputComponent : public UActorComponent
{
    TSubclassOf<class UAsyncPhysicsData> DataClass;                                   // 0x00A0 (size: 0x8)
    TArray<class UAsyncPhysicsData*> BufferedData;                                    // 0x00A8 (size: 0x10)
    class UAsyncPhysicsData* DataToConsume;                                           // 0x00B8 (size: 0x8)
    class UAsyncPhysicsData* DataToWrite;                                             // 0x00C0 (size: 0x8)

    void ServerRPCBufferInput(class UAsyncPhysicsData* AsyncPhysicsData);
    class UAsyncPhysicsData* GetDataToWrite();
    class UAsyncPhysicsData* GetDataToConsume();
}; // Size: 0xC8

class UAtmosphericFogComponent : public USkyAtmosphereComponent
{

    void SetSunMultiplier(float NewSunMultiplier);
    void SetStartDistance(float NewStartDistance);
    void SetPrecomputeParams(float DensityHeight, int32 MaxScatteringOrder, int32 InscatterAltitudeSampleNum);
    void SetFogMultiplier(float NewFogMultiplier);
    void SetDistanceScale(float NewDistanceScale);
    void SetDistanceOffset(float NewDistanceOffset);
    void SetDensityOffset(float NewDensityOffset);
    void SetDensityMultiplier(float NewDensityMultiplier);
    void SetDefaultLightColor(FLinearColor NewLightColor);
    void SetDefaultBrightness(float NewBrightness);
    void SetAltitudeScale(float NewAltitudeScale);
    void DisableSunDisk(bool NewSunDisk);
    void DisableGroundScattering(bool NewGroundScattering);
}; // Size: 0x330

class UAudioBus : public UObject
{
    EAudioBusChannels AudioBusChannels;                                               // 0x0030 (size: 0x1)

}; // Size: 0x38

class UAudioComponent : public USceneComponent
{
    class USoundBase* Sound;                                                          // 0x03D0 (size: 0x8)
    TArray<FAudioParameter> DefaultParameters;                                        // 0x03D8 (size: 0x10)
    TArray<FAudioParameter> InstanceParameters;                                       // 0x03E8 (size: 0x10)
    class USoundClass* SoundClassOverride;                                            // 0x03F8 (size: 0x8)
    uint8 bAutoDestroy;                                                               // 0x0400 (size: 0x1)
    uint8 bStopWhenOwnerDestroyed;                                                    // 0x0400 (size: 0x1)
    uint8 bShouldRemainActiveIfDropped;                                               // 0x0400 (size: 0x1)
    uint8 bAllowSpatialization;                                                       // 0x0400 (size: 0x1)
    uint8 bOverrideAttenuation;                                                       // 0x0400 (size: 0x1)
    uint8 bOverrideSubtitlePriority;                                                  // 0x0400 (size: 0x1)
    uint8 bIsUISound;                                                                 // 0x0400 (size: 0x1)
    uint8 bEnableLowPassFilter;                                                       // 0x0400 (size: 0x1)
    uint8 bOverridePriority;                                                          // 0x0401 (size: 0x1)
    uint8 bSuppressSubtitles;                                                         // 0x0401 (size: 0x1)
    uint8 bCanPlayMultipleInstances;                                                  // 0x0401 (size: 0x1)
    uint8 bDisableParameterUpdatesWhilePlaying;                                       // 0x0401 (size: 0x1)
    uint8 bAutoManageAttachment;                                                      // 0x0402 (size: 0x1)
    FName AudioComponentUserID;                                                       // 0x0408 (size: 0x8)
    float PitchModulationMin;                                                         // 0x0410 (size: 0x4)
    float PitchModulationMax;                                                         // 0x0414 (size: 0x4)
    float VolumeModulationMin;                                                        // 0x0418 (size: 0x4)
    float VolumeModulationMax;                                                        // 0x041C (size: 0x4)
    float VolumeMultiplier;                                                           // 0x0420 (size: 0x4)
    int32 EnvelopeFollowerAttackTime;                                                 // 0x0424 (size: 0x4)
    int32 EnvelopeFollowerReleaseTime;                                                // 0x0428 (size: 0x4)
    float Priority;                                                                   // 0x042C (size: 0x4)
    float SubtitlePriority;                                                           // 0x0430 (size: 0x4)
    class USoundEffectSourcePresetChain* SourceEffectChain;                           // 0x0438 (size: 0x8)
    float PitchMultiplier;                                                            // 0x0440 (size: 0x4)
    float LowPassFilterFrequency;                                                     // 0x0444 (size: 0x4)
    class USoundAttenuation* AttenuationSettings;                                     // 0x0450 (size: 0x8)
    FSoundAttenuationSettings AttenuationOverrides;                                   // 0x0458 (size: 0x3D0)
    class USoundConcurrency* ConcurrencySettings;                                     // 0x0828 (size: 0x8)
    TSet<USoundConcurrency*> ConcurrencySet;                                          // 0x0830 (size: 0x50)
    EAttachmentRule AutoAttachLocationRule;                                           // 0x088C (size: 0x1)
    EAttachmentRule AutoAttachRotationRule;                                           // 0x088D (size: 0x1)
    EAttachmentRule AutoAttachScaleRule;                                              // 0x088E (size: 0x1)
    FSoundModulationDefaultRoutingSettings ModulationRouting;                         // 0x0890 (size: 0x168)
    FAudioComponentOnAudioPlayStateChanged OnAudioPlayStateChanged;                   // 0x09F8 (size: 0x10)
    void OnAudioPlayStateChanged(EAudioComponentPlayState PlayState);
    FAudioComponentOnAudioVirtualizationChanged OnAudioVirtualizationChanged;         // 0x0A20 (size: 0x10)
    void OnAudioVirtualizationChanged(bool bIsVirtualized);
    FAudioComponentOnAudioFinished OnAudioFinished;                                   // 0x0A48 (size: 0x10)
    void OnAudioFinished();
    FAudioComponentOnAudioPlaybackPercent OnAudioPlaybackPercent;                     // 0x0A70 (size: 0x10)
    void OnAudioPlaybackPercent(const class USoundWave* PlayingSoundWave, const float PlaybackPercent);
    FAudioComponentOnAudioSingleEnvelopeValue OnAudioSingleEnvelopeValue;             // 0x0A98 (size: 0x10)
    void OnAudioSingleEnvelopeValue(const class USoundWave* PlayingSoundWave, const float EnvelopeValue);
    FAudioComponentOnAudioMultiEnvelopeValue OnAudioMultiEnvelopeValue;               // 0x0AC0 (size: 0x10)
    void OnAudioMultiEnvelopeValue(const float AverageEnvelopeValue, const float MaxEnvelope, const int32 NumWaveInstances);
    FAudioComponentOnQueueSubtitles OnQueueSubtitles;                                 // 0x0AE8 (size: 0x10)
    void OnQueueSubtitles(const TArray<FSubtitleCue>& Subtitles, float CueDuration);
    TWeakObjectPtr<class USceneComponent> AutoAttachParent;                           // 0x0B08 (size: 0x8)
    FName AutoAttachSocketName;                                                       // 0x0B10 (size: 0x8)

    void StopDelayed(float DelayTime);
    void Stop();
    void SetWaveParameter(FName InName, class USoundWave* InWave);
    void SetVolumeMultiplier(float NewVolumeMultiplier);
    void SetUISound(bool bInUISound);
    void SetSubmixSend(class USoundSubmixBase* Submix, float SendLevel);
    void SetSourceBusSendPreEffect(class USoundSourceBus* SoundSourceBus, float SourceBusSendLevel);
    void SetSourceBusSendPostEffect(class USoundSourceBus* SoundSourceBus, float SourceBusSendLevel);
    void SetSound(class USoundBase* NewSound);
    void SetPitchMultiplier(float NewPitchMultiplier);
    void SetPaused(bool bPause);
    void SetOverrideAttenuation(bool bInOverrideAttenuation);
    void SetOutputToBusOnly(bool bInOutputToBusOnly);
    void SetModulationRouting(const TSet<USoundModulatorBase*>& Modulators, const EModulationDestination Destination, const EModulationRouting RoutingMethod);
    void SetLowPassFilterFrequency(float InLowPassFilterFrequency);
    void SetLowPassFilterEnabled(bool InLowPassFilterEnabled);
    void SetIntParameter(FName InName, int32 inInt);
    void SetFloatParameter(FName InName, float InFloat);
    void SetBoolParameter(FName InName, bool InBool);
    void SetAudioBusSendPreEffect(class UAudioBus* AudioBus, float AudioBusSendLevel);
    void SetAudioBusSendPostEffect(class UAudioBus* AudioBus, float AudioBusSendLevel);
    void SetAttenuationSettings(class USoundAttenuation* InAttenuationSettings);
    void SetAttenuationOverrides(const FSoundAttenuationSettings& InAttenuationOverrides);
    void PlayQuantized(const class UObject* WorldContextObject, class UQuartzClockHandle*& InClockHandle, FQuartzQuantizationBoundary& InQuantizationBoundary, const FPlayQuantizedInDelegate& InDelegate, float InStartTime, float InFadeInDuration, float InFadeVolumeLevel, EAudioFaderCurve InFadeCurve);
    void Play(float StartTime);
    bool IsVirtualized();
    bool IsPlaying();
    bool HasCookedFFTData();
    bool HasCookedAmplitudeEnvelopeData();
    EAudioComponentPlayState GetPlayState();
    TSet<USoundModulatorBase*> GetModulators(const EModulationDestination Destination);
    bool GetCookedFFTDataForAllPlayingSounds(TArray<FSoundWaveSpectralDataPerSound>& OutSoundWaveSpectralData);
    bool GetCookedFFTData(const TArray<float>& FrequenciesToGet, TArray<FSoundWaveSpectralData>& OutSoundWaveSpectralData);
    bool GetCookedEnvelopeDataForAllPlayingSounds(TArray<FSoundWaveEnvelopeDataPerSound>& OutEnvelopeData);
    bool GetCookedEnvelopeData(float& OutEnvelopeData);
    void FadeOut(float FadeOutDuration, float FadeVolumeLevel, const EAudioFaderCurve FadeCurve);
    void FadeIn(float FadeInDuration, float FadeVolumeLevel, float StartTime, const EAudioFaderCurve FadeCurve);
    bool BP_GetAttenuationSettingsToApply(FSoundAttenuationSettings& OutAttenuationSettings);
    void AdjustVolume(float AdjustVolumeDuration, float AdjustVolumeLevel, const EAudioFaderCurve FadeCurve);
    void AdjustAttenuation(const FSoundAttenuationSettings& InAttenuationSettings);
}; // Size: 0xC10

class UAudioEngineSubsystem : public UDynamicSubsystem
{
}; // Size: 0x30

class UAudioParameterConversionStatics : public UBlueprintFunctionLibrary
{

    FAudioParameter StringToAudioParameter(FName Name, FString String);
    FAudioParameter StringArrayToAudioParameter(FName Name, TArray<FString> Strings);
    FAudioParameter ObjectToAudioParameter(FName Name, class UObject* Object);
    FAudioParameter ObjectArrayToAudioParameter(FName Name, TArray<class UObject*> Objects);
    FAudioParameter IntegerToAudioParameter(FName Name, int32 Integer);
    FAudioParameter IntegerArrayToAudioParameter(FName Name, TArray<int32> Integers);
    FAudioParameter FloatToAudioParameter(FName Name, float float);
    FAudioParameter FloatArrayToAudioParameter(FName Name, TArray<float> Floats);
    FAudioParameter BooleanToAudioParameter(FName Name, bool bool);
    FAudioParameter BooleanArrayToAudioParameter(FName Name, TArray<bool> Bools);
}; // Size: 0x28

class UAudioSettings : public UDeveloperSettings
{
    FSoftObjectPath DefaultSoundClassName;                                            // 0x0038 (size: 0x20)
    FSoftObjectPath DefaultMediaSoundClassName;                                       // 0x0058 (size: 0x20)
    FSoftObjectPath DefaultSoundConcurrencyName;                                      // 0x0078 (size: 0x20)
    FSoftObjectPath DefaultBaseSoundMix;                                              // 0x0098 (size: 0x20)
    FSoftObjectPath VoiPSoundClass;                                                   // 0x00B8 (size: 0x20)
    FSoftObjectPath MasterSubmix;                                                     // 0x00D8 (size: 0x20)
    FSoftObjectPath BaseDefaultSubmix;                                                // 0x00F8 (size: 0x20)
    FSoftObjectPath ReverbSubmix;                                                     // 0x0118 (size: 0x20)
    FSoftObjectPath EQSubmix;                                                         // 0x0138 (size: 0x20)
    EVoiceSampleRate VoiPSampleRate;                                                  // 0x0158 (size: 0x4)
    EDefaultAudioCompressionType DefaultAudioCompressionType;                         // 0x015C (size: 0x1)
    int32 DefaultCompressionQuality;                                                  // 0x0160 (size: 0x4)
    float DefaultReverbSendLevel;                                                     // 0x0164 (size: 0x4)
    int32 MaximumConcurrentStreams;                                                   // 0x0168 (size: 0x4)
    float GlobalMinPitchScale;                                                        // 0x016C (size: 0x4)
    float GlobalMaxPitchScale;                                                        // 0x0170 (size: 0x4)
    TArray<FAudioQualitySettings> QualityLevels;                                      // 0x0178 (size: 0x10)
    uint8 bAllowPlayWhenSilent;                                                       // 0x0188 (size: 0x1)
    uint8 bDisableMasterEQ;                                                           // 0x0188 (size: 0x1)
    uint8 bAllowCenterChannel3DPanning;                                               // 0x0188 (size: 0x1)
    uint32 NumStoppingSources;                                                        // 0x018C (size: 0x4)
    EPanningMethod PanningMethod;                                                     // 0x0190 (size: 0x1)
    EMonoChannelUpmixMethod MonoChannelUpmixMethod;                                   // 0x0191 (size: 0x1)
    FString DialogueFilenameFormat;                                                   // 0x0198 (size: 0x10)
    TArray<FSoundDebugEntry> DebugSounds;                                             // 0x01A8 (size: 0x10)
    TArray<FDefaultAudioBusSettings> DefaultAudioBuses;                               // 0x01B8 (size: 0x10)
    class USoundClass* DefaultSoundClass;                                             // 0x01C8 (size: 0x8)
    class USoundClass* DefaultMediaSoundClass;                                        // 0x01D0 (size: 0x8)
    class USoundConcurrency* DefaultSoundConcurrency;                                 // 0x01D8 (size: 0x8)

}; // Size: 0x1E8

class UAudioSubsystemCollectionRoot : public UObject
{
}; // Size: 0x30

class UAudioWidgetSubsystem : public UEngineSubsystem
{
}; // Size: 0x30

class UAutoDestroySubsystem : public UTickableWorldSubsystem
{
    TArray<class AActor*> ActorsToPoll;                                               // 0x0040 (size: 0x10)

    void OnActorEndPlay(class AActor* Actor, TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
}; // Size: 0x50

class UAutomationTestSettings : public UObject
{
    TArray<FString> EngineTestModules;                                                // 0x0028 (size: 0x10)
    TArray<FString> EditorTestModules;                                                // 0x0038 (size: 0x10)
    FSoftObjectPath AutomationTestmap;                                                // 0x0048 (size: 0x20)
    TArray<FEditorMapPerformanceTestDefinition> EditorPerformanceTestMaps;            // 0x0068 (size: 0x10)
    TArray<FString> AssetsToOpen;                                                     // 0x0078 (size: 0x10)
    TArray<FString> MapsToPIETest;                                                    // 0x0088 (size: 0x10)
    bool bUseAllProjectMapsToPlayInPIE;                                               // 0x0098 (size: 0x1)
    FBuildPromotionTestSettings BuildPromotionTest;                                   // 0x00A0 (size: 0x1F0)
    FMaterialEditorPromotionSettings MaterialEditorPromotionTest;                     // 0x0290 (size: 0x30)
    FParticleEditorPromotionSettings ParticleEditorPromotionTest;                     // 0x02C0 (size: 0x10)
    FBlueprintEditorPromotionSettings BlueprintEditorPromotionTest;                   // 0x02D0 (size: 0x30)
    TArray<FString> TestLevelFolders;                                                 // 0x0300 (size: 0x10)
    TArray<FExternalToolDefinition> ExternalTools;                                    // 0x0310 (size: 0x10)
    TArray<FEditorImportExportTestDefinition> ImportExportTestDefinitions;            // 0x0320 (size: 0x10)
    TArray<FLaunchOnTestSettings> LaunchOnSettings;                                   // 0x0330 (size: 0x10)
    FIntPoint DefaultScreenshotResolution;                                            // 0x0340 (size: 0x8)
    float PIETestDuration;                                                            // 0x0348 (size: 0x4)
    float DefaultInteractiveFramerate;                                                // 0x034C (size: 0x4)
    float DefaultInteractiveFramerateWaitTime;                                        // 0x0350 (size: 0x4)
    float DefaultInteractiveFramerateDuration;                                        // 0x0354 (size: 0x4)

}; // Size: 0x358

class UAvoidanceManager : public UObject
{
    float DefaultTimeToLive;                                                          // 0x0030 (size: 0x4)
    float LockTimeAfterAvoid;                                                         // 0x0034 (size: 0x4)
    float LockTimeAfterClean;                                                         // 0x0038 (size: 0x4)
    float DeltaTimeToPredict;                                                         // 0x003C (size: 0x4)
    float ArtificialRadiusExpansion;                                                  // 0x0040 (size: 0x4)
    float TestHeightDifference;                                                       // 0x0044 (size: 0x4)
    float HeightCheckMargin;                                                          // 0x0048 (size: 0x4)

    bool RegisterMovementComponent(class UMovementComponent* MovementComp, float AvoidanceWeight);
    int32 GetObjectCount();
    int32 GetNewAvoidanceUID();
    FVector GetAvoidanceVelocityForComponent(class UMovementComponent* MovementComp);
}; // Size: 0xE0

class UBillboardComponent : public UPrimitiveComponent
{
    class UTexture2D* Sprite;                                                         // 0x0518 (size: 0x8)
    uint8 bIsScreenSizeScaled;                                                        // 0x0520 (size: 0x1)
    float ScreenSize;                                                                 // 0x0524 (size: 0x4)
    float U;                                                                          // 0x0528 (size: 0x4)
    float UL;                                                                         // 0x052C (size: 0x4)
    float V;                                                                          // 0x0530 (size: 0x4)
    float VL;                                                                         // 0x0534 (size: 0x4)
    float OpacityMaskRefVal;                                                          // 0x0538 (size: 0x4)

    void SetUV(int32 NewU, int32 NewUL, int32 NewV, int32 NewVL);
    void SetSpriteAndUV(class UTexture2D* NewSprite, int32 NewU, int32 NewUL, int32 NewV, int32 NewVL);
    void SetSprite(class UTexture2D* NewSprite);
    void SetOpacityMaskRefVal(float RefVal);
}; // Size: 0x540

class UBlendProfile : public UObject
{
    class USkeleton* OwningSkeleton;                                                  // 0x0030 (size: 0x8)
    TArray<FBlendProfileBoneEntry> ProfileEntries;                                    // 0x0038 (size: 0x10)
    EBlendProfileMode Mode;                                                           // 0x0048 (size: 0x1)

}; // Size: 0x50

class UBlendSpace : public UAnimationAsset
{
    bool bContainsRotationOffsetMeshSpaceSamples;                                     // 0x0088 (size: 0x1)
    FInterpolationParameter InterpolationParam;                                       // 0x008C (size: 0x30)
    float TargetWeightInterpolationSpeedPerSec;                                       // 0x00BC (size: 0x4)
    bool bTargetWeightInterpolationEaseInOut;                                         // 0x00C0 (size: 0x1)
    bool bAllowMeshSpaceBlending;                                                     // 0x00C1 (size: 0x1)
    bool bLoop;                                                                       // 0x00C2 (size: 0x1)
    float AnimLength;                                                                 // 0x00C4 (size: 0x4)
    TEnumAsByte<ENotifyTriggerMode::Type> NotifyTriggerMode;                          // 0x00C8 (size: 0x1)
    bool bInterpolateUsingGrid;                                                       // 0x00C9 (size: 0x1)
    EPreferredTriangulationDirection PreferredTriangulationDirection;                 // 0x00CA (size: 0x1)
    EBlendSpacePerBoneBlendMode PerBoneBlendMode;                                     // 0x00CB (size: 0x1)
    TArray<FPerBoneInterpolation> ManualPerBoneOverrides;                             // 0x00D0 (size: 0x10)
    FBlendSpaceBlendProfile PerBoneBlendProfile;                                      // 0x00E0 (size: 0x10)
    int32 SampleIndexWithMarkers;                                                     // 0x0100 (size: 0x4)
    TArray<FBlendSample> SampleData;                                                  // 0x0108 (size: 0x10)
    TArray<FEditorElement> GridSamples;                                               // 0x0118 (size: 0x10)
    FBlendSpaceData BlendSpaceData;                                                   // 0x0128 (size: 0x20)
    FBlendParameter BlendParameters;                                                  // 0x0148 (size: 0x60)
    TEnumAsByte<EBlendSpaceAxis> AxisToScaleAnimation;                                // 0x01A8 (size: 0x1)
    TArray<int32> DimensionIndices;                                                   // 0x01B0 (size: 0x10)

}; // Size: 0x1C0

class UBlendSpace1D : public UBlendSpace
{
    bool bScaleAnimation;                                                             // 0x01C0 (size: 0x1)

}; // Size: 0x1C8

class UBlueprint : public UBlueprintCore
{
    UClass* ParentClass;                                                              // 0x0058 (size: 0x8)
    TEnumAsByte<EBlueprintType> BlueprintType;                                        // 0x0060 (size: 0x1)
    uint8 bRecompileOnLoad;                                                           // 0x0061 (size: 0x1)
    uint8 bHasBeenRegenerated;                                                        // 0x0061 (size: 0x1)
    uint8 bIsRegeneratingOnLoad;                                                      // 0x0061 (size: 0x1)
    int32 BlueprintSystemVersion;                                                     // 0x0064 (size: 0x4)
    class USimpleConstructionScript* SimpleConstructionScript;                        // 0x0068 (size: 0x8)
    TArray<class UActorComponent*> ComponentTemplates;                                // 0x0070 (size: 0x10)
    TArray<class UTimelineTemplate*> Timelines;                                       // 0x0080 (size: 0x10)
    TArray<FBPComponentClassOverride> ComponentClassOverrides;                        // 0x0090 (size: 0x10)
    class UInheritableComponentHandler* InheritableComponentHandler;                  // 0x00A0 (size: 0x8)

}; // Size: 0xA8

class UBlueprintAsyncActionBase : public UObject
{

    void Activate();
}; // Size: 0x30

class UBlueprintCore : public UObject
{
    UClass* SkeletonGeneratedClass;                                                   // 0x0028 (size: 0x8)
    UClass* GeneratedClass;                                                           // 0x0030 (size: 0x8)
    bool bLegacyNeedToPurgeSkelRefs;                                                  // 0x0038 (size: 0x1)
    FGuid BlueprintGuid;                                                              // 0x003C (size: 0x10)

}; // Size: 0x50

class UBlueprintExtension : public UObject
{
}; // Size: 0x28

class UBlueprintFunctionLibrary : public UObject
{
}; // Size: 0x28

class UBlueprintGeneratedClass : public UClass
{
    int32 NumReplicatedProperties;                                                    // 0x0208 (size: 0x4)
    uint8 bHasCookedComponentInstancingData;                                          // 0x020C (size: 0x1)
    TArray<class UDynamicBlueprintBinding*> DynamicBindingObjects;                    // 0x0210 (size: 0x10)
    TArray<class UActorComponent*> ComponentTemplates;                                // 0x0220 (size: 0x10)
    TArray<class UTimelineTemplate*> Timelines;                                       // 0x0230 (size: 0x10)
    TArray<FBPComponentClassOverride> ComponentClassOverrides;                        // 0x0240 (size: 0x10)
    TArray<FFieldNotificationId> FieldNotifies;                                       // 0x0250 (size: 0x10)
    class USimpleConstructionScript* SimpleConstructionScript;                        // 0x0268 (size: 0x8)
    class UInheritableComponentHandler* InheritableComponentHandler;                  // 0x0270 (size: 0x8)
    class UFunction* UberGraphFunction;                                               // 0x0280 (size: 0x8)
    TMap<class FName, class FGuid> CookedPropertyGuids;                               // 0x0288 (size: 0x50)
    TMap<class FName, class FBlueprintCookedComponentInstancingData> CookedComponentInstancingData; // 0x02D8 (size: 0x50)

}; // Size: 0x360

class UBlueprintMapLibrary : public UBlueprintFunctionLibrary
{

    void SetMapPropertyByName(class UObject* Object, FName PropertyName, const TMap<int32, int32>& Value);
    void Map_Values(const TMap<int32, int32>& TargetMap, TArray<int32>& Values);
    bool Map_Remove(const TMap<int32, int32>& TargetMap, const int32& Key);
    int32 Map_Length(const TMap<int32, int32>& TargetMap);
    void Map_Keys(const TMap<int32, int32>& TargetMap, TArray<int32>& keys);
    bool Map_IsNotEmpty(const TMap<int32, int32>& TargetMap);
    bool Map_IsEmpty(const TMap<int32, int32>& TargetMap);
    bool Map_Find(const TMap<int32, int32>& TargetMap, const int32& Key, int32& Value);
    bool Map_Contains(const TMap<int32, int32>& TargetMap, const int32& Key);
    void Map_Clear(const TMap<int32, int32>& TargetMap);
    void Map_Add(const TMap<int32, int32>& TargetMap, const int32& Key, const int32& Value);
}; // Size: 0x28

class UBlueprintPathsLibrary : public UBlueprintFunctionLibrary
{

    FString VideoCaptureDir();
    void ValidatePath(FString InPath, bool& bDidSucceed, FText& OutReason);
    void Split(FString InPath, FString& PathPart, FString& FilenamePart, FString& ExtensionPart);
    FString SourceConfigDir();
    bool ShouldSaveToUserDir();
    FString ShaderWorkingDir();
    void SetProjectFilePath(FString NewGameProjectFilePath);
    FString SetExtension(FString InPath, FString InNewExtension);
    FString ScreenShotDir();
    FString SandboxesDir();
    FString RootDir();
    void RemoveDuplicateSlashes(FString InPath, FString& OutPath);
    FString ProjectUserDir();
    FString ProjectSavedDir();
    FString ProjectPluginsDir();
    FString ProjectPersistentDownloadDir();
    FString ProjectModsDir();
    FString ProjectLogDir();
    FString ProjectIntermediateDir();
    FString ProjectDir();
    FString ProjectContentDir();
    FString ProjectConfigDir();
    FString ProfilingDir();
    void NormalizeFilename(FString InPath, FString& OutPath);
    void NormalizeDirectoryName(FString InPath, FString& OutPath);
    FString MakeValidFileName(FString InString, FString InReplacementChar);
    void MakeStandardFilename(FString InPath, FString& OutPath);
    void MakePlatformFilename(FString InPath, FString& OutPath);
    bool MakePathRelativeTo(FString InPath, FString InRelativeTo, FString& OutPath);
    FString LaunchDir();
    bool IsSamePath(FString PathA, FString PathB);
    bool IsRestrictedPath(FString InPath);
    bool IsRelative(FString InPath);
    bool IsProjectFilePathSet();
    bool IsDrive(FString InPath);
    bool HasProjectPersistentDownloadDir();
    TArray<FString> GetToolTipLocalizationPaths();
    TArray<FString> GetRestrictedFolderNames();
    FString GetRelativePathToRoot();
    TArray<FString> GetPropertyNameLocalizationPaths();
    FString GetProjectFilePath();
    FString GetPath(FString InPath);
    FString GetInvalidFileSystemChars();
    TArray<FString> GetGameLocalizationPaths();
    FString GetExtension(FString InPath, bool bIncludeDot);
    TArray<FString> GetEngineLocalizationPaths();
    TArray<FString> GetEditorLocalizationPaths();
    FString GetCleanFilename(FString InPath);
    FString GetBaseFilename(FString InPath, bool bRemovePath);
    FString GeneratedConfigDir();
    FString GameUserDeveloperDir();
    FString GameSourceDir();
    FString GameDevelopersDir();
    FString GameAgnosticSavedDir();
    bool FileExists(FString InPath);
    FString FeaturePackDir();
    FString EnterprisePluginsDir();
    FString EnterpriseFeaturePackDir();
    FString EnterpriseDir();
    FString EngineVersionAgnosticUserDir();
    FString EngineUserDir();
    FString EngineSourceDir();
    FString EngineSavedDir();
    FString EnginePluginsDir();
    FString EngineIntermediateDir();
    FString EngineDir();
    FString EngineContentDir();
    FString EngineConfigDir();
    bool DirectoryExists(FString InPath);
    FString DiffDir();
    FString CreateTempFilename(FString Path, FString Prefix, FString Extension);
    FString ConvertToSandboxPath(FString InPath, FString InSandboxName);
    FString ConvertRelativePathToFull(FString InPath, FString InBasePath);
    FString ConvertFromSandboxPath(FString InPath, FString InSandboxName);
    FString Combine(const TArray<FString>& InPaths);
    bool CollapseRelativeDirectories(FString InPath, FString& OutPath);
    FString CloudDir();
    FString ChangeExtension(FString InPath, FString InNewExtension);
    FString BugItDir();
    FString AutomationTransientDir();
    FString AutomationLogDir();
    FString AutomationDir();
}; // Size: 0x28

class UBlueprintPlatformLibrary : public UBlueprintFunctionLibrary
{

    void SetAllowedDeviceOrientation(TEnumAsByte<EScreenOrientation::Type> NewAllowedDeviceOrientation);
    int32 ScheduleLocalNotificationFromNow(int32 inSecondsFromNow, const FText& Title, const FText& Body, const FText& Action, FString ActivationEvent);
    void ScheduleLocalNotificationBadgeFromNow(int32 inSecondsFromNow, FString ActivationEvent);
    int32 ScheduleLocalNotificationBadgeAtTime(const FDateTime& FireDateTime, bool LocalTime, FString ActivationEvent);
    int32 ScheduleLocalNotificationAtTime(const FDateTime& FireDateTime, bool LocalTime, const FText& Title, const FText& Body, const FText& Action, FString ActivationEvent);
    void GetLaunchNotification(bool& NotificationLaunchedApp, FString& ActivationEvent, int32& FireDate);
    TEnumAsByte<EScreenOrientation::Type> GetDeviceOrientation();
    TEnumAsByte<EScreenOrientation::Type> GetAllowedDeviceOrientation();
    void ClearAllLocalNotifications();
    void CancelLocalNotificationById(int32 NotificationId);
    void CancelLocalNotification(FString ActivationEvent);
}; // Size: 0x28

class UBlueprintSetLibrary : public UBlueprintFunctionLibrary
{

    void SetSetPropertyByName(class UObject* Object, FName PropertyName, const TSet<int32>& Value);
    void Set_Union(const TSet<int32>& A, const TSet<int32>& B, TSet<int32>& Result);
    void Set_ToArray(const TSet<int32>& A, TArray<int32>& Result);
    void Set_RemoveItems(const TSet<int32>& TargetSet, const TArray<int32>& Items);
    bool Set_Remove(const TSet<int32>& TargetSet, const int32& Item);
    int32 Set_Length(const TSet<int32>& TargetSet);
    bool Set_IsNotEmpty(const TSet<int32>& TargetSet);
    bool Set_IsEmpty(const TSet<int32>& TargetSet);
    void Set_Intersection(const TSet<int32>& A, const TSet<int32>& B, TSet<int32>& Result);
    void Set_Difference(const TSet<int32>& A, const TSet<int32>& B, TSet<int32>& Result);
    bool Set_Contains(const TSet<int32>& TargetSet, const int32& ItemToFind);
    void Set_Clear(const TSet<int32>& TargetSet);
    void Set_AddItems(const TSet<int32>& TargetSet, const TArray<int32>& NewItems);
    void Set_Add(const TSet<int32>& TargetSet, const int32& NewItem);
}; // Size: 0x28

class UBlueprintTypeConversions : public UObject
{

    TSet<int32> ConvertSetType(const TSet<int32>& Inset);
    TMap<int32, int32> ConvertMapType(const TMap<int32, int32>& InMap);
    int32 ConvertFVector4fToFVector4d(int32 InFromData);
    int32 ConvertFVector4dToFVector4f(int32 InFromData);
    int32 ConvertFVector3fToFVector3d(int32 InFromData);
    int32 ConvertFVector3dToFVector3f(int32 InFromData);
    int32 ConvertFVector2fToFVector2d(int32 InFromData);
    int32 ConvertFVector2dToFVector2f(int32 InFromData);
    int32 ConvertFTransform3fToFTransform3d(int32 InFromData);
    int32 ConvertFTransform3dToFTransform3f(int32 InFromData);
    int32 ConvertFRotator3fToFRotator3d(int32 InFromData);
    int32 ConvertFRotator3dToFRotator3f(int32 InFromData);
    int32 ConvertFQuat4fToFQuat4d(int32 InFromData);
    int32 ConvertFQuat4dToFQuat4f(int32 InFromData);
    int32 ConvertFPlane4fToFPlane4d(int32 InFromData);
    int32 ConvertFPlane4dToFPlane4f(int32 InFromData);
    int32 ConvertFMatrix44fToFMatrix44d(int32 InFromData);
    int32 ConvertFMatrix44dToFMatrix44f(int32 InFromData);
    int32 ConvertFBox2fToFBox2d(int32 InFromData);
    int32 ConvertFBox2dToFBox2f(int32 InFromData);
    TArray<int32> ConvertArrayType(const TArray<int32>& inArray);
}; // Size: 0x28

class UBodySetup : public UBodySetupCore
{
    FKAggregateGeom AggGeom;                                                          // 0x0038 (size: 0x80)
    uint8 bAlwaysFullAnimWeight;                                                      // 0x00B8 (size: 0x1)
    uint8 bConsiderForBounds;                                                         // 0x00B8 (size: 0x1)
    uint8 bMeshCollideAll;                                                            // 0x00B8 (size: 0x1)
    uint8 bDoubleSidedGeometry;                                                       // 0x00B8 (size: 0x1)
    uint8 bGenerateNonMirroredCollision;                                              // 0x00B8 (size: 0x1)
    uint8 bSharedCookedData;                                                          // 0x00B8 (size: 0x1)
    uint8 bGenerateMirroredCollision;                                                 // 0x00B8 (size: 0x1)
    uint8 bSupportUVsAndFaceRemap;                                                    // 0x00B8 (size: 0x1)
    uint8 bNeverNeedsCookedCollisionData;                                             // 0x00B9 (size: 0x1)
    class UPhysicalMaterial* PhysMaterial;                                            // 0x00C0 (size: 0x8)
    FWalkableSlopeOverride WalkableSlopeOverride;                                     // 0x00C8 (size: 0x10)
    FBodyInstance DefaultInstance;                                                    // 0x0148 (size: 0x198)
    FVector BuildScale3D;                                                             // 0x02E8 (size: 0x18)

}; // Size: 0x320

class UBoneMaskFilter : public UObject
{
    TArray<FInputBlendPose> BlendPoses;                                               // 0x0028 (size: 0x10)

}; // Size: 0x38

class UBookMark : public UBookmarkBase
{
    FVector Location;                                                                 // 0x0028 (size: 0x18)
    FRotator Rotation;                                                                // 0x0040 (size: 0x18)
    TArray<FString> HiddenLevels;                                                     // 0x0058 (size: 0x10)

}; // Size: 0x68

class UBookMark2D : public UBookmarkBase
{
    float Zoom2D;                                                                     // 0x0028 (size: 0x4)
    FIntPoint Location;                                                               // 0x002C (size: 0x8)

}; // Size: 0x38

class UBookmarkBase : public UObject
{
}; // Size: 0x28

class UBoundsCopyComponent : public UActorComponent
{
    TSoftObjectPtr<AActor> BoundsSourceActor;                                         // 0x00A0 (size: 0x28)
    bool bUseCollidingComponentsForSourceBounds;                                      // 0x00C8 (size: 0x1)
    bool bKeepOwnBoundsScale;                                                         // 0x00C9 (size: 0x1)
    bool bUseCollidingComponentsForOwnBounds;                                         // 0x00CA (size: 0x1)
    FTransform PostTransform;                                                         // 0x00D0 (size: 0x60)
    bool bCopyXBounds;                                                                // 0x0130 (size: 0x1)
    bool bCopyYBounds;                                                                // 0x0131 (size: 0x1)
    bool bCopyZBounds;                                                                // 0x0132 (size: 0x1)

}; // Size: 0x140

class UBoxComponent : public UShapeComponent
{
    FVector BoxExtent;                                                                // 0x0540 (size: 0x18)

    void SetBoxExtent(FVector InBoxExtent, bool bUpdateOverlaps);
    FVector GetUnscaledBoxExtent();
    FVector GetScaledBoxExtent();
}; // Size: 0x560

class UBoxReflectionCaptureComponent : public UReflectionCaptureComponent
{
    float BoxTransitionDistance;                                                      // 0x0298 (size: 0x4)
    class UBoxComponent* PreviewInfluenceBox;                                         // 0x02A0 (size: 0x8)
    class UBoxComponent* PreviewCaptureBox;                                           // 0x02A8 (size: 0x8)

}; // Size: 0x2B0

class UBrushBuilder : public UObject
{
    FString BitmapFilename;                                                           // 0x0028 (size: 0x10)
    FString ToolTip;                                                                  // 0x0038 (size: 0x10)
    uint8 NotifyBadParams;                                                            // 0x0048 (size: 0x1)
    TArray<FVector> Vertices;                                                         // 0x0050 (size: 0x10)
    TArray<FBuilderPoly> Polys;                                                       // 0x0060 (size: 0x10)
    FName Layer;                                                                      // 0x0070 (size: 0x8)
    uint8 MergeCoplanars;                                                             // 0x0078 (size: 0x1)

}; // Size: 0x80

class UBrushComponent : public UPrimitiveComponent
{
    class UModel* Brush;                                                              // 0x0518 (size: 0x8)
    class UBodySetup* BrushBodySetup;                                                 // 0x0520 (size: 0x8)

}; // Size: 0x530

class UBuiltInAttributesExtensions : public UBlueprintFunctionLibrary
{
}; // Size: 0x28

class UButtonStyleAsset : public UObject
{
    FButtonStyle ButtonStyle;                                                         // 0x0030 (size: 0x3F0)

}; // Size: 0x420

class UCachedAnimDataLibrary : public UBlueprintFunctionLibrary
{

    bool StateMachine_IsStateRelevant(class UAnimInstance* InAnimInstance, const FCachedAnimStateData& CachedAnimStateData);
    float StateMachine_GetLocalWeight(class UAnimInstance* InAnimInstance, const FCachedAnimStateData& CachedAnimStateData);
    float StateMachine_GetGlobalWeight(class UAnimInstance* InAnimInstance, const FCachedAnimStateData& CachedAnimStateData);
}; // Size: 0x28

class UCameraComponent : public USceneComponent
{
    float FieldOfView;                                                                // 0x0230 (size: 0x4)
    float OrthoWidth;                                                                 // 0x0234 (size: 0x4)
    bool bAutoCalculateOrthoPlanes;                                                   // 0x0238 (size: 0x1)
    float AutoPlaneShift;                                                             // 0x023C (size: 0x4)
    float OrthoNearClipPlane;                                                         // 0x0240 (size: 0x4)
    float OrthoFarClipPlane;                                                          // 0x0244 (size: 0x4)
    bool bUpdateOrthoPlanes;                                                          // 0x0248 (size: 0x1)
    bool bUseCameraHeightAsViewTarget;                                                // 0x0249 (size: 0x1)
    float AspectRatio;                                                                // 0x024C (size: 0x4)
    TEnumAsByte<EAspectRatioAxisConstraint> AspectRatioAxisConstraint;                // 0x0250 (size: 0x1)
    uint8 bConstrainAspectRatio;                                                      // 0x0251 (size: 0x1)
    uint8 bOverrideAspectRatioAxisConstraint;                                         // 0x0251 (size: 0x1)
    uint8 bUseFieldOfViewForLOD;                                                      // 0x0251 (size: 0x1)
    uint8 bLockToHmd;                                                                 // 0x0251 (size: 0x1)
    uint8 bUsePawnControlRotation;                                                    // 0x0251 (size: 0x1)
    TEnumAsByte<ECameraProjectionMode::Type> ProjectionMode;                          // 0x0252 (size: 0x1)
    float PostProcessBlendWeight;                                                     // 0x02C0 (size: 0x4)
    FPostProcessSettings PostProcessSettings;                                         // 0x02F0 (size: 0x6F0)

    void SetUseFieldOfViewForLOD(bool bInUseFieldOfViewForLOD);
    void SetUseCameraHeightAsViewTarget(bool bInUseCameraHeightAsViewTarget);
    void SetUpdateOrthoPlanes(bool bInUpdateOrthoPlanes);
    void SetProjectionMode(TEnumAsByte<ECameraProjectionMode::Type> InProjectionMode);
    void SetPostProcessBlendWeight(float InPostProcessBlendWeight);
    void SetOrthoWidth(float InOrthoWidth);
    void SetOrthoNearClipPlane(float InOrthoNearClipPlane);
    void SetOrthoFarClipPlane(float InOrthoFarClipPlane);
    void SetFieldOfView(float InFieldOfView);
    void SetConstraintAspectRatio(bool bInConstrainAspectRatio);
    void SetAutoPlaneShift(float InAutoPlaneShift);
    void SetAutoCalculateOrthoPlanes(bool bAutoCalculate);
    void SetAspectRatioAxisConstraint(TEnumAsByte<EAspectRatioAxisConstraint> InAspectRatioAxisConstraint);
    void SetAspectRatio(float InAspectRatio);
    void RemoveBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject);
    void OnCameraMeshHiddenChanged();
    void GetCameraView(float DeltaTime, FMinimalViewInfo& DesiredView);
    void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
}; // Size: 0x9E0

class UCameraLensEffectInterfaceClassSupportLibrary : public UBlueprintFunctionLibrary
{

    void SetInterfaceClass(TSubclassOf<class AActor> Class, FCameraLensInterfaceClassSupport& Var, EInterfaceValidResult& Result);
    void IsInterfaceValid(const TScriptInterface<class ICameraLensEffectInterface>& CameraLens, EInterfaceValidResult& Result);
    void IsInterfaceClassValid(const FCameraLensInterfaceClassSupport& CameraLens, EInterfaceValidResult& Result);
    TSubclassOf<class AActor> GetInterfaceClass(const FCameraLensInterfaceClassSupport& CameraLens);
}; // Size: 0x28

class UCameraModifier : public UObject
{
    uint8 bDebug;                                                                     // 0x0028 (size: 0x1)
    uint8 bExclusive;                                                                 // 0x0028 (size: 0x1)
    uint8 Priority;                                                                   // 0x002C (size: 0x1)
    class APlayerCameraManager* CameraOwner;                                          // 0x0030 (size: 0x8)
    float AlphaInTime;                                                                // 0x0038 (size: 0x4)
    float AlphaOutTime;                                                               // 0x003C (size: 0x4)
    float Alpha;                                                                      // 0x0040 (size: 0x4)

    void OnCameraOwnerDestroyed(class AActor* InOwner);
    bool IsPendingDisable();
    bool IsDisabled();
    class AActor* GetViewTarget();
    void EnableModifier();
    void DisableModifier(bool bImmediate);
    void BlueprintModifyPostProcess(float DeltaTime, float& PostProcessBlendWeight, FPostProcessSettings& PostProcessSettings);
    void BlueprintModifyCamera(float DeltaTime, FVector ViewLocation, FRotator ViewRotation, float FOV, FVector& NewViewLocation, FRotator& NewViewRotation, float& NewFOV);
}; // Size: 0x48

class UCameraModifier_CameraShake : public UCameraModifier
{
    TArray<FActiveCameraShakeInfo> ActiveShakes;                                      // 0x0048 (size: 0x10)
    TMap<class TSubclassOf<UCameraShakeBase>, class FPooledCameraShakes> ExpiredPooledShakesMap; // 0x0058 (size: 0x50)
    float SplitScreenShakeScale;                                                      // 0x00A8 (size: 0x4)

}; // Size: 0xB0

class UCameraShakeBase : public UObject
{
    bool bSingleInstance;                                                             // 0x0028 (size: 0x1)
    float ShakeScale;                                                                 // 0x002C (size: 0x4)
    class UCameraShakePattern* RootShakePattern;                                      // 0x0030 (size: 0x8)
    class APlayerCameraManager* CameraManager;                                        // 0x0038 (size: 0x8)

    void SetRootShakePattern(class UCameraShakePattern* InPattern);
    class UCameraShakePattern* GetRootShakePattern();
}; // Size: 0xE0

class UCameraShakePattern : public UObject
{
}; // Size: 0x28

class UCameraShakeSourceComponent : public USceneComponent
{
    ECameraShakeAttenuation Attenuation;                                              // 0x0230 (size: 0x1)
    float InnerAttenuationRadius;                                                     // 0x0234 (size: 0x4)
    float OuterAttenuationRadius;                                                     // 0x0238 (size: 0x4)
    TSubclassOf<class UCameraShakeBase> CameraShake;                                  // 0x0240 (size: 0x8)
    bool bAutoStart;                                                                  // 0x0248 (size: 0x1)

    void StopAllCameraShakesOfType(TSubclassOf<class UCameraShakeBase> InCameraShake, bool bImmediately);
    void StopAllCameraShakes(bool bImmediately);
    void StartCameraShake(TSubclassOf<class UCameraShakeBase> InCameraShake, float Scale, ECameraShakePlaySpace PlaySpace, FRotator UserPlaySpaceRot);
    void Start();
    float GetAttenuationFactor(const FVector& Location);
}; // Size: 0x250

class UCancellableAsyncAction : public UBlueprintAsyncActionBase
{

    bool IsActive();
    void Cancel();
}; // Size: 0x30

class UCanvas : public UObject
{
    float OrgX;                                                                       // 0x0028 (size: 0x4)
    float OrgY;                                                                       // 0x002C (size: 0x4)
    float ClipX;                                                                      // 0x0030 (size: 0x4)
    float ClipY;                                                                      // 0x0034 (size: 0x4)
    FColor DrawColor;                                                                 // 0x0038 (size: 0x4)
    uint8 bCenterX;                                                                   // 0x003C (size: 0x1)
    uint8 bCenterY;                                                                   // 0x003C (size: 0x1)
    uint8 bNoSmooth;                                                                  // 0x003C (size: 0x1)
    int32 SizeX;                                                                      // 0x0040 (size: 0x4)
    int32 SizeY;                                                                      // 0x0044 (size: 0x4)
    FPlane ColorModulate;                                                             // 0x0050 (size: 0x20)
    class UTexture2D* DefaultTexture;                                                 // 0x0070 (size: 0x8)
    class UTexture2D* GradientTexture0;                                               // 0x0078 (size: 0x8)
    class UReporterGraph* ReporterGraph;                                              // 0x0080 (size: 0x8)

    FVector2D K2_TextSize(class UFont* RenderFont, FString RenderText, FVector2D Scale);
    FVector2D K2_StrLen(class UFont* RenderFont, FString RenderText);
    FVector K2_Project(FVector WorldLocation);
    void K2_DrawTriangle(class UTexture* RenderTexture, TArray<FCanvasUVTri> Triangles);
    void K2_DrawTexture(class UTexture* RenderTexture, FVector2D ScreenPosition, FVector2D ScreenSize, FVector2D CoordinatePosition, FVector2D CoordinateSize, FLinearColor RenderColor, TEnumAsByte<EBlendMode> BlendMode, float Rotation, FVector2D PivotPoint);
    void K2_DrawText(class UFont* RenderFont, FString RenderText, FVector2D ScreenPosition, FVector2D Scale, FLinearColor RenderColor, float Kerning, FLinearColor ShadowColor, FVector2D ShadowOffset, bool bCentreX, bool bCentreY, bool bOutlined, FLinearColor OutlineColor);
    void K2_DrawPolygon(class UTexture* RenderTexture, FVector2D ScreenPosition, FVector2D Radius, int32 NumberOfSides, FLinearColor RenderColor);
    void K2_DrawMaterialTriangle(class UMaterialInterface* RenderMaterial, TArray<FCanvasUVTri> Triangles);
    void K2_DrawMaterial(class UMaterialInterface* RenderMaterial, FVector2D ScreenPosition, FVector2D ScreenSize, FVector2D CoordinatePosition, FVector2D CoordinateSize, float Rotation, FVector2D PivotPoint);
    void K2_DrawLine(FVector2D ScreenPositionA, FVector2D ScreenPositionB, float Thickness, FLinearColor RenderColor);
    void K2_DrawBox(FVector2D ScreenPosition, FVector2D ScreenSize, float Thickness, FLinearColor RenderColor);
    void K2_DrawBorder(class UTexture* BorderTexture, class UTexture* BackgroundTexture, class UTexture* LeftBorderTexture, class UTexture* RightBorderTexture, class UTexture* TopBorderTexture, class UTexture* BottomBorderTexture, FVector2D ScreenPosition, FVector2D ScreenSize, FVector2D CoordinatePosition, FVector2D CoordinateSize, FLinearColor RenderColor, FVector2D BorderScale, FVector2D BackgroundScale, float Rotation, FVector2D PivotPoint, FVector2D CornerSize);
    void K2_Deproject(FVector2D ScreenPosition, FVector& WorldOrigin, FVector& WorldDirection);
}; // Size: 0x390

class UCanvasRenderTarget2D : public UTextureRenderTarget2D
{
    FCanvasRenderTarget2DOnCanvasRenderTargetUpdate OnCanvasRenderTargetUpdate;       // 0x0160 (size: 0x10)
    void OnCanvasRenderTargetUpdate(class UCanvas* Canvas, int32 Width, int32 Height);
    TWeakObjectPtr<class UWorld> World;                                               // 0x0170 (size: 0x8)
    ETextureRenderTargetSampleCount SampleCount;                                      // 0x0178 (size: 0x1)
    bool bShouldClearRenderTargetOnReceiveUpdate;                                     // 0x0179 (size: 0x1)

    void UpdateResource();
    void SetSampleCount(ETextureRenderTargetSampleCount InSampleCount);
    void ReceiveUpdate(class UCanvas* Canvas, int32 Width, int32 Height);
    void GetSize(int32& Width, int32& Height);
    ETextureRenderTargetSampleCount GetSampleCount();
    class UCanvasRenderTarget2D* CreateCanvasRenderTarget2D(class UObject* WorldContextObject, TSubclassOf<class UCanvasRenderTarget2D> CanvasRenderTarget2DClass, int32 Width, int32 Height);
}; // Size: 0x180

class UCapsuleComponent : public UShapeComponent
{
    float CapsuleHalfHeight;                                                          // 0x0540 (size: 0x4)
    float CapsuleRadius;                                                              // 0x0544 (size: 0x4)

    void SetCapsuleSize(float InRadius, float InHalfHeight, bool bUpdateOverlaps);
    void SetCapsuleRadius(float Radius, bool bUpdateOverlaps);
    void SetCapsuleHalfHeight(float HalfHeight, bool bUpdateOverlaps);
    void GetUnscaledCapsuleSize_WithoutHemisphere(float& OutRadius, float& OutHalfHeightWithoutHemisphere);
    void GetUnscaledCapsuleSize(float& OutRadius, float& OutHalfHeight);
    float GetUnscaledCapsuleRadius();
    float GetUnscaledCapsuleHalfHeight_WithoutHemisphere();
    float GetUnscaledCapsuleHalfHeight();
    float GetShapeScale();
    void GetScaledCapsuleSize_WithoutHemisphere(float& OutRadius, float& OutHalfHeightWithoutHemisphere);
    void GetScaledCapsuleSize(float& OutRadius, float& OutHalfHeight);
    float GetScaledCapsuleRadius();
    float GetScaledCapsuleHalfHeight_WithoutHemisphere();
    float GetScaledCapsuleHalfHeight();
}; // Size: 0x550

class UChannel : public UObject
{
    class UNetConnection* Connection;                                                 // 0x0028 (size: 0x8)

}; // Size: 0x68

class UChaosBlueprintLibrary : public UBlueprintFunctionLibrary
{

    class UChaosEventRelay* GetEventRelayFromContext(class UObject* ContextObject);
}; // Size: 0x28

class UChaosEventRelay : public UObject
{
    FChaosEventRelayOnCollisionEvent OnCollisionEvent;                                // 0x0028 (size: 0x10)
    void CollisionEventSignature(const TArray<FCollisionChaosEvent>& CollisionEvents);
    FChaosEventRelayOnBreakEvent OnBreakEvent;                                        // 0x0038 (size: 0x10)
    void BreakEventSignature(const TArray<FChaosBreakEvent>& BreakEvents);
    FChaosEventRelayOnRemovalEvent OnRemovalEvent;                                    // 0x0048 (size: 0x10)
    void RemovalEventSignature(const TArray<FChaosRemovalEvent>& RemovalEvents);
    FChaosEventRelayOnCrumblingEvent OnCrumblingEvent;                                // 0x0058 (size: 0x10)
    void CrumblingEventSignature(const TArray<FChaosCrumblingEvent>& CrumblingEvents);

}; // Size: 0x68

class UCharacterMovementComponent : public UPawnMovementComponent
{
    class ACharacter* CharacterOwner;                                                 // 0x0168 (size: 0x8)
    float GravityScale;                                                               // 0x0170 (size: 0x4)
    float MaxStepHeight;                                                              // 0x0174 (size: 0x4)
    float JumpZVelocity;                                                              // 0x0178 (size: 0x4)
    float JumpOffJumpZFactor;                                                         // 0x017C (size: 0x4)
    float WalkableFloorAngle;                                                         // 0x019C (size: 0x4)
    float WalkableFloorZ;                                                             // 0x01A0 (size: 0x4)
    FVector GravityDirection;                                                         // 0x01A8 (size: 0x18)
    FQuat WorldToGravityTransform;                                                    // 0x01C0 (size: 0x20)
    FQuat GravityToWorldTransform;                                                    // 0x01E0 (size: 0x20)
    TEnumAsByte<EMovementMode> MovementMode;                                          // 0x0201 (size: 0x1)
    uint8 CustomMovementMode;                                                         // 0x0202 (size: 0x1)
    ENetworkSmoothingMode NetworkSmoothingMode;                                       // 0x0203 (size: 0x1)
    float GroundFriction;                                                             // 0x0204 (size: 0x4)
    float MaxWalkSpeed;                                                               // 0x0248 (size: 0x4)
    float MaxWalkSpeedCrouched;                                                       // 0x024C (size: 0x4)
    float MaxSwimSpeed;                                                               // 0x0250 (size: 0x4)
    float MaxFlySpeed;                                                                // 0x0254 (size: 0x4)
    float MaxCustomMovementSpeed;                                                     // 0x0258 (size: 0x4)
    float MaxAcceleration;                                                            // 0x025C (size: 0x4)
    float MinAnalogWalkSpeed;                                                         // 0x0260 (size: 0x4)
    float BrakingFrictionFactor;                                                      // 0x0264 (size: 0x4)
    float BrakingFriction;                                                            // 0x0268 (size: 0x4)
    float BrakingSubStepTime;                                                         // 0x026C (size: 0x4)
    float BrakingDecelerationWalking;                                                 // 0x0270 (size: 0x4)
    float BrakingDecelerationFalling;                                                 // 0x0274 (size: 0x4)
    float BrakingDecelerationSwimming;                                                // 0x0278 (size: 0x4)
    float BrakingDecelerationFlying;                                                  // 0x027C (size: 0x4)
    float AirControl;                                                                 // 0x0280 (size: 0x4)
    float AirControlBoostMultiplier;                                                  // 0x0284 (size: 0x4)
    float AirControlBoostVelocityThreshold;                                           // 0x0288 (size: 0x4)
    float FallingLateralFriction;                                                     // 0x028C (size: 0x4)
    float CrouchedHalfHeight;                                                         // 0x0290 (size: 0x4)
    float Buoyancy;                                                                   // 0x0294 (size: 0x4)
    float PerchRadiusThreshold;                                                       // 0x0298 (size: 0x4)
    float PerchAdditionalHeight;                                                      // 0x029C (size: 0x4)
    FRotator RotationRate;                                                            // 0x02A0 (size: 0x18)
    uint8 bUseSeparateBrakingFriction;                                                // 0x02B8 (size: 0x1)
    uint8 bApplyGravityWhileJumping;                                                  // 0x02B8 (size: 0x1)
    uint8 bUseControllerDesiredRotation;                                              // 0x02B8 (size: 0x1)
    uint8 bOrientRotationToMovement;                                                  // 0x02B8 (size: 0x1)
    uint8 bSweepWhileNavWalking;                                                      // 0x02B8 (size: 0x1)
    uint8 bMovementInProgress;                                                        // 0x02B8 (size: 0x1)
    uint8 bEnableScopedMovementUpdates;                                               // 0x02B8 (size: 0x1)
    uint8 bEnableServerDualMoveScopedMovementUpdates;                                 // 0x02B9 (size: 0x1)
    uint8 bForceMaxAccel;                                                             // 0x02B9 (size: 0x1)
    uint8 bRunPhysicsWithNoController;                                                // 0x02B9 (size: 0x1)
    uint8 bForceNextFloorCheck;                                                       // 0x02B9 (size: 0x1)
    uint8 bShrinkProxyCapsule;                                                        // 0x02B9 (size: 0x1)
    uint8 bCanWalkOffLedges;                                                          // 0x02B9 (size: 0x1)
    uint8 bCanWalkOffLedgesWhenCrouching;                                             // 0x02B9 (size: 0x1)
    uint8 bNetworkSkipProxyPredictionOnNetUpdate;                                     // 0x02BA (size: 0x1)
    uint8 bNetworkAlwaysReplicateTransformUpdateTimestamp;                            // 0x02BA (size: 0x1)
    uint8 bDeferUpdateMoveComponent;                                                  // 0x02BA (size: 0x1)
    uint8 bEnablePhysicsInteraction;                                                  // 0x02BA (size: 0x1)
    uint8 bTouchForceScaledToMass;                                                    // 0x02BA (size: 0x1)
    uint8 bPushForceScaledToMass;                                                     // 0x02BA (size: 0x1)
    uint8 bPushForceUsingZOffset;                                                     // 0x02BA (size: 0x1)
    uint8 bScalePushForceToVelocity;                                                  // 0x02BB (size: 0x1)
    class USceneComponent* DeferredUpdatedMoveComponent;                              // 0x02C0 (size: 0x8)
    float MaxOutOfWaterStepHeight;                                                    // 0x02C8 (size: 0x4)
    float OutofWaterZ;                                                                // 0x02CC (size: 0x4)
    float Mass;                                                                       // 0x02D0 (size: 0x4)
    float StandingDownwardForceScale;                                                 // 0x02D4 (size: 0x4)
    float InitialPushForceFactor;                                                     // 0x02D8 (size: 0x4)
    float PushForceFactor;                                                            // 0x02DC (size: 0x4)
    float PushForcePointZOffsetFactor;                                                // 0x02E0 (size: 0x4)
    float TouchForceFactor;                                                           // 0x02E4 (size: 0x4)
    float MinTouchForce;                                                              // 0x02E8 (size: 0x4)
    float MaxTouchForce;                                                              // 0x02EC (size: 0x4)
    float RepulsionForce;                                                             // 0x02F0 (size: 0x4)
    FVector Acceleration;                                                             // 0x02F8 (size: 0x18)
    FQuat LastUpdateRotation;                                                         // 0x0310 (size: 0x20)
    FVector LastUpdateLocation;                                                       // 0x0330 (size: 0x18)
    FVector LastUpdateVelocity;                                                       // 0x0348 (size: 0x18)
    float ServerLastTransformUpdateTimeStamp;                                         // 0x0360 (size: 0x4)
    float ServerLastClientGoodMoveAckTime;                                            // 0x0364 (size: 0x4)
    float ServerLastClientAdjustmentTime;                                             // 0x0368 (size: 0x4)
    FVector PendingImpulseToApply;                                                    // 0x0370 (size: 0x18)
    FVector PendingForceToApply;                                                      // 0x0388 (size: 0x18)
    float AnalogInputModifier;                                                        // 0x03A0 (size: 0x4)
    float MaxSimulationTimeStep;                                                      // 0x03B0 (size: 0x4)
    int32 MaxSimulationIterations;                                                    // 0x03B4 (size: 0x4)
    int32 MaxJumpApexAttemptsPerSimulation;                                           // 0x03B8 (size: 0x4)
    float MaxDepenetrationWithGeometry;                                               // 0x03BC (size: 0x4)
    float MaxDepenetrationWithGeometryAsProxy;                                        // 0x03C0 (size: 0x4)
    float MaxDepenetrationWithPawn;                                                   // 0x03C4 (size: 0x4)
    float MaxDepenetrationWithPawnAsProxy;                                            // 0x03C8 (size: 0x4)
    float NetworkSimulatedSmoothLocationTime;                                         // 0x03CC (size: 0x4)
    float NetworkSimulatedSmoothRotationTime;                                         // 0x03D0 (size: 0x4)
    float ListenServerNetworkSimulatedSmoothLocationTime;                             // 0x03D4 (size: 0x4)
    float ListenServerNetworkSimulatedSmoothRotationTime;                             // 0x03D8 (size: 0x4)
    float NetProxyShrinkRadius;                                                       // 0x03DC (size: 0x4)
    float NetProxyShrinkHalfHeight;                                                   // 0x03E0 (size: 0x4)
    float NetworkMaxSmoothUpdateDistance;                                             // 0x03E4 (size: 0x4)
    float NetworkNoSmoothUpdateDistance;                                              // 0x03E8 (size: 0x4)
    float NetworkMinTimeBetweenClientAckGoodMoves;                                    // 0x03EC (size: 0x4)
    float NetworkMinTimeBetweenClientAdjustments;                                     // 0x03F0 (size: 0x4)
    float NetworkMinTimeBetweenClientAdjustmentsLargeCorrection;                      // 0x03F4 (size: 0x4)
    float NetworkLargeClientCorrectionDistance;                                       // 0x03F8 (size: 0x4)
    float LedgeCheckThreshold;                                                        // 0x03FC (size: 0x4)
    float JumpOutOfWaterPitch;                                                        // 0x0400 (size: 0x4)
    FFindFloorResult CurrentFloor;                                                    // 0x0408 (size: 0x108)
    TEnumAsByte<EMovementMode> DefaultLandMovementMode;                               // 0x0510 (size: 0x1)
    TEnumAsByte<EMovementMode> DefaultWaterMovementMode;                              // 0x0511 (size: 0x1)
    TEnumAsByte<EMovementMode> GroundMovementMode;                                    // 0x0512 (size: 0x1)
    uint8 bMaintainHorizontalGroundVelocity;                                          // 0x051C (size: 0x1)
    uint8 bImpartBaseVelocityX;                                                       // 0x051C (size: 0x1)
    uint8 bImpartBaseVelocityY;                                                       // 0x051C (size: 0x1)
    uint8 bImpartBaseVelocityZ;                                                       // 0x051C (size: 0x1)
    uint8 bImpartBaseAngularVelocity;                                                 // 0x051C (size: 0x1)
    uint8 bJustTeleported;                                                            // 0x051C (size: 0x1)
    uint8 bNetworkUpdateReceived;                                                     // 0x051C (size: 0x1)
    uint8 bNetworkMovementModeChanged;                                                // 0x051C (size: 0x1)
    uint8 bNetworkGravityDirectionChanged;                                            // 0x051D (size: 0x1)
    uint8 bIgnoreClientMovementErrorChecksAndCorrection;                              // 0x051D (size: 0x1)
    uint8 bServerAcceptClientAuthoritativePosition;                                   // 0x051D (size: 0x1)
    uint8 bNotifyApex;                                                                // 0x051D (size: 0x1)
    uint8 bCheatFlying;                                                               // 0x051D (size: 0x1)
    uint8 bWantsToCrouch;                                                             // 0x051D (size: 0x1)
    uint8 bCrouchMaintainsBaseLocation;                                               // 0x051D (size: 0x1)
    uint8 bIgnoreBaseRotation;                                                        // 0x051D (size: 0x1)
    uint8 bFastAttachedMove;                                                          // 0x051E (size: 0x1)
    uint8 bAlwaysCheckFloor;                                                          // 0x051E (size: 0x1)
    uint8 bUseFlatBaseForFloorChecks;                                                 // 0x051E (size: 0x1)
    uint8 bPerformingJumpOff;                                                         // 0x051E (size: 0x1)
    uint8 bWantsToLeaveNavWalking;                                                    // 0x051E (size: 0x1)
    uint8 bUseRVOAvoidance;                                                           // 0x051E (size: 0x1)
    uint8 bRequestedMoveUseAcceleration;                                              // 0x051E (size: 0x1)
    uint8 bWasSimulatingRootMotion;                                                   // 0x051F (size: 0x1)
    uint8 bAllowPhysicsRotationDuringAnimRootMotion;                                  // 0x051F (size: 0x1)
    float FormerBaseVelocityDecayHalfLife;                                            // 0x0520 (size: 0x4)
    uint8 bHasRequestedVelocity;                                                      // 0x0524 (size: 0x1)
    uint8 bRequestedMoveWithMaxSpeed;                                                 // 0x0524 (size: 0x1)
    uint8 bWasAvoidanceUpdated;                                                       // 0x0524 (size: 0x1)
    uint8 bProjectNavMeshWalking;                                                     // 0x0524 (size: 0x1)
    uint8 bProjectNavMeshOnBothWorldChannels;                                         // 0x0524 (size: 0x1)
    float AvoidanceConsiderationRadius;                                               // 0x0544 (size: 0x4)
    FVector RequestedVelocity;                                                        // 0x0548 (size: 0x18)
    FVector LastUpdateRequestedVelocity;                                              // 0x0560 (size: 0x18)
    int32 AvoidanceUID;                                                               // 0x0578 (size: 0x4)
    FNavAvoidanceMask AvoidanceGroup;                                                 // 0x057C (size: 0x4)
    FNavAvoidanceMask GroupsToAvoid;                                                  // 0x0580 (size: 0x4)
    FNavAvoidanceMask GroupsToIgnore;                                                 // 0x0584 (size: 0x4)
    float AvoidanceWeight;                                                            // 0x0588 (size: 0x4)
    FVector PendingLaunchVelocity;                                                    // 0x0590 (size: 0x18)
    float NavMeshProjectionInterval;                                                  // 0x06F0 (size: 0x4)
    float NavMeshProjectionTimer;                                                     // 0x06F4 (size: 0x4)
    float NavMeshProjectionInterpSpeed;                                               // 0x06F8 (size: 0x4)
    float NavMeshProjectionHeightScaleUp;                                             // 0x06FC (size: 0x4)
    float NavMeshProjectionHeightScaleDown;                                           // 0x0700 (size: 0x4)
    float NavWalkingFloorDistTolerance;                                               // 0x0704 (size: 0x4)
    bool bBasedMovementIgnorePhysicsBase;                                             // 0x0708 (size: 0x1)
    bool bStayBasedInAir;                                                             // 0x0709 (size: 0x1)
    float StayBasedInAirHeight;                                                       // 0x070C (size: 0x4)
    FCharacterMovementComponentPostPhysicsTickFunction PostPhysicsTickFunction;       // 0x0740 (size: 0x30)
    float MinTimeBetweenTimeStampResets;                                              // 0x0788 (size: 0x4)
    FRootMotionSourceGroup CurrentRootMotion;                                         // 0x0CD8 (size: 0x48)
    FRootMotionSourceGroup ServerCorrectionRootMotion;                                // 0x0D20 (size: 0x48)
    FRootMotionMovementParams RootMotionParams;                                       // 0x0ED0 (size: 0x70)
    FVector AnimRootMotionVelocity;                                                   // 0x0F40 (size: 0x18)

    void SetWalkableFloorZ(float InWalkableFloorZ);
    void SetWalkableFloorAngle(float InWalkableFloorAngle);
    void SetMovementMode(TEnumAsByte<EMovementMode> NewMovementMode, uint8 NewCustomMode);
    void SetGroupsToIgnoreMask(const FNavAvoidanceMask& GroupMask);
    void SetGroupsToIgnore(int32 GroupFlags);
    void SetGroupsToAvoidMask(const FNavAvoidanceMask& GroupMask);
    void SetGroupsToAvoid(int32 GroupFlags);
    void SetGravityDirection(const FVector& GravityDir);
    void SetCrouchedHalfHeight(const float NewValue);
    void SetAvoidanceGroupMask(const FNavAvoidanceMask& GroupMask);
    void SetAvoidanceGroup(int32 GroupFlags);
    void SetAvoidanceEnabled(bool bEnable);
    float K2_GetWalkableFloorZ();
    float K2_GetWalkableFloorAngle();
    void K2_FindFloor(FVector CapsuleLocation, FFindFloorResult& FloorResult);
    void K2_ComputeFloorDist(FVector CapsuleLocation, float LineDistance, float SweepDistance, float SweepRadius, FFindFloorResult& FloorResult);
    bool IsWalking();
    bool IsWalkable(const FHitResult& hit);
    bool HasCustomGravity();
    float GetValidPerchRadius();
    float GetPerchRadiusThreshold();
    class UPrimitiveComponent* GetMovementBase();
    float GetMinAnalogSpeed();
    float GetMaxJumpHeightWithJumpTime();
    float GetMaxJumpHeight();
    float GetMaxBrakingDeceleration();
    float GetMaxAcceleration();
    FVector GetLastUpdateVelocity();
    FRotator GetLastUpdateRotation();
    FVector GetLastUpdateRequestedVelocity();
    FVector GetLastUpdateLocation();
    FVector GetImpartedMovementBaseVelocity();
    FVector GetGravityDirection();
    FVector GetCurrentAcceleration();
    float GetCrouchedHalfHeight();
    class ACharacter* GetCharacterOwner();
    float GetAnalogInputModifier();
    void DisableMovement();
    void ClearAccumulatedForces();
    void CapsuleTouched(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
    void CalcVelocity(float DeltaTime, float Friction, bool bFluid, float BrakingDeceleration);
    void AddImpulse(FVector Impulse, bool bVelocityChange);
    void AddForce(FVector Force);
}; // Size: 0xF80

class UCheatManager : public UObject
{
    class ADebugCameraController* DebugCameraControllerRef;                           // 0x0028 (size: 0x8)
    TSubclassOf<class ADebugCameraController> DebugCameraControllerClass;             // 0x0030 (size: 0x8)
    TArray<class UCheatManagerExtension*> CheatManagerExtensions;                     // 0x0078 (size: 0x10)

    void Walk();
    void ViewSelf();
    void ViewPlayer(FString S);
    void ViewClass(TSubclassOf<class AActor> DesiredClass);
    void ViewActor(FName ActorName);
    void UpdateSafeArea();
    void ToggleServerStatReplicatorUpdateStatNet();
    void ToggleServerStatReplicatorClientOverwrite();
    void ToggleDebugCamera();
    void ToggleAILogging();
    void TestCollisionDistance();
    void Teleport();
    void Summon(FString ClassName);
    void StreamLevelOut(FName PackageName);
    void StreamLevelIn(FName PackageName);
    void SpawnServerStatReplicator();
    void Slomo(float NewTimeDilation);
    void SetWorldOrigin();
    void SetMouseSensitivityToDefault();
    void ServerToggleAILogging();
    void ReceiveInitCheatManager();
    void ReceiveEndPlay();
    void PlayersOnly();
    void OnPlayerEndPlayed(class AActor* Player, TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
    void OnlyLoadLevel(FName PackageName);
    void LogLoc();
    void InvertMouse();
    void God();
    void Ghost();
    class APlayerController* GetPlayerController();
    void FreezeFrame(float Delay);
    void Fly();
    void FlushLog();
    void EnableDebugCamera();
    void DumpVoiceMutingState();
    void DumpPartyState();
    void DumpOnlineSessionState();
    void DumpChatState();
    void DisableDebugCamera();
    void DestroyTarget();
    void DestroyServerStatReplicator();
    void DestroyPawns(TSubclassOf<class APawn> aClass);
    void DestroyAllPawnsExceptTarget();
    void DestroyAll(TSubclassOf<class AActor> aClass);
    void DebugCapsuleSweepSize(float HalfHeight, float Radius);
    void DebugCapsuleSweepPawn();
    void DebugCapsuleSweepComplex(bool bTraceComplex);
    void DebugCapsuleSweepClear();
    void DebugCapsuleSweepChannel(TEnumAsByte<ECollisionChannel> Channel);
    void DebugCapsuleSweepCapture();
    void DebugCapsuleSweep();
    void DamageTarget(float DamageAmount);
    void CheatScript(FString ScriptName);
    void ChangeSize(float F);
    void BugItStringCreator(FVector ViewLocation, FRotator ViewRotation, FString& GoString, FString& LocString);
    void BugItGo(float X, float Y, float Z, float Pitch, float Yaw, float roll);
    void BugIt(FString ScreenShotDescription);
}; // Size: 0x88

class UCheatManagerExtension : public UObject
{

    void RemovedFromCheatManager();
    class APlayerController* GetPlayerController();
    void AddedToCheatManager();
}; // Size: 0x28

class UCheckBoxStyleAsset : public UObject
{
    FCheckBoxStyle CheckBoxStyle;                                                     // 0x0030 (size: 0xAD0)

}; // Size: 0xB00

class UChildActorComponent : public USceneComponent
{
    TSubclassOf<class AActor> ChildActorClass;                                        // 0x0230 (size: 0x8)
    class AActor* ChildActor;                                                         // 0x0238 (size: 0x8)
    class AActor* ChildActorTemplate;                                                 // 0x0240 (size: 0x8)
    uint8 bChildActorIsTransient;                                                     // 0x0260 (size: 0x1)

    void SetChildActorClass(TSubclassOf<class AActor> InClass);
    void OnRep_ChildActor();
    void OnChildActorDestroyed(class AActor* Actor);
}; // Size: 0x280

class UChildConnection : public UNetConnection
{
    class UNetConnection* Parent;                                                     // 0x1E00 (size: 0x8)

}; // Size: 0x1E08

class UCloudStorageBase : public UPlatformInterfaceBase
{
    TArray<FString> LocalCloudFiles;                                                  // 0x0038 (size: 0x10)
    uint8 bSuppressDelegateCalls;                                                     // 0x0048 (size: 0x1)

}; // Size: 0x50

class UClusterUnionComponent : public UPrimitiveComponent
{
    bool bEnableDamageFromCollision;                                                  // 0x0518 (size: 0x1)
    FClusterUnionComponentOnComponentAddedEvent OnComponentAddedEvent;                // 0x0520 (size: 0x10)
    void OnClusterUnionAddedComponent(class UPrimitiveComponent* Component, const TSet<int32>& BoneIds, bool bIsNew);
    FClusterUnionComponentOnComponentRemovedEvent OnComponentRemovedEvent;            // 0x0530 (size: 0x10)
    void OnClusterUnionRemovedComponent(class UPrimitiveComponent* Component);
    FClusterUnionComponentOnComponentBoundsChangedEvent OnComponentBoundsChangedEvent; // 0x0540 (size: 0x10)
    void OnClusterUnionBoundsChanged(class UClusterUnionComponent* Component, const FBoxSphereBounds& Bounds);
    TArray<FComponentReference> ClusteredComponentsReferences;                        // 0x05E8 (size: 0x10)
    int32 GravityGroupIndexOverride;                                                  // 0x05F8 (size: 0x4)
    FClusterUnionReplicatedData ReplicatedRigidState;                                 // 0x0700 (size: 0x2)

    void SetIsAnchored(bool bIsAnchored);
    void SetEnableDamageFromCollision(bool bValue);
    void RemoveComponentFromCluster(class UPrimitiveComponent* InComponent);
    void RemoveComponentBonesFromCluster(class UPrimitiveComponent* InComponent, const TArray<int32>& BoneIds);
    void OnRep_RigidState();
    bool IsComponentAdded(class UPrimitiveComponent* Component);
    bool IsAuthority();
    void HandleComponentPhysicsStateChangePostAddIntoClusterUnion(class UPrimitiveComponent* ChangedComponent, EComponentPhysicsStateChange StateChange);
    void HandleComponentPhysicsStateChange(class UPrimitiveComponent* ChangedComponent, EComponentPhysicsStateChange StateChange);
    TArray<class UPrimitiveComponent*> GetPrimitiveComponents();
    TArray<class AActor*> GetActors();
    void ForceSetChildToParent(class UPrimitiveComponent* InComponent, const TArray<int32>& BoneIds, const TArray<FTransform>& ChildToParent);
    void AddComponentToCluster(class UPrimitiveComponent* InComponent, const TArray<int32>& BoneIds, bool bRebuildGeometry);
}; // Size: 0x760

class UClusterUnionReplicatedProxyComponent : public UActorComponent
{
    TWeakObjectPtr<class UClusterUnionComponent> ParentClusterUnion;                  // 0x00A0 (size: 0x8)
    bool bNetUpdateParentClusterUnion;                                                // 0x00A8 (size: 0x1)
    TWeakObjectPtr<class UPrimitiveComponent> ChildClusteredComponent;                // 0x00AC (size: 0x8)
    bool bNetUpdateChildClusteredComponent;                                           // 0x00B4 (size: 0x1)
    TArray<int32> ParticleBoneIds;                                                    // 0x00B8 (size: 0x10)
    bool bNetUpdateParticleBoneIds;                                                   // 0x0118 (size: 0x1)
    TArray<FTransform> ParticleChildToParents;                                        // 0x0120 (size: 0x10)
    bool bNetUpdateParticleChildToParents;                                            // 0x0130 (size: 0x1)
    bool bIsPendingDeletion;                                                          // 0x0131 (size: 0x1)

    void SetParticleChildToParent(int32 BoneID, const FTransform& ChildToParent);
    void SetParticleBoneIds(const TArray<int32>& InIds);
    void SetParentClusterUnion(class UClusterUnionComponent* InComponent);
    void SetChildClusteredComponent(class UPrimitiveComponent* InComponent);
    void OnRep_ParticleChildToParents();
    void OnRep_ParticleBoneIds();
    void OnRep_ParentClusterUnion();
    void OnRep_ChildClusteredComponent();
    void MarkPendingDeletion();
    bool IsPendingDeletion();
    TArray<int32> GetParticleBoneIds();
    class UClusterUnionComponent* GetParentClusterUnionComponent();
    class UPrimitiveComponent* GetChildClusteredComponent();
}; // Size: 0x140

class UCollisionProfile : public UDeveloperSettings
{
    TArray<FCollisionResponseTemplate> Profiles;                                      // 0x0038 (size: 0x10)
    TArray<FCustomChannelSetup> DefaultChannelResponses;                              // 0x0048 (size: 0x10)
    TArray<FCustomProfile> EditProfiles;                                              // 0x0058 (size: 0x10)
    TArray<FRedirector> ProfileRedirects;                                             // 0x0068 (size: 0x10)
    TArray<FRedirector> CollisionChannelRedirects;                                    // 0x0078 (size: 0x10)

}; // Size: 0x170

class UColorInputDeviceCurveProperty : public UInputDeviceProperty
{
    FDeviceColorCurveData ColorData;                                                  // 0x0030 (size: 0x10)
    TMap<class FName, class FDeviceColorCurveData> DeviceOverrideData;                // 0x0040 (size: 0x50)

}; // Size: 0xA0

class UColorInputDeviceProperty : public UInputDeviceProperty
{
    FDeviceColorData ColorData;                                                       // 0x0030 (size: 0x8)
    TMap<class FName, class FDeviceColorData> DeviceOverrideData;                     // 0x0038 (size: 0x50)

}; // Size: 0x98

class UCommandlet : public UObject
{
    FString HelpDescription;                                                          // 0x0028 (size: 0x10)
    FString HelpUsage;                                                                // 0x0038 (size: 0x10)
    FString HelpWebLink;                                                              // 0x0048 (size: 0x10)
    TArray<FString> HelpParamNames;                                                   // 0x0058 (size: 0x10)
    TArray<FString> HelpParamDescriptions;                                            // 0x0068 (size: 0x10)
    uint8 IsServer;                                                                   // 0x0078 (size: 0x1)
    uint8 IsClient;                                                                   // 0x0078 (size: 0x1)
    uint8 IsEditor;                                                                   // 0x0078 (size: 0x1)
    uint8 LogToConsole;                                                               // 0x0078 (size: 0x1)
    uint8 ShowErrorCount;                                                             // 0x0078 (size: 0x1)
    uint8 ShowProgress;                                                               // 0x0078 (size: 0x1)
    uint8 FastExit;                                                                   // 0x0078 (size: 0x1)
    uint8 UseCommandletResultAsExitCode;                                              // 0x0078 (size: 0x1)

}; // Size: 0x80

class UComponentDelegateBinding : public UDynamicBlueprintBinding
{
    TArray<FBlueprintComponentDelegateBinding> ComponentDelegateBindings;             // 0x0028 (size: 0x10)

}; // Size: 0x38

class UComponentElementCounterInterface : public UObject
{
}; // Size: 0x30

class UComponentElementHierarchyInterface : public UObject
{
}; // Size: 0x30

class UComponentElementObjectInterface : public UObject
{
}; // Size: 0x30

class UComponentElementSelectionInterface : public UObject
{
}; // Size: 0x30

class UComponentElementWorldInterface : public UObject
{
}; // Size: 0x30

class UCompositeCurveTable : public UCurveTable
{
    TArray<class UCurveTable*> ParentTables;                                          // 0x00A0 (size: 0x10)
    TArray<class UCurveTable*> OldParentTables;                                       // 0x00B0 (size: 0x10)

}; // Size: 0xC8

class UCompositeDataTable : public UDataTable
{
    TArray<class UDataTable*> ParentTables;                                           // 0x00B0 (size: 0x10)
    TArray<class UDataTable*> OldParentTables;                                        // 0x00C0 (size: 0x10)

}; // Size: 0xD8

class UConsole : public UObject
{
    class ULocalPlayer* ConsoleTargetPlayer;                                          // 0x0038 (size: 0x8)
    class UTexture2D* DefaultTexture_Black;                                           // 0x0040 (size: 0x8)
    class UTexture2D* DefaultTexture_White;                                           // 0x0048 (size: 0x8)
    TArray<FString> HistoryBuffer;                                                    // 0x0068 (size: 0x10)

}; // Size: 0x130

class UConstraintInstanceBlueprintLibrary : public UBlueprintFunctionLibrary
{

    void SetProjectionParams(FConstraintInstanceAccessor& Accessor, bool bEnableProjection, float ProjectionLinearAlpha, float ProjectionAngularAlpha);
    void SetParentDominates(FConstraintInstanceAccessor& Accessor, bool bParentDominates);
    void SetOrientationDriveTwistAndSwing(FConstraintInstanceAccessor& Accessor, bool bEnableTwistDrive, bool bEnableSwingDrive);
    void SetOrientationDriveSLERP(FConstraintInstanceAccessor& Accessor, bool bEnableSLERP);
    void SetMassConditioningEnabled(FConstraintInstanceAccessor& Accessor, bool bEnableMassConditioning);
    void SetLinearVelocityTarget(FConstraintInstanceAccessor& Accessor, const FVector& InVelTarget);
    void SetLinearVelocityDrive(FConstraintInstanceAccessor& Accessor, bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ);
    void SetLinearSoftLimitParams(FConstraintInstanceAccessor& Accessor, bool bSoftLinearLimit, float LinearLimitStiffness, float LinearLimitDamping, float LinearLimitRestitution, float LinearLimitContactDistance);
    void SetLinearPositionTarget(FConstraintInstanceAccessor& Accessor, const FVector& InPosTarget);
    void SetLinearPositionDrive(FConstraintInstanceAccessor& Accessor, bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ);
    void SetLinearPlasticity(FConstraintInstanceAccessor& Accessor, bool bLinearPlasticity, float LinearPlasticityThreshold, TEnumAsByte<EConstraintPlasticityType> PlasticityType);
    void SetLinearLimits(FConstraintInstanceAccessor& Accessor, TEnumAsByte<ELinearConstraintMotion> XMotion, TEnumAsByte<ELinearConstraintMotion> YMotion, TEnumAsByte<ELinearConstraintMotion> ZMotion, float Limit);
    void SetLinearDriveParams(FConstraintInstanceAccessor& Accessor, float PositionStrength, float VelocityStrength, float InForceLimit);
    void SetLinearBreakable(FConstraintInstanceAccessor& Accessor, bool bLinearBreakable, float LinearBreakThreshold);
    void SetDisableCollision(FConstraintInstanceAccessor& Accessor, bool bDisableCollision);
    void SetContactTransferScale(FConstraintInstanceAccessor& Accessor, float ContactTransferScale);
    void SetAngularVelocityTarget(FConstraintInstanceAccessor& Accessor, const FVector& InVelTarget);
    void SetAngularVelocityDriveTwistAndSwing(FConstraintInstanceAccessor& Accessor, bool bEnableTwistDrive, bool bEnableSwingDrive);
    void SetAngularVelocityDriveSLERP(FConstraintInstanceAccessor& Accessor, bool bEnableSLERP);
    void SetAngularSoftTwistLimitParams(FConstraintInstanceAccessor& Accessor, bool bSoftTwistLimit, float TwistLimitStiffness, float TwistLimitDamping, float TwistLimitRestitution, float TwistLimitContactDistance);
    void SetAngularSoftSwingLimitParams(FConstraintInstanceAccessor& Accessor, bool bSoftSwingLimit, float SwingLimitStiffness, float SwingLimitDamping, float SwingLimitRestitution, float SwingLimitContactDistance);
    void SetAngularPlasticity(FConstraintInstanceAccessor& Accessor, bool bAngularPlasticity, float AngularPlasticityThreshold);
    void SetAngularOrientationTarget(FConstraintInstanceAccessor& Accessor, const FRotator& InPosTarget);
    void SetAngularLimits(FConstraintInstanceAccessor& Accessor, TEnumAsByte<EAngularConstraintMotion> Swing1MotionType, float Swing1LimitAngle, TEnumAsByte<EAngularConstraintMotion> Swing2MotionType, float Swing2LimitAngle, TEnumAsByte<EAngularConstraintMotion> TwistMotionType, float TwistLimitAngle);
    void SetAngularDriveParams(FConstraintInstanceAccessor& Accessor, float PositionStrength, float VelocityStrength, float InForceLimit);
    void SetAngularDriveMode(FConstraintInstanceAccessor& Accessor, TEnumAsByte<EAngularDriveMode::Type> DriveMode);
    void SetAngularBreakable(FConstraintInstanceAccessor& Accessor, bool bAngularBreakable, float AngularBreakThreshold);
    void GetProjectionParams(FConstraintInstanceAccessor& Accessor, bool& bEnableProjection, float& ProjectionLinearAlpha, float& ProjectionAngularAlpha);
    bool GetParentDominates(FConstraintInstanceAccessor& Accessor);
    void GetOrientationDriveTwistAndSwing(FConstraintInstanceAccessor& Accessor, bool& bOutEnableTwistDrive, bool& bOutEnableSwingDrive);
    void GetOrientationDriveSLERP(FConstraintInstanceAccessor& Accessor, bool& bOutEnableSLERP);
    bool GetMassConditioningEnabled(FConstraintInstanceAccessor& Accessor);
    void GetLinearVelocityTarget(FConstraintInstanceAccessor& Accessor, FVector& OutVelTarget);
    void GetLinearVelocityDrive(FConstraintInstanceAccessor& Accessor, bool& bOutEnableDriveX, bool& bOutEnableDriveY, bool& bOutEnableDriveZ);
    void GetLinearSoftLimitParams(FConstraintInstanceAccessor& Accessor, bool& bSoftLinearLimit, float& LinearLimitStiffness, float& LinearLimitDamping, float& LinearLimitRestitution, float& LinearLimitContactDistance);
    void GetLinearPositionTarget(FConstraintInstanceAccessor& Accessor, FVector& OutPosTarget);
    void GetLinearPositionDrive(FConstraintInstanceAccessor& Accessor, bool& bOutEnableDriveX, bool& bOutEnableDriveY, bool& bOutEnableDriveZ);
    void GetLinearPlasticity(FConstraintInstanceAccessor& Accessor, bool& bLinearPlasticity, float& LinearPlasticityThreshold, TEnumAsByte<EConstraintPlasticityType>& PlasticityType);
    void GetLinearLimits(FConstraintInstanceAccessor& Accessor, TEnumAsByte<ELinearConstraintMotion>& XMotion, TEnumAsByte<ELinearConstraintMotion>& YMotion, TEnumAsByte<ELinearConstraintMotion>& ZMotion, float& Limit);
    void GetLinearDriveParams(FConstraintInstanceAccessor& Accessor, float& OutPositionStrength, float& OutVelocityStrength, float& OutForceLimit);
    void GetLinearBreakable(FConstraintInstanceAccessor& Accessor, bool& bLinearBreakable, float& LinearBreakThreshold);
    bool GetDisableCollsion(FConstraintInstanceAccessor& Accessor);
    void GetContactTransferScale(FConstraintInstanceAccessor& Accessor, float& ContactTransferScale);
    void GetAttachedBodyNames(FConstraintInstanceAccessor& Accessor, FName& ParentBody, FName& ChildBody);
    void GetAngularVelocityTarget(FConstraintInstanceAccessor& Accessor, FVector& OutVelTarget);
    void GetAngularVelocityDriveTwistAndSwing(FConstraintInstanceAccessor& Accessor, bool& bOutEnableTwistDrive, bool& bOutEnableSwingDrive);
    void GetAngularVelocityDriveSLERP(FConstraintInstanceAccessor& Accessor, bool& bOutEnableSLERP);
    void GetAngularSoftTwistLimitParams(FConstraintInstanceAccessor& Accessor, bool& bSoftTwistLimit, float& TwistLimitStiffness, float& TwistLimitDamping, float& TwistLimitRestitution, float& TwistLimitContactDistance);
    void GetAngularSoftSwingLimitParams(FConstraintInstanceAccessor& Accessor, bool& bSoftSwingLimit, float& SwingLimitStiffness, float& SwingLimitDamping, float& SwingLimitRestitution, float& SwingLimitContactDistance);
    void GetAngularPlasticity(FConstraintInstanceAccessor& Accessor, bool& bAngularPlasticity, float& AngularPlasticityThreshold);
    void GetAngularOrientationTarget(FConstraintInstanceAccessor& Accessor, FRotator& OutPosTarget);
    void GetAngularLimits(FConstraintInstanceAccessor& Accessor, TEnumAsByte<EAngularConstraintMotion>& Swing1MotionType, float& Swing1LimitAngle, TEnumAsByte<EAngularConstraintMotion>& Swing2MotionType, float& Swing2LimitAngle, TEnumAsByte<EAngularConstraintMotion>& TwistMotionType, float& TwistLimitAngle);
    void GetAngularDriveParams(FConstraintInstanceAccessor& Accessor, float& OutPositionStrength, float& OutVelocityStrength, float& OutForceLimit);
    void GetAngularDriveMode(FConstraintInstanceAccessor& Accessor, TEnumAsByte<EAngularDriveMode::Type>& OutDriveMode);
    void GetAngularBreakable(FConstraintInstanceAccessor& Accessor, bool& bAngularBreakable, float& AngularBreakThreshold);
    void CopyParams(FConstraintInstanceAccessor& Accessor, FConstraintInstanceAccessor& SourceAccessor, bool bKeepPosition, bool bKeepRotation);
}; // Size: 0x28

class UContentBundleDescriptor : public UObject
{
    FString DisplayName;                                                              // 0x0028 (size: 0x10)
    FColor DebugColor;                                                                // 0x0038 (size: 0x4)
    FGuid Guid;                                                                       // 0x003C (size: 0x10)

}; // Size: 0x50

class UContentBundleDuplicateForPIEHelper : public UObject
{
}; // Size: 0x28

class UContentBundleEngineSubsystem : public UEngineSubsystem
{
    TSoftClassPtr<UContentBundleTypeFactory> ContentBundleTypeFactoryClass;           // 0x00A0 (size: 0x28)
    class UContentBundleTypeFactory* ContentBundleTypeFactory;                        // 0x00C8 (size: 0x8)

}; // Size: 0xD0

class UContentBundleManager : public UObject
{
}; // Size: 0x38

class UContentBundleTypeFactory : public UObject
{
}; // Size: 0x28

class UContentBundleUnsavedActorMonitor : public UObject
{
}; // Size: 0x28

class UControlChannel : public UChannel
{
}; // Size: 0x80

class UCurveBase : public UObject
{

    void GetValueRange(float& MinValue, float& MaxValue);
    void GetTimeRange(float& MinTime, float& MaxTime);
}; // Size: 0x30

class UCurveFloat : public UCurveBase
{
    FRichCurve FloatCurve;                                                            // 0x0030 (size: 0x80)
    bool bIsEventCurve;                                                               // 0x00B0 (size: 0x1)

    float GetFloatValue(float InTime);
}; // Size: 0xB8

class UCurveLinearColor : public UCurveBase
{
    FRichCurve FloatCurves;                                                           // 0x0030 (size: 0x200)
    float AdjustHue;                                                                  // 0x0230 (size: 0x4)
    float AdjustSaturation;                                                           // 0x0234 (size: 0x4)
    float AdjustBrightness;                                                           // 0x0238 (size: 0x4)
    float AdjustBrightnessCurve;                                                      // 0x023C (size: 0x4)
    float AdjustVibrance;                                                             // 0x0240 (size: 0x4)
    float AdjustMinAlpha;                                                             // 0x0244 (size: 0x4)
    float AdjustMaxAlpha;                                                             // 0x0248 (size: 0x4)

    FLinearColor GetUnadjustedLinearColorValue(float InTime);
    FLinearColor GetLinearColorValue(float InTime);
    FLinearColor GetClampedLinearColorValue(float InTime);
}; // Size: 0x250

class UCurveLinearColorAtlas : public UTexture2D
{
    uint32 TextureSize;                                                               // 0x0150 (size: 0x4)
    uint8 bSquareResolution;                                                          // 0x0154 (size: 0x1)
    uint32 TextureHeight;                                                             // 0x0158 (size: 0x4)
    TArray<class UCurveLinearColor*> GradientCurves;                                  // 0x0160 (size: 0x10)

    bool GetCurvePosition(class UCurveLinearColor* InCurve, float& Position);
}; // Size: 0x170

class UCurveTable : public UObject
{
}; // Size: 0xA0

class UCurveVector : public UCurveBase
{
    FRichCurve FloatCurves;                                                           // 0x0030 (size: 0x180)

    FVector GetVectorValue(float InTime);
}; // Size: 0x1B0

class UDEPRECATED_Breakpoint : public UObject
{
}; // Size: 0x28

class UDEPRECATED_CurveEdPresetCurve : public UObject
{
}; // Size: 0x28

class UDEPRECATED_DataLayer : public UObject
{
    FName DataLayerLabel;                                                             // 0x0028 (size: 0x8)
    uint8 bIsRuntime;                                                                 // 0x0030 (size: 0x1)
    EDataLayerRuntimeState InitialRuntimeState;                                       // 0x0034 (size: 0x1)
    FColor DebugColor;                                                                // 0x0038 (size: 0x4)
    class UDEPRECATED_DataLayer* Parent;                                              // 0x0040 (size: 0x8)
    TArray<class UDEPRECATED_DataLayer*> Children;                                    // 0x0048 (size: 0x10)

    bool IsVisible();
    bool IsRuntime();
    bool IsInitiallyVisible();
    bool IsInitiallyActive();
    bool IsEffectiveVisible();
    bool IsDynamicallyLoaded();
    EDataLayerState GetInitialState();
    EDataLayerRuntimeState GetInitialRuntimeState();
    FColor GetDebugColor();
    FName GetDataLayerLabel();
    bool Equals(const FActorDataLayer& ActorDataLayer);
}; // Size: 0x58

class UDPICustomScalingRule : public UObject
{
}; // Size: 0x28

class UDamageType : public UObject
{
    uint8 bCausedByWorld;                                                             // 0x0028 (size: 0x1)
    uint8 bScaleMomentumByMass;                                                       // 0x0028 (size: 0x1)
    uint8 bRadialDamageVelChange;                                                     // 0x0028 (size: 0x1)
    float DamageImpulse;                                                              // 0x002C (size: 0x4)
    float DestructibleImpulse;                                                        // 0x0030 (size: 0x4)
    float DestructibleDamageSpreadScale;                                              // 0x0034 (size: 0x4)
    float DamageFalloff;                                                              // 0x0038 (size: 0x4)

}; // Size: 0x40

class UDataAsset : public UObject
{
    TSubclassOf<class UDataAsset> NativeClass;                                        // 0x0028 (size: 0x8)

}; // Size: 0x30

class UDataDrivenCVarEngineSubsystem : public UEngineSubsystem
{
    FDataDrivenCVarEngineSubsystemOnDataDrivenCVarDelegate OnDataDrivenCVarDelegate;  // 0x0030 (size: 0x10)
    void OnDataDrivenCVarChanged(FString CVarName);

    void OnDataDrivenCVarChanged__DelegateSignature(FString CVarName);
}; // Size: 0x40

class UDataDrivenConsoleVariableSettings : public UDeveloperSettings
{
    TArray<FDataDrivenConsoleVariable> CVarsArray;                                    // 0x0050 (size: 0x10)

}; // Size: 0x70

class UDataLayerAsset : public UDataAsset
{
    EDataLayerType DataLayerType;                                                     // 0x0030 (size: 0x1)
    bool bSupportsActorFilters;                                                       // 0x0031 (size: 0x1)
    FColor DebugColor;                                                                // 0x0034 (size: 0x4)
    EDataLayerLoadFilter LoadFilter;                                                  // 0x0038 (size: 0x1)

    bool IsServerOnly();
    bool IsRuntime();
    bool IsClientOnly();
    EDataLayerType GetType();
    FColor GetDebugColor();
}; // Size: 0x40

class UDataLayerInstance : public UObject
{
    EDataLayerRuntimeState InitialRuntimeState;                                       // 0x0028 (size: 0x1)
    class UDataLayerInstance* Parent;                                                 // 0x0030 (size: 0x8)
    TArray<class UDataLayerInstance*> Children;                                       // 0x0038 (size: 0x10)

    bool IsVisible();
    bool IsServerOnly();
    bool IsRuntime();
    bool IsInitiallyVisible();
    bool IsEffectiveVisible();
    bool IsClientOnly();
    EDataLayerType GetType();
    EDataLayerRuntimeState GetInitialRuntimeState();
    FColor GetDebugColor();
    FString GetDataLayerShortName();
    FString GetDataLayerFullName();
    class UDataLayerAsset* GetAsset();
}; // Size: 0x48

class UDataLayerInstancePrivate : public UDataLayerInstance
{
    FString ShortName;                                                                // 0x0048 (size: 0x10)
    class UDataLayerAsset* DataLayerAsset;                                            // 0x0058 (size: 0x8)

}; // Size: 0x60

class UDataLayerInstanceWithAsset : public UDataLayerInstance
{
    class UDataLayerAsset* DataLayerAsset;                                            // 0x0048 (size: 0x8)

}; // Size: 0x50

class UDataLayerLoadingPolicy : public UObject
{
}; // Size: 0x28

class UDataLayerManager : public UObject
{
    FDataLayerManagerOnDataLayerInstanceRuntimeStateChanged OnDataLayerInstanceRuntimeStateChanged; // 0x0028 (size: 0x10)
    void OnDataLayerInstanceRuntimeStateChanged(const class UDataLayerInstance* DataLayer, EDataLayerRuntimeState State);
    TSet<UObject*> ReferencedObjects;                                                 // 0x0038 (size: 0x50)

    bool SetDataLayerRuntimeState(const class UDataLayerAsset* InDataLayerAsset, EDataLayerRuntimeState InState, bool bInIsRecursive);
    bool SetDataLayerInstanceRuntimeState(const class UDataLayerInstance* InDataLayerInstance, EDataLayerRuntimeState InState, bool bInIsRecursive);
    TArray<class UDataLayerInstance*> GetDataLayerInstances();
    EDataLayerRuntimeState GetDataLayerInstanceRuntimeState(const class UDataLayerInstance* InDataLayerInstance);
    class UDataLayerInstance* GetDataLayerInstanceFromName(const FName& InDataLayerInstanceName);
    class UDataLayerInstance* GetDataLayerInstanceFromAsset(const class UDataLayerAsset* InDataLayerAsset);
    EDataLayerRuntimeState GetDataLayerInstanceEffectiveRuntimeState(const class UDataLayerInstance* InDataLayerInstance);
}; // Size: 0xD8

class UDataLayerSubsystem : public UWorldSubsystem
{
    FDataLayerSubsystemOnDataLayerRuntimeStateChanged OnDataLayerRuntimeStateChanged; // 0x0030 (size: 0x10)
    void OnDataLayerRuntimeStateChanged(const class UDataLayerInstance* DataLayer, EDataLayerRuntimeState State);
    TSoftClassPtr<UDataLayerLoadingPolicy> DataLayerLoadingPolicyClass;               // 0x0040 (size: 0x28)

    void SetDataLayerStateByLabel(const FName& InDataLayerLabel, EDataLayerState InState);
    void SetDataLayerState(const FActorDataLayer& InDataLayer, EDataLayerState InState);
    void SetDataLayerRuntimeStateByLabel(const FName& InDataLayerLabel, EDataLayerRuntimeState InState, bool bInIsRecursive);
    void SetDataLayerRuntimeState(const FActorDataLayer& InDataLayer, EDataLayerRuntimeState InState, bool bInIsRecursive);
    void SetDataLayerInstanceRuntimeState(const class UDataLayerAsset* InDataLayerAsset, EDataLayerRuntimeState InState, bool bInIsRecursive);
    TSet<FName> GetLoadedDataLayerNames();
    EDataLayerState GetDataLayerStateByLabel(const FName& InDataLayerLabel);
    EDataLayerState GetDataLayerState(const FActorDataLayer& InDataLayer);
    EDataLayerRuntimeState GetDataLayerRuntimeStateByLabel(const FName& InDataLayerLabel);
    EDataLayerRuntimeState GetDataLayerRuntimeState(const FActorDataLayer& InDataLayer);
    EDataLayerRuntimeState GetDataLayerInstanceRuntimeState(const class UDataLayerAsset* InDataLayerAsset);
    class UDataLayerInstance* GetDataLayerInstanceFromAsset(const class UDataLayerAsset* InDataLayerAsset);
    EDataLayerRuntimeState GetDataLayerInstanceEffectiveRuntimeState(const class UDataLayerAsset* InDataLayerAsset);
    class UDataLayerInstance* GetDataLayerFromName(FName InDataLayerName);
    class UDataLayerInstance* GetDataLayerFromLabel(FName InDataLayerLabel);
    EDataLayerRuntimeState GetDataLayerEffectiveRuntimeStateByLabel(const FName& InDataLayerLabel);
    EDataLayerRuntimeState GetDataLayerEffectiveRuntimeState(const FActorDataLayer& InDataLayer);
    class UDataLayerInstance* GetDataLayer(const FActorDataLayer& InDataLayer);
    TSet<FName> GetActiveDataLayerNames();
}; // Size: 0x68

class UDataStreamChannel : public UChannel
{
}; // Size: 0x2098

class UDataTable : public UObject
{
    class UScriptStruct* RowStruct;                                                   // 0x0028 (size: 0x8)
    uint8 bStripFromClientBuilds;                                                     // 0x0080 (size: 0x1)
    uint8 bIgnoreExtraFields;                                                         // 0x0080 (size: 0x1)
    uint8 bIgnoreMissingFields;                                                       // 0x0080 (size: 0x1)
    FString ImportKeyField;                                                           // 0x0088 (size: 0x10)

}; // Size: 0xB0

class UDataTableFunctionLibrary : public UBlueprintFunctionLibrary
{

    class UScriptStruct* GetDataTableRowStruct(const class UDataTable* Table);
    void GetDataTableRowNames(const class UDataTable* Table, TArray<FName>& OutRowNames);
    bool GetDataTableRowFromName(class UDataTable* Table, FName RowName, FTableRowBase& OutRow);
    void GetDataTableColumnNames(const class UDataTable* Table, TArray<FName>& OutColumnNames);
    bool GetDataTableColumnNameFromExportName(const class UDataTable* Table, FString ColumnExportName, FName& OutColumnName);
    void GetDataTableColumnExportNames(const class UDataTable* Table, TArray<FString>& OutExportColumnNames);
    TArray<FString> GetDataTableColumnAsString(const class UDataTable* DataTable, FName PropertyName);
    void EvaluateCurveTableRow(class UCurveTable* CurveTable, FName RowName, float InXY, TEnumAsByte<EEvaluateCurveTableResult::Type>& OutResult, float& OutXY, FString ContextString);
    bool DoesDataTableRowExist(const class UDataTable* Table, FName RowName);
}; // Size: 0x28

class UDebugCameraControllerSettings : public UDeveloperSettings
{
    TArray<FDebugCameraControllerSettingsViewModeIndex> CycleViewModes;               // 0x0038 (size: 0x10)

}; // Size: 0x48

class UDebugDrawComponent : public UPrimitiveComponent
{
}; // Size: 0x570

class UDebugDrawService : public UBlueprintFunctionLibrary
{
}; // Size: 0x28

class UDebugGarbageCollectionGraph : public UObject
{
}; // Size: 0x48

class UDecalComponent : public USceneComponent
{
    class UMaterialInterface* DecalMaterial;                                          // 0x0230 (size: 0x8)
    int32 SortOrder;                                                                  // 0x0238 (size: 0x4)
    float FadeScreenSize;                                                             // 0x023C (size: 0x4)
    float FadeStartDelay;                                                             // 0x0240 (size: 0x4)
    float FadeDuration;                                                               // 0x0244 (size: 0x4)
    float FadeInDuration;                                                             // 0x0248 (size: 0x4)
    float FadeInStartDelay;                                                           // 0x024C (size: 0x4)
    uint8 bDestroyOwnerAfterFade;                                                     // 0x0250 (size: 0x1)
    FVector DecalSize;                                                                // 0x0258 (size: 0x18)
    FLinearColor DecalColor;                                                          // 0x0270 (size: 0x10)

    void SetSortOrder(int32 Value);
    void SetFadeScreenSize(float NewFadeScreenSize);
    void SetFadeOut(float StartDelay, float Duration, bool DestroyOwnerAfterFade);
    void SetFadeIn(float StartDelay, float Duration);
    void SetDecalMaterial(class UMaterialInterface* NewDecalMaterial);
    void SetDecalColor(const FLinearColor& Color);
    float GetFadeStartDelay();
    float GetFadeInStartDelay();
    float GetFadeInDuration();
    float GetFadeDuration();
    class UMaterialInterface* GetDecalMaterial();
    class UMaterialInstanceDynamic* CreateDynamicMaterialInstance();
}; // Size: 0x2A0

class UDefault__AnimBlueprintGeneratedClass
{
}; // Size: 0x0

class UDefault__BlueprintGeneratedClass
{
}; // Size: 0x0

class UDemoNetConnection : public UNetConnection
{
}; // Size: 0x1E50

class UDemoNetDriver : public UNetDriver
{
    TMap<class FString, class FRollbackNetStartupActorInfo> RollbackNetStartupActors; // 0x0900 (size: 0x50)
    float CheckpointSaveMaxMSPerFrame;                                                // 0x0A34 (size: 0x4)
    TArray<FMulticastRecordOptions> MulticastRecordOptions;                           // 0x0A50 (size: 0x10)
    TArray<class APlayerController*> SpectatorControllers;                            // 0x0A60 (size: 0x10)

}; // Size: 0x1580

class UDemoPendingNetGame : public UPendingNetGame
{
}; // Size: 0xC0

class UDeprecatedDataLayerInstance : public UDataLayerInstance
{
    FName Label;                                                                      // 0x0048 (size: 0x8)
    FName DeprecatedDataLayerFName;                                                   // 0x0050 (size: 0x8)
    EDataLayerType DataLayerType;                                                     // 0x0058 (size: 0x1)
    FColor DebugColor;                                                                // 0x005C (size: 0x4)

}; // Size: 0x60

class UDeviceProfile : public UTextureLODSettings
{
    FString DeviceType;                                                               // 0x0038 (size: 0x10)
    FString BaseProfileName;                                                          // 0x0048 (size: 0x10)
    uint8 bIsVisibleForAssets;                                                        // 0x0058 (size: 0x1)
    class UDeviceProfile* Parent;                                                     // 0x0060 (size: 0x8)
    TArray<FString> CVars;                                                            // 0x0090 (size: 0x10)
    TArray<FDPMatchingRulestruct> MatchingRules;                                      // 0x00A0 (size: 0x10)

}; // Size: 0xD0

class UDeviceProfileFragment : public UObject
{
    TArray<FString> CVars;                                                            // 0x0028 (size: 0x10)

}; // Size: 0x38

class UDeviceProfileManager : public UObject
{
    TArray<class UDeviceProfile*> Profiles;                                           // 0x0028 (size: 0x10)
    TArray<class UDeviceProfile*> BackupProfiles;                                     // 0x0038 (size: 0x10)

}; // Size: 0x90

class UDialogueSoundWaveProxy : public USoundBase
{
}; // Size: 0x180

class UDialogueVoice : public UObject
{
    TEnumAsByte<EGrammaticalGender::Type> Gender;                                     // 0x0028 (size: 0x1)
    TEnumAsByte<EGrammaticalNumber::Type> Plurality;                                  // 0x0029 (size: 0x1)
    FGuid LocalizationGUID;                                                           // 0x002C (size: 0x10)

}; // Size: 0x40

class UDialogueWave : public UObject
{
    uint8 bMature;                                                                    // 0x0028 (size: 0x1)
    uint8 bOverride_SubtitleOverride;                                                 // 0x0028 (size: 0x1)
    FString SpokenText;                                                               // 0x0030 (size: 0x10)
    FString SubtitleOverride;                                                         // 0x0040 (size: 0x10)
    TArray<FDialogueContextMapping> ContextMappings;                                  // 0x0050 (size: 0x10)
    FGuid LocalizationGUID;                                                           // 0x0060 (size: 0x10)

}; // Size: 0x70

class UDirectionalLightComponent : public ULightComponent
{
    float ShadowCascadeBiasDistribution;                                              // 0x0370 (size: 0x4)
    uint8 bEnableLightShaftOcclusion;                                                 // 0x0374 (size: 0x1)
    float OcclusionMaskDarkness;                                                      // 0x0378 (size: 0x4)
    float OcclusionDepthRange;                                                        // 0x037C (size: 0x4)
    FVector LightShaftOverrideDirection;                                              // 0x0380 (size: 0x18)
    float WholeSceneDynamicShadowRadius;                                              // 0x0398 (size: 0x4)
    float DynamicShadowDistanceMovableLight;                                          // 0x039C (size: 0x4)
    float DynamicShadowDistanceStationaryLight;                                       // 0x03A0 (size: 0x4)
    int32 DynamicShadowCascades;                                                      // 0x03A4 (size: 0x4)
    float CascadeDistributionExponent;                                                // 0x03A8 (size: 0x4)
    float CascadeTransitionFraction;                                                  // 0x03AC (size: 0x4)
    float ShadowDistanceFadeoutFraction;                                              // 0x03B0 (size: 0x4)
    uint8 bUseInsetShadowsForMovableObjects;                                          // 0x03B4 (size: 0x1)
    int32 FarShadowCascadeCount;                                                      // 0x03B8 (size: 0x4)
    float FarShadowDistance;                                                          // 0x03BC (size: 0x4)
    float DistanceFieldShadowDistance;                                                // 0x03C0 (size: 0x4)
    int32 ForwardShadingPriority;                                                     // 0x03C4 (size: 0x4)
    float LightSourceAngle;                                                           // 0x03C8 (size: 0x4)
    float LightSourceSoftAngle;                                                       // 0x03CC (size: 0x4)
    float ShadowSourceAngleFactor;                                                    // 0x03D0 (size: 0x4)
    float TraceDistance;                                                              // 0x03D4 (size: 0x4)
    uint8 bUsedAsAtmosphereSunLight;                                                  // 0x03D8 (size: 0x1)
    uint8 bAtmosphereSunLight;                                                        // 0x03D8 (size: 0x1)
    int32 AtmosphereSunLightIndex;                                                    // 0x03DC (size: 0x4)
    FLinearColor AtmosphereSunDiskColorScale;                                         // 0x03E0 (size: 0x10)
    uint8 bPerPixelAtmosphereTransmittance;                                           // 0x03F0 (size: 0x1)
    uint8 bCastShadowsOnClouds;                                                       // 0x03F0 (size: 0x1)
    uint8 bCastShadowsOnAtmosphere;                                                   // 0x03F0 (size: 0x1)
    uint8 bCastCloudShadows;                                                          // 0x03F0 (size: 0x1)
    float CloudShadowStrength;                                                        // 0x03F4 (size: 0x4)
    float CloudShadowOnAtmosphereStrength;                                            // 0x03F8 (size: 0x4)
    float CloudShadowOnSurfaceStrength;                                               // 0x03FC (size: 0x4)
    float CloudShadowDepthBias;                                                       // 0x0400 (size: 0x4)
    float CloudShadowExtent;                                                          // 0x0404 (size: 0x4)
    float CloudShadowMapResolutionScale;                                              // 0x0408 (size: 0x4)
    float CloudShadowRaySampleCountScale;                                             // 0x040C (size: 0x4)
    FLinearColor CloudScatteredLuminanceScale;                                        // 0x0410 (size: 0x10)
    FLightmassDirectionalLightSettings LightmassSettings;                             // 0x0420 (size: 0x10)
    uint8 bCastModulatedShadows;                                                      // 0x0430 (size: 0x1)
    FColor ModulatedShadowColor;                                                      // 0x0434 (size: 0x4)
    float ShadowAmount;                                                               // 0x0438 (size: 0x4)

    void SetShadowSourceAngleFactor(float NewValue);
    void SetShadowDistanceFadeoutFraction(float NewValue);
    void SetShadowCascadeBiasDistribution(float NewValue);
    void SetShadowAmount(float NewValue);
    void SetOcclusionMaskDarkness(float NewValue);
    void SetOcclusionDepthRange(float NewValue);
    void SetLightSourceSoftAngle(float NewValue);
    void SetLightSourceAngle(float NewValue);
    void SetLightShaftOverrideDirection(FVector NewValue);
    void SetForwardShadingPriority(int32 NewValue);
    void SetEnableLightShaftOcclusion(bool bNewValue);
    void SetDynamicShadowDistanceStationaryLight(float NewValue);
    void SetDynamicShadowDistanceMovableLight(float NewValue);
    void SetDynamicShadowCascades(int32 NewValue);
    void SetCascadeTransitionFraction(float NewValue);
    void SetCascadeDistributionExponent(float NewValue);
    void SetAtmosphereSunLightIndex(int32 NewValue);
    void SetAtmosphereSunLight(bool bNewValue);
}; // Size: 0x440

class UDistribution : public UObject
{
}; // Size: 0x30

class UDistributionFloat : public UDistribution
{
    uint8 bCanBeBaked;                                                                // 0x0030 (size: 0x1)
    uint8 bBakedDataSuccesfully;                                                      // 0x0030 (size: 0x1)

}; // Size: 0x38

class UDistributionFloatConstant : public UDistributionFloat
{
    float Constant;                                                                   // 0x0038 (size: 0x4)

}; // Size: 0x40

class UDistributionFloatConstantCurve : public UDistributionFloat
{
    FInterpCurveFloat ConstantCurve;                                                  // 0x0038 (size: 0x18)

}; // Size: 0x50

class UDistributionFloatParameterBase : public UDistributionFloatConstant
{
    FName ParameterName;                                                              // 0x0040 (size: 0x8)
    float MinInput;                                                                   // 0x0048 (size: 0x4)
    float MaxInput;                                                                   // 0x004C (size: 0x4)
    float MinOutput;                                                                  // 0x0050 (size: 0x4)
    float MaxOutput;                                                                  // 0x0054 (size: 0x4)
    TEnumAsByte<DistributionParamMode> ParamMode;                                     // 0x0058 (size: 0x1)

}; // Size: 0x60

class UDistributionFloatParticleParameter : public UDistributionFloatParameterBase
{
}; // Size: 0x60

class UDistributionFloatUniform : public UDistributionFloat
{
    float Min;                                                                        // 0x0038 (size: 0x4)
    float Max;                                                                        // 0x003C (size: 0x4)

}; // Size: 0x40

class UDistributionFloatUniformCurve : public UDistributionFloat
{
    FInterpCurveVector2D ConstantCurve;                                               // 0x0038 (size: 0x18)

}; // Size: 0x50

class UDistributionVector : public UDistribution
{
    uint8 bCanBeBaked;                                                                // 0x0030 (size: 0x1)
    uint8 bIsDirty;                                                                   // 0x0030 (size: 0x1)
    uint8 bBakedDataSuccesfully;                                                      // 0x0030 (size: 0x1)

}; // Size: 0x38

class UDistributionVectorConstant : public UDistributionVector
{
    FVector Constant;                                                                 // 0x0038 (size: 0x18)
    uint8 bLockAxes;                                                                  // 0x0050 (size: 0x1)
    TEnumAsByte<EDistributionVectorLockFlags> LockedAxes;                             // 0x0054 (size: 0x1)

}; // Size: 0x58

class UDistributionVectorConstantCurve : public UDistributionVector
{
    FInterpCurveVector ConstantCurve;                                                 // 0x0038 (size: 0x18)
    uint8 bLockAxes;                                                                  // 0x0050 (size: 0x1)
    TEnumAsByte<EDistributionVectorLockFlags> LockedAxes;                             // 0x0054 (size: 0x1)

}; // Size: 0x58

class UDistributionVectorParameterBase : public UDistributionVectorConstant
{
    FName ParameterName;                                                              // 0x0058 (size: 0x8)
    FVector MinInput;                                                                 // 0x0060 (size: 0x18)
    FVector MaxInput;                                                                 // 0x0078 (size: 0x18)
    FVector MinOutput;                                                                // 0x0090 (size: 0x18)
    FVector MaxOutput;                                                                // 0x00A8 (size: 0x18)
    TEnumAsByte<DistributionParamMode> ParamModes;                                    // 0x00C0 (size: 0x3)

}; // Size: 0xC8

class UDistributionVectorParticleParameter : public UDistributionVectorParameterBase
{
}; // Size: 0xC8

class UDistributionVectorUniform : public UDistributionVector
{
    FVector Max;                                                                      // 0x0038 (size: 0x18)
    FVector Min;                                                                      // 0x0050 (size: 0x18)
    uint8 bLockAxes;                                                                  // 0x0068 (size: 0x1)
    TEnumAsByte<EDistributionVectorLockFlags> LockedAxes;                             // 0x006C (size: 0x1)
    TEnumAsByte<EDistributionVectorMirrorFlags> MirrorFlags;                          // 0x006D (size: 0x3)
    uint8 bUseExtremes;                                                               // 0x0070 (size: 0x1)

}; // Size: 0x78

class UDistributionVectorUniformCurve : public UDistributionVector
{
    FInterpCurveTwoVectors ConstantCurve;                                             // 0x0038 (size: 0x18)
    uint8 bLockAxes1;                                                                 // 0x0050 (size: 0x1)
    uint8 bLockAxes2;                                                                 // 0x0050 (size: 0x1)
    TEnumAsByte<EDistributionVectorLockFlags> LockedAxes;                             // 0x0054 (size: 0x2)
    TEnumAsByte<EDistributionVectorMirrorFlags> MirrorFlags;                          // 0x0056 (size: 0x3)
    uint8 bUseExtremes;                                                               // 0x005C (size: 0x1)

}; // Size: 0x60

class UDrawFrustumComponent : public UPrimitiveComponent
{
    bool bFrustumEnabled;                                                             // 0x0518 (size: 0x1)
    FColor FrustumColor;                                                              // 0x051C (size: 0x4)
    float FrustumAngle;                                                               // 0x0520 (size: 0x4)
    float FrustumAspectRatio;                                                         // 0x0524 (size: 0x4)
    float FrustumStartDist;                                                           // 0x0528 (size: 0x4)
    float FrustumEndDist;                                                             // 0x052C (size: 0x4)
    class UTexture* Texture;                                                          // 0x0530 (size: 0x8)

}; // Size: 0x540

class UDrawSphereComponent : public USphereComponent
{
}; // Size: 0x550

class UDynamicBlueprintBinding : public UObject
{
}; // Size: 0x28

class UDynamicSubsystem : public USubsystem
{
}; // Size: 0x30

class UEdGraph : public UObject
{
    TSubclassOf<class UEdGraphSchema> Schema;                                         // 0x0028 (size: 0x8)
    TArray<class UEdGraphNode*> Nodes;                                                // 0x0030 (size: 0x10)
    uint8 bEditable;                                                                  // 0x0040 (size: 0x1)
    uint8 bAllowDeletion;                                                             // 0x0040 (size: 0x1)
    uint8 bAllowRenaming;                                                             // 0x0040 (size: 0x1)

}; // Size: 0x60

class UEdGraphNode : public UObject
{
    TArray<class UEdGraphPin_Deprecated*> DeprecatedPins;                             // 0x0038 (size: 0x10)
    int32 NodePosX;                                                                   // 0x0048 (size: 0x4)
    int32 NodePosY;                                                                   // 0x004C (size: 0x4)
    int32 NodeWidth;                                                                  // 0x0050 (size: 0x4)
    int32 NodeHeight;                                                                 // 0x0054 (size: 0x4)
    TEnumAsByte<ENodeAdvancedPins::Type> AdvancedPinDisplay;                          // 0x0058 (size: 0x1)
    ENodeEnabledState EnabledState;                                                   // 0x0059 (size: 0x1)
    uint8 bDisplayAsDisabled;                                                         // 0x005B (size: 0x1)
    uint8 bUserSetEnabledState;                                                       // 0x005B (size: 0x1)
    uint8 bIsIntermediateNode;                                                        // 0x005B (size: 0x1)
    uint8 bHasCompilerMessage;                                                        // 0x005B (size: 0x1)
    FString NodeComment;                                                              // 0x0060 (size: 0x10)
    int32 ErrorType;                                                                  // 0x0070 (size: 0x4)
    FString ErrorMsg;                                                                 // 0x0078 (size: 0x10)
    FGuid NodeGuid;                                                                   // 0x0088 (size: 0x10)

}; // Size: 0x98

class UEdGraphNode_Documentation : public UEdGraphNode
{
    FString Link;                                                                     // 0x0098 (size: 0x10)
    FString Excerpt;                                                                  // 0x00A8 (size: 0x10)

}; // Size: 0xB8

class UEdGraphPin_Deprecated : public UObject
{
    FString PinName;                                                                  // 0x0028 (size: 0x10)
    FString PinToolTip;                                                               // 0x0038 (size: 0x10)
    TEnumAsByte<EEdGraphPinDirection> Direction;                                      // 0x0048 (size: 0x1)
    FEdGraphPinType PinType;                                                          // 0x0050 (size: 0x58)
    FString DefaultValue;                                                             // 0x00A8 (size: 0x10)
    FString AutogeneratedDefaultValue;                                                // 0x00B8 (size: 0x10)
    class UObject* DefaultObject;                                                     // 0x00C8 (size: 0x8)
    FText DefaultTextValue;                                                           // 0x00D0 (size: 0x10)
    TArray<class UEdGraphPin_Deprecated*> LinkedTo;                                   // 0x00E0 (size: 0x10)
    TArray<class UEdGraphPin_Deprecated*> SubPins;                                    // 0x00F0 (size: 0x10)
    class UEdGraphPin_Deprecated* ParentPin;                                          // 0x0100 (size: 0x8)
    class UEdGraphPin_Deprecated* ReferencePassThroughConnection;                     // 0x0108 (size: 0x8)

}; // Size: 0x110

class UEdGraphSchema : public UObject
{
}; // Size: 0x28

class UEditorFlagCollector : public UObject
{

    TArray<FName> GetFlagNames();
}; // Size: 0x28

class UEndpointSubmix : public USoundSubmixBase
{
    FName EndpointType;                                                               // 0x0090 (size: 0x8)
    TSubclassOf<class UAudioEndpointSettingsBase> EndpointSettingsClass;              // 0x0098 (size: 0x8)
    class UAudioEndpointSettingsBase* EndpointSettings;                               // 0x00A0 (size: 0x8)

}; // Size: 0xA8

class UEngine : public UObject
{
    class UFont* TinyFont;                                                            // 0x0030 (size: 0x8)
    FSoftObjectPath TinyFontName;                                                     // 0x0038 (size: 0x20)
    class UFont* SmallFont;                                                           // 0x0058 (size: 0x8)
    FSoftObjectPath SmallFontName;                                                    // 0x0060 (size: 0x20)
    class UFont* MediumFont;                                                          // 0x0080 (size: 0x8)
    FSoftObjectPath MediumFontName;                                                   // 0x0088 (size: 0x20)
    class UFont* LargeFont;                                                           // 0x00A8 (size: 0x8)
    FSoftObjectPath LargeFontName;                                                    // 0x00B0 (size: 0x20)
    class UFont* SubtitleFont;                                                        // 0x00D0 (size: 0x8)
    FSoftObjectPath SubtitleFontName;                                                 // 0x00D8 (size: 0x20)
    TArray<class UFont*> AdditionalFonts;                                             // 0x00F8 (size: 0x10)
    TArray<FString> AdditionalFontNames;                                              // 0x0108 (size: 0x10)
    TSubclassOf<class UConsole> ConsoleClass;                                         // 0x0118 (size: 0x8)
    FSoftClassPath ConsoleClassName;                                                  // 0x0120 (size: 0x20)
    TSubclassOf<class UGameViewportClient> GameViewportClientClass;                   // 0x0140 (size: 0x8)
    FSoftClassPath GameViewportClientClassName;                                       // 0x0148 (size: 0x20)
    TSubclassOf<class ULocalPlayer> LocalPlayerClass;                                 // 0x0168 (size: 0x8)
    FSoftClassPath LocalPlayerClassName;                                              // 0x0170 (size: 0x20)
    TSubclassOf<class AWorldSettings> WorldSettingsClass;                             // 0x0190 (size: 0x8)
    FSoftClassPath WorldSettingsClassName;                                            // 0x0198 (size: 0x20)
    FSoftClassPath NavigationSystemClassName;                                         // 0x01B8 (size: 0x20)
    TSubclassOf<class UNavigationSystemBase> NavigationSystemClass;                   // 0x01D8 (size: 0x8)
    FSoftClassPath NavigationSystemConfigClassName;                                   // 0x01E0 (size: 0x20)
    TSubclassOf<class UNavigationSystemConfig> NavigationSystemConfigClass;           // 0x0200 (size: 0x8)
    FSoftClassPath AvoidanceManagerClassName;                                         // 0x0208 (size: 0x20)
    TSubclassOf<class UAvoidanceManager> AvoidanceManagerClass;                       // 0x0228 (size: 0x8)
    FSoftClassPath AIControllerClassName;                                             // 0x0230 (size: 0x20)
    TSubclassOf<class UPhysicsCollisionHandler> PhysicsCollisionHandlerClass;         // 0x0250 (size: 0x8)
    FSoftClassPath PhysicsCollisionHandlerClassName;                                  // 0x0258 (size: 0x20)
    FSoftClassPath GameUserSettingsClassName;                                         // 0x0278 (size: 0x20)
    TSubclassOf<class UGameUserSettings> GameUserSettingsClass;                       // 0x0298 (size: 0x8)
    class UGameUserSettings* GameUserSettings;                                        // 0x02A0 (size: 0x8)
    TSubclassOf<class ALevelScriptActor> LevelScriptActorClass;                       // 0x02A8 (size: 0x8)
    FSoftClassPath LevelScriptActorClassName;                                         // 0x02B0 (size: 0x20)
    FSoftClassPath DefaultBlueprintBaseClassName;                                     // 0x02D0 (size: 0x20)
    FSoftClassPath GameSingletonClassName;                                            // 0x02F0 (size: 0x20)
    class UObject* GameSingleton;                                                     // 0x0310 (size: 0x8)
    FSoftClassPath AssetManagerClassName;                                             // 0x0318 (size: 0x20)
    class UAssetManager* AssetManager;                                                // 0x0338 (size: 0x8)
    class UTexture2D* DefaultTexture;                                                 // 0x0340 (size: 0x8)
    FSoftObjectPath DefaultTextureName;                                               // 0x0348 (size: 0x20)
    class UTexture* DefaultDiffuseTexture;                                            // 0x0368 (size: 0x8)
    FSoftObjectPath DefaultDiffuseTextureName;                                        // 0x0370 (size: 0x20)
    class UTexture2D* DefaultBSPVertexTexture;                                        // 0x0390 (size: 0x8)
    FSoftObjectPath DefaultBSPVertexTextureName;                                      // 0x0398 (size: 0x20)
    class UTexture2D* HighFrequencyNoiseTexture;                                      // 0x03B8 (size: 0x8)
    FSoftObjectPath HighFrequencyNoiseTextureName;                                    // 0x03C0 (size: 0x20)
    class UTexture2D* DefaultBokehTexture;                                            // 0x03E0 (size: 0x8)
    FSoftObjectPath DefaultBokehTextureName;                                          // 0x03E8 (size: 0x20)
    class UTexture2D* DefaultBloomKernelTexture;                                      // 0x0408 (size: 0x8)
    FSoftObjectPath DefaultBloomKernelTextureName;                                    // 0x0410 (size: 0x20)
    class UTexture2D* DefaultFilmGrainTexture;                                        // 0x0430 (size: 0x8)
    FSoftObjectPath DefaultFilmGrainTextureName;                                      // 0x0438 (size: 0x20)
    class UMaterial* WireframeMaterial;                                               // 0x0458 (size: 0x8)
    FString WireframeMaterialName;                                                    // 0x0460 (size: 0x10)
    class UMaterial* DebugMeshMaterial;                                               // 0x0470 (size: 0x8)
    FSoftObjectPath DebugMeshMaterialName;                                            // 0x0478 (size: 0x20)
    class UMaterial* NaniteHiddenSectionMaterial;                                     // 0x0498 (size: 0x8)
    FString NaniteHiddenSectionMaterialName;                                          // 0x04A0 (size: 0x10)
    class UMaterial* EmissiveMeshMaterial;                                            // 0x04B0 (size: 0x8)
    FSoftObjectPath EmissiveMeshMaterialName;                                         // 0x04B8 (size: 0x20)
    class UMaterial* LevelColorationLitMaterial;                                      // 0x04D8 (size: 0x8)
    FString LevelColorationLitMaterialName;                                           // 0x04E0 (size: 0x10)
    class UMaterial* LevelColorationUnlitMaterial;                                    // 0x04F0 (size: 0x8)
    FString LevelColorationUnlitMaterialName;                                         // 0x04F8 (size: 0x10)
    class UMaterial* LightingTexelDensityMaterial;                                    // 0x0508 (size: 0x8)
    FString LightingTexelDensityName;                                                 // 0x0510 (size: 0x10)
    class UMaterial* ShadedLevelColorationLitMaterial;                                // 0x0520 (size: 0x8)
    FString ShadedLevelColorationLitMaterialName;                                     // 0x0528 (size: 0x10)
    class UMaterial* ShadedLevelColorationUnlitMaterial;                              // 0x0538 (size: 0x8)
    FString ShadedLevelColorationUnlitMaterialName;                                   // 0x0540 (size: 0x10)
    class UMaterial* RemoveSurfaceMaterial;                                           // 0x0550 (size: 0x8)
    FSoftObjectPath RemoveSurfaceMaterialName;                                        // 0x0558 (size: 0x20)
    class UMaterial* VertexColorMaterial;                                             // 0x0578 (size: 0x8)
    FString VertexColorMaterialName;                                                  // 0x0580 (size: 0x10)
    class UMaterial* VertexColorViewModeMaterial_ColorOnly;                           // 0x0590 (size: 0x8)
    FString VertexColorViewModeMaterialName_ColorOnly;                                // 0x0598 (size: 0x10)
    class UMaterial* VertexColorViewModeMaterial_AlphaAsColor;                        // 0x05A8 (size: 0x8)
    FString VertexColorViewModeMaterialName_AlphaAsColor;                             // 0x05B0 (size: 0x10)
    class UMaterial* VertexColorViewModeMaterial_RedOnly;                             // 0x05C0 (size: 0x8)
    FString VertexColorViewModeMaterialName_RedOnly;                                  // 0x05C8 (size: 0x10)
    class UMaterial* VertexColorViewModeMaterial_GreenOnly;                           // 0x05D8 (size: 0x8)
    FString VertexColorViewModeMaterialName_GreenOnly;                                // 0x05E0 (size: 0x10)
    class UMaterial* VertexColorViewModeMaterial_BlueOnly;                            // 0x05F0 (size: 0x8)
    FString VertexColorViewModeMaterialName_BlueOnly;                                 // 0x05F8 (size: 0x10)
    FSoftObjectPath DebugEditorMaterialName;                                          // 0x0608 (size: 0x20)
    class UMaterial* ConstraintLimitMaterial;                                         // 0x0628 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialX;                         // 0x0630 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialXAxis;                     // 0x0638 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialY;                         // 0x0640 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialYAxis;                     // 0x0648 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialZ;                         // 0x0650 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialZAxis;                     // 0x0658 (size: 0x8)
    class UMaterialInstanceDynamic* ConstraintLimitMaterialPrismatic;                 // 0x0660 (size: 0x8)
    class UMaterial* InvalidLightmapSettingsMaterial;                                 // 0x0668 (size: 0x8)
    FSoftObjectPath InvalidLightmapSettingsMaterialName;                              // 0x0670 (size: 0x20)
    class UMaterial* PreviewShadowsIndicatorMaterial;                                 // 0x0690 (size: 0x8)
    FSoftObjectPath PreviewShadowsIndicatorMaterialName;                              // 0x0698 (size: 0x20)
    class UMaterial* ArrowMaterial;                                                   // 0x06B8 (size: 0x8)
    class UMaterialInstanceDynamic* ArrowMaterialYellow;                              // 0x06C0 (size: 0x8)
    FSoftObjectPath ArrowMaterialName;                                                // 0x06C8 (size: 0x20)
    FLinearColor LightingOnlyBrightness;                                              // 0x06E8 (size: 0x10)
    TArray<FLinearColor> ShaderComplexityColors;                                      // 0x06F8 (size: 0x10)
    TArray<FLinearColor> QuadComplexityColors;                                        // 0x0708 (size: 0x10)
    TArray<FLinearColor> LightComplexityColors;                                       // 0x0718 (size: 0x10)
    TArray<FLinearColor> StationaryLightOverlapColors;                                // 0x0728 (size: 0x10)
    TArray<FLinearColor> LODColorationColors;                                         // 0x0738 (size: 0x10)
    TArray<FLinearColor> HLODColorationColors;                                        // 0x0748 (size: 0x10)
    TArray<FLinearColor> StreamingAccuracyColors;                                     // 0x0758 (size: 0x10)
    FLinearColor GPUSkinCacheVisualizationExcludedColor;                              // 0x0768 (size: 0x10)
    FLinearColor GPUSkinCacheVisualizationIncludedColor;                              // 0x0778 (size: 0x10)
    FLinearColor GPUSkinCacheVisualizationRecomputeTangentsColor;                     // 0x0788 (size: 0x10)
    float GPUSkinCacheVisualizationLowMemoryThresholdInMB;                            // 0x0798 (size: 0x4)
    float GPUSkinCacheVisualizationHighMemoryThresholdInMB;                           // 0x079C (size: 0x4)
    FLinearColor GPUSkinCacheVisualizationLowMemoryColor;                             // 0x07A0 (size: 0x10)
    FLinearColor GPUSkinCacheVisualizationMidMemoryColor;                             // 0x07B0 (size: 0x10)
    FLinearColor GPUSkinCacheVisualizationHighMemoryColor;                            // 0x07C0 (size: 0x10)
    TArray<FLinearColor> GPUSkinCacheVisualizationRayTracingLODOffsetColors;          // 0x07D0 (size: 0x10)
    float MaxPixelShaderAdditiveComplexityCount;                                      // 0x07E0 (size: 0x4)
    float MaxES3PixelShaderAdditiveComplexityCount;                                   // 0x07E4 (size: 0x4)
    float MinLightMapDensity;                                                         // 0x07E8 (size: 0x4)
    float IdealLightMapDensity;                                                       // 0x07EC (size: 0x4)
    float MaxLightMapDensity;                                                         // 0x07F0 (size: 0x4)
    uint8 bRenderLightMapDensityGrayscale;                                            // 0x07F4 (size: 0x1)
    float RenderLightMapDensityGrayscaleScale;                                        // 0x07F8 (size: 0x4)
    float RenderLightMapDensityColorScale;                                            // 0x07FC (size: 0x4)
    FLinearColor LightMapDensityVertexMappedColor;                                    // 0x0800 (size: 0x10)
    FLinearColor LightMapDensitySelectedColor;                                        // 0x0810 (size: 0x10)
    TArray<FStatColorMapping> StatColorMappings;                                      // 0x0820 (size: 0x10)
    class UPhysicalMaterial* DefaultPhysMaterial;                                     // 0x0830 (size: 0x8)
    FSoftObjectPath DefaultPhysMaterialName;                                          // 0x0838 (size: 0x20)
    class UPhysicalMaterial* DefaultDestructiblePhysMaterial;                         // 0x0858 (size: 0x8)
    FSoftObjectPath DefaultDestructiblePhysMaterialName;                              // 0x0860 (size: 0x20)
    TArray<FGameNameRedirect> ActiveGameNameRedirects;                                // 0x0880 (size: 0x10)
    TArray<FClassRedirect> ActiveClassRedirects;                                      // 0x0890 (size: 0x10)
    TArray<FPluginRedirect> ActivePluginRedirects;                                    // 0x08A0 (size: 0x10)
    TArray<FStructRedirect> ActiveStructRedirects;                                    // 0x08B0 (size: 0x10)
    class UTexture2D* PreIntegratedSkinBRDFTexture;                                   // 0x08C0 (size: 0x8)
    FSoftObjectPath PreIntegratedSkinBRDFTextureName;                                 // 0x08C8 (size: 0x20)
    class UTexture2D* BlueNoiseScalarTexture;                                         // 0x08E8 (size: 0x8)
    class UTexture2D* BlueNoiseVec2Texture;                                           // 0x08F0 (size: 0x8)
    FSoftObjectPath BlueNoiseScalarTextureName;                                       // 0x08F8 (size: 0x20)
    FSoftObjectPath BlueNoiseVec2TextureName;                                         // 0x0918 (size: 0x20)
    class UTexture2DArray* GlintTexture;                                              // 0x0938 (size: 0x8)
    class UTexture2DArray* GlintTexture2;                                             // 0x0940 (size: 0x8)
    FSoftObjectPath GlintTextureName;                                                 // 0x0948 (size: 0x20)
    FSoftObjectPath GlintTexture2Name;                                                // 0x0968 (size: 0x20)
    class UVolumeTexture* SimpleVolumeTexture;                                        // 0x0988 (size: 0x8)
    FSoftObjectPath SimpleVolumeTextureName;                                          // 0x0990 (size: 0x20)
    class UVolumeTexture* SimpleVolumeEnvTexture;                                     // 0x09B0 (size: 0x8)
    FSoftObjectPath SimpleVolumeEnvTextureName;                                       // 0x09B8 (size: 0x20)
    class UTexture2D* MiniFontTexture;                                                // 0x09D8 (size: 0x8)
    FSoftObjectPath MiniFontTextureName;                                              // 0x09E0 (size: 0x20)
    class UTexture* WeightMapPlaceholderTexture;                                      // 0x0A00 (size: 0x8)
    class UTexture* WeightMapArrayPlaceholderTexture;                                 // 0x0A08 (size: 0x8)
    FSoftObjectPath WeightMapPlaceholderTextureName;                                  // 0x0A10 (size: 0x20)
    FSoftObjectPath WeightMapArrayPlaceholderTextureName;                             // 0x0A30 (size: 0x20)
    class UTexture2D* LightMapDensityTexture;                                         // 0x0A50 (size: 0x8)
    FSoftObjectPath LightMapDensityTextureName;                                       // 0x0A58 (size: 0x20)
    class UGameViewportClient* GameViewport;                                          // 0x0A80 (size: 0x8)
    TArray<FString> DeferredCommands;                                                 // 0x0A88 (size: 0x10)
    float NearClipPlane;                                                              // 0x0A98 (size: 0x4)
    uint8 bSubtitlesEnabled;                                                          // 0x0A9C (size: 0x1)
    uint8 bSubtitlesForcedOff;                                                        // 0x0A9C (size: 0x1)
    int32 MaximumLoopIterationCount;                                                  // 0x0AA0 (size: 0x4)
    uint8 bCanBlueprintsTickByDefault;                                                // 0x0AA4 (size: 0x1)
    uint8 bOptimizeAnimBlueprintMemberVariableAccess;                                 // 0x0AA4 (size: 0x1)
    uint8 bAllowMultiThreadedAnimationUpdate;                                         // 0x0AA4 (size: 0x1)
    uint8 bEnableEditorPSysRealtimeLOD;                                               // 0x0AA4 (size: 0x1)
    uint8 bSmoothFrameRate;                                                           // 0x0AA4 (size: 0x1)
    uint8 bUseFixedFrameRate;                                                         // 0x0AA4 (size: 0x1)
    float FixedFrameRate;                                                             // 0x0AA8 (size: 0x4)
    FFloatRange SmoothedFrameRateRange;                                               // 0x0AAC (size: 0x10)
    class UEngineCustomTimeStep* CustomTimeStep;                                      // 0x0AC0 (size: 0x8)
    FSoftClassPath CustomTimeStepClassName;                                           // 0x0AE8 (size: 0x20)
    class UTimecodeProvider* TimecodeProvider;                                        // 0x0B08 (size: 0x8)
    FSoftClassPath TimecodeProviderClassName;                                         // 0x0B30 (size: 0x20)
    bool bGenerateDefaultTimecode;                                                    // 0x0B50 (size: 0x1)
    FFrameRate GenerateDefaultTimecodeFrameRate;                                      // 0x0B54 (size: 0x8)
    float GenerateDefaultTimecodeFrameDelay;                                          // 0x0B5C (size: 0x4)
    uint8 bCheckForMultiplePawnsSpawnedInAFrame;                                      // 0x0B60 (size: 0x1)
    int32 NumPawnsAllowedToBeSpawnedInAFrame;                                         // 0x0B64 (size: 0x4)
    uint8 bShouldGenerateLowQualityLightmaps;                                         // 0x0B68 (size: 0x1)
    FColor C_WorldBox;                                                                // 0x0B6C (size: 0x4)
    FColor C_BrushWire;                                                               // 0x0B70 (size: 0x4)
    FColor C_AddWire;                                                                 // 0x0B74 (size: 0x4)
    FColor C_SubtractWire;                                                            // 0x0B78 (size: 0x4)
    FColor C_SemiSolidWire;                                                           // 0x0B7C (size: 0x4)
    FColor C_NonSolidWire;                                                            // 0x0B80 (size: 0x4)
    FColor C_WireBackground;                                                          // 0x0B84 (size: 0x4)
    FColor C_ScaleBoxHi;                                                              // 0x0B88 (size: 0x4)
    FColor C_VolumeCollision;                                                         // 0x0B8C (size: 0x4)
    FColor C_BSPCollision;                                                            // 0x0B90 (size: 0x4)
    FColor C_OrthoBackground;                                                         // 0x0B94 (size: 0x4)
    FColor C_Volume;                                                                  // 0x0B98 (size: 0x4)
    FColor C_BrushShape;                                                              // 0x0B9C (size: 0x4)
    FDirectoryPath GameScreenshotSaveDirectory;                                       // 0x0BA8 (size: 0x10)
    bool UseStaticMeshMinLODPerQualityLevels;                                         // 0x0BB8 (size: 0x1)
    bool UseSkeletalMeshMinLODPerQualityLevels;                                       // 0x0BB9 (size: 0x1)
    bool UseGrassVarityPerQualityLevels;                                              // 0x0BBA (size: 0x1)
    ETransitionType TransitionType;                                                   // 0x0BBB (size: 0x1)
    FString TransitionDescription;                                                    // 0x0BC0 (size: 0x10)
    FString TransitionGameMode;                                                       // 0x0BD0 (size: 0x10)
    uint8 bAllowMatureLanguage;                                                       // 0x0BE0 (size: 0x1)
    float CameraRotationThreshold;                                                    // 0x0BE4 (size: 0x4)
    float CameraTranslationThreshold;                                                 // 0x0BE8 (size: 0x4)
    float PrimitiveProbablyVisibleTime;                                               // 0x0BEC (size: 0x4)
    float MaxOcclusionPixelsFraction;                                                 // 0x0BF0 (size: 0x4)
    uint8 bPauseOnLossOfFocus;                                                        // 0x0BF4 (size: 0x1)
    int32 MaxParticleResize;                                                          // 0x0BF8 (size: 0x4)
    int32 MaxParticleResizeWarn;                                                      // 0x0BFC (size: 0x4)
    TArray<FDropNoteInfo> PendingDroppedNotes;                                        // 0x0C00 (size: 0x10)
    float NetClientTicksPerSecond;                                                    // 0x0C10 (size: 0x4)
    float DisplayGamma;                                                               // 0x0C14 (size: 0x4)
    float MinDesiredFrameRate;                                                        // 0x0C18 (size: 0x4)
    FLinearColor DefaultSelectedMaterialColor;                                        // 0x0C1C (size: 0x10)
    FLinearColor SelectedMaterialColor;                                               // 0x0C2C (size: 0x10)
    FLinearColor SelectionOutlineColor;                                               // 0x0C3C (size: 0x10)
    FLinearColor SubduedSelectionOutlineColor;                                        // 0x0C4C (size: 0x10)
    FLinearColor SelectedMaterialColorOverride;                                       // 0x0C5C (size: 0x10)
    bool bIsOverridingSelectedColor;                                                  // 0x0C6C (size: 0x1)
    uint8 bEnableOnScreenDebugMessages;                                               // 0x0C70 (size: 0x1)
    uint8 bEnableOnScreenDebugMessagesDisplay;                                        // 0x0C70 (size: 0x1)
    uint8 bSuppressMapWarnings;                                                       // 0x0C70 (size: 0x1)
    uint8 bDisableAILogging;                                                          // 0x0C70 (size: 0x1)
    uint32 bEnableVisualLogRecordingOnStart;                                          // 0x0C74 (size: 0x4)
    int32 ScreenSaverInhibitorSemaphore;                                              // 0x0C78 (size: 0x4)
    uint8 bLockReadOnlyLevels;                                                        // 0x0C7C (size: 0x1)
    FString ParticleEventManagerClassPath;                                            // 0x0C80 (size: 0x10)
    float SelectionHighlightIntensity;                                                // 0x0C90 (size: 0x4)
    float BSPSelectionHighlightIntensity;                                             // 0x0C94 (size: 0x4)
    float SelectionHighlightIntensityBillboards;                                      // 0x0C98 (size: 0x4)
    uint32 GlobalNetTravelCount;                                                      // 0x0F30 (size: 0x4)
    TArray<FNetDriverDefinition> NetDriverDefinitions;                                // 0x0F38 (size: 0x10)
    TArray<FIrisNetDriverConfig> IrisNetDriverConfigs;                                // 0x0F48 (size: 0x10)
    TArray<FString> ServerActors;                                                     // 0x0F58 (size: 0x10)
    TArray<FString> RuntimeServerActors;                                              // 0x0F68 (size: 0x10)
    float NetErrorLogInterval;                                                        // 0x0F78 (size: 0x4)
    uint8 bStartedLoadMapMovie;                                                       // 0x0F7C (size: 0x1)
    int32 NextWorldContextHandle;                                                     // 0x0FB8 (size: 0x4)

}; // Size: 0x10A0

class UEngineBaseTypes : public UObject
{
}; // Size: 0x28

class UEngineCustomTimeStep : public UObject
{
}; // Size: 0x28

class UEngineElementsLibrary : public UBlueprintFunctionLibrary
{
}; // Size: 0x28

class UEngineHandlerComponentFactory : public UHandlerComponentFactory
{
}; // Size: 0x28

class UEngineMessage : public ULocalMessage
{
    FString FailedPlaceMessage;                                                       // 0x0028 (size: 0x10)
    FString MaxedOutMessage;                                                          // 0x0038 (size: 0x10)
    FString EnteredMessage;                                                           // 0x0048 (size: 0x10)
    FString LeftMessage;                                                              // 0x0058 (size: 0x10)
    FString GlobalNameChange;                                                         // 0x0068 (size: 0x10)
    FString SpecEnteredMessage;                                                       // 0x0078 (size: 0x10)
    FString NewPlayerMessage;                                                         // 0x0088 (size: 0x10)
    FString NewSpecMessage;                                                           // 0x0098 (size: 0x10)

}; // Size: 0xA8

class UEngineSubsystem : public UDynamicSubsystem
{
}; // Size: 0x30

class UEngineTypes : public UObject
{
}; // Size: 0x28

class UExponentialHeightFogComponent : public USceneComponent
{
    float FogDensity;                                                                 // 0x0230 (size: 0x4)
    float FogHeightFalloff;                                                           // 0x0234 (size: 0x4)
    FExponentialHeightFogData SecondFogData;                                          // 0x0238 (size: 0xC)
    FLinearColor FogInscatteringColor;                                                // 0x0244 (size: 0x10)
    FLinearColor FogInscatteringLuminance;                                            // 0x0254 (size: 0x10)
    FLinearColor SkyAtmosphereAmbientContributionColorScale;                          // 0x0264 (size: 0x10)
    class UTextureCube* InscatteringColorCubemap;                                     // 0x0278 (size: 0x8)
    float InscatteringColorCubemapAngle;                                              // 0x0280 (size: 0x4)
    FLinearColor InscatteringTextureTint;                                             // 0x0284 (size: 0x10)
    float FullyDirectionalInscatteringColorDistance;                                  // 0x0294 (size: 0x4)
    float NonDirectionalInscatteringColorDistance;                                    // 0x0298 (size: 0x4)
    float DirectionalInscatteringExponent;                                            // 0x029C (size: 0x4)
    float DirectionalInscatteringStartDistance;                                       // 0x02A0 (size: 0x4)
    FLinearColor DirectionalInscatteringColor;                                        // 0x02A4 (size: 0x10)
    FLinearColor DirectionalInscatteringLuminance;                                    // 0x02B4 (size: 0x10)
    float FogMaxOpacity;                                                              // 0x02C4 (size: 0x4)
    float StartDistance;                                                              // 0x02C8 (size: 0x4)
    float FogCutoffDistance;                                                          // 0x02CC (size: 0x4)
    bool bEnableVolumetricFog;                                                        // 0x02D0 (size: 0x1)
    float VolumetricFogScatteringDistribution;                                        // 0x02D4 (size: 0x4)
    FColor VolumetricFogAlbedo;                                                       // 0x02D8 (size: 0x4)
    FLinearColor VolumetricFogEmissive;                                               // 0x02DC (size: 0x10)
    float VolumetricFogExtinctionScale;                                               // 0x02EC (size: 0x4)
    float VolumetricFogDistance;                                                      // 0x02F0 (size: 0x4)
    float VolumetricFogStartDistance;                                                 // 0x02F4 (size: 0x4)
    float VolumetricFogNearFadeInDistance;                                            // 0x02F8 (size: 0x4)
    float VolumetricFogStaticLightingScatteringIntensity;                             // 0x02FC (size: 0x4)
    bool bOverrideLightColorsWithFogInscatteringColors;                               // 0x0300 (size: 0x1)
    uint8 bHoldout;                                                                   // 0x0301 (size: 0x1)
    uint8 bRenderInMainPass;                                                          // 0x0301 (size: 0x1)

    void SetVolumetricFogScatteringDistribution(float NewValue);
    void SetVolumetricFogExtinctionScale(float NewValue);
    void SetVolumetricFogEmissive(FLinearColor NewValue);
    void SetVolumetricFogDistance(float NewValue);
    void SetVolumetricFogAlbedo(FColor NewValue);
    void SetVolumetricFog(bool bNewValue);
    void SetStartDistance(float Value);
    void SetSecondFogHeightOffset(float Value);
    void SetSecondFogHeightFalloff(float Value);
    void SetSecondFogDensity(float Value);
    void SetSecondFogData(FExponentialHeightFogData NewValue);
    void SetRenderInMainPass(bool bValue);
    void SetNonDirectionalInscatteringColorDistance(float Value);
    void SetInscatteringTextureTint(FLinearColor Value);
    void SetInscatteringColorCubemapAngle(float Value);
    void SetInscatteringColorCubemap(class UTextureCube* Value);
    void SetHoldout(bool bNewHoldout);
    void SetFullyDirectionalInscatteringColorDistance(float Value);
    void SetFogMaxOpacity(float Value);
    void SetFogInscatteringColor(FLinearColor Value);
    void SetFogHeightFalloff(float Value);
    void SetFogDensity(float Value);
    void SetFogCutoffDistance(float Value);
    void SetDirectionalInscatteringStartDistance(float Value);
    void SetDirectionalInscatteringExponent(float Value);
    void SetDirectionalInscatteringColor(FLinearColor Value);
}; // Size: 0x310

class UExporter : public UObject
{
    UClass* SupportedClass;                                                           // 0x0028 (size: 0x8)
    class UObject* ExportRootScope;                                                   // 0x0030 (size: 0x8)
    TArray<FString> FormatExtension;                                                  // 0x0038 (size: 0x10)
    TArray<FString> FormatDescription;                                                // 0x0048 (size: 0x10)
    int32 PreferredFormatIndex;                                                       // 0x0058 (size: 0x4)
    int32 TextIndent;                                                                 // 0x005C (size: 0x4)
    uint8 bText;                                                                      // 0x0060 (size: 0x1)
    uint8 bSelectedOnly;                                                              // 0x0060 (size: 0x1)
    uint8 bForceFileOperations;                                                       // 0x0060 (size: 0x1)
    class UAssetExportTask* ExportTask;                                               // 0x0068 (size: 0x8)

    bool ScriptRunAssetExportTask(class UAssetExportTask* Task);
    bool RunAssetExportTasks(const TArray<class UAssetExportTask*>& ExportTasks);
    bool RunAssetExportTask(class UAssetExportTask* Task);
}; // Size: 0x78

class UExternalDataLayerAsset : public UDataLayerAsset
{
    FExternalDataLayerUID UID;                                                        // 0x0040 (size: 0x4)

}; // Size: 0x48

class UExternalDataLayerEngineSubsystem : public UEngineSubsystem
{
}; // Size: 0xA0

class UExternalDataLayerInjectionPolicy : public UObject
{
}; // Size: 0x28

class UExternalDataLayerInstance : public UDataLayerInstanceWithAsset
{
}; // Size: 0x50

class UExternalDataLayerManager : public UObject
{
    TMap<class UExternalDataLayerAsset*, class URuntimeHashExternalStreamingObjectBase*> ExternalStreamingObjects; // 0x0030 (size: 0x50)

}; // Size: 0x80

class UFXSystemAsset : public UObject
{
    uint32 MaxPoolSize;                                                               // 0x0028 (size: 0x4)
    uint32 PoolPrimeSize;                                                             // 0x002C (size: 0x4)

}; // Size: 0x48

class UFXSystemComponent : public UPrimitiveComponent
{

    void SetVectorParameter(FName ParameterName, FVector Param);
    void SetUseAutoManageAttachment(bool bAutoManage);
    void SetIntParameter(FName ParameterName, int32 Param);
    void SetFloatParameter(FName ParameterName, float Param);
    void SetEmitterEnable(FName EmitterName, bool bNewEnableState);
    void SetColorParameter(FName ParameterName, FLinearColor Param);
    void SetBoolParameter(FName ParameterName, bool Param);
    void SetAutoAttachmentParameters(class USceneComponent* Parent, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule);
    void SetActorParameter(FName ParameterName, class AActor* Param);
    void ReleaseToPool();
    class UFXSystemAsset* GetFXSystemAsset();
}; // Size: 0x520

class UFieldNotificationLibrary : public UBlueprintFunctionLibrary
{

    bool SetPropertyValueAndBroadcastFields(bool NewValueByRef, const int32& OldValue, const int32& NewValue, class UObject* Object, class UObject* NetOwner, bool bHasLocalRepNotify, bool bShouldFlushDormancyOnSet, bool bIsNetProperty, TArray<FFieldNotificationId> ExtraFieldIds);
    bool SetPropertyValueAndBroadcast(bool NewValueByRef, const int32& OldValue, const int32& NewValue, class UObject* Object, class UObject* NetOwner, bool bHasLocalRepNotify, bool bShouldFlushDormancyOnSet, bool bIsNetProperty);
    void BroadcastFieldValueChanged(class UObject* Object, FFieldNotificationId FieldId);
    void BroadcastFieldsValueChanged(class UObject* Object, TArray<FFieldNotificationId> FieldIds);
}; // Size: 0x28

class UFloatingPawnMovement : public UPawnMovementComponent
{
    float MaxSpeed;                                                                   // 0x0158 (size: 0x4)
    float Acceleration;                                                               // 0x015C (size: 0x4)
    float Deceleration;                                                               // 0x0160 (size: 0x4)
    float TurningBoost;                                                               // 0x0164 (size: 0x4)
    uint8 bPositionCorrected;                                                         // 0x0168 (size: 0x1)

}; // Size: 0x170

class UFont : public UObject
{
    EFontCacheType FontCacheType;                                                     // 0x0030 (size: 0x1)
    EFontRasterizationMode FontRasterizationMode;                                     // 0x0031 (size: 0x1)
    FFontSdfSettings SdfSettings;                                                     // 0x0034 (size: 0x4)
    TArray<FFontCharacter> Characters;                                                // 0x0038 (size: 0x10)
    TArray<class UTexture2D*> Textures;                                               // 0x0048 (size: 0x10)
    int32 IsRemapped;                                                                 // 0x0058 (size: 0x4)
    float EmScale;                                                                    // 0x005C (size: 0x4)
    float Ascent;                                                                     // 0x0060 (size: 0x4)
    float Descent;                                                                    // 0x0064 (size: 0x4)
    float Leading;                                                                    // 0x0068 (size: 0x4)
    int32 Kerning;                                                                    // 0x006C (size: 0x4)
    FFontImportOptionsData ImportOptions;                                             // 0x0070 (size: 0xB0)
    int32 NumCharacters;                                                              // 0x0120 (size: 0x4)
    TArray<int32> MaxCharHeight;                                                      // 0x0128 (size: 0x10)
    float ScalingFactor;                                                              // 0x0138 (size: 0x4)
    int32 LegacyFontSize;                                                             // 0x013C (size: 0x4)
    FName LegacyFontName;                                                             // 0x0140 (size: 0x8)
    FCompositeFont CompositeFont;                                                     // 0x0148 (size: 0x40)

}; // Size: 0x1D8

class UFontFace : public UObject
{
    FString SourceFilename;                                                           // 0x0030 (size: 0x10)
    EFontHinting Hinting;                                                             // 0x0040 (size: 0x1)
    EFontLoadingPolicy LoadingPolicy;                                                 // 0x0041 (size: 0x1)
    EFontLayoutMethod LayoutMethod;                                                   // 0x0042 (size: 0x1)
    int32 AscendOverriddenValue;                                                      // 0x0044 (size: 0x4)
    bool bIsAscendOverridden;                                                         // 0x0048 (size: 0x1)
    int32 DescendOverriddenValue;                                                     // 0x004C (size: 0x4)
    bool bIsDescendOverridden;                                                        // 0x0050 (size: 0x1)

}; // Size: 0x68

class UFontImportOptions : public UObject
{
    FFontImportOptionsData Data;                                                      // 0x0028 (size: 0xB0)

}; // Size: 0xD8

class UForceFeedbackAttenuation : public UObject
{
    FForceFeedbackAttenuationSettings Attenuation;                                    // 0x0028 (size: 0xC0)

}; // Size: 0xE8

class UForceFeedbackComponent : public USceneComponent
{
    class UForceFeedbackEffect* ForceFeedbackEffect;                                  // 0x0230 (size: 0x8)
    uint8 bAutoDestroy;                                                               // 0x0238 (size: 0x1)
    uint8 bStopWhenOwnerDestroyed;                                                    // 0x0238 (size: 0x1)
    uint8 bLooping;                                                                   // 0x0238 (size: 0x1)
    uint8 bIgnoreTimeDilation;                                                        // 0x0238 (size: 0x1)
    uint8 bOverrideAttenuation;                                                       // 0x0238 (size: 0x1)
    float IntensityMultiplier;                                                        // 0x023C (size: 0x4)
    class UForceFeedbackAttenuation* AttenuationSettings;                             // 0x0240 (size: 0x8)
    FForceFeedbackAttenuationSettings AttenuationOverrides;                           // 0x0248 (size: 0xC0)
    FForceFeedbackComponentOnForceFeedbackFinished OnForceFeedbackFinished;           // 0x0308 (size: 0x10)
    void OnForceFeedbackFinished(class UForceFeedbackComponent* ForceFeedbackComponent);

    void Stop();
    void SetIntensityMultiplier(float NewIntensityMultiplier);
    void SetForceFeedbackEffect(class UForceFeedbackEffect* NewForceFeedbackEffect);
    void Play(float StartTime);
    bool BP_GetAttenuationSettingsToApply(FForceFeedbackAttenuationSettings& OutAttenuationSettings);
    void AdjustAttenuation(const FForceFeedbackAttenuationSettings& InAttenuationSettings);
}; // Size: 0x320

class UForceFeedbackEffect : public UObject
{
    TArray<FForceFeedbackChannelDetails> ChannelDetails;                              // 0x0028 (size: 0x10)
    TMap<class FName, class FForceFeedbackEffectOverridenChannelDetails> PerDeviceOverrides; // 0x0038 (size: 0x50)
    TArray<class UInputDeviceProperty*> DeviceProperties;                             // 0x0088 (size: 0x10)
    float Duration;                                                                   // 0x0098 (size: 0x4)

}; // Size: 0xA0

class UGameEngine : public UEngine
{
    float MaxDeltaTime;                                                               // 0x10A0 (size: 0x4)
    float ServerFlushLogInterval;                                                     // 0x10A4 (size: 0x4)
    class UGameInstance* GameInstance;                                                // 0x10A8 (size: 0x8)

}; // Size: 0x10F8

class UGameInstance : public UObject
{
    TArray<class ULocalPlayer*> LocalPlayers;                                         // 0x0038 (size: 0x10)
    class UOnlineSession* OnlineSession;                                              // 0x0048 (size: 0x8)
    TArray<class UObject*> ReferencedObjects;                                         // 0x0050 (size: 0x10)
    FGameInstanceOnPawnControllerChangedDelegates OnPawnControllerChangedDelegates;   // 0x0078 (size: 0x10)
    void OnPawnControllerChanged(class APawn* Pawn, class AController* Controller);
    FGameInstanceOnInputDeviceConnectionChange OnInputDeviceConnectionChange;         // 0x00A0 (size: 0x10)
    void OnUserInputDeviceConnectionChange(EInputDeviceConnectionState NewConnectionState, FPlatformUserId PlatformUserId, FInputDeviceId InputDeviceId);
    FGameInstanceOnUserInputDevicePairingChange OnUserInputDevicePairingChange;       // 0x00B0 (size: 0x10)
    void OnUserInputDevicePairingChange(FInputDeviceId InputDeviceId, FPlatformUserId NewUserPlatformId, FPlatformUserId OldUserPlatformId);

    void ReceiveShutdown();
    void ReceiveInit();
    void HandleTravelError(TEnumAsByte<ETravelFailure::Type> FailureType);
    void HandleNetworkError(TEnumAsByte<ENetworkFailure::Type> FailureType, bool bIsServer);
    void DebugRemovePlayer(int32 ControllerId);
    void DebugCreatePlayer(int32 ControllerId);
}; // Size: 0x1C0

class UGameInstanceSubsystem : public USubsystem
{
}; // Size: 0x30

class UGameUserSettings : public UObject
{
    bool bUseVSync;                                                                   // 0x0028 (size: 0x1)
    bool bUseDynamicResolution;                                                       // 0x0029 (size: 0x1)
    uint32 ResolutionSizeX;                                                           // 0x0088 (size: 0x4)
    uint32 ResolutionSizeY;                                                           // 0x008C (size: 0x4)
    uint32 LastUserConfirmedResolutionSizeX;                                          // 0x0090 (size: 0x4)
    uint32 LastUserConfirmedResolutionSizeY;                                          // 0x0094 (size: 0x4)
    int32 WindowPosX;                                                                 // 0x0098 (size: 0x4)
    int32 WindowPosY;                                                                 // 0x009C (size: 0x4)
    int32 FullscreenMode;                                                             // 0x00A0 (size: 0x4)
    int32 LastConfirmedFullscreenMode;                                                // 0x00A4 (size: 0x4)
    int32 PreferredFullscreenMode;                                                    // 0x00A8 (size: 0x4)
    uint32 Version;                                                                   // 0x00AC (size: 0x4)
    int32 AudioQualityLevel;                                                          // 0x00B0 (size: 0x4)
    int32 LastConfirmedAudioQualityLevel;                                             // 0x00B4 (size: 0x4)
    float FrameRateLimit;                                                             // 0x00B8 (size: 0x4)
    int32 DesiredScreenWidth;                                                         // 0x00C0 (size: 0x4)
    bool bUseDesiredScreenHeight;                                                     // 0x00C4 (size: 0x1)
    int32 DesiredScreenHeight;                                                        // 0x00C8 (size: 0x4)
    int32 LastUserConfirmedDesiredScreenWidth;                                        // 0x00CC (size: 0x4)
    int32 LastUserConfirmedDesiredScreenHeight;                                       // 0x00D0 (size: 0x4)
    float LastRecommendedScreenWidth;                                                 // 0x00D4 (size: 0x4)
    float LastRecommendedScreenHeight;                                                // 0x00D8 (size: 0x4)
    float LastCPUBenchmarkResult;                                                     // 0x00DC (size: 0x4)
    float LastGPUBenchmarkResult;                                                     // 0x00E0 (size: 0x4)
    TArray<float> LastCPUBenchmarkSteps;                                              // 0x00E8 (size: 0x10)
    TArray<float> LastGPUBenchmarkSteps;                                              // 0x00F8 (size: 0x10)
    float LastGPUBenchmarkMultiplier;                                                 // 0x0108 (size: 0x4)
    bool bUseHDRDisplayOutput;                                                        // 0x010C (size: 0x1)
    int32 HDRDisplayOutputNits;                                                       // 0x0110 (size: 0x4)
    FGameUserSettingsOnGameUserSettingsUINeedsUpdate OnGameUserSettingsUINeedsUpdate; // 0x0138 (size: 0x10)
    void OnGameUserSettingsUINeedsUpdate();

    void ValidateSettings();
    bool SupportsHDRDisplayOutput();
    void SetVSyncEnabled(bool bEnable);
    void SetVisualEffectQuality(int32 Value);
    void SetViewDistanceQuality(int32 Value);
    void SetToDefaults();
    void SetTextureQuality(int32 Value);
    void SetShadowQuality(int32 Value);
    void SetShadingQuality(int32 Value);
    void SetScreenResolution(FIntPoint Resolution);
    void SetResolutionScaleValueEx(float NewScaleValue);
    void SetResolutionScaleNormalized(float NewScaleNormalized);
    void SetReflectionQuality(int32 Value);
    void SetPostProcessingQuality(int32 Value);
    void SetOverallScalabilityLevel(int32 Value);
    void SetGlobalIlluminationQuality(int32 Value);
    void SetFullscreenMode(TEnumAsByte<EWindowMode::Type> InFullscreenMode);
    void SetFrameRateLimit(float NewLimit);
    void SetFoliageQuality(int32 Value);
    void SetDynamicResolutionEnabled(bool bEnable);
    void SetBenchmarkFallbackValues();
    void SetAudioQualityLevel(int32 QualityLevel);
    void SetAntiAliasingQuality(int32 Value);
    void SaveSettings();
    void RunHardwareBenchmark(int32 WorkScale, float CPUMultiplier, float GPUMultiplier);
    void RevertVideoMode();
    void ResetToCurrentSettings();
    void LoadSettings(bool bForceReload);
    bool IsVSyncEnabled();
    bool IsVSyncDirty();
    bool IsScreenResolutionDirty();
    bool IsHDREnabled();
    bool IsFullscreenModeDirty();
    bool IsDynamicResolutionEnabled();
    bool IsDynamicResolutionDirty();
    bool IsDirty();
    int32 GetVisualEffectQuality();
    int32 GetViewDistanceQuality();
    int32 GetTextureQuality();
    int32 GetSyncInterval();
    int32 GetShadowQuality();
    int32 GetShadingQuality();
    FIntPoint GetScreenResolution();
    float GetResolutionScaleNormalized();
    void GetResolutionScaleInformationEx(float& CurrentScaleNormalized, float& CurrentScaleValue, float& MinScaleValue, float& MaxScaleValue);
    int32 GetReflectionQuality();
    float GetRecommendedResolutionScale();
    TEnumAsByte<EWindowMode::Type> GetPreferredFullscreenMode();
    int32 GetPostProcessingQuality();
    int32 GetOverallScalabilityLevel();
    FIntPoint GetLastConfirmedScreenResolution();
    TEnumAsByte<EWindowMode::Type> GetLastConfirmedFullscreenMode();
    int32 GetGlobalIlluminationQuality();
    class UGameUserSettings* GetGameUserSettings();
    TEnumAsByte<EWindowMode::Type> GetFullscreenMode();
    float GetFrameRateLimit();
    int32 GetFramePace();
    int32 GetFoliageQuality();
    FIntPoint GetDesktopResolution();
    FIntPoint GetDefaultWindowPosition();
    TEnumAsByte<EWindowMode::Type> GetDefaultWindowMode();
    float GetDefaultResolutionScale();
    FIntPoint GetDefaultResolution();
    int32 GetCurrentHDRDisplayNits();
    int32 GetAudioQualityLevel();
    int32 GetAntiAliasingQuality();
    void EnableHDRDisplayOutput(bool bEnable, int32 DisplayNits);
    void ConfirmVideoMode();
    void ApplySettings(bool bCheckForCommandLineOverrides);
    void ApplyResolutionSettings(bool bCheckForCommandLineOverrides);
    void ApplyNonResolutionSettings();
    void ApplyHardwareBenchmarkResults();
}; // Size: 0x148

class UGameViewportClient : public UScriptViewportClient
{
    class UConsole* ViewportConsole;                                                  // 0x0040 (size: 0x8)
    TArray<FDebugDisplayProperty> DebugProperties;                                    // 0x0048 (size: 0x10)
    int32 MaxSplitscreenPlayers;                                                      // 0x0068 (size: 0x4)
    class UWorld* World;                                                              // 0x0078 (size: 0x8)
    class UGameInstance* GameInstance;                                                // 0x0080 (size: 0x8)

    void SSSwapControllers();
    void ShowTitleSafeArea();
    void SetConsoleTarget(int32 PlayerIndex);
}; // Size: 0x3B0

class UGameplayStatics : public UBlueprintFunctionLibrary
{

    void UnRetainAllSoundsInSoundClass(class USoundClass* InSoundClass);
    void UnloadStreamLevelBySoftObjectPtr(const class UObject* WorldContextObject, const TSoftObjectPtr<UWorld> Level, FLatentActionInfo LatentInfo, bool bShouldBlockOnUnload);
    void UnloadStreamLevel(const class UObject* WorldContextObject, FName LevelName, FLatentActionInfo LatentInfo, bool bShouldBlockOnUnload);
    bool SuggestProjectileVelocity_MovingTarget(const class UObject* WorldContextObject, FVector& OutLaunchVelocity, FVector ProjectileStartLocation, class AActor* TargetActor, FVector TargetLocationOffset, double GravityZOverride, double TimeToTarget, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, float DrawDebugTime, FLinearColor DrawDebugColor);
    bool SuggestProjectileVelocity_CustomArc(const class UObject* WorldContextObject, FVector& OutLaunchVelocity, FVector StartPos, FVector EndPos, float OverrideGravityZ, float ArcParam);
    class UAudioComponent* SpawnSoundAttached(class USoundBase* Sound, class USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, TEnumAsByte<EAttachLocation::Type> LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
    class UAudioComponent* SpawnSoundAtLocation(const class UObject* WorldContextObject, class USoundBase* Sound, FVector Location, FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, bool bAutoDestroy);
    class UAudioComponent* SpawnSound2D(const class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy);
    class UObject* SpawnObject(UClass* ObjectClass, class UObject* Outer);
    class UForceFeedbackComponent* SpawnForceFeedbackAttached(class UForceFeedbackEffect* ForceFeedbackEffect, class USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, TEnumAsByte<EAttachLocation::Type> LocationType, bool bStopWhenAttachedToDestroyed, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy);
    class UForceFeedbackComponent* SpawnForceFeedbackAtLocation(const class UObject* WorldContextObject, class UForceFeedbackEffect* ForceFeedbackEffect, FVector Location, FRotator Rotation, bool bLooping, float IntensityMultiplier, float StartTime, class UForceFeedbackAttenuation* AttenuationSettings, bool bAutoDestroy);
    class UParticleSystemComponent* SpawnEmitterAttached(class UParticleSystem* EmitterTemplate, class USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, FVector Scale, TEnumAsByte<EAttachLocation::Type> LocationType, bool bAutoDestroy, EPSCPoolMethod PoolingMethod, bool bAutoActivate);
    class UParticleSystemComponent* SpawnEmitterAtLocation(const class UObject* WorldContextObject, class UParticleSystem* EmitterTemplate, FVector Location, FRotator Rotation, FVector Scale, bool bAutoDestroy, EPSCPoolMethod PoolingMethod, bool bAutoActivateSystem);
    class UAudioComponent* SpawnDialogueAttached(class UDialogueWave* Dialogue, const FDialogueContext& Context, class USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, TEnumAsByte<EAttachLocation::Type> LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAutoDestroy);
    class UAudioComponent* SpawnDialogueAtLocation(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const FDialogueContext& Context, FVector Location, FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, bool bAutoDestroy);
    class UAudioComponent* SpawnDialogue2D(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime, bool bAutoDestroy);
    class UDecalComponent* SpawnDecalAttached(class UMaterialInterface* DecalMaterial, FVector DecalSize, class USceneComponent* AttachToComponent, FName AttachPointName, FVector Location, FRotator Rotation, TEnumAsByte<EAttachLocation::Type> LocationType, float LifeSpan);
    class UDecalComponent* SpawnDecalAtLocation(const class UObject* WorldContextObject, class UMaterialInterface* DecalMaterial, FVector DecalSize, FVector Location, FRotator Rotation, float LifeSpan);
    void SetWorldOriginLocation(const class UObject* WorldContextObject, FIntVector NewLocation);
    void SetViewportMouseCaptureMode(const class UObject* WorldContextObject, const EMouseCaptureMode MouseCaptureMode);
    void SetSubtitlesEnabled(bool bEnabled);
    void SetSoundMixClassOverride(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier, class USoundClass* InSoundClass, float Volume, float Pitch, float FadeInTime, bool bApplyToChildren);
    void SetSoundClassDistanceScale(const class UObject* WorldContextObject, class USoundClass* SoundClass, float DistanceAttenuationScale, float TimeSec);
    void SetPlayerPlatformUserId(class APlayerController* PlayerController, FPlatformUserId UserId);
    void SetPlayerControllerID(class APlayerController* Player, int32 ControllerId);
    void SetMaxAudioChannelsScaled(const class UObject* WorldContextObject, float MaxChannelCountScale);
    void SetGlobalTimeDilation(const class UObject* WorldContextObject, float TimeDilation);
    void SetGlobalPitchModulation(const class UObject* WorldContextObject, float PitchModulation, float TimeSec);
    void SetGlobalListenerFocusParameters(const class UObject* WorldContextObject, float FocusAzimuthScale, float NonFocusAzimuthScale, float FocusDistanceScale, float NonFocusDistanceScale, float FocusVolumeScale, float NonFocusVolumeScale, float FocusPriorityScale, float NonFocusPriorityScale);
    bool SetGamePaused(const class UObject* WorldContextObject, bool bPaused);
    void SetForceDisableSplitscreen(const class UObject* WorldContextObject, bool bDisable);
    void SetEnableWorldRendering(const class UObject* WorldContextObject, bool bEnable);
    void SetBaseSoundMix(const class UObject* WorldContextObject, class USoundMix* InSoundMix);
    bool SetActiveSpatialPluginByName(const class UObject* WorldContextObject, FName InPluginName);
    bool SaveGameToSlot(class USaveGame* SaveGameObject, FString SlotName, const int32 UserIndex);
    void RemovePlayer(class APlayerController* Player, bool bDestroyPawn);
    FVector RebaseZeroOriginOntoLocal(class UObject* WorldContextObject, FVector WorldLocation);
    FVector RebaseLocalOriginOntoZero(class UObject* WorldContextObject, FVector WorldLocation);
    void PushSoundMixModifier(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier);
    bool ProjectWorldToScreen(class APlayerController* Player, const FVector& WorldPosition, FVector2D& ScreenPosition, bool bPlayerViewportRelative);
    void PrimeSound(class USoundBase* InSound);
    void PrimeAllSoundsInSoundClass(class USoundClass* InSoundClass);
    void PopSoundMixModifier(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier);
    void PlayWorldCameraShake(const class UObject* WorldContextObject, TSubclassOf<class UCameraShakeBase> Shake, FVector Epicenter, float InnerRadius, float OuterRadius, float Falloff, bool bOrientShakeTowardsEpicenter);
    void PlaySoundAtLocation(const class UObject* WorldContextObject, class USoundBase* Sound, FVector Location, FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, const class AActor* OwningActor, const class UInitialActiveSoundParams* InitialParams);
    void PlaySound2D(const class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, const class AActor* OwningActor, bool bIsUISound);
    void PlayDialogueAtLocation(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const FDialogueContext& Context, FVector Location, FRotator Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings);
    void PlayDialogue2D(const class UObject* WorldContextObject, class UDialogueWave* Dialogue, const FDialogueContext& Context, float VolumeMultiplier, float PitchMultiplier, float StartTime);
    FString ParseOption(FString Options, FString Key);
    void OpenLevelBySoftObjectPtr(const class UObject* WorldContextObject, const TSoftObjectPtr<UWorld> Level, bool bAbsolute, FString Options);
    void OpenLevel(const class UObject* WorldContextObject, FName LevelName, bool bAbsolute, FString Options);
    bool ObjectIsA(const class UObject* Object, UClass* ObjectClass);
    FHitResult MakeHitResult(bool bBlockingHit, bool bInitialOverlap, float Time, float Distance, FVector Location, FVector ImpactPoint, FVector Normal, FVector ImpactNormal, class UPhysicalMaterial* PhysMat, class AActor* HitActor, class UPrimitiveComponent* HitComponent, FName HitBoneName, FName BoneName, int32 HitItem, int32 ElementIndex, int32 FaceIndex, FVector TraceStart, FVector TraceEnd);
    void LoadStreamLevelBySoftObjectPtr(const class UObject* WorldContextObject, const TSoftObjectPtr<UWorld> Level, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, FLatentActionInfo LatentInfo);
    void LoadStreamLevel(const class UObject* WorldContextObject, FName LevelName, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, FLatentActionInfo LatentInfo);
    class USaveGame* LoadGameFromSlot(FString SlotName, const int32 UserIndex);
    bool IsSplitscreenForceDisabled(const class UObject* WorldContextObject);
    bool IsGamePaused(const class UObject* WorldContextObject);
    bool IsAnyLocalPlayerCameraWithinRange(const class UObject* WorldContextObject, const FVector& Location, float MaximumRange);
    bool HasOption(FString Options, FString InKey);
    bool HasLaunchOption(FString OptionToCheck);
    int32 GrassOverlappingSphereCount(const class UObject* WorldContextObject, const class UStaticMesh* StaticMesh, FVector CenterPosition, float Radius);
    FIntVector GetWorldOriginLocation(const class UObject* WorldContextObject);
    double GetWorldDeltaSeconds(const class UObject* WorldContextObject);
    void GetViewProjectionMatrix(FMinimalViewInfo DesiredView, FMatrix& ViewMatrix, FMatrix& ProjectionMatrix, FMatrix& ViewProjectionMatrix);
    EMouseCaptureMode GetViewportMouseCaptureMode(const class UObject* WorldContextObject);
    double GetUnpausedTimeSeconds(const class UObject* WorldContextObject);
    double GetTimeSeconds(const class UObject* WorldContextObject);
    TEnumAsByte<EPhysicalSurface> GetSurfaceType(const FHitResult& hit);
    class ULevelStreaming* GetStreamingLevel(const class UObject* WorldContextObject, FName PackageName);
    double GetRealTimeSeconds(const class UObject* WorldContextObject);
    class APlayerState* GetPlayerStateFromUniqueNetId(const class UObject* WorldContextObject, const FUniqueNetIdRepl& UniqueID);
    class APlayerState* GetPlayerState(const class UObject* WorldContextObject, int32 PlayerStateIndex);
    class APawn* GetPlayerPawn(const class UObject* WorldContextObject, int32 PlayerIndex);
    int32 GetPlayerControllerID(class APlayerController* Player);
    class APlayerController* GetPlayerControllerFromPlatformUser(const class UObject* WorldContextObject, FPlatformUserId UserId);
    class APlayerController* GetPlayerControllerFromID(const class UObject* WorldContextObject, int32 ControllerId);
    class APlayerController* GetPlayerController(const class UObject* WorldContextObject, int32 PlayerIndex);
    class ACharacter* GetPlayerCharacter(const class UObject* WorldContextObject, int32 PlayerIndex);
    class APlayerCameraManager* GetPlayerCameraManager(const class UObject* WorldContextObject, int32 PlayerIndex);
    FString GetPlatformName();
    UClass* GetObjectClass(const class UObject* Object);
    int32 GetNumPlayerStates(const class UObject* WorldContextObject);
    int32 GetNumPlayerControllers(const class UObject* WorldContextObject);
    int32 GetNumLocalPlayerControllers(const class UObject* WorldContextObject);
    int32 GetMaxAudioChannelCount(const class UObject* WorldContextObject);
    void GetKeyValue(FString Pair, FString& Key, FString& Value);
    int32 GetIntOption(FString Options, FString Key, int32 DefaultValue);
    float GetGlobalTimeDilation(const class UObject* WorldContextObject);
    class AGameStateBase* GetGameState(const class UObject* WorldContextObject);
    class AGameModeBase* GetGameMode(const class UObject* WorldContextObject);
    class UGameInstance* GetGameInstance(const class UObject* WorldContextObject);
    bool GetEnableWorldRendering(const class UObject* WorldContextObject);
    class UReverbEffect* GetCurrentReverbEffect(const class UObject* WorldContextObject);
    FString GetCurrentLevelName(const class UObject* WorldContextObject, bool bRemovePrefixString);
    bool GetClosestListenerLocation(const class UObject* WorldContextObject, const FVector& Location, float MaximumRange, const bool bAllowAttenuationOverride, FVector& ListenerPosition);
    TArray<FName> GetAvailableSpatialPluginNames(const class UObject* WorldContextObject);
    double GetAudioTimeSeconds(const class UObject* WorldContextObject);
    void GetAllActorsWithTag(const class UObject* WorldContextObject, FName Tag, TArray<class AActor*>& OutActors);
    void GetAllActorsWithInterface(const class UObject* WorldContextObject, TSubclassOf<class UInterface> Interface, TArray<class AActor*>& OutActors);
    void GetAllActorsOfClassWithTag(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, FName Tag, TArray<class AActor*>& OutActors);
    void GetAllActorsOfClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>& OutActors);
    class AActor* GetActorOfClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass);
    void GetActorArrayBounds(const TArray<class AActor*>& Actors, bool bOnlyCollidingComponents, FVector& Center, FVector& BoxExtent);
    FVector GetActorArrayAverageLocation(const TArray<class AActor*>& Actors);
    FName GetActiveSpatialPluginName(const class UObject* WorldContextObject);
    void GetAccurateRealTime(int32& Seconds, double& PartialSeconds);
    void FlushLevelStreaming(const class UObject* WorldContextObject);
    class AActor* FinishSpawningActor(class AActor* Actor, const FTransform& SpawnTransform, ESpawnActorScaleMethod TransformScaleMethod);
    class AActor* FindNearestActor(FVector Origin, const TArray<class AActor*>& ActorsToCheck, float& Distance);
    bool FindCollisionUV(const FHitResult& hit, int32 UVChannel, FVector2D& UV);
    void EnableLiveStreaming(bool Enable);
    bool DoesSaveGameExist(FString SlotName, const int32 UserIndex);
    bool DeprojectScreenToWorld(class APlayerController* Player, const FVector2D& ScreenPosition, FVector& WorldPosition, FVector& WorldDirection);
    bool DeprojectSceneCaptureToWorld(class ASceneCapture2D* SceneCapture2D, const FVector2D& TargetUV, FVector& WorldPosition, FVector& WorldDirection);
    bool DeleteGameInSlot(FString SlotName, const int32 UserIndex);
    void DeactivateReverbEffect(const class UObject* WorldContextObject, FName TagName);
    class UAudioComponent* CreateSound2D(const class UObject* WorldContextObject, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, bool bPersistAcrossLevelTransition, bool bAutoDestroy);
    class USaveGame* CreateSaveGameObject(TSubclassOf<class USaveGame> SaveGameClass);
    class APlayerController* CreatePlayerFromPlatformUser(const class UObject* WorldContextObject, FPlatformUserId UserId, bool bSpawnPlayerController);
    class APlayerController* CreatePlayer(const class UObject* WorldContextObject, int32 ControllerId, bool bSpawnPlayerController);
    void ClearSoundMixModifiers(const class UObject* WorldContextObject);
    void ClearSoundMixClassOverride(const class UObject* WorldContextObject, class USoundMix* InSoundMixModifier, class USoundClass* InSoundClass, float FadeOutTime);
    void CancelAsyncLoading();
    void BreakHitResult(const FHitResult& hit, bool& bBlockingHit, bool& bInitialOverlap, float& Time, float& Distance, FVector& Location, FVector& ImpactPoint, FVector& Normal, FVector& ImpactNormal, class UPhysicalMaterial*& PhysMat, class AActor*& HitActor, class UPrimitiveComponent*& HitComponent, FName& HitBoneName, FName& BoneName, int32& HitItem, int32& ElementIndex, int32& FaceIndex, FVector& TraceStart, FVector& TraceEnd);
    bool BlueprintSuggestProjectileVelocity(const class UObject* WorldContextObject, FVector& TossVelocity, FVector StartLocation, FVector endLocation, float LaunchSpeed, float OverrideGravityZ, TEnumAsByte<ESuggestProjVelocityTraceOption::Type> TraceOption, float CollisionRadius, bool bFavorHighArc, bool bDrawDebug, bool bAcceptClosestOnNoSolutions);
    bool Blueprint_PredictProjectilePath_ByTraceChannel(const class UObject* WorldContextObject, FHitResult& OutHit, TArray<FVector>& OutPathPositions, FVector& OutLastTraceDestination, FVector StartPos, FVector LaunchVelocity, bool bTracePath, float ProjectileRadius, TEnumAsByte<ECollisionChannel> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ);
    bool Blueprint_PredictProjectilePath_ByObjectType(const class UObject* WorldContextObject, FHitResult& OutHit, TArray<FVector>& OutPathPositions, FVector& OutLastTraceDestination, FVector StartPos, FVector LaunchVelocity, bool bTracePath, float ProjectileRadius, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, float DrawDebugTime, float SimFrequency, float MaxSimTime, float OverrideGravityZ);
    bool Blueprint_PredictProjectilePath_Advanced(const class UObject* WorldContextObject, const FPredictProjectilePathParams& PredictParams, FPredictProjectilePathResult& PredictResult);
    class AActor* BeginSpawningActorFromBlueprint(const class UObject* WorldContextObject, const class UBlueprint* Blueprint, const FTransform& SpawnTransform, bool bNoCollisionFail);
    class AActor* BeginDeferredActorSpawnFromClass(const class UObject* WorldContextObject, TSubclassOf<class AActor> ActorClass, const FTransform& SpawnTransform, ESpawnActorCollisionHandlingMethod CollisionHandlingOverride, class AActor* Owner, ESpawnActorScaleMethod TransformScaleMethod);
    bool AreSubtitlesEnabled();
    bool AreAnyListenersWithinRange(const class UObject* WorldContextObject, const FVector& Location, float MaximumRange);
    bool ApplyRadialDamageWithFalloff(const class UObject* WorldContextObject, float BaseDamage, float MinimumDamage, const FVector& Origin, float DamageInnerRadius, float DamageOuterRadius, float DamageFalloff, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, TEnumAsByte<ECollisionChannel> DamagePreventionChannel);
    bool ApplyRadialDamage(const class UObject* WorldContextObject, float BaseDamage, const FVector& Origin, float DamageRadius, TSubclassOf<class UDamageType> DamageTypeClass, const TArray<class AActor*>& IgnoreActors, class AActor* DamageCauser, class AController* InstigatedByController, bool bDoFullDamage, TEnumAsByte<ECollisionChannel> DamagePreventionChannel);
    float ApplyPointDamage(class AActor* DamagedActor, float BaseDamage, const FVector& HitFromDirection, const FHitResult& HitInfo, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass);
    float ApplyDamage(class AActor* DamagedActor, float BaseDamage, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass);
    void AnnounceAccessibleString(FString AnnouncementString);
    void ActivateReverbEffect(const class UObject* WorldContextObject, class UReverbEffect* ReverbEffect, FName TagName, float Priority, float Volume, float FadeTime);
}; // Size: 0x28

class UGarbageCollectionSettings : public UDeveloperSettings
{
    float TimeBetweenPurgingPendingKillObjects;                                       // 0x0038 (size: 0x4)
    uint8 FlushStreamingOnGC;                                                         // 0x003C (size: 0x1)
    uint8 AllowParallelGC;                                                            // 0x003C (size: 0x1)
    uint8 IncrementalBeginDestroyEnabled;                                             // 0x003C (size: 0x1)
    uint8 MultithreadedDestructionEnabled;                                            // 0x003C (size: 0x1)
    uint8 CreateGCClusters;                                                           // 0x003C (size: 0x1)
    uint8 AssetClusteringEnabled;                                                     // 0x003C (size: 0x1)
    uint8 ActorClusteringEnabled;                                                     // 0x003C (size: 0x1)
    uint8 UseDisregardForGCOnDedicatedServers;                                        // 0x003C (size: 0x1)
    uint8 VerifyUObjectsAreNotFGCObjects;                                             // 0x003D (size: 0x1)
    uint8 GarbageEliminationEnabled;                                                  // 0x003D (size: 0x1)
    uint8 DumpObjectCountsToLogWhenMaxObjectLimitExceeded;                            // 0x003D (size: 0x1)
    int32 MinGCClusterSize;                                                           // 0x0040 (size: 0x4)
    int32 NumRetriesBeforeForcingGC;                                                  // 0x0044 (size: 0x4)
    int32 MaxObjectsNotConsideredByGC;                                                // 0x0048 (size: 0x4)
    int32 SizeOfPermanentObjectPool;                                                  // 0x004C (size: 0x4)
    int32 MaxObjectsInGame;                                                           // 0x0050 (size: 0x4)
    int32 MaxObjectsInEditor;                                                         // 0x0054 (size: 0x4)

}; // Size: 0x58

class UGraphNodeContextMenuContext : public UObject
{
    class UBlueprint* Blueprint;                                                      // 0x0028 (size: 0x8)
    class UEdGraph* Graph;                                                            // 0x0030 (size: 0x8)
    class UEdGraphNode* Node;                                                         // 0x0038 (size: 0x8)
    bool bIsDebugging;                                                                // 0x0048 (size: 0x1)

}; // Size: 0x50

class UHLODBuilder : public UObject
{
}; // Size: 0x28

class UHLODBuilderSettings : public UObject
{
}; // Size: 0x28

class UHLODEngineSubsystem : public UEngineSubsystem
{
}; // Size: 0x30

class UHLODInstancedStaticMeshComponent : public UInstancedStaticMeshComponent
{
}; // Size: 0x980

class UHLODLayer : public UObject
{
    EHLODLayerType LayerType;                                                         // 0x0028 (size: 0x1)
    TSubclassOf<class UHLODBuilder> HLODBuilderClass;                                 // 0x0030 (size: 0x8)
    class UHLODBuilderSettings* HLODBuilderSettings;                                  // 0x0038 (size: 0x8)
    uint8 bIsSpatiallyLoaded;                                                         // 0x0040 (size: 0x1)
    int32 CellSize;                                                                   // 0x0044 (size: 0x4)
    double LoadingRange;                                                              // 0x0048 (size: 0x8)
    class UHLODLayer* ParentLayer;                                                    // 0x0050 (size: 0x8)
    TSubclassOf<class AWorldPartitionHLOD> HLODActorClass;                            // 0x0058 (size: 0x8)
    TSubclassOf<class UWorldPartitionHLODModifier> HLODModifierClass;                 // 0x0060 (size: 0x8)

}; // Size: 0x68

class UHLODProxy : public UObject
{
    TArray<FHLODProxyMesh> ProxyMeshes;                                               // 0x0028 (size: 0x10)
    TMap<class UHLODProxyDesc*, class FHLODProxyMesh> HLODActors;                     // 0x0038 (size: 0x50)

}; // Size: 0x88

class UHLODProxyDesc : public UObject
{
}; // Size: 0x28

class UHapticFeedbackEffect_Base : public UObject
{
}; // Size: 0x28

class UHapticFeedbackEffect_Buffer : public UHapticFeedbackEffect_Base
{
    TArray<uint8> Amplitudes;                                                         // 0x0028 (size: 0x10)
    int32 SampleRate;                                                                 // 0x0038 (size: 0x4)

}; // Size: 0x40

class UHapticFeedbackEffect_Curve : public UHapticFeedbackEffect_Base
{
    FHapticFeedbackDetails_Curve HapticDetails;                                       // 0x0028 (size: 0x110)

}; // Size: 0x138

class UHapticFeedbackEffect_SoundWave : public UHapticFeedbackEffect_Base
{
    class USoundWave* SoundWave;                                                      // 0x0028 (size: 0x8)
    bool bUseStereo;                                                                  // 0x0030 (size: 0x1)

}; // Size: 0x48

class UHealthSnapshotBlueprintLibrary : public UBlueprintFunctionLibrary
{

    void StopPerformanceSnapshots();
    void StartPerformanceSnapshots();
    void LogPerformanceSnapshot(const FString SnapshotTitle, bool bResetStats);
}; // Size: 0x28

class UHeterogeneousVolumeComponent : public UMeshComponent
{
    FIntVector VolumeResolution;                                                      // 0x0550 (size: 0xC)
    FTransform FrameTransform;                                                        // 0x0560 (size: 0x60)
    float Frame;                                                                      // 0x05C0 (size: 0x4)
    float FrameRate;                                                                  // 0x05C4 (size: 0x4)
    float StartFrame;                                                                 // 0x05C8 (size: 0x4)
    float EndFrame;                                                                   // 0x05CC (size: 0x4)
    uint8 bPlaying;                                                                   // 0x05D0 (size: 0x1)
    uint8 bLooping;                                                                   // 0x05D0 (size: 0x1)
    float StreamingMipBias;                                                           // 0x05D4 (size: 0x4)
    uint8 bIssueBlockingRequests;                                                     // 0x05D8 (size: 0x1)
    uint8 bPivotAtCentroid;                                                           // 0x05D8 (size: 0x1)
    float StepFactor;                                                                 // 0x05DC (size: 0x4)
    float ShadowStepFactor;                                                           // 0x05E0 (size: 0x4)
    float ShadowBiasFactor;                                                           // 0x05E4 (size: 0x4)
    float LightingDownsampleFactor;                                                   // 0x05E8 (size: 0x4)
    class UMaterialInstanceDynamic* MaterialInstanceDynamic;                          // 0x05F0 (size: 0x8)

    void SetVolumeResolution(FIntVector NewValue);
    void SetStreamingMipBias(int32 NewValue);
    void SetStartFrame(float NewValue);
    void SetPlaying(bool NewValue);
    void SetLooping(bool NewValue);
    void SetFrameRate(float NewValue);
    void SetFrame(float NewValue);
    void SetEndFrame(float NewValue);
    void Play();
}; // Size: 0x600

class UHierarchicalInstancedStaticMeshComponent : public UInstancedStaticMeshComponent
{
    uint8 bUseTranslatedInstanceSpace;                                                // 0x0988 (size: 0x1)
    FVector TranslatedInstanceSpaceOrigin;                                            // 0x0990 (size: 0x18)
    TArray<int32> SortedInstances;                                                    // 0x09A8 (size: 0x10)
    int32 NumBuiltInstances;                                                          // 0x09B8 (size: 0x4)
    FBox BuiltInstanceBounds;                                                         // 0x09C0 (size: 0x38)
    FBox UnbuiltInstanceBounds;                                                       // 0x09F8 (size: 0x38)
    TArray<FBox> UnbuiltInstanceBoundsList;                                           // 0x0A30 (size: 0x10)
    uint8 bEnableDensityScaling;                                                      // 0x0A40 (size: 0x1)
    int32 OcclusionLayerNumNodes;                                                     // 0x0A48 (size: 0x4)
    FBoxSphereBounds CacheMeshExtendedBounds;                                         // 0x0A50 (size: 0x38)
    int32 InstanceCountToRender;                                                      // 0x0A88 (size: 0x4)

}; // Size: 0xB10

class UHierarchicalLODSetup : public UObject
{
    TArray<FHierarchicalSimplification> HierarchicalLODSetup;                         // 0x0028 (size: 0x10)
    TSoftObjectPtr<UMaterialInterface> OverrideBaseMaterial;                          // 0x0038 (size: 0x28)

}; // Size: 0x60

class UImportanceSamplingLibrary : public UBlueprintFunctionLibrary
{

    float RandomSobolFloat(int32 Index, int32 Dimension, float Seed);
    FVector RandomSobolCell3D(int32 Index, int32 NumCells, FVector Cell, FVector Seed);
    FVector2D RandomSobolCell2D(int32 Index, int32 NumCells, FVector2D Cell, FVector2D Seed);
    float NextSobolFloat(int32 Index, int32 Dimension, float PreviousValue);
    FVector NextSobolCell3D(int32 Index, int32 NumCells, FVector PreviousValue);
    FVector2D NextSobolCell2D(int32 Index, int32 NumCells, FVector2D PreviousValue);
    FImportanceTexture MakeImportanceTexture(class UTexture2D* Texture, TEnumAsByte<EImportanceWeight::Type> WeightingFunc);
    void ImportanceSample(const FImportanceTexture& Texture, const FVector2D& Rand, int32 Samples, float Intensity, FVector2D& SamplePosition, FLinearColor& SampleColor, float& SampleIntensity, float& SampleSize);
    void BreakImportanceTexture(const FImportanceTexture& ImportanceTexture, class UTexture2D*& Texture, TEnumAsByte<EImportanceWeight::Type>& WeightingFunc);
}; // Size: 0x28

class UInGameAdManager : public UPlatformInterfaceBase
{
    uint8 bShouldPauseWhileAdOpen;                                                    // 0x0038 (size: 0x1)
    TArray<FInGameAdManagerClickedBannerDelegates> ClickedBannerDelegates;            // 0x0040 (size: 0x10)
    TArray<FInGameAdManagerClosedAdDelegates> ClosedAdDelegates;                      // 0x0050 (size: 0x10)

}; // Size: 0x60

class UInheritableComponentHandler : public UObject
{
    TArray<FComponentOverrideRecord> Records;                                         // 0x0028 (size: 0x10)
    TArray<class UActorComponent*> UnnecessaryComponents;                             // 0x0038 (size: 0x10)

}; // Size: 0x48

class UInitialActiveSoundParams : public UObject
{
    TArray<FAudioParameter> AudioParams;                                              // 0x0028 (size: 0x10)

}; // Size: 0x38

class UInputActionDelegateBinding : public UInputDelegateBinding
{
    TArray<FBlueprintInputActionDelegateBinding> InputActionDelegateBindings;         // 0x0028 (size: 0x10)

}; // Size: 0x38

class UInputAxisDelegateBinding : public UInputDelegateBinding
{
    TArray<FBlueprintInputAxisDelegateBinding> InputAxisDelegateBindings;             // 0x0028 (size: 0x10)

}; // Size: 0x38

class UInputAxisKeyDelegateBinding : public UInputDelegateBinding
{
    TArray<FBlueprintInputAxisKeyDelegateBinding> InputAxisKeyDelegateBindings;       // 0x0028 (size: 0x10)

}; // Size: 0x38

class UInputComponent : public UActorComponent
{
    TArray<FCachedKeyToActionInfo> CachedKeyToActionInfo;                             // 0x0110 (size: 0x10)

    bool WasControllerKeyJustReleased(FKey Key);
    bool WasControllerKeyJustPressed(FKey Key);
    void OnInputOwnerEndPlayed(class AActor* InOwner, TEnumAsByte<EEndPlayReason::Type> EndPlayReason);
    bool IsControllerKeyDown(FKey Key);
    void GetTouchState(int32 FingerIndex, float& LocationX, float& LocationY, bool& bIsCurrentlyPressed);
    FVector GetControllerVectorKeyState(FKey Key);
    void GetControllerMouseDelta(float& DeltaX, float& DeltaY);
    float GetControllerKeyTimeDown(FKey Key);
    void GetControllerAnalogStickState(TEnumAsByte<EControllerAnalogStick::Type> WhichStick, float& StickX, float& StickY);
    float GetControllerAnalogKeyState(FKey Key);
}; // Size: 0x128

class UInputDelegateBinding : public UDynamicBlueprintBinding
{
}; // Size: 0x28

class UInputDeviceAudioBasedVibrationProperty : public UInputDeviceProperty
{
    FAudioBasedVibrationData Data;                                                    // 0x0030 (size: 0x8)
    TMap<class FName, class FAudioBasedVibrationData> DeviceOverrideData;             // 0x0038 (size: 0x50)

}; // Size: 0x88

class UInputDeviceLibrary : public UBlueprintFunctionLibrary
{

    FPlatformUserId PlatformUserId_None();
    bool NotEqual_PlatformUserId(FPlatformUserId A, FPlatformUserId B);
    bool NotEqual_InputDeviceId(FInputDeviceId A, FInputDeviceId B);
    bool IsValidPlatformId(FPlatformUserId UserId);
    bool IsValidInputDevice(FInputDeviceId DeviceID);
    bool IsUnpairedUserId(const FPlatformUserId PlatformId);
    bool IsInputDeviceMappedToUnpairedUser(const FInputDeviceId InputDevice);
    bool IsDevicePropertyHandleValid(const FInputDevicePropertyHandle& InHandle);
    FInputDeviceId InputDeviceId_None();
    FPlatformUserId GetUserForUnpairedInputDevices();
    FPlatformUserId GetUserForInputDevice(FInputDeviceId DeviceID);
    FPlatformUserId GetPrimaryPlatformUser();
    FInputDeviceId GetPrimaryInputDeviceForUser(FPlatformUserId UserId);
    class APlayerController* GetPlayerControllerFromPlatformUser(const FPlatformUserId UserId);
    class APlayerController* GetPlayerControllerFromInputDevice(const FInputDeviceId DeviceID);
    EInputDeviceConnectionState GetInputDeviceConnectionState(const FInputDeviceId DeviceID);
    FInputDeviceId GetDefaultInputDevice();
    int32 GetAllInputDevicesForUser(const FPlatformUserId UserId, TArray<FInputDeviceId>& OutInputDevices);
    int32 GetAllInputDevices(TArray<FInputDeviceId>& OutInputDevices);
    int32 GetAllConnectedInputDevices(TArray<FInputDeviceId>& OutInputDevices);
    int32 GetAllActiveUsers(TArray<FPlatformUserId>& OutUsers);
    bool EqualEqual_PlatformUserId(FPlatformUserId A, FPlatformUserId B);
    bool EqualEqual_InputDeviceId(FInputDeviceId A, FInputDeviceId B);
}; // Size: 0x28

class UInputDeviceProperty : public UObject
{
    float PropertyDuration;                                                           // 0x0028 (size: 0x4)

    void ResetDeviceProperty(const FPlatformUserId PlatformUser, const FInputDeviceId DeviceID, bool bForceReset);
    void EvaluateDeviceProperty(const FPlatformUserId PlatformUser, const FInputDeviceId DeviceID, const float DeltaTime, const float Duration);
    void ApplyDeviceProperty(const FPlatformUserId UserId, const FInputDeviceId DeviceID);
}; // Size: 0x30

class UInputDeviceSubsystem : public UEngineSubsystem
{
    FInputDeviceSubsystemOnInputHardwareDeviceChanged OnInputHardwareDeviceChanged;   // 0x0038 (size: 0x10)
    void HardwareInputDeviceChanged(const FPlatformUserId UserId, const FInputDeviceId DeviceID);
    TSet<FActiveDeviceProperty> ActiveProperties;                                     // 0x0048 (size: 0x50)
    TSet<FInputDevicePropertyHandle> PropertiesPendingRemoval;                        // 0x0098 (size: 0x50)

    void RemoveDevicePropertyHandles(const TSet<FInputDevicePropertyHandle>& HandlesToRemove);
    void RemoveDevicePropertyByHandle(const FInputDevicePropertyHandle HandleToRemove);
    void RemoveAllDeviceProperties();
    bool IsPropertyActive(const FInputDevicePropertyHandle Handle);
    FHardwareDeviceIdentifier GetMostRecentlyUsedHardwareDevice(const FPlatformUserId InUserId);
    FHardwareDeviceIdentifier GetInputDeviceHardwareIdentifier(const FInputDeviceId InputDevice);
    class UInputDeviceProperty* GetActiveDeviceProperty(const FInputDevicePropertyHandle Handle);
    FInputDevicePropertyHandle ActivateDevicePropertyOfClass(TSubclassOf<class UInputDeviceProperty> PropertyClass, const FActivateDevicePropertyParams& Params);
}; // Size: 0x198

class UInputDeviceTriggerEffect : public UInputDeviceProperty
{
    FDeviceTriggerBaseData BaseTriggerData;                                           // 0x0030 (size: 0x2)

}; // Size: 0x40

class UInputDeviceTriggerFeedbackProperty : public UInputDeviceTriggerEffect
{
    FDeviceTriggerFeedbackData TriggerData;                                           // 0x0040 (size: 0x10)
    TMap<class FName, class FDeviceTriggerFeedbackData> DeviceOverrideData;           // 0x0050 (size: 0x50)

}; // Size: 0xB8

class UInputDeviceTriggerResistanceProperty : public UInputDeviceTriggerEffect
{
    FDeviceTriggerTriggerResistanceData TriggerData;                                  // 0x0040 (size: 0x10)
    TMap<class FName, class FDeviceTriggerTriggerResistanceData> DeviceOverrideData;  // 0x0050 (size: 0x50)

}; // Size: 0xC0

class UInputDeviceTriggerVibrationProperty : public UInputDeviceTriggerEffect
{
    FDeviceTriggerTriggerVibrationData TriggerData;                                   // 0x0040 (size: 0x18)
    TMap<class FName, class FDeviceTriggerTriggerVibrationData> DeviceOverrideData;   // 0x0058 (size: 0x50)

}; // Size: 0xC0

class UInputKeyDelegateBinding : public UInputDelegateBinding
{
    TArray<FBlueprintInputKeyDelegateBinding> InputKeyDelegateBindings;               // 0x0028 (size: 0x10)

}; // Size: 0x38

class UInputPlatformSettings : public UPlatformSettings
{
    int32 MaxTriggerFeedbackPosition;                                                 // 0x0040 (size: 0x4)
    int32 MaxTriggerFeedbackStrength;                                                 // 0x0044 (size: 0x4)
    int32 MaxTriggerVibrationTriggerPosition;                                         // 0x0048 (size: 0x4)
    int32 MaxTriggerVibrationFrequency;                                               // 0x004C (size: 0x4)
    int32 MaxTriggerVibrationAmplitude;                                               // 0x0050 (size: 0x4)
    TArray<FHardwareDeviceIdentifier> HardwareDevices;                                // 0x0058 (size: 0x10)

}; // Size: 0x68

class UInputSettings : public UObject
{
    TArray<FInputAxisConfigEntry> AxisConfig;                                         // 0x0028 (size: 0x10)
    FPerPlatformSettings PlatformSettings;                                            // 0x0038 (size: 0x10)
    uint8 bAltEnterTogglesFullscreen;                                                 // 0x0048 (size: 0x1)
    uint8 bF11TogglesFullscreen;                                                      // 0x0048 (size: 0x1)
    uint8 bUseMouseForTouch;                                                          // 0x0048 (size: 0x1)
    uint8 bEnableMouseSmoothing;                                                      // 0x0048 (size: 0x1)
    uint8 bEnableFOVScaling;                                                          // 0x0048 (size: 0x1)
    uint8 bCaptureMouseOnLaunch;                                                      // 0x0048 (size: 0x1)
    uint8 bEnableLegacyInputScales;                                                   // 0x0048 (size: 0x1)
    uint8 bEnableMotionControls;                                                      // 0x0048 (size: 0x1)
    uint8 bFilterInputByPlatformUser;                                                 // 0x0049 (size: 0x1)
    uint8 bEnableInputDeviceSubsystem;                                                // 0x0049 (size: 0x1)
    uint8 bShouldFlushPressedKeysOnViewportFocusLost;                                 // 0x0049 (size: 0x1)
    uint8 bEnableDynamicComponentInputBinding;                                        // 0x0049 (size: 0x1)
    uint8 bAlwaysShowTouchInterface;                                                  // 0x0049 (size: 0x1)
    uint8 bShowConsoleOnFourFingerTap;                                                // 0x0049 (size: 0x1)
    uint8 bEnableGestureRecognizer;                                                   // 0x0049 (size: 0x1)
    uint8 bUseAutocorrect;                                                            // 0x0049 (size: 0x1)
    TArray<FString> ExcludedAutocorrectOS;                                            // 0x0050 (size: 0x10)
    TArray<FString> ExcludedAutocorrectCultures;                                      // 0x0060 (size: 0x10)
    TArray<FString> ExcludedAutocorrectDeviceModels;                                  // 0x0070 (size: 0x10)
    EMouseCaptureMode DefaultViewportMouseCaptureMode;                                // 0x0080 (size: 0x1)
    EMouseLockMode DefaultViewportMouseLockMode;                                      // 0x0081 (size: 0x1)
    float FOVScale;                                                                   // 0x0084 (size: 0x4)
    float DoubleClickTime;                                                            // 0x0088 (size: 0x4)
    TArray<FInputActionKeyMapping> ActionMappings;                                    // 0x0090 (size: 0x10)
    TArray<FInputAxisKeyMapping> AxisMappings;                                        // 0x00A0 (size: 0x10)
    TArray<FInputActionSpeechMapping> SpeechMappings;                                 // 0x00B0 (size: 0x10)
    TSoftClassPtr<UPlayerInput> DefaultPlayerInputClass;                              // 0x00C0 (size: 0x28)
    TSoftClassPtr<UInputComponent> DefaultInputComponentClass;                        // 0x00E8 (size: 0x28)
    FSoftObjectPath DefaultTouchInterface;                                            // 0x0110 (size: 0x20)
    TArray<FKey> ConsoleKeys;                                                         // 0x0130 (size: 0x10)

    void SaveKeyMappings();
    void RemoveAxisMapping(const FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
    void RemoveActionMapping(const FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
    class UInputSettings* GetInputSettings();
    void GetAxisNames(TArray<FName>& AxisNames);
    void GetAxisMappingByName(const FName InAxisName, TArray<FInputAxisKeyMapping>& OutMappings);
    void GetActionNames(TArray<FName>& ActionNames);
    void GetActionMappingByName(const FName InActionName, TArray<FInputActionKeyMapping>& OutMappings);
    void ForceRebuildKeymaps();
    void AddAxisMapping(const FInputAxisKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
    void AddActionMapping(const FInputActionKeyMapping& KeyMapping, bool bForceRebuildKeymaps);
}; // Size: 0x140

class UInputTouchDelegateBinding : public UInputDelegateBinding
{
    TArray<FBlueprintInputTouchDelegateBinding> InputTouchDelegateBindings;           // 0x0028 (size: 0x10)

}; // Size: 0x38

class UInputVectorAxisDelegateBinding : public UInputAxisKeyDelegateBinding
{
}; // Size: 0x38

class UInstancedPlacemenClientSettings : public UObject
{
}; // Size: 0x28

class UInstancedStaticMeshComponent : public UStaticMeshComponent
{
    TArray<FInstancedStaticMeshInstanceData> PerInstanceSMData;                       // 0x05E0 (size: 0x10)
    TArray<FMatrix> PerInstancePrevTransform;                                         // 0x05F0 (size: 0x10)
    FBox NavigationBounds;                                                            // 0x0600 (size: 0x38)
    FTransform PreviousComponentTransform;                                            // 0x0640 (size: 0x60)
    int32 NumCustomDataFloats;                                                        // 0x06A0 (size: 0x4)
    TArray<float> PerInstanceSMCustomData;                                            // 0x06A8 (size: 0x10)
    int32 InstancingRandomSeed;                                                       // 0x06B8 (size: 0x4)
    TArray<FInstancedStaticMeshRandomSeed> AdditionalRandomSeeds;                     // 0x06C0 (size: 0x10)
    float InstanceLODDistanceScale;                                                   // 0x06D0 (size: 0x4)
    int32 InstanceStartCullDistance;                                                  // 0x06D4 (size: 0x4)
    int32 InstanceEndCullDistance;                                                    // 0x06D8 (size: 0x4)
    uint8 bUseGpuLodSelection;                                                        // 0x06DC (size: 0x1)
    uint8 bInheritPerInstanceData;                                                    // 0x06DC (size: 0x1)
    TArray<int32> InstanceReorderTable;                                               // 0x06E0 (size: 0x10)
    bool bDisableCollision;                                                           // 0x06F0 (size: 0x1)
    int32 NumPendingLightmaps;                                                        // 0x0960 (size: 0x4)
    TArray<FInstancedStaticMeshMappingInfo> CachedMappings;                           // 0x0968 (size: 0x10)

    bool UpdateInstanceTransform(int32 InstanceIndex, const FTransform& NewInstanceTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport);
    void SetNumCustomDataFloats(int32 InNumCustomDataFloats);
    void SetLODDistanceScale(float InLODDistanceScale);
    bool SetCustomDataValue(int32 InstanceIndex, int32 CustomDataIndex, float CustomDataValue, bool bMarkRenderStateDirty);
    void SetCullDistances(int32 StartCullDistance, int32 EndCullDistance);
    bool RemoveInstances(const TArray<int32>& InstancesToRemove);
    bool RemoveInstance(int32 InstanceIndex);
    bool IsValidInstance(int32 InstanceIndex);
    float GetLODDistanceScale();
    bool GetInstanceTransform(int32 InstanceIndex, FTransform& OutInstanceTransform, bool bWorldSpace);
    TArray<int32> GetInstancesOverlappingSphere(const FVector& Center, float Radius, bool bSphereInWorldSpace);
    TArray<int32> GetInstancesOverlappingBox(const FBox& Box, bool bBoxInWorldSpace);
    int32 GetInstanceCount();
    void GetCullDistances(int32& OutStartCullDistance, int32& OutEndCullDistance);
    void ClearInstances();
    bool BatchUpdateInstancesTransforms(int32 StartInstanceIndex, const TArray<FTransform>& NewInstancesTransforms, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport);
    bool BatchUpdateInstancesTransform(int32 StartInstanceIndex, int32 NumInstances, const FTransform& NewInstancesTransform, bool bWorldSpace, bool bMarkRenderStateDirty, bool bTeleport);
    int32 AddInstanceWorldSpace(const FTransform& WorldTransform);
    TArray<int32> AddInstances(const TArray<FTransform>& InstanceTransforms, bool bShouldReturnIndices, bool bWorldSpace, bool bUpdateNavigation);
    int32 AddInstance(const FTransform& instanceTransform, bool bWorldSpace);
}; // Size: 0x980

class UIntSerialization : public UObject
{
    uint16 UnsignedInt16Variable;                                                     // 0x0028 (size: 0x2)
    uint32 UnsignedInt32Variable;                                                     // 0x002C (size: 0x4)
    uint64 UnsignedInt64Variable;                                                     // 0x0030 (size: 0x8)
    int8 SignedInt8Variable;                                                          // 0x0038 (size: 0x1)
    int16 SignedInt16Variable;                                                        // 0x003A (size: 0x2)
    int64 SignedInt64Variable;                                                        // 0x0040 (size: 0x8)
    uint8 UnsignedInt8Variable;                                                       // 0x0048 (size: 0x1)
    int32 SignedInt32Variable;                                                        // 0x004C (size: 0x4)

}; // Size: 0x50

class UInterpCurveEdSetup : public UObject
{
    TArray<FCurveEdTab> Tabs;                                                         // 0x0028 (size: 0x10)
    int32 ActiveTab;                                                                  // 0x0038 (size: 0x4)

}; // Size: 0x40

class UInterpToMovementComponent : public UMovementComponent
{
    float Duration;                                                                   // 0x0108 (size: 0x4)
    uint8 bPauseOnImpact;                                                             // 0x010C (size: 0x1)
    bool bSweep;                                                                      // 0x0110 (size: 0x1)
    ETeleportType TeleportType;                                                       // 0x0111 (size: 0x1)
    EInterpToBehaviourType BehaviourType;                                             // 0x0112 (size: 0x1)
    bool bCheckIfStillInWorld;                                                        // 0x0113 (size: 0x1)
    uint8 bForceSubStepping;                                                          // 0x0114 (size: 0x1)
    FInterpToMovementComponentOnInterpToReverse OnInterpToReverse;                    // 0x0118 (size: 0x10)
    void OnInterpToReverseDelegate(const FHitResult& ImpactResult, float Time);
    FInterpToMovementComponentOnInterpToStop OnInterpToStop;                          // 0x0128 (size: 0x10)
    void OnInterpToStopDelegate(const FHitResult& ImpactResult, float Time);
    FInterpToMovementComponentOnWaitBeginDelegate OnWaitBeginDelegate;                // 0x0138 (size: 0x10)
    void OnInterpToWaitBeginDelegate(const FHitResult& ImpactResult, float Time);
    FInterpToMovementComponentOnWaitEndDelegate OnWaitEndDelegate;                    // 0x0148 (size: 0x10)
    void OnInterpToWaitEndDelegate(const FHitResult& ImpactResult, float Time);
    FInterpToMovementComponentOnResetDelegate OnResetDelegate;                        // 0x0158 (size: 0x10)
    void OnInterpToResetDelegate(const FHitResult& ImpactResult, float Time);
    float MaxSimulationTimeStep;                                                      // 0x0168 (size: 0x4)
    float SpeedMultiplier;                                                            // 0x016C (size: 0x4)
    int32 MaxSimulationIterations;                                                    // 0x0170 (size: 0x4)
    TArray<FInterpControlPoint> ControlPoints;                                        // 0x0178 (size: 0x10)

    void StopSimulating(const FHitResult& HitResult);
    void RestartMovement(float InitialDirection);
    void ResetControlPoints();
    void OnInterpToWaitEndDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void OnInterpToWaitBeginDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void OnInterpToStopDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void OnInterpToReverseDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void OnInterpToResetDelegate__DelegateSignature(const FHitResult& ImpactResult, float Time);
    void FinaliseControlPoints();
    void AddControlPointPosition(FVector Pos, bool bPositionIsRelative);
}; // Size: 0x1C0

class UKismetArrayLibrary : public UBlueprintFunctionLibrary
{

    void SortStringArray(TArray<FString>& TargetArray, bool bStableSort, EArraySortOrder SortOrder);
    void SortNameArray(TArray<FName>& TargetArray, bool bStableSort, bool bLexicalSort, EArraySortOrder SortOrder);
    void SortIntArray(TArray<int32>& TargetArray, bool bStableSort, EArraySortOrder SortOrder);
    void SortInt64Array(TArray<int64>& TargetArray, bool bStableSort, EArraySortOrder SortOrder);
    void SortFloatArray(TArray<double>& TargetArray, bool bStableSort, EArraySortOrder SortOrder);
    void SortByteArray(TArray<uint8>& TargetArray, bool bStableSort, EArraySortOrder SortOrder);
    void SetArrayPropertyByName(class UObject* Object, FName PropertyName, const TArray<int32>& Value);
    void FilterArray(const TArray<class AActor*>& TargetArray, TSubclassOf<class AActor> FilterClass, TArray<class AActor*>& FilteredArray);
    void Array_Swap(const TArray<int32>& TargetArray, int32 FirstIndex, int32 SecondIndex);
    void Array_ShuffleFromStream(const TArray<int32>& TargetArray, FRandomStream& RandomStream);
    void Array_Shuffle(const TArray<int32>& TargetArray);
    void Array_Set(const TArray<int32>& TargetArray, int32 Index, const int32& Item, bool bSizeToFit);
    void Array_Reverse(const TArray<int32>& TargetArray);
    void Array_Resize(const TArray<int32>& TargetArray, int32 Size);
    bool Array_RemoveItem(const TArray<int32>& TargetArray, const int32& Item);
    void Array_Remove(const TArray<int32>& TargetArray, int32 IndexToRemove);
    void Array_RandomFromStream(const TArray<int32>& TargetArray, FRandomStream& RandomStream, int32& OutItem, int32& OutIndex);
    void Array_Random(const TArray<int32>& TargetArray, int32& OutItem, int32& OutIndex);
    int32 Array_Length(const TArray<int32>& TargetArray);
    int32 Array_LastIndex(const TArray<int32>& TargetArray);
    bool Array_IsValidIndex(const TArray<int32>& TargetArray, int32 IndexToTest);
    bool Array_IsNotEmpty(const TArray<int32>& TargetArray);
    bool Array_IsEmpty(const TArray<int32>& TargetArray);
    void Array_Insert(const TArray<int32>& TargetArray, const int32& NewItem, int32 Index);
    bool Array_Identical(const TArray<int32>& ArrayA, const TArray<int32>& ArrayB);
    void Array_Get(const TArray<int32>& TargetArray, int32 Index, int32& Item);
    int32 Array_Find(const TArray<int32>& TargetArray, const int32& ItemToFind);
    bool Array_Contains(const TArray<int32>& TargetArray, const int32& ItemToFind);
    void Array_Clear(const TArray<int32>& TargetArray);
    void Array_Append(const TArray<int32>& TargetArray, const TArray<int32>& SourceArray);
    int32 Array_AddUnique(const TArray<int32>& TargetArray, const int32& NewItem);
    int32 Array_Add(const TArray<int32>& TargetArray, const int32& NewItem);
}; // Size: 0x28

class UKismetGuidLibrary : public UBlueprintFunctionLibrary
{

    void Parse_StringToGuid(FString GuidString, FGuid& OutGuid, bool& Success);
    bool NotEqual_GuidGuid(const FGuid& A, const FGuid& B);
    FGuid NewGuid();
    bool IsValid_Guid(const FGuid& InGuid);
    void Invalidate_Guid(FGuid& InGuid);
    bool EqualEqual_GuidGuid(const FGuid& A, const FGuid& B);
    FString Conv_GuidToString(const FGuid& InGuid);
}; // Size: 0x28

class UKismetInputLibrary : public UBlueprintFunctionLibrary
{

    bool PointerEvent_IsTouchEvent(const FPointerEvent& Input);
    bool PointerEvent_IsMouseButtonDown(const FPointerEvent& Input, FKey MouseButton);
    float PointerEvent_GetWheelDelta(const FPointerEvent& Input);
    int32 PointerEvent_GetUserIndex(const FPointerEvent& Input);
    int32 PointerEvent_GetTouchpadIndex(const FPointerEvent& Input);
    FVector2D PointerEvent_GetScreenSpacePosition(const FPointerEvent& Input);
    int32 PointerEvent_GetPointerIndex(const FPointerEvent& Input);
    FVector2D PointerEvent_GetLastScreenSpacePosition(const FPointerEvent& Input);
    ESlateGesture PointerEvent_GetGestureType(const FPointerEvent& Input);
    FVector2D PointerEvent_GetGestureDelta(const FPointerEvent& Input);
    FKey PointerEvent_GetEffectingButton(const FPointerEvent& Input);
    FVector2D PointerEvent_GetCursorDelta(const FPointerEvent& Input);
    bool ModifierKeysState_IsShiftDown(const FSlateModifierKeysState& KeysState);
    bool ModifierKeysState_IsControlDown(const FSlateModifierKeysState& KeysState);
    bool ModifierKeysState_IsCommandDown(const FSlateModifierKeysState& KeysState);
    bool ModifierKeysState_IsAltDown(const FSlateModifierKeysState& KeysState);
    bool Key_IsVectorAxis(const FKey& Key);
    bool Key_IsValid(const FKey& Key);
    bool Key_IsMouseButton(const FKey& Key);
    bool Key_IsModifierKey(const FKey& Key);
    bool Key_IsKeyboardKey(const FKey& Key);
    bool Key_IsGamepadKey(const FKey& Key);
    bool Key_IsDigital(const FKey& Key);
    bool Key_IsButtonAxis(const FKey& Key);
    bool Key_IsAxis3D(const FKey& Key);
    bool Key_IsAxis2D(const FKey& Key);
    bool Key_IsAxis1D(const FKey& Key);
    bool Key_IsAnalog(const FKey& Key);
    EUINavigation Key_GetNavigationDirectionFromKey(const FKeyEvent& InKeyEvent);
    EUINavigation Key_GetNavigationDirectionFromAnalog(const FAnalogInputEvent& InAnalogEvent);
    EUINavigationAction Key_GetNavigationActionFromKey(const FKeyEvent& InKeyEvent);
    EUINavigationAction Key_GetNavigationAction(const FKey& InKey);
    FText Key_GetDisplayName(const FKey& Key, bool bLongDisplayName);
    bool InputEvent_IsShiftDown(const FInputEvent& Input);
    bool InputEvent_IsRightShiftDown(const FInputEvent& Input);
    bool InputEvent_IsRightControlDown(const FInputEvent& Input);
    bool InputEvent_IsRightCommandDown(const FInputEvent& Input);
    bool InputEvent_IsRightAltDown(const FInputEvent& Input);
    bool InputEvent_IsRepeat(const FInputEvent& Input);
    bool InputEvent_IsLeftShiftDown(const FInputEvent& Input);
    bool InputEvent_IsLeftControlDown(const FInputEvent& Input);
    bool InputEvent_IsLeftCommandDown(const FInputEvent& Input);
    bool InputEvent_IsLeftAltDown(const FInputEvent& Input);
    bool InputEvent_IsControlDown(const FInputEvent& Input);
    bool InputEvent_IsCommandDown(const FInputEvent& Input);
    bool InputEvent_IsAltDown(const FInputEvent& Input);
    FText InputChord_GetDisplayName(const FInputChord& Key);
    int32 GetUserIndex(const FKeyEvent& Input);
    FSlateModifierKeysState GetModifierKeysState();
    FKey GetKey(const FKeyEvent& Input);
    float GetAnalogValue(const FAnalogInputEvent& Input);
    bool EqualEqual_KeyKey(FKey A, FKey B);
    bool EqualEqual_InputChordInputChord(FInputChord A, FInputChord B);
    void CalibrateTilt();
}; // Size: 0x28

class UKismetInternationalizationLibrary : public UBlueprintFunctionLibrary
{

    bool SetCurrentLocale(FString Culture, const bool SaveToConfig);
    bool SetCurrentLanguageAndLocale(FString Culture, const bool SaveToConfig);
    bool SetCurrentLanguage(FString Culture, const bool SaveToConfig);
    bool SetCurrentCulture(FString Culture, const bool SaveToConfig);
    bool SetCurrentAssetGroupCulture(const FName AssetGroup, FString Culture, const bool SaveToConfig);
    FString GetSuitableCulture(const TArray<FString>& AvailableCultures, FString CultureToMatch, FString FallbackCulture);
    FString GetNativeCulture(const ELocalizedTextSourceCategory TextCategory);
    TArray<FString> GetLocalizedCultures(const bool IncludeGame, const bool IncludeEngine, const bool IncludeEditor, const bool IncludeAdditional);
    FString GetCurrentLocale();
    FString GetCurrentLanguage();
    FString GetCurrentCulture();
    FString GetCurrentAssetGroupCulture(const FName AssetGroup);
    FString GetCultureDisplayName(FString Culture, const bool Localized);
    void ClearCurrentAssetGroupCulture(const FName AssetGroup, const bool SaveToConfig);
}; // Size: 0x28

class UKismetMaterialLibrary : public UBlueprintFunctionLibrary
{

    void SetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, FName ParameterName, const FLinearColor& ParameterValue);
    void SetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, FName ParameterName, float ParameterValue);
    FLinearColor GetVectorParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, FName ParameterName);
    float GetScalarParameterValue(class UObject* WorldContextObject, class UMaterialParameterCollection* Collection, FName ParameterName);
    class UMaterialInstanceDynamic* CreateDynamicMaterialInstance(class UObject* WorldContextObject, class UMaterialInterface* Parent, FName OptionalName, EMIDCreationFlags CreationFlags);
}; // Size: 0x28

class UKismetMathLibrary : public UBlueprintFunctionLibrary
{

    int32 Xor_IntInt(int32 A, int32 B);
    int64 Xor_Int64Int64(int64 A, int64 B);
    int32 Wrap(int32 Value, int32 Min, int32 Max);
    FVector WeightedMovingAverage_FVector(FVector CurrentSample, FVector PreviousSample, float Weight);
    FRotator WeightedMovingAverage_FRotator(FRotator CurrentSample, FRotator PreviousSample, float Weight);
    float WeightedMovingAverage_Float(float CurrentSample, float PreviousSample, float Weight);
    double VSizeXYSquared(FVector A);
    double VSizeXY(FVector A);
    double VSizeSquared(FVector A);
    double VSize2DSquared(FVector2D A);
    double VSize2D(FVector2D A);
    double VSize(FVector A);
    FVector VLerp(FVector A, FVector B, float Alpha);
    FVector VInterpTo_Constant(FVector Current, FVector Target, float DeltaTime, float InterpSpeed);
    FVector VInterpTo(FVector Current, FVector Target, float DeltaTime, float InterpSpeed);
    FVector VectorSpringInterp(FVector Current, FVector Target, FVectorSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass, float TargetVelocityAmount, bool bClamp, FVector MinValue, FVector MaxValue, bool bInitializeFromTarget);
    FVector Vector_Zero();
    FVector Vector_Up();
    void Vector_UnwindEuler(FVector& A);
    FVector2D Vector_UnitCartesianToSpherical(FVector A);
    FVector Vector_ToRadians(FVector A);
    FVector Vector_ToDegrees(FVector A);
    FVector Vector_SnappedToGrid(FVector InVect, float InGridSize);
    FVector Vector_SlerpVectorToDirection(FVector Vector, FVector Direction, double Alpha);
    FVector Vector_SlerpNormals(FVector NormalA, FVector NormalB, double Alpha);
    void Vector_Set(FVector& A, double X, double Y, double Z);
    FVector Vector_Right();
    FVector Vector_Reciprocal(const FVector& A);
    FVector Vector_ProjectOnToNormal(FVector V, FVector InNormal);
    FVector Vector_One();
    FVector Vector_NormalUnsafe(const FVector& A);
    void Vector_Normalize(FVector& A, float Tolerance);
    FVector Vector_Normal2D(FVector A, float Tolerance);
    FVector Vector_MirrorByPlane(FVector A, const FPlane& InPlane);
    FVector Vector_Left();
    bool Vector_IsZero(const FVector& A);
    bool Vector_IsUnit(const FVector& A, float SquaredLenthTolerance);
    bool Vector_IsUniform(const FVector& A, float Tolerance);
    bool Vector_IsNormal(const FVector& A);
    bool Vector_IsNearlyZero(const FVector& A, float Tolerance);
    bool Vector_IsNAN(const FVector& A);
    double Vector_HeadingAngle(FVector A);
    FVector Vector_GetSignVector(FVector A);
    FVector Vector_GetProjection(FVector A);
    double Vector_GetAbsMin(FVector A);
    double Vector_GetAbsMax(FVector A);
    FVector Vector_GetAbs(FVector A);
    FVector Vector_Forward();
    FVector Vector_Down();
    double Vector_DistanceSquared(FVector v1, FVector v2);
    double Vector_Distance2DSquared(FVector v1, FVector v2);
    double Vector_Distance2D(FVector v1, FVector v2);
    double Vector_Distance(FVector v1, FVector v2);
    double Vector_CosineAngle2D(FVector A, FVector B);
    FVector Vector_ComponentMin(FVector A, FVector B);
    FVector Vector_ComponentMax(FVector A, FVector B);
    FVector Vector_ClampSizeMax2D(FVector A, double Max);
    FVector Vector_ClampSizeMax(FVector A, double Max);
    FVector Vector_ClampSize2D(FVector A, double Min, double Max);
    FVector Vector_BoundedToCube(FVector InVect, float InRadius);
    FVector Vector_BoundedToBox(FVector InVect, FVector InBoxMin, FVector InBoxMax);
    FVector Vector_Backward();
    void Vector_Assign(FVector& A, const FVector& InVector);
    void Vector_AddBounded(FVector& A, FVector InAddVect, float InRadius);
    FVector4 Vector4_Zero();
    double Vector4_SizeSquared3(const FVector4& A);
    double Vector4_SizeSquared(const FVector4& A);
    double Vector4_Size3(const FVector4& A);
    double Vector4_Size(const FVector4& A);
    void Vector4_Set(FVector4& A, double X, double Y, double Z, double W);
    FVector4 Vector4_NormalUnsafe3(const FVector4& A);
    void Vector4_Normalize3(FVector4& A, float Tolerance);
    FVector4 Vector4_Normal3(const FVector4& A, float Tolerance);
    FVector4 Vector4_Negated(const FVector4& A);
    FVector4 Vector4_MirrorByVector3(const FVector4& Direction, const FVector4& SurfaceNormal);
    bool Vector4_IsZero(const FVector4& A);
    bool Vector4_IsUnit3(const FVector4& A, float SquaredLenthTolerance);
    bool Vector4_IsNormal3(const FVector4& A);
    bool Vector4_IsNearlyZero3(const FVector4& A, float Tolerance);
    bool Vector4_IsNAN(const FVector4& A);
    double Vector4_DotProduct3(const FVector4& A, const FVector4& B);
    double Vector4_DotProduct(const FVector4& A, const FVector4& B);
    FVector4 Vector4_CrossProduct3(const FVector4& A, const FVector4& B);
    void Vector4_Assign(FVector4& A, const FVector4& InVector);
    FVector2D Vector2DInterpTo_Constant(FVector2D Current, FVector2D Target, float DeltaTime, float InterpSpeed);
    FVector2D Vector2DInterpTo(FVector2D Current, FVector2D Target, float DeltaTime, float InterpSpeed);
    FVector2D Vector2D_Zero();
    FVector2D Vector2D_Unit45Deg();
    FVector2D Vector2D_One();
    FVector VEase(FVector A, FVector B, float Alpha, TEnumAsByte<EEasingFunc::Type> EasingFunc, float BlendExp, int32 Steps);
    FDateTime UtcNow();
    FVector4 TransformVector4(const FMatrix& Matrix, const FVector4& Vec4);
    FRotator TransformRotation(const FTransform& T, FRotator Rotation);
    FVector TransformLocation(const FTransform& T, FVector Location);
    FVector TransformDirection(const FTransform& T, FVector Direction);
    float Transform_Determinant(const FTransform& Transform);
    double ToUnixTimestampDouble(const FDateTime& Time);
    int64 ToUnixTimestamp(const FDateTime& Time);
    FVector2D ToSign2D(FVector2D A);
    FVector2D ToRounded2D(FVector2D A);
    FString ToHex_LinearColor(FLinearColor InColor);
    void ToDirectionAndLength2D(FVector2D A, FVector2D& OutDir, double& OutLength);
    FDateTime Today();
    FTransform TLerp(const FTransform& A, const FTransform& B, float Alpha, TEnumAsByte<ELerpInterpolationMode::Type> InterpMode);
    FTransform TInterpTo(const FTransform& Current, const FTransform& Target, float DeltaTime, float InterpSpeed);
    FTimespan TimespanZeroValue();
    float TimespanRatio(FTimespan A, FTimespan B);
    FTimespan TimespanMinValue();
    FTimespan TimespanMaxValue();
    bool TimespanFromString(FString TimespanString, FTimespan& Result);
    FTransform TEase(const FTransform& A, const FTransform& B, float Alpha, TEnumAsByte<EEasingFunc::Type> EasingFunc, float BlendExp, int32 Steps);
    double Tan(double A);
    FVector Subtract_VectorVector(FVector A, FVector B);
    FVector Subtract_VectorInt(FVector A, int32 B);
    FVector Subtract_VectorFloat(FVector A, double B);
    FVector4 Subtract_Vector4Vector4(const FVector4& A, const FVector4& B);
    FVector2D Subtract_Vector2DVector2D(FVector2D A, FVector2D B);
    FVector2D Subtract_Vector2DFloat(FVector2D A, double B);
    FTimespan Subtract_TimespanTimespan(FTimespan A, FTimespan B);
    FQuat Subtract_QuatQuat(const FQuat& A, const FQuat& B);
    FLinearColor Subtract_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    FIntPoint Subtract_IntPointIntPoint(FIntPoint A, FIntPoint B);
    FIntPoint Subtract_IntPointInt(FIntPoint A, int32 B);
    int32 Subtract_IntInt(int32 A, int32 B);
    int64 Subtract_Int64Int64(int64 A, int64 B);
    double Subtract_DoubleDouble(double A, double B);
    FDateTime Subtract_DateTimeTimespan(FDateTime A, FTimespan B);
    FTimespan Subtract_DateTimeDateTime(FDateTime A, FDateTime B);
    uint8 Subtract_ByteByte(uint8 A, uint8 B);
    double Square(double A);
    double Sqrt(double A);
    FVector Spherical2DToUnitCartesian(FVector2D A);
    double Sin(double A);
    int64 SignOfInteger64(int64 A);
    int32 SignOfInteger(int32 A);
    double SignOfFloat(double A);
    void SetVectorSpringStateVelocity(FVectorSpringState& SpringState, FVector Velocity);
    void SetRandomStreamSeed(FRandomStream& Stream, int32 NewSeed);
    void SetQuaternionSpringStateAngularVelocity(FQuaternionSpringState& SpringState, FVector AngularVelocity);
    void SetFloatSpringStateVelocity(FFloatSpringState& SpringState, float Velocity);
    void Set2D(FVector2D& A, double X, double Y);
    FVector SelectVector(FVector A, FVector B, bool bPickA);
    FTransform SelectTransform(const FTransform& A, const FTransform& B, bool bPickA);
    FText SelectText(const FText A, const FText B, bool bPickA);
    FString SelectString(FString A, FString B, bool bPickA);
    FRotator SelectRotator(FRotator A, FRotator B, bool bPickA);
    class UObject* SelectObject(class UObject* A, class UObject* B, bool bSelectA);
    FName SelectName(const FName A, const FName B, bool bPickA);
    int32 SelectInt(int32 A, int32 B, bool bPickA);
    double SelectFloat(double A, double B, bool bPickA);
    FLinearColor SelectColor(FLinearColor A, FLinearColor B, bool bPickA);
    UClass* SelectClass(UClass* A, UClass* B, bool bSelectA);
    void SeedRandomStream(FRandomStream& Stream);
    double SafeDivide(double A, double B);
    int64 Round64(double A);
    int32 Round(double A);
    FRotator RotatorFromAxisAndAngle(FVector Axis, float Angle);
    FVector RotateAngleAxis(FVector InVect, float AngleDeg, FVector Axis);
    FRotator RLerp(FRotator A, FRotator B, float Alpha, bool bShortestPath);
    FRotator RInterpTo_Constant(FRotator Current, FRotator Target, float DeltaTime, float InterpSpeed);
    FRotator RInterpTo(FRotator Current, FRotator Target, float DeltaTime, float InterpSpeed);
    void RGBToHSV_Vector(FLinearColor RGB, FLinearColor& HSV);
    void RGBToHSV(FLinearColor InColor, float& H, float& S, float& V, float& A);
    FLinearColor RGBLinearToHSV(FLinearColor RGB);
    void ResetVectorSpringState(FVectorSpringState& SpringState);
    void ResetRandomStream(const FRandomStream& Stream);
    void ResetQuaternionSpringState(FQuaternionSpringState& SpringState);
    void ResetFloatSpringState(FFloatSpringState& SpringState);
    FRotator REase(FRotator A, FRotator B, float Alpha, bool bShortestPath, TEnumAsByte<EEasingFunc::Type> EasingFunc, float BlendExp, int32 Steps);
    FVector RandomUnitVectorInEllipticalConeInRadiansFromStream(const FRandomStream& Stream, const FVector& ConeDir, float MaxYawInRadians, float MaxPitchInRadians);
    FVector RandomUnitVectorInEllipticalConeInRadians(FVector ConeDir, float MaxYawInRadians, float MaxPitchInRadians);
    FVector RandomUnitVectorInEllipticalConeInDegreesFromStream(const FRandomStream& Stream, const FVector& ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees);
    FVector RandomUnitVectorInEllipticalConeInDegrees(FVector ConeDir, float MaxYawInDegrees, float MaxPitchInDegrees);
    FVector RandomUnitVectorInConeInRadiansFromStream(const FRandomStream& Stream, const FVector& ConeDir, float ConeHalfAngleInRadians);
    FVector RandomUnitVectorInConeInRadians(FVector ConeDir, float ConeHalfAngleInRadians);
    FVector RandomUnitVectorInConeInDegreesFromStream(const FRandomStream& Stream, const FVector& ConeDir, float ConeHalfAngleInDegrees);
    FVector RandomUnitVectorInConeInDegrees(FVector ConeDir, float ConeHalfAngleInDegrees);
    FVector RandomUnitVectorFromStream(const FRandomStream& Stream);
    FVector RandomUnitVector();
    FRotator RandomRotatorFromStream(const FRandomStream& Stream, bool bRoll);
    FRotator RandomRotator(bool bRoll);
    FVector RandomPointInBoundingBoxFromStream_Box(const FRandomStream& Stream, const FBox Box);
    FVector RandomPointInBoundingBoxFromStream(const FRandomStream& Stream, const FVector Center, const FVector HalfSize);
    FVector RandomPointInBoundingBox_Box(const FBox Box);
    FVector RandomPointInBoundingBox(const FVector Center, const FVector HalfSize);
    int32 RandomIntegerInRangeFromStream(const FRandomStream& Stream, int32 Min, int32 Max);
    int32 RandomIntegerInRange(int32 Min, int32 Max);
    int32 RandomIntegerFromStream(const FRandomStream& Stream, int32 Max);
    int64 RandomInteger64InRange(int64 Min, int64 Max);
    int64 RandomInteger64(int64 Max);
    int32 RandomInteger(int32 Max);
    float RandomFloatInRangeFromStream(const FRandomStream& Stream, float Min, float Max);
    double RandomFloatInRange(double Min, double Max);
    float RandomFloatFromStream(const FRandomStream& Stream);
    double RandomFloat();
    bool RandomBoolWithWeightFromStream(const FRandomStream& RandomStream, float Weight);
    bool RandomBoolWithWeight(float Weight);
    bool RandomBoolFromStream(const FRandomStream& Stream);
    bool RandomBool();
    double RadiansToDegrees(double A);
    FQuat QuaternionSpringInterp(FQuat Current, FQuat Target, FQuaternionSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass, float TargetVelocityAmount, bool bInitializeFromTarget);
    FVector Quat_VectorUp(const FQuat& Q);
    FVector Quat_VectorRight(const FQuat& Q);
    FVector Quat_VectorForward(const FQuat& Q);
    FVector Quat_UnrotateVector(const FQuat& Q, const FVector& V);
    FQuat Quat_Slerp(const FQuat& A, const FQuat& B, double Alpha);
    float Quat_SizeSquared(const FQuat& Q);
    float Quat_Size(const FQuat& Q);
    void Quat_SetFromEuler(FQuat& Q, const FVector& Euler);
    void Quat_SetComponents(FQuat& Q, float X, float Y, float Z, float W);
    FRotator Quat_Rotator(const FQuat& Q);
    FVector Quat_RotateVector(const FQuat& Q, const FVector& V);
    FQuat Quat_Normalized(const FQuat& Q, float Tolerance);
    void Quat_Normalize(FQuat& Q, float Tolerance);
    FQuat Quat_MakeFromEuler(const FVector& Euler);
    FQuat Quat_Log(const FQuat& Q);
    bool Quat_IsNormalized(const FQuat& Q);
    bool Quat_IsNonFinite(const FQuat& Q);
    bool Quat_IsIdentity(const FQuat& Q, float Tolerance);
    bool Quat_IsFinite(const FQuat& Q);
    FQuat Quat_Inversed(const FQuat& Q);
    FQuat Quat_Identity();
    FVector Quat_GetRotationAxis(const FQuat& Q);
    FVector Quat_GetAxisZ(const FQuat& Q);
    FVector Quat_GetAxisY(const FQuat& Q);
    FVector Quat_GetAxisX(const FQuat& Q);
    float Quat_GetAngle(const FQuat& Q);
    FQuat Quat_FindBetweenVectors(FVector Start, FVector End);
    FQuat Quat_FindBetweenNormals(FVector StartNormal, FVector EndNormal);
    FQuat Quat_Exp(const FQuat& Q);
    FVector Quat_Euler(const FQuat& Q);
    void Quat_EnforceShortestArcWith(FQuat& A, const FQuat& B);
    float Quat_AngularDistance(const FQuat& A, const FQuat& B);
    FVector ProjectVectorOnToVector(FVector V, FVector Target);
    FVector ProjectVectorOnToPlane(FVector V, FVector PlaneNormal);
    FVector ProjectPointOnToPlane(FVector Point, FVector PlaneBase, FVector PlaneNormal);
    bool PointsAreCoplanar(const TArray<FVector>& Points, float Tolerance);
    float PerlinNoise1D(const float Value);
    int32 Percent_IntInt(int32 A, int32 B);
    int64 Percent_Int64Int64(int64 A, int64 B);
    double Percent_FloatFloat(double A, double B);
    uint8 Percent_ByteByte(uint8 A, uint8 B);
    int32 Or_IntInt(int32 A, int32 B);
    int64 Or_Int64Int64(int64 A, int64 B);
    FDateTime Now();
    bool NotEqualExactly_VectorVector(FVector A, FVector B);
    bool NotEqualExactly_Vector4Vector4(const FVector4& A, const FVector4& B);
    bool NotEqualExactly_Vector2DVector2D(FVector2D A, FVector2D B);
    bool NotEqual_VectorVector(FVector A, FVector B, float ErrorTolerance);
    bool NotEqual_Vector4Vector4(const FVector4& A, const FVector4& B, float ErrorTolerance);
    bool NotEqual_Vector2DVector2D(FVector2D A, FVector2D B, float ErrorTolerance);
    bool NotEqual_TimespanTimespan(FTimespan A, FTimespan B);
    bool NotEqual_RotatorRotator(FRotator A, FRotator B, float ErrorTolerance);
    bool NotEqual_QuatQuat(const FQuat& A, const FQuat& B, float ErrorTolerance);
    bool NotEqual_ObjectObject(class UObject* A, class UObject* B);
    bool NotEqual_NameName(FName A, FName B);
    bool NotEqual_MatrixMatrix(const FMatrix& A, const FMatrix& B, float Tolerance);
    bool NotEqual_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    bool NotEqual_IntPointIntPoint(FIntPoint A, FIntPoint B);
    bool NotEqual_IntInt(int32 A, int32 B);
    bool NotEqual_Int64Int64(int64 A, int64 B);
    bool NotEqual_DoubleDouble(double A, double B);
    bool NotEqual_DateTimeDateTime(FDateTime A, FDateTime B);
    bool NotEqual_ClassClass(UClass* A, UClass* B);
    bool NotEqual_ByteByte(uint8 A, uint8 B);
    bool NotEqual_BoolBool(bool A, bool B);
    bool Not_PreBool(bool A);
    int64 Not_Int64(int64 A);
    int32 Not_Int(int32 A);
    FVector2D NormalSafe2D(FVector2D A, float Tolerance);
    double NormalizeToRange(double Value, double RangeMin, double RangeMax);
    FRotator NormalizedDeltaRotator(FRotator A, FRotator B);
    float NormalizeAxis(float Angle);
    void Normalize2D(FVector2D& A, float Tolerance);
    FVector2D Normal2D(FVector2D A);
    FVector Normal(FVector A, float Tolerance);
    FVector NegateVector(FVector A);
    FRotator NegateRotator(FRotator A);
    FVector2D Negated2D(const FVector2D& A);
    bool NearlyEqual_TransformTransform(const FTransform& A, const FTransform& B, float LocationTolerance, float RotationTolerance, float Scale3DTolerance);
    bool NearlyEqual_FloatFloat(double A, double B, double ErrorTolerance);
    double MultiplyMultiply_FloatFloat(double base, double Exp);
    double MultiplyByPi(double Value);
    FVector Multiply_VectorVector(FVector A, FVector B);
    FVector Multiply_VectorInt(FVector A, int32 B);
    FVector Multiply_VectorFloat(FVector A, double B);
    FVector4 Multiply_Vector4Vector4(const FVector4& A, const FVector4& B);
    FVector2D Multiply_Vector2DVector2D(FVector2D A, FVector2D B);
    FVector2D Multiply_Vector2DFloat(FVector2D A, double B);
    FTimespan Multiply_TimespanFloat(FTimespan A, float Scalar);
    FRotator Multiply_RotatorInt(FRotator A, int32 B);
    FRotator Multiply_RotatorFloat(FRotator A, float B);
    FQuat Multiply_QuatQuat(const FQuat& A, const FQuat& B);
    FMatrix Multiply_MatrixMatrix(const FMatrix& A, const FMatrix& B);
    FMatrix Multiply_MatrixFloat(const FMatrix& A, double B);
    FLinearColor Multiply_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    FLinearColor Multiply_LinearColorFloat(FLinearColor A, float B);
    FIntPoint Multiply_IntPointIntPoint(FIntPoint A, FIntPoint B);
    FIntPoint Multiply_IntPointInt(FIntPoint A, int32 B);
    int32 Multiply_IntInt(int32 A, int32 B);
    double Multiply_IntFloat(int32 A, double B);
    int64 Multiply_Int64Int64(int64 A, int64 B);
    double Multiply_DoubleDouble(double A, double B);
    uint8 Multiply_ByteByte(uint8 A, uint8 B);
    FVector MirrorVectorByNormal(FVector InVect, FVector InNormal);
    void MinOfIntArray(const TArray<int32>& IntArray, int32& IndexOfMinValue, int32& MinValue);
    void MinOfFloatArray(const TArray<float>& FloatArray, int32& IndexOfMinValue, float& MinValue);
    void MinOfByteArray(const TArray<uint8>& ByteArray, int32& IndexOfMinValue, uint8& MinValue);
    int64 MinInt64(int64 A, int64 B);
    void MinimumAreaRectangle(class UObject* WorldContextObject, const TArray<FVector>& InVerts, const FVector& SampleSurfaceNormal, FVector& OutRectCenter, FRotator& OutRectRotation, float& OutSideLengthX, float& OutSideLengthY, bool bDebugDraw);
    void MinAreaRectangle(class UObject* WorldContextObject, const TArray<FVector>& InPoints, const FVector& SampleSurfaceNormal, FVector& OutRectCenter, FRotator& OutRectRotation, float& OutRectLengthX, float& OutRectLengthY, bool bDebugDraw);
    int32 Min(int32 A, int32 B);
    void MedianOfIntArray(TArray<int32> IntArray, float& MedianValue);
    void MaxOfIntArray(const TArray<int32>& IntArray, int32& IndexOfMaxValue, int32& MaxValue);
    void MaxOfFloatArray(const TArray<float>& FloatArray, int32& IndexOfMaxValue, float& MaxValue);
    void MaxOfByteArray(const TArray<uint8>& ByteArray, int32& IndexOfMaxValue, uint8& MaxValue);
    int64 MaxInt64(int64 A, int64 B);
    int32 Max(int32 A, int32 B);
    FVector4 Matrix_TransformVector4(const FMatrix& M, FVector4 V);
    FVector4 Matrix_TransformVector(const FMatrix& M, FVector V);
    FVector4 Matrix_TransformPosition(const FMatrix& M, FVector V);
    FQuat Matrix_ToQuat(const FMatrix& M);
    void Matrix_SetOrigin(FMatrix& M, FVector NewOrigin);
    void Matrix_SetColumn(FMatrix& M, TEnumAsByte<EMatrixColumns::Type> column, FVector Value);
    void Matrix_SetAxis(FMatrix& M, TEnumAsByte<EAxis::Type> Axis, FVector AxisVector);
    FMatrix Matrix_ScaleTranslation(const FMatrix& M, FVector Scale3D);
    FMatrix Matrix_RemoveTranslation(const FMatrix& M);
    void Matrix_RemoveScaling(FMatrix& M, float Tolerance);
    FMatrix Matrix_Mirror(const FMatrix& M, TEnumAsByte<EAxis::Type> MirrorAxis, TEnumAsByte<EAxis::Type> FlipAxis);
    FVector Matrix_InverseTransformVector(const FMatrix& M, FVector V);
    FVector Matrix_InverseTransformPosition(const FMatrix& M, FVector V);
    FMatrix Matrix_Identity();
    FVector Matrix_GetUnitAxis(const FMatrix& M, TEnumAsByte<EAxis::Type> Axis);
    void Matrix_GetUnitAxes(const FMatrix& M, FVector& X, FVector& Y, FVector& Z);
    FMatrix Matrix_GetTransposed(const FMatrix& M);
    FMatrix Matrix_GetTransposeAdjoint(const FMatrix& M);
    FVector Matrix_GetScaleVector(const FMatrix& M, float Tolerance);
    FVector Matrix_GetScaledAxis(const FMatrix& M, TEnumAsByte<EAxis::Type> Axis);
    void Matrix_GetScaledAxes(const FMatrix& M, FVector& X, FVector& Y, FVector& Z);
    float Matrix_GetRotDeterminant(const FMatrix& M);
    FRotator Matrix_GetRotator(const FMatrix& M);
    FVector Matrix_GetOrigin(const FMatrix& InMatrix);
    float Matrix_GetMaximumAxisScale(const FMatrix& M);
    FMatrix Matrix_GetMatrixWithoutScale(const FMatrix& M, float Tolerance);
    FMatrix Matrix_GetInverse(const FMatrix& M);
    bool Matrix_GetFrustumTopPlane(const FMatrix& M, FPlane& OutPlane);
    bool Matrix_GetFrustumRightPlane(const FMatrix& M, FPlane& OutPlane);
    bool Matrix_GetFrustumNearPlane(const FMatrix& M, FPlane& OutPlane);
    bool Matrix_GetFrustumLeftPlane(const FMatrix& M, FPlane& OutPlane);
    bool Matrix_GetFrustumFarPlane(const FMatrix& M, FPlane& OutPlane);
    bool Matrix_GetFrustumBottomPlane(const FMatrix& M, FPlane& OutPlane);
    float Matrix_GetDeterminant(const FMatrix& M);
    FVector Matrix_GetColumn(const FMatrix& M, TEnumAsByte<EMatrixColumns::Type> column);
    bool Matrix_ContainsNaN(const FMatrix& M);
    FMatrix Matrix_ConcatenateTranslation(const FMatrix& M, FVector Translation);
    FMatrix Matrix_ApplyScale(const FMatrix& M, float Scale);
    double MapRangeUnclamped(double Value, double InRangeA, double InRangeB, double OutRangeA, double OutRangeB);
    double MapRangeClamped(double Value, double InRangeA, double InRangeB, double OutRangeA, double OutRangeB);
    FVector_NetQuantizeNormal MakeVector_NetQuantizeNormal(double X, double Y, double Z);
    FVector_NetQuantize100 MakeVector_NetQuantize100(double X, double Y, double Z);
    FVector_NetQuantize10 MakeVector_NetQuantize10(double X, double Y, double Z);
    FVector_NetQuantize MakeVector_NetQuantize(double X, double Y, double Z);
    FVector4 MakeVector4(double X, double Y, double Z, double W);
    FVector2D MakeVector2D(double X, double Y);
    FVector MakeVector(double X, double Y, double Z);
    FTransform MakeTransform(FVector Location, FRotator Rotation, FVector Scale);
    FTimespan MakeTimespan2(int32 Days, int32 Hours, int32 Minutes, int32 Seconds, int32 FractionNano);
    FTimespan MakeTimespan(int32 Days, int32 Hours, int32 Minutes, int32 Seconds, int32 Milliseconds);
    FRotator MakeRotFromZY(const FVector& Z, const FVector& Y);
    FRotator MakeRotFromZX(const FVector& Z, const FVector& X);
    FRotator MakeRotFromZ(const FVector& Z);
    FRotator MakeRotFromYZ(const FVector& Y, const FVector& Z);
    FRotator MakeRotFromYX(const FVector& Y, const FVector& X);
    FRotator MakeRotFromY(const FVector& Y);
    FRotator MakeRotFromXZ(const FVector& X, const FVector& Z);
    FRotator MakeRotFromXY(const FVector& X, const FVector& Y);
    FRotator MakeRotFromX(const FVector& X);
    FRotator MakeRotator(float roll, float Pitch, float Yaw);
    FRotator MakeRotationFromAxes(FVector Forward, FVector Right, FVector Up);
    FTransform MakeRelativeTransform(const FTransform& A, const FTransform& RelativeTo);
    FRandomStream MakeRandomStream(int32 InitialSeed);
    FQuat MakeQuat(float X, float Y, float Z, float W);
    FQualifiedFrameTime MakeQualifiedFrameTime(FFrameNumber Frame, FFrameRate FrameRate, float SubFrame);
    float MakePulsatingValue(float InCurrentTime, float InPulsesPerSecond, float InPhase);
    FPlane MakePlaneFromPointAndNormal(FVector Point, FVector Normal);
    FFrameRate MakeFrameRate(int32 Numerator, int32 Denominator);
    FDateTime MakeDateTime(int32 Year, int32 month, int32 day, int32 Hour, int32 Minute, int32 Second, int32 Millisecond);
    FLinearColor MakeColor(float R, float G, float B, float A);
    FBox MakeBoxWithOrigin(const FVector& Origin, const FVector& Extent);
    FBoxSphereBounds MakeBoxSphereBounds(FVector Origin, FVector BoxExtent, float SphereRadius);
    FBox2D MakeBox2D(FVector2D Min, FVector2D Max);
    FBox MakeBox(FVector Min, FVector Max);
    double Loge(double A);
    double Log(double A, double base);
    bool LinePlaneIntersection_OriginNormal(const FVector& LineStart, const FVector& LineEnd, FVector PlaneOrigin, FVector PlaneNormal, float& T, FVector& Intersection);
    bool LinePlaneIntersection(const FVector& LineStart, const FVector& LineEnd, const FPlane& APlane, float& T, FVector& Intersection);
    FLinearColor LinearColorLerpUsingHSV(FLinearColor A, FLinearColor B, float Alpha);
    FLinearColor LinearColorLerp(FLinearColor A, FLinearColor B, float Alpha);
    FLinearColor LinearColor_Yellow();
    FLinearColor LinearColor_White();
    FLinearColor LinearColor_Transparent();
    FColor LinearColor_ToRGBE(FLinearColor InLinearColor);
    FLinearColor LinearColor_ToNewOpacity(FLinearColor InColor, float InOpacity);
    void LinearColor_SetTemperature(FLinearColor& InOutColor, float InTemperature);
    void LinearColor_SetRGBA(FLinearColor& InOutColor, float R, float G, float B, float A);
    void LinearColor_SetRandomHue(FLinearColor& InOutColor);
    void LinearColor_SetFromSRGB(FLinearColor& InOutColor, const FColor& InSRGB);
    void LinearColor_SetFromPow22(FLinearColor& InOutColor, const FColor& InColor);
    void LinearColor_SetFromHSV(FLinearColor& InOutColor, float H, float S, float V, float A);
    void LinearColor_Set(FLinearColor& InOutColor, FLinearColor InColor);
    FLinearColor LinearColor_Red();
    FColor LinearColor_QuantizeRound(FLinearColor InColor);
    FColor LinearColor_Quantize(FLinearColor InColor);
    bool LinearColor_IsNearEqual(FLinearColor A, FLinearColor B, float Tolerance);
    FLinearColor LinearColor_Green();
    FLinearColor LinearColor_Gray();
    float LinearColor_GetMin(FLinearColor InColor);
    float LinearColor_GetMax(FLinearColor InColor);
    float LinearColor_GetLuminance(FLinearColor InColor);
    float LinearColor_Distance(FLinearColor C1, FLinearColor C2);
    FLinearColor LinearColor_Desaturated(FLinearColor InColor, float InDesaturation);
    FLinearColor LinearColor_Blue();
    FLinearColor LinearColor_Black();
    FVector LessLess_VectorRotator(FVector A, FRotator B);
    bool LessEqual_TimespanTimespan(FTimespan A, FTimespan B);
    bool LessEqual_IntInt(int32 A, int32 B);
    bool LessEqual_Int64Int64(int64 A, int64 B);
    bool LessEqual_DoubleDouble(double A, double B);
    bool LessEqual_DateTimeDateTime(FDateTime A, FDateTime B);
    bool LessEqual_ByteByte(uint8 A, uint8 B);
    bool Less_TimespanTimespan(FTimespan A, FTimespan B);
    bool Less_IntInt(int32 A, int32 B);
    bool Less_Int64Int64(int64 A, int64 B);
    bool Less_DoubleDouble(double A, double B);
    bool Less_DateTimeDateTime(FDateTime A, FDateTime B);
    bool Less_ByteByte(uint8 A, uint8 B);
    double Lerp(double A, double B, double Alpha);
    bool IsZero2D(const FVector2D& A);
    bool IsPointInBoxWithTransform_Box(FVector Point, const FTransform& BoxWorldTransform, FBox BoxExtent);
    bool IsPointInBoxWithTransform(FVector Point, const FTransform& BoxWorldTransform, FVector BoxExtent);
    bool IsPointInBox_Box(FVector Point, FBox Box);
    bool IsPointInBox(FVector Point, FVector BoxOrigin, FVector BoxExtent);
    bool IsNearlyZero2D(const FVector2D& A, float Tolerance);
    bool IsMorning(FDateTime A);
    bool IsLeapYear(int32 Year);
    bool IsAfternoon(FDateTime A);
    FTransform InvertTransform(const FTransform& T);
    FRotator InverseTransformRotation(const FTransform& T, FRotator Rotation);
    FVector InverseTransformLocation(const FTransform& T, FVector Location);
    FVector InverseTransformDirection(const FTransform& T, FVector Direction);
    FIntPoint IntPoint_Zero();
    FIntPoint IntPoint_Up();
    FIntPoint IntPoint_Right();
    FIntPoint IntPoint_One();
    FIntPoint IntPoint_Left();
    FIntPoint IntPoint_Down();
    bool InRange_IntInt(int32 Value, int32 Min, int32 Max, bool InclusiveMin, bool InclusiveMax);
    bool InRange_Int64Int64(int64 Value, int64 Min, int64 Max, bool InclusiveMin, bool InclusiveMax);
    bool InRange_FloatFloat(double Value, double Min, double Max, bool InclusiveMin, bool InclusiveMax);
    double Hypotenuse(double Width, double Height);
    FLinearColor HSVToRGBLinear(FLinearColor HSV);
    void HSVToRGB_Vector(FLinearColor HSV, FLinearColor& RGB);
    FLinearColor HSVToRGB(float H, float S, float V, float A);
    double GridSnap_Float(double Location, double GridSize);
    FVector GreaterGreater_VectorRotator(FVector A, FRotator B);
    bool GreaterEqual_TimespanTimespan(FTimespan A, FTimespan B);
    bool GreaterEqual_IntInt(int32 A, int32 B);
    bool GreaterEqual_Int64Int64(int64 A, int64 B);
    bool GreaterEqual_DoubleDouble(double A, double B);
    bool GreaterEqual_DateTimeDateTime(FDateTime A, FDateTime B);
    bool GreaterEqual_ByteByte(uint8 A, uint8 B);
    bool Greater_TimespanTimespan(FTimespan A, FTimespan B);
    bool Greater_IntInt(int32 A, int32 B);
    bool Greater_Int64Int64(int64 A, int64 B);
    bool Greater_DoubleDouble(double A, double B);
    bool Greater_DateTimeDateTime(FDateTime A, FDateTime B);
    bool Greater_ByteByte(uint8 A, uint8 B);
    int32 GetYear(FDateTime A);
    void GetYawPitchFromVector(FVector InVec, float& Yaw, float& Pitch);
    FVector GetVectorArrayAverage(const TArray<FVector>& Vectors);
    FVector GetUpVector(FRotator InRot);
    float GetTotalSeconds(FTimespan A);
    float GetTotalMinutes(FTimespan A);
    float GetTotalMilliseconds(FTimespan A);
    float GetTotalHours(FTimespan A);
    float GetTotalDays(FTimespan A);
    FTimespan GetTimeOfDay(FDateTime A);
    double GetTAU();
    void GetSlopeDegreeAngles(const FVector& MyRightYAxis, const FVector& FloorNormal, const FVector& UpVector, float& OutSlopePitchDegreeAngle, float& OutSlopeRollDegreeAngle);
    int32 GetSeconds(FTimespan A);
    int32 GetSecond(FDateTime A);
    float GetRuntimeFloatCurveValue(const FRuntimeFloatCurve& Curve, const float InTime, const float InDefaultValue);
    FVector2D GetRotated2D(FVector2D A, float AngleDeg);
    FVector GetRightVector(FRotator InRot);
    FVector GetReflectionVector(FVector Direction, FVector SurfaceNormal);
    float GetPointDistanceToSegment(FVector Point, FVector SegmentStart, FVector SegmentEnd);
    float GetPointDistanceToLine(FVector Point, FVector LineOrigin, FVector LineDirection);
    double GetPI();
    int32 GetMonth(FDateTime A);
    int32 GetMinutes(FTimespan A);
    int32 GetMinute(FDateTime A);
    double GetMinElement(FVector A);
    double GetMin2D(FVector2D A);
    int32 GetMilliseconds(FTimespan A);
    int32 GetMillisecond(FDateTime A);
    double GetMaxElement(FVector A);
    double GetMax2D(FVector2D A);
    int32 GetHours(FTimespan A);
    int32 GetHour12(FDateTime A);
    int32 GetHour(FDateTime A);
    FVector GetForwardVector(FRotator InRot);
    FTimespan GetDuration(FTimespan A);
    FVector GetDirectionUnitVector(FVector from, FVector To);
    int32 GetDays(FTimespan A);
    int32 GetDayOfYear(FDateTime A);
    int32 GetDay(FDateTime A);
    FDateTime GetDate(FDateTime A);
    double GetBoxVolume(const FBox& InBox);
    FVector GetBoxSize(const FBox& InBox);
    FVector GetBoxCenter(const FBox& InBox);
    void GetAzimuthAndElevation(FVector InDirection, const FTransform& ReferenceFrame, float& Azimuth, float& Elevation);
    void GetAxes(FRotator A, FVector& X, FVector& Y, FVector& Z);
    double GetAbsMax2D(FVector2D A);
    FVector2D GetAbs2D(FVector2D A);
    double FWrap(double Value, double Min, double Max);
    FIntVector FTruncVector(const FVector& InVector);
    int64 FTrunc64(double A);
    int32 FTrunc(double A);
    FDateTime FromUnixTimestamp(const int64 UnixTime);
    FTimespan FromSeconds(float Seconds);
    FTimespan FromMinutes(float Minutes);
    FTimespan FromMilliseconds(float Milliseconds);
    FTimespan FromHours(float Hours);
    FTimespan FromDays(float Days);
    double Fraction(double A);
    int64 FMod64(double Dividend, double Divisor, double& Remainder);
    int32 FMod(double Dividend, double Divisor, double& Remainder);
    double FMin(double A, double B);
    double FMax(double A, double B);
    float FloatSpringInterp(float Current, float Target, FFloatSpringState& SpringState, float Stiffness, float CriticalDampingFactor, float DeltaTime, float Mass, float TargetVelocityAmount, bool bClamp, float MinValue, float MaxValue, bool bInitializeFromTarget);
    float FixedTurn(float InCurrent, float InDesired, float InDeltaRate);
    double FInterpTo_Constant(double Current, double Target, double DeltaTime, double InterpSpeed);
    double FInterpTo(double Current, double Target, double DeltaTime, double InterpSpeed);
    double FInterpEaseInOut(double A, double B, double Alpha, double Exponent);
    FRotator FindRelativeLookAtRotation(const FTransform& StartTransform, const FVector& TargetLocation);
    void FindNearestPointsOnLineSegments(FVector Segment1Start, FVector Segment1End, FVector Segment2Start, FVector Segment2End, FVector& Segment1Point, FVector& Segment2Point);
    FRotator FindLookAtRotation(const FVector& Start, const FVector& Target);
    FVector FindClosestPointOnSegment(FVector Point, FVector SegmentStart, FVector SegmentEnd);
    FVector FindClosestPointOnLine(FVector Point, FVector LineOrigin, FVector LineDirection);
    int64 FFloor64(double A);
    int32 FFloor(double A);
    double FClamp(double Value, double Min, double Max);
    int64 FCeil64(double A);
    int32 FCeil(double A);
    double Exp(double A);
    bool EqualExactly_VectorVector(FVector A, FVector B);
    bool EqualExactly_Vector4Vector4(const FVector4& A, const FVector4& B);
    bool EqualExactly_Vector2DVector2D(FVector2D A, FVector2D B);
    bool EqualEqual_VectorVector(FVector A, FVector B, float ErrorTolerance);
    bool EqualEqual_Vector4Vector4(const FVector4& A, const FVector4& B, float ErrorTolerance);
    bool EqualEqual_Vector2DVector2D(FVector2D A, FVector2D B, float ErrorTolerance);
    bool EqualEqual_TransformTransform(const FTransform& A, const FTransform& B);
    bool EqualEqual_TimespanTimespan(FTimespan A, FTimespan B);
    bool EqualEqual_RotatorRotator(FRotator A, FRotator B, float ErrorTolerance);
    bool EqualEqual_QuatQuat(const FQuat& A, const FQuat& B, float Tolerance);
    bool EqualEqual_ObjectObject(class UObject* A, class UObject* B);
    bool EqualEqual_NameName(FName A, FName B);
    bool EqualEqual_MatrixMatrix(const FMatrix& A, const FMatrix& B, float Tolerance);
    bool EqualEqual_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    bool EqualEqual_IntInt(int32 A, int32 B);
    bool EqualEqual_Int64Int64(int64 A, int64 B);
    bool EqualEqual_DoubleDouble(double A, double B);
    bool EqualEqual_DateTimeDateTime(FDateTime A, FDateTime B);
    bool EqualEqual_ClassClass(UClass* A, UClass* B);
    bool EqualEqual_ByteByte(uint8 A, uint8 B);
    bool EqualEqual_BoolBool(bool A, bool B);
    bool Equal_IntPointIntPoint(FIntPoint A, FIntPoint B);
    double Ease(double A, double B, double Alpha, TEnumAsByte<EEasingFunc::Type> EasingFunc, double BlendExp, int32 Steps);
    FVector DynamicWeightedMovingAverage_FVector(FVector CurrentSample, FVector PreviousSample, float MaxDistance, float MinWeight, float MaxWeight);
    FRotator DynamicWeightedMovingAverage_FRotator(FRotator CurrentSample, FRotator PreviousSample, float MaxDistance, float MinWeight, float MaxWeight);
    float DynamicWeightedMovingAverage_Float(float CurrentSample, float PreviousSample, float MaxDistance, float MinWeight, float MaxWeight);
    double DotProduct2D(FVector2D A, FVector2D B);
    double Dot_VectorVector(FVector A, FVector B);
    FVector Divide_VectorVector(FVector A, FVector B);
    FVector Divide_VectorInt(FVector A, int32 B);
    FVector Divide_VectorFloat(FVector A, double B);
    FVector4 Divide_Vector4Vector4(const FVector4& A, const FVector4& B);
    FVector2D Divide_Vector2DVector2D(FVector2D A, FVector2D B);
    FVector2D Divide_Vector2DFloat(FVector2D A, double B);
    FTimespan Divide_TimespanFloat(FTimespan A, float Scalar);
    FLinearColor Divide_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    FIntPoint Divide_IntPointIntPoint(FIntPoint A, FIntPoint B);
    FIntPoint Divide_IntPointInt(FIntPoint A, int32 B);
    int32 Divide_IntInt(int32 A, int32 B);
    int64 Divide_Int64Int64(int64 A, int64 B);
    double Divide_DoubleDouble(double A, double B);
    uint8 Divide_ByteByte(uint8 A, uint8 B);
    double DistanceSquared2D(FVector2D v1, FVector2D v2);
    double Distance2D(FVector2D v1, FVector2D v2);
    double DegTan(double A);
    double DegSin(double A);
    double DegreesToRadians(double A);
    double DegCos(double A);
    double DegAtan2(double Y, double X);
    double DegAtan(double A);
    double DegAsin(double A);
    double DegAcos(double A);
    int32 DaysInYear(int32 Year);
    int32 DaysInMonth(int32 Year, int32 month);
    FDateTime DateTimeMinValue();
    FDateTime DateTimeMaxValue();
    bool DateTimeFromString(FString DateTimeString, FDateTime& Result);
    bool DateTimeFromIsoString(FString IsoString, FDateTime& Result);
    double CrossProduct2D(FVector2D A, FVector2D B);
    FVector Cross_VectorVector(FVector A, FVector B);
    FVector CreateVectorFromYawPitch(float Yaw, float Pitch, float Length);
    double Cos(double A);
    int32 Convert3DTo1D(const FIntVector& Index3D, int32 XSize, int32 YSize);
    int32 Convert2DTo1D(const FIntPoint& Index2D, int32 XSize);
    FIntVector Convert1DTo3D(int32 Index1D, int32 XSize, int32 YSize);
    FIntPoint Convert1DTo2D(int32 Index1D, int32 XSize);
    FVector2D Conv_VectorToVector2D(FVector InVector);
    FTransform Conv_VectorToTransform(FVector InLocation);
    FRotator Conv_VectorToRotator(FVector InVec);
    FQuat Conv_VectorToQuaternion(FVector InVec);
    FLinearColor Conv_VectorToLinearColor(FVector InVec);
    FVector Conv_Vector4ToVector(const FVector4& InVector4);
    FRotator Conv_Vector4ToRotator(const FVector4& InVec);
    FQuat Conv_Vector4ToQuaternion(const FVector4& InVec);
    FVector Conv_Vector2DToVector(FVector2D InVector2D, float Z);
    FIntPoint Conv_Vector2DToIntPoint(FVector2D InVector2D);
    FMatrix Conv_TransformToMatrix(const FTransform& Transform);
    FVector Conv_RotatorToVector(FRotator InRot);
    FTransform Conv_RotatorToTransform(const FRotator& InRotator);
    FQuat Conv_RotatorToQuaternion(FRotator InRot);
    FTransform Conv_MatrixToTransform(const FMatrix& InMatrix);
    FRotator Conv_MatrixToRotator(const FMatrix& InMatrix);
    FVector Conv_LinearColorToVector(FLinearColor InLinearColor);
    FColor Conv_LinearColorToColor(FLinearColor InLinearColor, bool InUseSRGB);
    FVector Conv_IntVectorToVector(const FIntVector& InIntVector);
    FVector Conv_IntToVector(int32 inInt);
    FIntVector Conv_IntToIntVector(int32 inInt);
    int64 Conv_IntToInt64(int32 inInt);
    double Conv_IntToDouble(int32 inInt);
    uint8 Conv_IntToByte(int32 inInt);
    bool Conv_IntToBool(int32 inInt);
    FVector2D Conv_IntPointToVector2D(FIntPoint InIntPoint);
    int32 Conv_Int64ToInt(int64 inInt);
    double Conv_Int64ToDouble(int64 inInt);
    uint8 Conv_Int64ToByte(int64 inInt);
    double Conv_FloatToDouble(float InFloat);
    FVector2D Conv_DoubleToVector2D(double InDouble);
    FVector Conv_DoubleToVector(double InDouble);
    FLinearColor Conv_DoubleToLinearColor(double InDouble);
    int64 Conv_DoubleToInt64(double InDouble);
    float Conv_DoubleToFloat(double InDouble);
    FLinearColor Conv_ColorToLinearColor(FColor InColor);
    int64 Conv_ByteToInt64(uint8 InByte);
    int32 Conv_ByteToInt(uint8 InByte);
    double Conv_ByteToDouble(uint8 InByte);
    int32 Conv_BoolToInt(bool InBool);
    double Conv_BoolToDouble(bool InBool);
    uint8 Conv_BoolToByte(bool InBool);
    FTransform ComposeTransforms(const FTransform& A, const FTransform& B);
    FRotator ComposeRotators(FRotator A, FRotator B);
    bool ClassIsChildOf(UClass* TestClass, UClass* ParentClass);
    FVector ClampVectorSize(FVector A, double Min, double Max);
    int64 ClampInt64(int64 Value, int64 Min, int64 Max);
    float ClampAxis(float Angle);
    FVector2D ClampAxes2D(FVector2D A, double MinAxisVal, double MaxAxisVal);
    double ClampAngle(double AngleDegrees, double MinAngleDegrees, double MaxAngleDegrees);
    int32 Clamp(int32 Value, int32 Min, int32 Max);
    FLinearColor CInterpTo(FLinearColor Current, FLinearColor Target, float DeltaTime, float InterpSpeed);
    void BreakVector_NetQuantizeNormal(FVector_NetQuantizeNormal InVec, double& X, double& Y, double& Z);
    void BreakVector_NetQuantize100(FVector_NetQuantize100 InVec, double& X, double& Y, double& Z);
    void BreakVector_NetQuantize10(FVector_NetQuantize10 InVec, double& X, double& Y, double& Z);
    void BreakVector_NetQuantize(FVector_NetQuantize InVec, double& X, double& Y, double& Z);
    void BreakVector4(const FVector4& InVec, double& X, double& Y, double& Z, double& W);
    void BreakVector2D(FVector2D InVec, double& X, double& Y);
    void BreakVector(FVector InVec, double& X, double& Y, double& Z);
    void BreakTransform(const FTransform& InTransform, FVector& Location, FRotator& Rotation, FVector& Scale);
    void BreakTimespan2(FTimespan InTimespan, int32& Days, int32& Hours, int32& Minutes, int32& Seconds, int32& FractionNano);
    void BreakTimespan(FTimespan InTimespan, int32& Days, int32& Hours, int32& Minutes, int32& Seconds, int32& Milliseconds);
    void BreakRotIntoAxes(const FRotator& InRot, FVector& X, FVector& Y, FVector& Z);
    void BreakRotator(FRotator InRot, float& roll, float& Pitch, float& Yaw);
    void BreakRandomStream(const FRandomStream& InRandomStream, int32& InitialSeed);
    void BreakQuat(const FQuat& InQuat, float& X, float& Y, float& Z, float& W);
    void BreakQualifiedFrameTime(const FQualifiedFrameTime& InFrameTime, FFrameNumber& Frame, FFrameRate& FrameRate, float& SubFrame);
    void BreakFrameRate(const FFrameRate& InFrameRate, int32& Numerator, int32& Denominator);
    void BreakDateTime(FDateTime InDateTime, int32& Year, int32& month, int32& day, int32& Hour, int32& Minute, int32& Second, int32& Millisecond);
    void BreakColor(FLinearColor InColor, float& R, float& G, float& B, float& A);
    void BreakBoxSphereBounds(const FBoxSphereBounds& InBoxSphereBounds, FVector& Origin, FVector& BoxExtent, float& SphereRadius);
    FBox Box_Overlap(const FBox& A, const FBox& B);
    bool Box_IsPointInside(const FBox& Box, const FVector& Point);
    bool Box_IsInsideOrOn(const FBox& InnerTest, const FBox& OuterTest);
    bool Box_IsInside(const FBox& InnerTest, const FBox& OuterTest);
    bool Box_Intersects(const FBox& A, const FBox& B);
    FVector Box_GetClosestPointTo(const FBox& Box, const FVector& Point);
    FBox Box_ExpandBy(const FBox& Box, const FVector& Negative, const FVector& Positive);
    bool BooleanXOR(bool A, bool B);
    bool BooleanOR(bool A, bool B);
    bool BooleanNOR(bool A, bool B);
    bool BooleanNAND(bool A, bool B);
    bool BooleanAND(bool A, bool B);
    uint8 BMin(uint8 A, uint8 B);
    uint8 BMax(uint8 A, uint8 B);
    void AverageOfIntArray(const TArray<int32>& IntArray, float& AverageValue);
    double Atan2(double Y, double X);
    double Atan(double A);
    double Asin(double A);
    int32 And_IntInt(int32 A, int32 B);
    int64 And_Int64Int64(int64 A, int64 B);
    FVector Add_VectorVector(FVector A, FVector B);
    FVector Add_VectorInt(FVector A, int32 B);
    FVector Add_VectorFloat(FVector A, double B);
    FVector4 Add_Vector4Vector4(const FVector4& A, const FVector4& B);
    FVector2D Add_Vector2DVector2D(FVector2D A, FVector2D B);
    FVector2D Add_Vector2DFloat(FVector2D A, double B);
    FTimespan Add_TimespanTimespan(FTimespan A, FTimespan B);
    FQuat Add_QuatQuat(const FQuat& A, const FQuat& B);
    FMatrix Add_MatrixMatrix(const FMatrix& A, const FMatrix& B);
    FLinearColor Add_LinearColorLinearColor(FLinearColor A, FLinearColor B);
    FIntPoint Add_IntPointIntPoint(FIntPoint A, FIntPoint B);
    FIntPoint Add_IntPointInt(FIntPoint A, int32 B);
    int32 Add_IntInt(int32 A, int32 B);
    int64 Add_Int64Int64(int64 A, int64 B);
    double Add_DoubleDouble(double A, double B);
    FDateTime Add_DateTimeTimespan(FDateTime A, FTimespan B);
    FDateTime Add_DateTimeDateTime(FDateTime A, FDateTime B);
    uint8 Add_ByteByte(uint8 A, uint8 B);
    double Acos(double A);
    int64 Abs_Int64(int64 A);
    int32 Abs_Int(int32 A);
    double Abs(double A);
}; // Size: 0x28

class UKismetNodeHelperLibrary : public UBlueprintFunctionLibrary
{

    void MarkBit(int32& Data, int32 Index);
    bool HasUnmarkedBit(int32 Data, int32 NumBits);
    bool HasMarkedBit(int32 Data, int32 NumBits);
    uint8 GetValidValue(const class UEnum* Enum, uint8 EnumeratorValue);
    int32 GetUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits, bool bRandom);
    int32 GetRandomUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits);
    int32 GetFirstUnmarkedBit(int32 Data, int32 StartIdx, int32 NumBits);
    uint8 GetEnumeratorValueFromIndex(const class UEnum* Enum, uint8 EnumeratorIndex);
    FString GetEnumeratorUserFriendlyName(const class UEnum* Enum, uint8 EnumeratorValue);
    FName GetEnumeratorName(const class UEnum* Enum, uint8 EnumeratorValue);
    void ClearBit(int32& Data, int32 Index);
    void ClearAllBits(int32& Data);
    bool BitIsMarked(int32 Data, int32 Index);
}; // Size: 0x28

class UKismetRenderingLibrary : public UBlueprintFunctionLibrary
{

    void SetCastInsetShadowForAllAttachments(class UPrimitiveComponent* PrimitiveComponent, bool bCastInsetShadow, bool bLightAttachmentsAsGroup);
    void ResizeRenderTarget2D(class UTextureRenderTarget2D* TextureRenderTarget, int32 Width, int32 Height);
    class UVolumeTexture* RenderTargetCreateStaticVolumeTextureEditorOnly(class UTextureRenderTargetVolume* RenderTarget, FString Name, TEnumAsByte<TextureCompressionSettings> CompressionSettings, TEnumAsByte<TextureMipGenSettings> MipSettings);
    class UTextureCube* RenderTargetCreateStaticTextureCubeEditorOnly(class UTextureRenderTargetCube* RenderTarget, FString Name, TEnumAsByte<TextureCompressionSettings> CompressionSettings, TEnumAsByte<TextureMipGenSettings> MipSettings);
    class UTexture2D* RenderTargetCreateStaticTexture2DEditorOnly(class UTextureRenderTarget2D* RenderTarget, FString Name, TEnumAsByte<TextureCompressionSettings> CompressionSettings, TEnumAsByte<TextureMipGenSettings> MipSettings);
    class UTexture2DArray* RenderTargetCreateStaticTexture2DArrayEditorOnly(class UTextureRenderTarget2DArray* RenderTarget, FString Name, TEnumAsByte<TextureCompressionSettings> CompressionSettings, TEnumAsByte<TextureMipGenSettings> MipSettings);
    void ReleaseRenderTarget2D(class UTextureRenderTarget2D* TextureRenderTarget);
    void RefreshPathTracingOutput();
    FColor ReadRenderTargetUV(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, float U, float V);
    TArray<FLinearColor> ReadRenderTargetRawUVArea(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, FBox2D Area, bool bNormalize);
    FLinearColor ReadRenderTargetRawUV(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, float U, float V, bool bNormalize);
    TArray<FLinearColor> ReadRenderTargetRawPixelArea(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, int32 MinX, int32 MinY, int32 MaxX, int32 MaxY, bool bNormalize);
    FLinearColor ReadRenderTargetRawPixel(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, int32 X, int32 Y, bool bNormalize);
    bool ReadRenderTargetRaw(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, TArray<FLinearColor>& OutLinearSamples, bool bNormalize);
    FColor ReadRenderTargetPixel(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, int32 X, int32 Y);
    bool ReadRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, TArray<FColor>& OutSamples, bool bNormalize);
    FSkelMeshSkinWeightInfo MakeSkinWeightInfo(int32 Bone0, uint8 Weight0, int32 Bone1, uint8 Weight1, int32 Bone2, uint8 Weight2, int32 Bone3, uint8 Weight3);
    class UTexture2D* ImportFileAsTexture2D(class UObject* WorldContextObject, FString Filename);
    class UTexture2D* ImportBufferAsTexture2D(class UObject* WorldContextObject, const TArray<uint8>& Buffer);
    void ExportTexture2D(class UObject* WorldContextObject, class UTexture2D* Texture, FString FilePath, FString Filename);
    void ExportRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, FString FilePath, FString Filename);
    void EndDrawCanvasToRenderTarget(class UObject* WorldContextObject, const FDrawToRenderTargetContext& Context);
    void EnablePathTracing(bool bEnablePathTracer);
    void DrawMaterialToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UMaterialInterface* Material);
    class UTextureRenderTargetVolume* CreateRenderTargetVolume(class UObject* WorldContextObject, int32 Width, int32 Height, int32 Depth, TEnumAsByte<ETextureRenderTargetFormat> Format, FLinearColor ClearColor, bool bAutoGenerateMipMaps, bool bSupportUAVs);
    class UTextureRenderTarget2DArray* CreateRenderTarget2DArray(class UObject* WorldContextObject, int32 Width, int32 Height, int32 Slices, TEnumAsByte<ETextureRenderTargetFormat> Format, FLinearColor ClearColor, bool bAutoGenerateMipMaps, bool bSupportUAVs);
    class UTextureRenderTarget2D* CreateRenderTarget2D(class UObject* WorldContextObject, int32 Width, int32 Height, TEnumAsByte<ETextureRenderTargetFormat> Format, FLinearColor ClearColor, bool bAutoGenerateMipMaps, bool bSupportUAVs);
    void ConvertRenderTargetToTextureVolumeEditorOnly(class UObject* WorldContextObject, class UTextureRenderTargetVolume* RenderTarget, class UVolumeTexture* Texture);
    void ConvertRenderTargetToTextureCubeEditorOnly(class UObject* WorldContextObject, class UTextureRenderTargetCube* RenderTarget, class UTextureCube* Texture);
    void ConvertRenderTargetToTexture2DEditorOnly(class UObject* WorldContextObject, class UTextureRenderTarget2D* RenderTarget, class UTexture2D* Texture);
    void ConvertRenderTargetToTexture2DArrayEditorOnly(class UObject* WorldContextObject, class UTextureRenderTarget2DArray* RenderTarget, class UTexture2DArray* Texture);
    void ClearRenderTarget2D(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, FLinearColor ClearColor);
    FMatrix CalculateProjectionMatrix(const FMinimalViewInfo& MinimalViewInfo);
    void BreakSkinWeightInfo(FSkelMeshSkinWeightInfo InWeight, int32& Bone0, uint8& Weight0, int32& Bone1, uint8& Weight1, int32& Bone2, uint8& Weight2, int32& Bone3, uint8& Weight3);
    void BeginDrawCanvasToRenderTarget(class UObject* WorldContextObject, class UTextureRenderTarget2D* TextureRenderTarget, class UCanvas*& Canvas, FVector2D& Size, FDrawToRenderTargetContext& Context);
}; // Size: 0x28

class UKismetStringLibrary : public UBlueprintFunctionLibrary
{

    FString TrimTrailing(FString SourceString);
    FString Trim(FString SourceString);
    FString ToUpper(FString SourceString);
    FString ToLower(FString SourceString);
    FString TimeSecondsToString(float InSeconds);
    bool StartsWith(FString SourceString, FString InPrefix, TEnumAsByte<ESearchCase::Type> SearchCase);
    bool Split(FString SourceString, FString InStr, FString& LeftS, FString& RightS, TEnumAsByte<ESearchCase::Type> SearchCase, TEnumAsByte<ESearchDir::Type> SearchDir);
    FString RightPad(FString SourceString, int32 ChCount);
    FString RightChop(FString SourceString, int32 Count);
    FString Right(FString SourceString, int32 Count);
    FString Reverse(FString SourceString);
    int32 ReplaceInline(FString& SourceString, FString SearchText, FString ReplacementText, TEnumAsByte<ESearchCase::Type> SearchCase);
    FString Replace(FString SourceString, FString from, FString To, TEnumAsByte<ESearchCase::Type> SearchCase);
    TArray<FString> ParseIntoArray(FString SourceString, FString Delimiter, const bool CullEmptyStrings);
    bool NotEqual_StrStr(FString A, FString B);
    bool NotEqual_StriStri(FString A, FString B);
    FString Mid(FString SourceString, int32 Start, int32 Count);
    bool MatchesWildcard(FString SourceString, FString Wildcard, TEnumAsByte<ESearchCase::Type> SearchCase);
    int32 Len(FString S);
    FString LeftPad(FString SourceString, int32 ChCount);
    FString LeftChop(FString SourceString, int32 Count);
    FString Left(FString SourceString, int32 Count);
    FString JoinStringArray(const TArray<FString>& SourceArray, FString Separator);
    bool IsNumeric(FString SourceString);
    bool IsEmpty(FString InString);
    FString GetSubstring(FString SourceString, int32 StartIndex, int32 Length);
    int32 GetCharacterAsNumber(FString SourceString, int32 Index);
    TArray<FString> GetCharacterArrayFromString(FString SourceString);
    int32 FindSubstring(FString SearchIn, FString Substring, bool bUseCase, bool bSearchFromEnd, int32 StartPosition);
    bool EqualEqual_StrStr(FString A, FString B);
    bool EqualEqual_StriStri(FString A, FString B);
    bool EndsWith(FString SourceString, FString InSuffix, TEnumAsByte<ESearchCase::Type> SearchCase);
    int32 CullArray(FString SourceString, TArray<FString>& inArray);
    FString Conv_VectorToString(FVector InVec);
    FString Conv_Vector3fToString(FVector3f InVec);
    FString Conv_Vector2dToString(FVector2D InVec);
    FString Conv_TransformToString(const FTransform& InTrans);
    void Conv_StringToVector3f(FString InString, FVector3f& OutConvertedVector, bool& OutIsValid);
    void Conv_StringToVector2D(FString InString, FVector2D& OutConvertedVector2D, bool& OutIsValid);
    void Conv_StringToVector(FString InString, FVector& OutConvertedVector, bool& OutIsValid);
    void Conv_StringToRotator(FString InString, FRotator& OutConvertedRotator, bool& OutIsValid);
    FName Conv_StringToName(FString InString);
    int64 Conv_StringToInt64(FString InString);
    int32 Conv_StringToInt(FString InString);
    double Conv_StringToDouble(FString InString);
    void Conv_StringToColor(FString InString, FLinearColor& OutConvertedColor, bool& OutIsValid);
    FString Conv_RotatorToString(FRotator InRot);
    FString Conv_PlatformUserIdToString(FPlatformUserId InPlatformUserId);
    FString Conv_ObjectToString(class UObject* InObj);
    FString Conv_NameToString(FName InName);
    FString Conv_MatrixToString(const FMatrix& InMatrix);
    FString Conv_IntVectorToString(FIntVector InIntVec);
    FString Conv_IntToString(int32 inInt);
    FString Conv_IntPointToString(FIntPoint InIntPoint);
    FString Conv_Int64ToString(int64 inInt);
    FString Conv_InputDeviceIdToString(FInputDeviceId InDeviceId);
    FString Conv_DoubleToString(double InDouble);
    FString Conv_ColorToString(FLinearColor InColor);
    FString Conv_ByteToString(uint8 InByte);
    FString Conv_BoxToString(const FBox& Box);
    FString Conv_BoxCenterAndExtentsToString(const FBox& Box);
    FString Conv_BoolToString(bool InBool);
    bool Contains(FString SearchIn, FString Substring, bool bUseCase, bool bSearchFromEnd);
    FString Concat_StrStr(FString A, FString B);
    FString BuildString_Vector2d(FString AppendTo, FString Prefix, FVector2D InVector2D, FString Suffix);
    FString BuildString_Vector(FString AppendTo, FString Prefix, FVector InVector, FString Suffix);
    FString BuildString_Rotator(FString AppendTo, FString Prefix, FRotator InRot, FString Suffix);
    FString BuildString_Object(FString AppendTo, FString Prefix, class UObject* InObj, FString Suffix);
    FString BuildString_Name(FString AppendTo, FString Prefix, FName InName, FString Suffix);
    FString BuildString_IntVector(FString AppendTo, FString Prefix, FIntVector InIntVector, FString Suffix);
    FString BuildString_Int(FString AppendTo, FString Prefix, int32 inInt, FString Suffix);
    FString BuildString_Double(FString AppendTo, FString Prefix, double InDouble, FString Suffix);
    FString BuildString_Color(FString AppendTo, FString Prefix, FLinearColor InColor, FString Suffix);
    FString BuildString_Bool(FString AppendTo, FString Prefix, bool InBool, FString Suffix);
}; // Size: 0x28

class UKismetStringTableLibrary : public UBlueprintFunctionLibrary
{

    bool IsRegisteredTableId(const FName TableId);
    bool IsRegisteredTableEntry(const FName TableId, FString Key);
    FString GetTableNamespace(const FName TableId);
    FString GetTableEntrySourceString(const FName TableId, FString Key);
    FString GetTableEntryMetaData(const FName TableId, FString Key, const FName MetaDataId);
    TArray<FName> GetRegisteredStringTables();
    TArray<FName> GetMetaDataIdsFromStringTableEntry(const FName TableId, FString Key);
    TArray<FString> GetKeysFromStringTable(const FName TableId);
}; // Size: 0x28

class UKismetSystemLibrary : public UBlueprintFunctionLibrary
{

    void UnregisterForRemoteNotifications();
    void UnloadPrimaryAssetList(const TArray<FPrimaryAssetId>& PrimaryAssetIdList);
    void UnloadPrimaryAsset(FPrimaryAssetId PrimaryAssetId);
    void TransactObject(class UObject* Object);
    void StackTrace();
    bool SphereTraceSingleForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool SphereTraceSingleByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool SphereTraceSingle(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool SphereTraceMultiForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool SphereTraceMultiByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool SphereTraceMulti(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool SphereOverlapComponents(const class UObject* WorldContextObject, const FVector SpherePos, float SphereRadius, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>& OutComponents);
    bool SphereOverlapActors(const class UObject* WorldContextObject, const FVector SpherePos, float SphereRadius, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>& OutActors);
    void SnapshotObject(class UObject* Object);
    void ShowPlatformSpecificLeaderboardScreen(FString CategoryName);
    void ShowPlatformSpecificAchievementsScreen(const class APlayerController* SpecificPlayer);
    void ShowInterstitialAd();
    void ShowAdBanner(int32 AdIdIndex, bool bShowOnBottomOfScreen);
    void SetWindowTitle(const FText& Title);
    void SetVolumeButtonsHandledBySystem(bool bEnabled);
    void SetVectorPropertyByName(class UObject* Object, FName PropertyName, const FVector& Value);
    void SetVector3fPropertyByName(class UObject* Object, FName PropertyName, const FVector3f& Value);
    void SetUserActivity(const FUserActivity& UserActivity);
    void SetTransformPropertyByName(class UObject* Object, FName PropertyName, const FTransform& Value);
    void SetTextPropertyByName(class UObject* Object, FName PropertyName, const FText& Value);
    void SetSuppressViewportTransitionMessage(const class UObject* WorldContextObject, bool bState);
    void SetStructurePropertyByName(class UObject* Object, FName PropertyName, const FGenericStruct& Value);
    void SetStringPropertyByName(class UObject* Object, FName PropertyName, FString Value);
    void SetSoftObjectPropertyByName(class UObject* Object, FName PropertyName, const TSoftObjectPtr<UObject>& Value);
    void SetSoftClassPropertyByName(class UObject* Object, FName PropertyName, const TSoftClassPtr<UObject>& Value);
    void SetRotatorPropertyByName(class UObject* Object, FName PropertyName, const FRotator& Value);
    void SetObjectPropertyByName(class UObject* Object, FName PropertyName, class UObject* Value);
    void SetNamePropertyByName(class UObject* Object, FName PropertyName, const FName& Value);
    void SetLinearColorPropertyByName(class UObject* Object, FName PropertyName, const FLinearColor& Value);
    void SetIntPropertyByName(class UObject* Object, FName PropertyName, int32 Value);
    void SetInterfacePropertyByName(class UObject* Object, FName PropertyName, const FScriptInterface& Value);
    void SetInt64PropertyByName(class UObject* Object, FName PropertyName, int64 Value);
    void SetGamepadsBlockDeviceFeedback(bool bBlock);
    void SetFieldPathPropertyByName(class UObject* Object, FName PropertyName, const TFieldPath<FField>& Value);
    void SetDoublePropertyByName(class UObject* Object, FName PropertyName, double Value);
    void SetColorPropertyByName(class UObject* Object, FName PropertyName, const FColor& Value);
    void SetCollisionProfileNameProperty(class UObject* Object, FName PropertyName, const FCollisionProfileName& Value);
    void SetClassPropertyByName(class UObject* Object, FName PropertyName, UClass* Value);
    void SetBytePropertyByName(class UObject* Object, FName PropertyName, uint8 Value);
    void SetBoolPropertyByName(class UObject* Object, FName PropertyName, bool Value);
    void RetriggerableDelay(const class UObject* WorldContextObject, float Duration, FLatentActionInfo LatentInfo);
    void ResetGamepadAssignmentToController(int32 ControllerId);
    void ResetGamepadAssignments();
    void RegisterForRemoteNotifications();
    void QuitGame(const class UObject* WorldContextObject, class APlayerController* SpecificPlayer, TEnumAsByte<EQuitPreference::Type> QuitPreference, bool bIgnorePlatformRestrictions);
    void PrintWarning(FString InString);
    void PrintText(const class UObject* WorldContextObject, const FText InText, bool bPrintToScreen, bool bPrintToLog, FLinearColor TextColor, float Duration, const FName Key);
    void PrintString(const class UObject* WorldContextObject, FString InString, bool bPrintToScreen, bool bPrintToLog, FLinearColor TextColor, float Duration, const FName Key);
    bool ParseParamValue(FString InString, FString InParam, FString& OutValue);
    bool ParseParam(FString InString, FString InParam);
    void ParseCommandLine(FString InCmdLine, TArray<FString>& OutTokens, TArray<FString>& OutSwitches, TMap<class FString, class FString>& OutParams);
    void OnAssetLoaded__DelegateSignature(class UObject* Loaded);
    void OnAssetClassLoaded__DelegateSignature(UClass* Loaded);
    bool NotEqual_SoftObjectReference(const TSoftObjectPtr<UObject>& A, const TSoftObjectPtr<UObject>& B);
    bool NotEqual_SoftClassReference(const TSoftClassPtr<UObject>& A, const TSoftClassPtr<UObject>& B);
    bool NotEqual_PrimaryAssetType(FPrimaryAssetType A, FPrimaryAssetType B);
    bool NotEqual_PrimaryAssetId(FPrimaryAssetId A, FPrimaryAssetId B);
    FString NormalizeFilename(FString InFilename);
    void MoveComponentTo(class USceneComponent* Component, FVector TargetRelativeLocation, FRotator TargetRelativeRotation, bool bEaseOut, bool bEaseIn, float OverTime, bool bForceShortestRotationPath, TEnumAsByte<EMoveComponentAction::Type> MoveAction, FLatentActionInfo LatentInfo);
    FTopLevelAssetPath MakeTopLevelAssetPath(FString PackageName, FString AssetName);
    FSoftObjectPath MakeSoftObjectPath(FString PathString);
    FSoftClassPath MakeSoftClassPath(FString PathString);
    FText MakeLiteralText(FText Value);
    FString MakeLiteralString(FString Value);
    FName MakeLiteralName(FName Value);
    int64 MakeLiteralInt64(int64 Value);
    int32 MakeLiteralInt(int32 Value);
    double MakeLiteralDouble(double Value);
    uint8 MakeLiteralByte(uint8 Value);
    bool MakeLiteralBool(bool Value);
    FARFilter MakeARFilter(const TArray<FName>& PackageNames, const TArray<FName>& PackagePaths, const TArray<FSoftObjectPath>& SoftObjectPaths, const TArray<FTopLevelAssetPath>& ClassPaths, const TSet<FTopLevelAssetPath>& RecursiveClassPathsExclusionSet, const TArray<FName>& ClassNames, const TSet<FName>& RecursiveClassesExclusionSet, const bool bRecursivePaths, const bool bRecursiveClasses, const bool bIncludeOnlyOnDiskAssets);
    void LogString(FString InString, bool bPrintToLog);
    void LoadInterstitialAd(int32 AdIdIndex);
    UClass* LoadClassAsset_Blocking(TSoftClassPtr<UObject> AssetClass);
    void LoadAssetClass(const class UObject* WorldContextObject, TSoftClassPtr<UObject> AssetClass, FLoadAssetClassOnLoaded OnLoaded, FLatentActionInfo LatentInfo);
    class UObject* LoadAsset_Blocking(TSoftObjectPtr<UObject> Asset);
    void LoadAsset(const class UObject* WorldContextObject, TSoftObjectPtr<UObject> Asset, FLoadAssetOnLoaded OnLoaded, FLatentActionInfo LatentInfo);
    bool LineTraceSingleForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool LineTraceSingleByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool LineTraceSingle(const class UObject* WorldContextObject, const FVector Start, const FVector End, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool LineTraceMultiForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool LineTraceMultiByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool LineTraceMulti(const class UObject* WorldContextObject, const FVector Start, const FVector End, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    void LaunchURL(FString URL);
    void K2_UnPauseTimerHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    void K2_UnPauseTimerDelegate(FK2_UnPauseTimerDelegateDelegate Delegate);
    void K2_UnPauseTimer(class UObject* Object, FString FunctionName);
    bool K2_TimerExistsHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    bool K2_TimerExistsDelegate(FK2_TimerExistsDelegateDelegate Delegate);
    bool K2_TimerExists(class UObject* Object, FString FunctionName);
    FTimerHandle K2_SetTimerForNextTickDelegate(FK2_SetTimerForNextTickDelegateDelegate Delegate);
    FTimerHandle K2_SetTimerForNextTick(class UObject* Object, FString FunctionName);
    FTimerHandle K2_SetTimerDelegate(FK2_SetTimerDelegateDelegate Delegate, float Time, bool bLooping, bool bMaxOncePerFrame, float InitialStartDelay, float InitialStartDelayVariance);
    FTimerHandle K2_SetTimer(class UObject* Object, FString FunctionName, float Time, bool bLooping, bool bMaxOncePerFrame, float InitialStartDelay, float InitialStartDelayVariance);
    void K2_PauseTimerHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    void K2_PauseTimerDelegate(FK2_PauseTimerDelegateDelegate Delegate);
    void K2_PauseTimer(class UObject* Object, FString FunctionName);
    bool K2_IsValidTimerHandle(FTimerHandle Handle);
    bool K2_IsTimerPausedHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    bool K2_IsTimerPausedDelegate(FK2_IsTimerPausedDelegateDelegate Delegate);
    bool K2_IsTimerPaused(class UObject* Object, FString FunctionName);
    bool K2_IsTimerActiveHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    bool K2_IsTimerActiveDelegate(FK2_IsTimerActiveDelegateDelegate Delegate);
    bool K2_IsTimerActive(class UObject* Object, FString FunctionName);
    FTimerHandle K2_InvalidateTimerHandle(FTimerHandle& Handle);
    float K2_GetTimerRemainingTimeHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    float K2_GetTimerRemainingTimeDelegate(FK2_GetTimerRemainingTimeDelegateDelegate Delegate);
    float K2_GetTimerRemainingTime(class UObject* Object, FString FunctionName);
    float K2_GetTimerElapsedTimeHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    float K2_GetTimerElapsedTimeDelegate(FK2_GetTimerElapsedTimeDelegateDelegate Delegate);
    float K2_GetTimerElapsedTime(class UObject* Object, FString FunctionName);
    void K2_ClearTimerHandle(const class UObject* WorldContextObject, FTimerHandle Handle);
    void K2_ClearTimerDelegate(FK2_ClearTimerDelegateDelegate Delegate);
    void K2_ClearTimer(class UObject* Object, FString FunctionName);
    void K2_ClearAndInvalidateTimerHandle(const class UObject* WorldContextObject, FTimerHandle& Handle);
    bool IsValidSoftObjectReference(const TSoftObjectPtr<UObject>& SoftObjectReference);
    bool IsValidSoftClassReference(const TSoftClassPtr<UObject>& SoftClassReference);
    bool IsValidPrimaryAssetType(FPrimaryAssetType PrimaryAssetType);
    bool IsValidPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    bool IsValidInterface(const FScriptInterface& Interface);
    bool IsValidClass(UClass* Class);
    bool IsValid(const class UObject* Object);
    bool IsUnattended();
    bool IsStandalone(const class UObject* WorldContextObject);
    bool IsSplitScreen(const class UObject* WorldContextObject);
    bool IsServer(const class UObject* WorldContextObject);
    bool IsScreensaverEnabled();
    bool IsPackagedForDistribution();
    bool IsLoggedIn(const class APlayerController* SpecificPlayer);
    bool IsInterstitialAdRequested();
    bool IsInterstitialAdAvailable();
    bool IsDedicatedServer(const class UObject* WorldContextObject);
    bool IsControllerAssignedToGamepad(int32 ControllerId);
    void HideAdBanner();
    bool HasMultipleLocalPlayers(const class UObject* WorldContextObject);
    bool GetVolumeButtonsHandledBySystem();
    FString GetUniqueDeviceId();
    FString GetSystemPath(const class UObject* Object);
    bool GetSupportedFullscreenResolutions(TArray<FIntPoint>& Resolutions);
    FTopLevelAssetPath GetStructTopLevelAssetPath(const class UScriptStruct* Struct);
    TSoftObjectPtr<UObject> GetSoftObjectReferenceFromPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    FSoftObjectPath GetSoftObjectPath(const class UObject* Object);
    FTopLevelAssetPath GetSoftClassTopLevelAssetPath(TSoftClassPtr<UObject> SoftClassReference);
    TSoftClassPtr<UObject> GetSoftClassReferenceFromPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    FSoftClassPath GetSoftClassPath(const UClass* Class);
    int32 GetRenderingMaterialQualityLevel();
    int32 GetRenderingDetailMode();
    FString GetProjectSavedDirectory();
    FString GetProjectDirectory();
    FString GetProjectContentDirectory();
    void GetPrimaryAssetsWithBundleState(const TArray<FName>& RequiredBundles, const TArray<FName>& ExcludedBundles, const TArray<FPrimaryAssetType>& ValidTypes, bool bForceCurrentState, TArray<FPrimaryAssetId>& OutPrimaryAssetIdList);
    void GetPrimaryAssetIdList(FPrimaryAssetType PrimaryAssetType, TArray<FPrimaryAssetId>& OutPrimaryAssetIdList);
    FPrimaryAssetId GetPrimaryAssetIdFromSoftObjectReference(TSoftObjectPtr<UObject> SoftObjectReference);
    FPrimaryAssetId GetPrimaryAssetIdFromSoftClassReference(TSoftClassPtr<UObject> SoftClassReference);
    FPrimaryAssetId GetPrimaryAssetIdFromObject(class UObject* Object);
    FPrimaryAssetId GetPrimaryAssetIdFromClass(UClass* Class);
    TArray<FString> GetPreferredLanguages();
    FString GetPlatformUserName();
    FString GetPlatformUserDir();
    FString GetPathName(const class UObject* Object);
    class UObject* GetOuterObject(const class UObject* Object);
    FString GetObjectName(const class UObject* Object);
    class UObject* GetObjectFromPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    int32 GetMinYResolutionForUI();
    int32 GetMinYResolutionFor3DView();
    FString GetLocalCurrencySymbol();
    FString GetLocalCurrencyCode();
    double GetGameTimeInSeconds(const class UObject* WorldContextObject);
    FString GetGamepadControllerName(int32 ControllerId);
    class UTexture2D* GetGamepadButtonGlyph(FString ButtonKey, int32 ControllerIndex);
    FString GetGameName();
    FString GetGameBundleId();
    int64 GetFrameCount();
    FTopLevelAssetPath GetEnumTopLevelAssetPath(const class UEnum* Enum);
    FString GetEngineVersion();
    FString GetDisplayName(const class UObject* Object);
    FString GetDeviceId();
    FString GetDefaultLocale();
    FString GetDefaultLanguage();
    bool GetCurrentBundleState(FPrimaryAssetId PrimaryAssetId, bool bForceCurrentState, TArray<FName>& OutBundles);
    bool GetConvenientWindowedResolutions(TArray<FIntPoint>& Resolutions);
    FString GetConsoleVariableStringValue(FString VariableName);
    int32 GetConsoleVariableIntValue(FString VariableName);
    float GetConsoleVariableFloatValue(FString VariableName);
    bool GetConsoleVariableBoolValue(FString VariableName);
    void GetComponentBounds(const class USceneComponent* Component, FVector& Origin, FVector& BoxExtent, float& SphereRadius);
    FString GetCommandLine();
    FTopLevelAssetPath GetClassTopLevelAssetPath(const UClass* Class);
    UClass* GetClassFromPrimaryAssetId(FPrimaryAssetId PrimaryAssetId);
    FString GetClassDisplayName(const UClass* Class);
    FString GetBuildVersion();
    FString GetBuildConfiguration();
    int32 GetAdIDCount();
    void GetActorListFromComponentList(const TArray<class UPrimitiveComponent*>& ComponentList, UClass* ActorClassFilter, TArray<class AActor*>& OutActorList);
    void GetActorBounds(const class AActor* Actor, FVector& Origin, FVector& BoxExtent);
    void ForceCloseAdBanner();
    void FlushPersistentDebugLines(const class UObject* WorldContextObject);
    void FlushDebugStrings(const class UObject* WorldContextObject);
    void ExecuteConsoleCommand(const class UObject* WorldContextObject, FString Command, class APlayerController* SpecificPlayer);
    bool EqualEqual_SoftObjectReference(const TSoftObjectPtr<UObject>& A, const TSoftObjectPtr<UObject>& B);
    bool EqualEqual_SoftClassReference(const TSoftClassPtr<UObject>& A, const TSoftClassPtr<UObject>& B);
    bool EqualEqual_PrimaryAssetType(FPrimaryAssetType A, FPrimaryAssetType B);
    bool EqualEqual_PrimaryAssetId(FPrimaryAssetId A, FPrimaryAssetId B);
    int32 EndTransaction();
    void DrawDebugString(const class UObject* WorldContextObject, const FVector TextLocation, FString Text, class AActor* TestBaseActor, FLinearColor TextColor, float Duration);
    void DrawDebugSphere(const class UObject* WorldContextObject, const FVector Center, float Radius, int32 Segments, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugPoint(const class UObject* WorldContextObject, const FVector Position, float Size, FLinearColor PointColor, float Duration);
    void DrawDebugPlane(const class UObject* WorldContextObject, const FPlane& PlaneCoordinates, const FVector Location, float Size, FLinearColor PlaneColor, float Duration);
    void DrawDebugLine(const class UObject* WorldContextObject, const FVector LineStart, const FVector LineEnd, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugFrustum(const class UObject* WorldContextObject, const FTransform& FrustumTransform, FLinearColor FrustumColor, float Duration, float Thickness);
    void DrawDebugFloatHistoryTransform(const class UObject* WorldContextObject, const FDebugFloatHistory& FloatHistory, const FTransform& DrawTransform, FVector2D DrawSize, FLinearColor DrawColor, float Duration);
    void DrawDebugFloatHistoryLocation(const class UObject* WorldContextObject, const FDebugFloatHistory& FloatHistory, FVector DrawLocation, FVector2D DrawSize, FLinearColor DrawColor, float Duration);
    void DrawDebugCylinder(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, int32 Segments, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugCoordinateSystem(const class UObject* WorldContextObject, const FVector AxisLoc, const FRotator AxisRot, float Scale, float Duration, float Thickness);
    void DrawDebugConeInDegrees(const class UObject* WorldContextObject, const FVector Origin, const FVector Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugCone(const class UObject* WorldContextObject, const FVector Origin, const FVector Direction, float Length, float AngleWidth, float AngleHeight, int32 NumSides, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugCircle(const class UObject* WorldContextObject, FVector Center, float Radius, int32 NumSegments, FLinearColor LineColor, float Duration, float Thickness, FVector YAxis, FVector ZAxis, bool bDrawAxis);
    void DrawDebugCapsule(const class UObject* WorldContextObject, const FVector Center, float HalfHeight, float Radius, const FRotator Rotation, FLinearColor LineColor, float Duration, float Thickness);
    void DrawDebugCamera(const class ACameraActor* CameraActor, FLinearColor CameraColor, float Duration);
    void DrawDebugBox(const class UObject* WorldContextObject, const FVector Center, FVector Extent, FLinearColor LineColor, const FRotator Rotation, float Duration, float Thickness);
    void DrawDebugArrow(const class UObject* WorldContextObject, const FVector LineStart, const FVector LineEnd, float ArrowSize, FLinearColor LineColor, float Duration, float Thickness);
    bool DoesImplementInterface(const class UObject* TestObject, TSubclassOf<class UInterface> Interface);
    bool DoesClassImplementInterface(const UClass* TestClass, TSubclassOf<class UInterface> Interface);
    void DelayUntilNextTick(const class UObject* WorldContextObject, FLatentActionInfo LatentInfo);
    void Delay(const class UObject* WorldContextObject, float Duration, FLatentActionInfo LatentInfo);
    void CreateCopyForUndoBuffer(class UObject* ObjectToModify);
    FString ConvertToRelativePath(FString Filename);
    FString ConvertToAbsolutePath(FString Filename);
    FSoftObjectPath Conv_SoftObjRefToSoftObjPath(TSoftObjectPtr<UObject> SoftObjectReference);
    FSoftClassPath Conv_SoftObjRefToSoftClassPath(TSoftClassPtr<UObject> SoftClassReference);
    TSoftObjectPtr<UObject> Conv_SoftObjPathToSoftObjRef(const FSoftObjectPath& SoftObjectPath);
    FString Conv_SoftObjectReferenceToString(const TSoftObjectPtr<UObject>& SoftObjectReference);
    class UObject* Conv_SoftObjectReferenceToObject(const TSoftObjectPtr<UObject>& SoftObject);
    FString Conv_SoftClassReferenceToString(const TSoftClassPtr<UObject>& SoftClassReference);
    UClass* Conv_SoftClassReferenceToClass(const TSoftClassPtr<UObject>& SoftClass);
    TSoftClassPtr<UObject> Conv_SoftClassPathToSoftClassRef(const FSoftClassPath& SoftClassPath);
    FString Conv_PrimaryAssetTypeToString(FPrimaryAssetType PrimaryAssetType);
    FString Conv_PrimaryAssetIdToString(FPrimaryAssetId PrimaryAssetId);
    TSoftObjectPtr<UObject> Conv_ObjectToSoftObjectReference(class UObject* Object);
    UClass* Conv_ObjectToClass(class UObject* Object, UClass* Class);
    class UObject* Conv_InterfaceToObject(const FScriptInterface& Interface);
    FSoftComponentReference Conv_ComponentReferenceToSoftComponentReference(const FComponentReference& ComponentReference);
    TSoftClassPtr<UObject> Conv_ClassToSoftClassReference(const UClass*& Class);
    void ControlScreensaver(bool bAllowScreenSaver);
    bool ComponentOverlapComponents(class UPrimitiveComponent* Component, const FTransform& ComponentTransform, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>& OutComponents);
    bool ComponentOverlapActors(class UPrimitiveComponent* Component, const FTransform& ComponentTransform, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>& OutActors);
    void CollectGarbage();
    bool CapsuleTraceSingleForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool CapsuleTraceSingleByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool CapsuleTraceSingle(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool CapsuleTraceMultiForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool CapsuleTraceMultiByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool CapsuleTraceMulti(const class UObject* WorldContextObject, const FVector Start, const FVector End, float Radius, float HalfHeight, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool CapsuleOverlapComponents(const class UObject* WorldContextObject, const FVector CapsulePos, float Radius, float HalfHeight, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>& OutComponents);
    bool CapsuleOverlapActors(const class UObject* WorldContextObject, const FVector CapsulePos, float Radius, float HalfHeight, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>& OutActors);
    bool CanLaunchURL(FString URL);
    void CancelTransaction(const int32 Index);
    void BreakTopLevelAssetPath(const FTopLevelAssetPath& TopLevelAssetPath, FString& PathString);
    void BreakSoftObjectPath(FSoftObjectPath InSoftObjectPath, FString& PathString);
    void BreakSoftClassPath(FSoftClassPath InSoftClassPath, FString& PathString);
    void BreakARFilter(FARFilter InARFilter, TArray<FName>& PackageNames, TArray<FName>& PackagePaths, TArray<FSoftObjectPath>& SoftObjectPaths, TArray<FTopLevelAssetPath>& ClassPaths, TSet<FTopLevelAssetPath>& RecursiveClassPathsExclusionSet, TArray<FName>& ClassNames, TSet<FName>& RecursiveClassesExclusionSet, bool& bRecursivePaths, bool& bRecursiveClasses, bool& bIncludeOnlyOnDiskAssets);
    bool BoxTraceSingleForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool BoxTraceSingleByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool BoxTraceSingle(const class UObject* WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, FHitResult& OutHit, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool BoxTraceMultiForObjects(const class UObject* WorldContextObject, const FVector Start, const FVector End, const FVector HalfSize, const FRotator Orientation, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool BoxTraceMultiByProfile(const class UObject* WorldContextObject, const FVector Start, const FVector End, FVector HalfSize, const FRotator Orientation, FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool BoxTraceMulti(const class UObject* WorldContextObject, const FVector Start, const FVector End, FVector HalfSize, const FRotator Orientation, TEnumAsByte<ETraceTypeQuery> TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, TEnumAsByte<EDrawDebugTrace::Type> DrawDebugType, TArray<FHitResult>& OutHits, bool bIgnoreSelf, FLinearColor TraceColor, FLinearColor TraceHitColor, float DrawTime);
    bool BoxOverlapComponents(const class UObject* WorldContextObject, const FVector BoxPos, FVector Extent, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ComponentClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class UPrimitiveComponent*>& OutComponents);
    bool BoxOverlapActors(const class UObject* WorldContextObject, const FVector BoxPos, FVector BoxExtent, const TArray<TEnumAsByte<EObjectTypeQuery>>& ObjectTypes, UClass* ActorClassFilter, const TArray<class AActor*>& ActorsToIgnore, TArray<class AActor*>& OutActors);
    int32 BeginTransaction(FString Context, FText Description, class UObject* PrimaryObject);
    FDebugFloatHistory AddFloatHistorySample(float Value, const FDebugFloatHistory& FloatHistory);
}; // Size: 0x28

class UKismetTextLibrary : public UBlueprintFunctionLibrary
{

    FText TextTrimTrailing(const FText& InText);
    FText TextTrimPrecedingAndTrailing(const FText& InText);
    FText TextTrimPreceding(const FText& InText);
    FText TextToUpper(const FText& InText);
    FText TextToLower(const FText& InText);
    bool TextIsTransient(const FText& InText);
    bool TextIsFromStringTable(const FText& Text);
    bool TextIsEmpty(const FText& InText);
    bool TextIsCultureInvariant(const FText& InText);
    FText TextFromStringTable(const FName TableId, FString Key);
    bool StringTableIdAndKeyFromText(FText Text, FName& OutTableId, FString& OutKey);
    FText PolyglotDataToText(const FPolyglotTextData& PolyglotData);
    bool NotEqual_TextText(const FText& A, const FText& B);
    bool NotEqual_IgnoreCase_TextText(const FText& A, const FText& B);
    FText MakeInvariantText(FString InString);
    void IsPolyglotDataValid(const FPolyglotTextData& PolyglotData, bool& IsValid, FText& ErrorMessage);
    FString GetTextSourceString(FText Text);
    bool GetTextId(FText Text, FString& OutNamespace, FString& OutKey);
    FText GetEmptyText();
    FText Format(FText InPattern, TArray<FFormatArgumentData> InArgs);
    bool FindTextInLocalizationTable(FString NameSpace, FString Key, FText& OutText, FString SourceString);
    bool EqualEqual_TextText(const FText& A, const FText& B);
    bool EqualEqual_IgnoreCase_TextText(const FText& A, const FText& B);
    bool EditTextSourceString(class UObject* TextOwner, FText& Text, FString SourceString);
    FText Conv_VectorToText(FVector InVec);
    FText Conv_Vector2dToText(FVector2D InVec);
    FText Conv_TransformToText(const FTransform& InTrans);
    FString Conv_TextToString(const FText& InText);
    FText Conv_StringToText(FString InString);
    FText Conv_RotatorToText(FRotator InRot);
    FText Conv_ObjectToText(class UObject* InObj);
    FText Conv_NameToText(FName InName);
    FText Conv_IntToText(int32 Value, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits);
    FText Conv_Int64ToText(int64 Value, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits);
    FText Conv_DoubleToText(double Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits);
    FText Conv_ColorToText(FLinearColor InColor);
    FText Conv_ByteToText(uint8 Value);
    FText Conv_BoolToText(bool InBool);
    FText AsTimeZoneTime_DateTime(const FDateTime& InDateTime, FString InTimeZone);
    FText AsTimeZoneDateTime_DateTime(const FDateTime& InDateTime, FString InTimeZone);
    FText AsTimeZoneDate_DateTime(const FDateTime& InDateTime, FString InTimeZone);
    FText AsTimespan_Timespan(const FTimespan& InTimespan);
    FText AsTime_DateTime(const FDateTime& In);
    FText AsPercent_Float(float Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits);
    FText AsDateTime_DateTime(const FDateTime& In);
    FText AsDate_DateTime(const FDateTime& InDateTime);
    FText AsCurrencyBase(int32 BaseValue, FString CurrencyCode);
    FText AsCurrency_Integer(int32 Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits, FString CurrencyCode);
    FText AsCurrency_Float(float Value, TEnumAsByte<ERoundingMode> RoundingMode, bool bAlwaysSign, bool bUseGrouping, int32 MinimumIntegralDigits, int32 MaximumIntegralDigits, int32 MinimumFractionalDigits, int32 MaximumFractionalDigits, FString CurrencyCode);
}; // Size: 0x28

class ULODSyncComponent : public UActorComponent
{
    int32 NumLODs;                                                                    // 0x00A0 (size: 0x4)
    int32 ForcedLOD;                                                                  // 0x00A4 (size: 0x4)
    int32 MinLOD;                                                                     // 0x00A8 (size: 0x4)
    TArray<FComponentSync> ComponentsToSync;                                          // 0x00B0 (size: 0x10)
    TMap<class FName, class FLODMappingData> CustomLODMapping;                        // 0x00C0 (size: 0x50)
    int32 CurrentLOD;                                                                 // 0x0110 (size: 0x4)
    int32 CurrentNumLODs;                                                             // 0x0114 (size: 0x4)
    TArray<class UPrimitiveComponent*> DriveComponents;                               // 0x0118 (size: 0x10)
    TArray<class UPrimitiveComponent*> SubComponents;                                 // 0x0128 (size: 0x10)

    FString GetLODSyncDebugText();
}; // Size: 0x138

class ULayer : public UObject
{
    FName LayerName;                                                                  // 0x0028 (size: 0x8)
    uint8 bIsVisible;                                                                 // 0x0030 (size: 0x1)
    TArray<FLayerActorStats> ActorStats;                                              // 0x0038 (size: 0x10)

}; // Size: 0x48

class ULevel : public UObject
{
    class UWorld* OwningWorld;                                                        // 0x00C0 (size: 0x8)
    class UModel* Model;                                                              // 0x00C8 (size: 0x8)
    TArray<class UModelComponent*> ModelComponents;                                   // 0x00D0 (size: 0x10)
    class ULevelActorContainer* ActorCluster;                                         // 0x00E0 (size: 0x8)
    int32 NumTextureStreamingUnbuiltComponents;                                       // 0x00E8 (size: 0x4)
    int32 NumTextureStreamingDirtyResources;                                          // 0x00EC (size: 0x4)
    class ALevelScriptActor* LevelScriptActor;                                        // 0x00F0 (size: 0x8)
    class ANavigationObjectBase* NavListStart;                                        // 0x00F8 (size: 0x8)
    class ANavigationObjectBase* NavListEnd;                                          // 0x0100 (size: 0x8)
    TArray<class UNavigationDataChunk*> NavDataChunks;                                // 0x0108 (size: 0x10)
    float LightmapTotalSize;                                                          // 0x0118 (size: 0x4)
    float ShadowmapTotalSize;                                                         // 0x011C (size: 0x4)
    TArray<FVector> StaticNavigableGeometry;                                          // 0x0120 (size: 0x10)
    TArray<FGuid> StreamingTextureGuids;                                              // 0x0130 (size: 0x10)
    TArray<FName> StreamingTextures;                                                  // 0x0140 (size: 0x10)
    uint32 PackedTextureStreamingQualityLevelFeatureLevel;                            // 0x0150 (size: 0x4)
    FGuid LevelBuildDataId;                                                           // 0x0210 (size: 0x10)
    class UMapBuildDataRegistry* MapBuildData;                                        // 0x0220 (size: 0x8)
    FIntVector LightBuildLevelOffset;                                                 // 0x0228 (size: 0xC)
    uint8 bIsLightingScenario;                                                        // 0x0234 (size: 0x1)
    uint8 bTextureStreamingRotationChanged;                                           // 0x0234 (size: 0x1)
    uint8 bStaticComponentsRegisteredInStreamingManager;                              // 0x0234 (size: 0x1)
    uint8 bIsVisible;                                                                 // 0x0234 (size: 0x1)
    uint8 bIsPartitioned;                                                             // 0x0236 (size: 0x1)
    class AWorldSettings* WorldSettings;                                              // 0x02A0 (size: 0x8)
    class AWorldDataLayers* WorldDataLayers;                                          // 0x02A8 (size: 0x8)
    TSoftObjectPtr<UWorldPartitionRuntimeCell> WorldPartitionRuntimeCell;             // 0x02B0 (size: 0x28)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x02E0 (size: 0x10)
    TArray<FReplicatedStaticActorDestructionInfo> DestroyedReplicatedStaticActors;    // 0x0300 (size: 0x10)

}; // Size: 0x318

class ULevelActorContainer : public UObject
{
    TArray<class AActor*> Actors;                                                     // 0x0028 (size: 0x10)

}; // Size: 0x38

class ULevelInstanceComponent : public USceneComponent
{
}; // Size: 0x230

class ULevelInstanceEditorObject : public UObject
{
}; // Size: 0x28

class ULevelInstanceSubsystem : public UWorldSubsystem
{
}; // Size: 0x1C0

class ULevelScriptBlueprint : public UBlueprint
{
}; // Size: 0xA8

class ULevelStreaming : public UObject
{
    TSoftObjectPtr<UWorld> WorldAsset;                                                // 0x0028 (size: 0x28)
    int32 StreamingPriority;                                                          // 0x0050 (size: 0x4)
    FName PackageNameToLoad;                                                          // 0x0054 (size: 0x8)
    TArray<FName> LODPackageNames;                                                    // 0x0060 (size: 0x10)
    FTransform LevelTransform;                                                        // 0x0080 (size: 0x60)
    bool bClientOnlyVisible;                                                          // 0x00E0 (size: 0x1)
    int32 LevelLODIndex;                                                              // 0x00E4 (size: 0x4)
    uint8 bShouldBeVisible;                                                           // 0x00E8 (size: 0x1)
    uint8 bShouldBeLoaded;                                                            // 0x00E8 (size: 0x1)
    uint8 bLocked;                                                                    // 0x00EB (size: 0x1)
    uint8 bIsStatic;                                                                  // 0x00EB (size: 0x1)
    uint8 bShouldBlockOnLoad;                                                         // 0x00EB (size: 0x1)
    uint8 bShouldBlockOnUnload;                                                       // 0x00EB (size: 0x1)
    uint8 bDisableDistanceStreaming;                                                  // 0x00EB (size: 0x1)
    uint8 bDrawOnLevelStatusMap;                                                      // 0x00EB (size: 0x1)
    FLinearColor LevelColor;                                                          // 0x00EC (size: 0x10)
    TArray<class ALevelStreamingVolume*> EditorStreamingVolumes;                      // 0x0100 (size: 0x10)
    float MinTimeBetweenVolumeUnloadRequests;                                         // 0x0110 (size: 0x4)
    FLevelStreamingOnLevelLoaded OnLevelLoaded;                                       // 0x0118 (size: 0x10)
    void LevelStreamingLoadedStatus();
    FLevelStreamingOnLevelUnloaded OnLevelUnloaded;                                   // 0x0128 (size: 0x10)
    void LevelStreamingLoadedStatus();
    FLevelStreamingOnLevelShown OnLevelShown;                                         // 0x0138 (size: 0x10)
    void LevelStreamingVisibilityStatus();
    FLevelStreamingOnLevelHidden OnLevelHidden;                                       // 0x0148 (size: 0x10)
    void LevelStreamingVisibilityStatus();
    class ULevel* LoadedLevel;                                                        // 0x0158 (size: 0x8)
    class ULevel* PendingUnloadLevel;                                                 // 0x0160 (size: 0x8)

    bool ShouldBeLoaded();
    void SetShouldBeVisible(bool bInShouldBeVisible);
    void SetShouldBeLoaded(bool bInShouldBeLoaded);
    void SetPriority(int32 NewPriority);
    void SetLevelLODIndex(int32 LODIndex);
    void SetIsRequestingUnloadAndRemoval(bool bInIsRequestingUnloadAndRemoval);
    bool IsStreamingStatePending();
    bool IsLevelVisible();
    bool IsLevelLoaded();
    FName GetWorldAssetPackageFName();
    class ULevel* GetLoadedLevel();
    class ALevelScriptActor* GetLevelScriptActor();
    bool GetIsRequestingUnloadAndRemoval();
    class ULevelStreaming* CreateInstance(FString UniqueInstanceName);
}; // Size: 0x1A0

class ULevelStreamingAlwaysLoaded : public ULevelStreaming
{
}; // Size: 0x1A0

class ULevelStreamingDynamic : public ULevelStreaming
{
    uint8 bInitiallyLoaded;                                                           // 0x0198 (size: 0x1)
    uint8 bInitiallyVisible;                                                          // 0x0198 (size: 0x1)

    class ULevelStreamingDynamic* LoadLevelInstanceBySoftObjectPtr(class UObject* WorldContextObject, TSoftObjectPtr<UWorld> Level, FVector Location, FRotator Rotation, bool& bOutSuccess, FString OptionalLevelNameOverride, TSubclassOf<class ULevelStreamingDynamic> OptionalLevelStreamingClass, bool bLoadAsTempPackage);
    class ULevelStreamingDynamic* LoadLevelInstance(class UObject* WorldContextObject, FString LevelName, FVector Location, FRotator Rotation, bool& bOutSuccess, FString OptionalLevelNameOverride, TSubclassOf<class ULevelStreamingDynamic> OptionalLevelStreamingClass, bool bLoadAsTempPackage);
}; // Size: 0x1A0

class ULevelStreamingLevelInstance : public ULevelStreamingDynamic
{
}; // Size: 0x1D0

class ULevelStreamingLevelInstanceEditor : public ULevelStreamingAlwaysLoaded
{
}; // Size: 0x1A0

class ULevelStreamingPersistent : public ULevelStreaming
{
}; // Size: 0x1A0

class ULevelStreamingProfilingSubsystem : public UWorldSubsystem
{
}; // Size: 0xC0

class ULightComponent : public ULightComponentBase
{
    float Temperature;                                                                // 0x0268 (size: 0x4)
    float MaxDrawDistance;                                                            // 0x026C (size: 0x4)
    float MaxDistanceFadeRange;                                                       // 0x0270 (size: 0x4)
    uint8 bUseTemperature;                                                            // 0x0274 (size: 0x1)
    int32 ShadowMapChannel;                                                           // 0x0278 (size: 0x4)
    float MinRoughness;                                                               // 0x0280 (size: 0x4)
    float SpecularScale;                                                              // 0x0284 (size: 0x4)
    float ShadowResolutionScale;                                                      // 0x0288 (size: 0x4)
    float ShadowBias;                                                                 // 0x028C (size: 0x4)
    float ShadowSlopeBias;                                                            // 0x0290 (size: 0x4)
    float ShadowSharpen;                                                              // 0x0294 (size: 0x4)
    float ContactShadowLength;                                                        // 0x0298 (size: 0x4)
    uint8 ContactShadowLengthInWS;                                                    // 0x029C (size: 0x1)
    float ContactShadowCastingIntensity;                                              // 0x02A0 (size: 0x4)
    float ContactShadowNonCastingIntensity;                                           // 0x02A4 (size: 0x4)
    uint8 InverseSquaredFalloff;                                                      // 0x02A8 (size: 0x1)
    uint8 CastTranslucentShadows;                                                     // 0x02A8 (size: 0x1)
    uint8 bCastShadowsFromCinematicObjectsOnly;                                       // 0x02A8 (size: 0x1)
    uint8 bForceCachedShadowsForMovablePrimitives;                                    // 0x02A8 (size: 0x1)
    FLightingChannels LightingChannels;                                               // 0x02AC (size: 0x1)
    class UMaterialInterface* LightFunctionMaterial;                                  // 0x02B0 (size: 0x8)
    FVector LightFunctionScale;                                                       // 0x02B8 (size: 0x18)
    class UTextureLightProfile* IESTexture;                                           // 0x02D0 (size: 0x8)
    uint8 bUseIESBrightness;                                                          // 0x02D8 (size: 0x1)
    float IESBrightnessScale;                                                         // 0x02DC (size: 0x4)
    float LightFunctionFadeDistance;                                                  // 0x02E0 (size: 0x4)
    float DisabledBrightness;                                                         // 0x02E4 (size: 0x4)
    uint8 bEnableLightShaftBloom;                                                     // 0x02E8 (size: 0x1)
    float BloomScale;                                                                 // 0x02EC (size: 0x4)
    float BloomThreshold;                                                             // 0x02F0 (size: 0x4)
    float BloomMaxBrightness;                                                         // 0x02F4 (size: 0x4)
    FColor BloomTint;                                                                 // 0x02F8 (size: 0x4)
    bool bUseRayTracedDistanceFieldShadows;                                           // 0x02FC (size: 0x1)
    float RayStartOffsetDepthScale;                                                   // 0x0300 (size: 0x4)

    void SetVolumetricScatteringIntensity(float NewIntensity);
    void SetUseTemperature(bool bNewValue);
    void SetUseIESBrightness(bool bNewValue);
    void SetTransmission(bool bNewValue);
    void SetTemperature(float NewTemperature);
    void SetSpecularScale(float NewValue);
    void SetShadowSlopeBias(float NewValue);
    void SetShadowBias(float NewValue);
    void SetLightingChannels(bool bChannel0, bool bChannel1, bool bChannel2);
    void SetLightFunctionScale(FVector NewLightFunctionScale);
    void SetLightFunctionMaterial(class UMaterialInterface* NewLightFunctionMaterial);
    void SetLightFunctionFadeDistance(float NewLightFunctionFadeDistance);
    void SetLightFunctionDisabledBrightness(float NewValue);
    void SetLightFColor(FColor NewLightColor);
    void SetLightColor(FLinearColor NewLightColor, bool bSRGB);
    void SetIntensity(float NewIntensity);
    void SetIndirectLightingIntensity(float NewIntensity);
    void SetIESTexture(class UTextureLightProfile* NewValue);
    void SetIESBrightnessScale(float NewValue);
    void SetForceCachedShadowsForMovablePrimitives(bool bNewValue);
    void SetEnableLightShaftBloom(bool bNewValue);
    void SetBloomTint(FColor NewValue);
    void SetBloomThreshold(float NewValue);
    void SetBloomScale(float NewValue);
    void SetBloomMaxBrightness(float NewValue);
    void SetAffectTranslucentLighting(bool bNewValue);
}; // Size: 0x370

class ULightComponentBase : public USceneComponent
{
    FGuid LightGuid;                                                                  // 0x0230 (size: 0x10)
    float Brightness;                                                                 // 0x0240 (size: 0x4)
    float Intensity;                                                                  // 0x0244 (size: 0x4)
    FColor LightColor;                                                                // 0x0248 (size: 0x4)
    uint8 bAffectsWorld;                                                              // 0x024C (size: 0x1)
    uint8 CastShadows;                                                                // 0x024C (size: 0x1)
    uint8 CastStaticShadows;                                                          // 0x024C (size: 0x1)
    uint8 CastDynamicShadows;                                                         // 0x024C (size: 0x1)
    uint8 bAffectTranslucentLighting;                                                 // 0x024C (size: 0x1)
    uint8 bTransmission;                                                              // 0x024C (size: 0x1)
    uint8 bCastVolumetricShadow;                                                      // 0x024C (size: 0x1)
    uint8 bCastDeepShadow;                                                            // 0x024C (size: 0x1)
    uint8 bCastRaytracedShadow;                                                       // 0x024D (size: 0x1)
    TEnumAsByte<ECastRayTracedShadow::Type> CastRaytracedShadow;                      // 0x0250 (size: 0x1)
    uint8 bAffectReflection;                                                          // 0x0254 (size: 0x1)
    uint8 bAffectGlobalIllumination;                                                  // 0x0254 (size: 0x1)
    float DeepShadowLayerDistribution;                                                // 0x0258 (size: 0x4)
    float IndirectLightingIntensity;                                                  // 0x025C (size: 0x4)
    float VolumetricScatteringIntensity;                                              // 0x0260 (size: 0x4)
    int32 SamplesPerPixel;                                                            // 0x0264 (size: 0x4)

    void SetSamplesPerPixel(int32 NewValue);
    void SetCastVolumetricShadow(bool bNewValue);
    void SetCastShadows(bool bNewValue);
    void SetCastRaytracedShadows(TEnumAsByte<ECastRayTracedShadow::Type> bNewValue);
    void SetCastRaytracedShadow(bool bNewValue);
    void SetCastDeepShadow(bool bNewValue);
    void SetAffectReflection(bool bNewValue);
    void SetAffectGlobalIllumination(bool bNewValue);
    FLinearColor GetLightColor();
}; // Size: 0x270

class ULightMapTexture2D : public UTexture2D
{
}; // Size: 0x158

class ULightMapVirtualTexture : public UVirtualTexture
{
}; // Size: 0x28

class ULightMapVirtualTexture2D : public UTexture2D
{
    TArray<int8> TypeToLayer;                                                         // 0x0150 (size: 0x10)

}; // Size: 0x168

class ULightWeightInstanceBlueprintFunctionLibrary : public UBlueprintFunctionLibrary
{

    FActorInstanceHandle CreateNewLightWeightInstance(UClass* ActorClass, FTransform Transform, class UDataLayerInstance* Layer, class UWorld* World);
    FActorInstanceHandle ConvertActorToLightWeightInstance(class AActor* Actor);
}; // Size: 0x28

class ULightmappedSurfaceCollection : public UObject
{
    class UModel* SourceModel;                                                        // 0x0028 (size: 0x8)
    TArray<int32> Surfaces;                                                           // 0x0030 (size: 0x10)

}; // Size: 0x40

class ULightmassPortalComponent : public USceneComponent
{
    class UBoxComponent* PreviewBox;                                                  // 0x0230 (size: 0x8)

}; // Size: 0x240

class ULightmassPrimitiveSettingsObject : public UObject
{
    FLightmassPrimitiveSettings LightmassSettings;                                    // 0x0028 (size: 0x18)

}; // Size: 0x40

class ULineBatchComponent : public UPrimitiveComponent
{
}; // Size: 0x560

class ULocalFogVolumeComponent : public USceneComponent
{
    float RadialFogExtinction;                                                        // 0x0230 (size: 0x4)
    float HeightFogExtinction;                                                        // 0x0234 (size: 0x4)
    float HeightFogFalloff;                                                           // 0x0238 (size: 0x4)
    float HeightFogOffset;                                                            // 0x023C (size: 0x4)
    float FogPhaseG;                                                                  // 0x0240 (size: 0x4)
    FLinearColor FogAlbedo;                                                           // 0x0244 (size: 0x10)
    FLinearColor FogEmissive;                                                         // 0x0254 (size: 0x10)
    int32 FogSortPriority;                                                            // 0x0264 (size: 0x4)

    void SetRadialFogExtinction(float NewValue);
    void SetHeightFogOffset(float NewValue);
    void SetHeightFogFalloff(float NewValue);
    void SetHeightFogExtinction(float NewValue);
    void SetFogPhaseG(float NewValue);
    void SetFogEmissive(FLinearColor NewValue);
    void SetFogAlbedo(FLinearColor NewValue);
}; // Size: 0x270

class ULocalLightComponent : public ULightComponent
{
    ELightUnits IntensityUnits;                                                       // 0x0370 (size: 0x1)
    float InverseExposureBlend;                                                       // 0x0374 (size: 0x4)
    float Radius;                                                                     // 0x0378 (size: 0x4)
    float AttenuationRadius;                                                          // 0x037C (size: 0x4)
    FLightmassPointLightSettings LightmassSettings;                                   // 0x0380 (size: 0xC)

    void SetIntensityUnits(ELightUnits NewIntensityUnits);
    void SetAttenuationRadius(float NewRadius);
    float GetUnitsConversionFactor(ELightUnits SrcUnits, ELightUnits TargetUnits, float CosHalfConeAngle);
}; // Size: 0x390

class ULocalMessage : public UObject
{
}; // Size: 0x28

class ULocalPlayer : public UPlayer
{
    class UGameViewportClient* ViewportClient;                                        // 0x0078 (size: 0x8)
    TEnumAsByte<EAspectRatioAxisConstraint> AspectRatioAxisConstraint;                // 0x00B8 (size: 0x1)
    TSubclassOf<class APlayerController> PendingLevelPlayerControllerClass;           // 0x00C0 (size: 0x8)
    uint8 bSentSplitJoin;                                                             // 0x00C8 (size: 0x1)
    int32 ControllerId;                                                               // 0x00E0 (size: 0x4)

}; // Size: 0x2B0

class ULocalPlayerSaveGame : public USaveGame
{
    class ULocalPlayer* OwningPlayer;                                                 // 0x0028 (size: 0x8)
    FString SaveSlotName;                                                             // 0x0030 (size: 0x10)
    int32 SavedDataVersion;                                                           // 0x0040 (size: 0x4)
    int32 LoadedDataVersion;                                                          // 0x0044 (size: 0x4)
    int32 CurrentSaveRequest;                                                         // 0x0048 (size: 0x4)
    int32 LastSuccessfulSaveRequest;                                                  // 0x004C (size: 0x4)
    int32 LastErrorSaveRequest;                                                       // 0x0050 (size: 0x4)

    bool WasSaveRequested();
    bool WasLoaded();
    bool WasLastSaveSuccessful();
    bool SaveGameToSlotForLocalPlayer();
    void ResetToDefault();
    void OnResetToDefault();
    void OnPreSave();
    void OnPostSave(bool bSuccess);
    void OnPostLoad();
    class ULocalPlayerSaveGame* LoadOrCreateSaveGameForLocalPlayer(TSubclassOf<class ULocalPlayerSaveGame> SaveGameClass, class APlayerController* LocalPlayerController, FString SlotName);
    bool IsSaveInProgress();
    FString GetSaveSlotName();
    int32 GetSavedDataVersion();
    int32 GetPlatformUserIndex();
    FPlatformUserId GetPlatformUserId();
    class APlayerController* GetLocalPlayerController();
    int32 GetLatestDataVersion();
    int32 GetInvalidDataVersion();
    bool AsyncSaveGameToSlotForLocalPlayer();
    bool AsyncLoadOrCreateSaveGameForLocalPlayer(TSubclassOf<class ULocalPlayerSaveGame> SaveGameClass, class APlayerController* LocalPlayerController, FString SlotName, FAsyncLoadOrCreateSaveGameForLocalPlayerDelegate Delegate);
}; // Size: 0x58

class ULocalPlayerSubsystem : public USubsystem
{
}; // Size: 0x30

class UMapBuildDataRegistry : public UObject
{
    TEnumAsByte<ELightingBuildQuality> LevelLightingQuality;                          // 0x0028 (size: 0x1)

}; // Size: 0x230

class UMaterial : public UMaterialInterface
{
    class UPhysicalMaterial* PhysMaterial;                                            // 0x00C8 (size: 0x8)
    class UPhysicalMaterialMask* PhysMaterialMask;                                    // 0x00D0 (size: 0x8)
    class UPhysicalMaterial* PhysicalMaterialMap;                                     // 0x00D8 (size: 0x40)
    TArray<class UPhysicalMaterial*> RenderTracePhysicalMaterialOutputs;              // 0x0118 (size: 0x10)
    TEnumAsByte<EMaterialDomain> MaterialDomain;                                      // 0x0128 (size: 0x1)
    TEnumAsByte<EBlendMode> BlendMode;                                                // 0x0129 (size: 0x1)
    TEnumAsByte<EDecalBlendMode> DecalBlendMode;                                      // 0x012A (size: 0x1)
    TEnumAsByte<EMaterialDecalResponse> MaterialDecalResponse;                        // 0x012B (size: 0x1)
    FMaterialOverrideNanite NaniteOverrideMaterial;                                   // 0x0130 (size: 0x38)
    FDisplacementScaling DisplacementScaling;                                         // 0x0168 (size: 0x8)
    TEnumAsByte<EMaterialShadingModel> ShadingModel;                                  // 0x0170 (size: 0x1)
    uint8 bCastDynamicShadowAsMasked;                                                 // 0x0171 (size: 0x1)
    FMaterialShadingModelField ShadingModels;                                         // 0x0172 (size: 0x2)
    float OpacityMaskClipValue;                                                       // 0x0174 (size: 0x4)
    uint8 bEnableSeparateTranslucency;                                                // 0x0178 (size: 0x1)
    uint8 bEnableResponsiveAA;                                                        // 0x0178 (size: 0x1)
    uint8 bScreenSpaceReflections;                                                    // 0x0178 (size: 0x1)
    uint8 bContactShadows;                                                            // 0x0178 (size: 0x1)
    uint8 TwoSided;                                                                   // 0x0178 (size: 0x1)
    uint8 bIsThinSurface;                                                             // 0x0178 (size: 0x1)
    uint8 DitheredLODTransition;                                                      // 0x0178 (size: 0x1)
    uint8 DitherOpacityMask;                                                          // 0x0178 (size: 0x1)
    uint8 bAllowNegativeEmissiveColor;                                                // 0x0179 (size: 0x1)
    uint8 bHasPixelAnimation;                                                         // 0x0179 (size: 0x1)
    uint8 bEnableTessellation;                                                        // 0x0179 (size: 0x1)
    TEnumAsByte<EMaterialTranslucencyPass> TranslucencyPass;                          // 0x017A (size: 0x1)
    TEnumAsByte<ETranslucencyLightingMode> TranslucencyLightingMode;                  // 0x017B (size: 0x1)
    uint8 bEnableMobileSeparateTranslucency;                                          // 0x017C (size: 0x1)
    int32 NumCustomizedUVs;                                                           // 0x0180 (size: 0x4)
    float TranslucencyDirectionalLightingIntensity;                                   // 0x0184 (size: 0x4)
    float TranslucentShadowDensityScale;                                              // 0x0188 (size: 0x4)
    float TranslucentSelfShadowDensityScale;                                          // 0x018C (size: 0x4)
    float TranslucentSelfShadowSecondDensityScale;                                    // 0x0190 (size: 0x4)
    float TranslucentSelfShadowSecondOpacity;                                         // 0x0194 (size: 0x4)
    float TranslucentBackscatteringExponent;                                          // 0x0198 (size: 0x4)
    FLinearColor TranslucentMultipleScatteringExtinction;                             // 0x019C (size: 0x10)
    float TranslucentShadowStartOffset;                                               // 0x01AC (size: 0x4)
    uint8 bDisableDepthTest;                                                          // 0x01B0 (size: 0x1)
    uint8 bWriteOnlyAlpha;                                                            // 0x01B0 (size: 0x1)
    uint8 bGenerateSphericalParticleNormals;                                          // 0x01B0 (size: 0x1)
    uint8 bTangentSpaceNormal;                                                        // 0x01B0 (size: 0x1)
    uint8 bUseEmissiveForDynamicAreaLighting;                                         // 0x01B0 (size: 0x1)
    uint8 bUsedAsSpecialEngineMaterial;                                               // 0x01B0 (size: 0x1)
    uint8 bUsedWithSkeletalMesh;                                                      // 0x01B0 (size: 0x1)
    uint8 bUsedWithEditorCompositing;                                                 // 0x01B0 (size: 0x1)
    uint8 bUsedWithParticleSprites;                                                   // 0x01B1 (size: 0x1)
    uint8 bUsedWithBeamTrails;                                                        // 0x01B1 (size: 0x1)
    uint8 bUsedWithMeshParticles;                                                     // 0x01B1 (size: 0x1)
    uint8 bUsedWithNiagaraSprites;                                                    // 0x01B1 (size: 0x1)
    uint8 bUsedWithNiagaraRibbons;                                                    // 0x01B1 (size: 0x1)
    uint8 bUsedWithNiagaraMeshParticles;                                              // 0x01B1 (size: 0x1)
    uint8 bUsedWithGeometryCache;                                                     // 0x01B1 (size: 0x1)
    uint8 bUsedWithStaticLighting;                                                    // 0x01B1 (size: 0x1)
    uint8 bUsedWithMorphTargets;                                                      // 0x01B2 (size: 0x1)
    uint8 bUsedWithSplineMeshes;                                                      // 0x01B2 (size: 0x1)
    uint8 bUsedWithInstancedStaticMeshes;                                             // 0x01B2 (size: 0x1)
    uint8 bUsedWithGeometryCollections;                                               // 0x01B2 (size: 0x1)
    uint8 bUsesDistortion;                                                            // 0x01B2 (size: 0x1)
    uint8 bRootNodeOverridesDefaultDistortion;                                        // 0x01B2 (size: 0x1)
    uint8 bUsedWithClothing;                                                          // 0x01B2 (size: 0x1)
    uint8 bUsedWithWater;                                                             // 0x01B4 (size: 0x1)
    uint8 bUsedWithHairStrands;                                                       // 0x01B4 (size: 0x1)
    uint8 bUsedWithLidarPointCloud;                                                   // 0x01B4 (size: 0x1)
    uint8 bUsedWithVirtualHeightfieldMesh;                                            // 0x01B4 (size: 0x1)
    uint8 bUsedWithNanite;                                                            // 0x01B4 (size: 0x1)
    uint8 bUsedWithVolumetricCloud;                                                   // 0x01B4 (size: 0x1)
    uint8 bUsedWithHeterogeneousVolumes;                                              // 0x01B4 (size: 0x1)
    uint8 bUsedWithUI;                                                                // 0x01B8 (size: 0x1)
    uint8 bAutomaticallySetUsageInEditor;                                             // 0x01B8 (size: 0x1)
    uint8 bFullyRough;                                                                // 0x01B8 (size: 0x1)
    uint8 bUseFullPrecision;                                                          // 0x01B8 (size: 0x1)
    TEnumAsByte<EMaterialFloatPrecisionMode> FloatPrecisionMode;                      // 0x01B9 (size: 0x1)
    uint8 bUseLightmapDirectionality;                                                 // 0x01BA (size: 0x1)
    uint8 bMobileEnableHighQualityBRDF;                                               // 0x01BA (size: 0x1)
    uint8 bUseAlphaToCoverage;                                                        // 0x01BA (size: 0x1)
    uint8 bForwardRenderUsePreintegratedGFForSimpleIBL;                               // 0x01BC (size: 0x1)
    uint8 bUseHQForwardReflections;                                                   // 0x01C0 (size: 0x1)
    uint8 bForwardBlendsSkyLightCubemaps;                                             // 0x01C0 (size: 0x1)
    uint8 bUsePlanarForwardReflections;                                               // 0x01C0 (size: 0x1)
    uint8 bNormalCurvatureToRoughness;                                                // 0x01C0 (size: 0x1)
    uint8 AllowTranslucentCustomDepthWrites;                                          // 0x01C0 (size: 0x1)
    uint8 bAllowFrontLayerTranslucency;                                               // 0x01C0 (size: 0x1)
    uint8 Wireframe;                                                                  // 0x01C0 (size: 0x1)
    TEnumAsByte<EMaterialShadingRate> ShadingRate;                                    // 0x01C1 (size: 0x1)
    uint8 bAllowVariableRateShading;                                                  // 0x01C2 (size: 0x1)
    uint8 bCanMaskedBeAssumedOpaque;                                                  // 0x01C2 (size: 0x1)
    uint8 bIsMasked;                                                                  // 0x01C2 (size: 0x1)
    uint8 bIsPreviewMaterial;                                                         // 0x01C2 (size: 0x1)
    uint8 bIsFunctionPreviewMaterial;                                                 // 0x01C2 (size: 0x1)
    uint8 bUseMaterialAttributes;                                                     // 0x01C2 (size: 0x1)
    uint8 bEnableExecWire;                                                            // 0x01C2 (size: 0x1)
    uint8 bEnableNewHLSLGenerator;                                                    // 0x01C2 (size: 0x1)
    uint8 bCastRayTracedShadows;                                                      // 0x01C3 (size: 0x1)
    uint8 bUseTranslucencyVertexFog;                                                  // 0x01C3 (size: 0x1)
    uint8 bApplyCloudFogging;                                                         // 0x01C3 (size: 0x1)
    uint8 bIsSky;                                                                     // 0x01C3 (size: 0x1)
    uint8 bComputeFogPerPixel;                                                        // 0x01C3 (size: 0x1)
    uint8 bOutputTranslucentVelocity;                                                 // 0x01C3 (size: 0x1)
    uint8 bAllowDevelopmentShaderCompile;                                             // 0x01C3 (size: 0x1)
    uint8 bIsMaterialEditorStatsMaterial;                                             // 0x01C3 (size: 0x1)
    TEnumAsByte<EBlendableLocation> BlendableLocation;                                // 0x01C4 (size: 0x1)
    uint8 BlendableOutputAlpha;                                                       // 0x01C5 (size: 0x1)
    uint8 bUsedWithNeuralNetworks;                                                    // 0x01C5 (size: 0x1)
    uint8 bEnableStencilTest;                                                         // 0x01C5 (size: 0x1)
    TEnumAsByte<EMaterialStencilCompare> StencilCompare;                              // 0x01C6 (size: 0x1)
    uint8 StencilRefValue;                                                            // 0x01C7 (size: 0x1)
    int8 NeuralProfileId;                                                             // 0x01C8 (size: 0x1)
    TEnumAsByte<ERefractionMode> RefractionMode;                                      // 0x01C9 (size: 0x1)
    TEnumAsByte<ERefractionMode> RefractionMethod;                                    // 0x01CA (size: 0x1)
    TEnumAsByte<ERefractionCoverageMode> RefractionCoverageMode;                      // 0x01CB (size: 0x1)
    int32 BlendablePriority;                                                          // 0x01CC (size: 0x4)
    uint8 bIsBlendable;                                                               // 0x01D0 (size: 0x1)
    uint16 PreshaderGap;                                                              // 0x01D2 (size: 0x2)
    uint32 UsageFlagWarnings;                                                         // 0x01D4 (size: 0x4)
    float RefractionDepthBias;                                                        // 0x01DC (size: 0x4)
    float MaxWorldPositionOffsetDisplacement;                                         // 0x01E0 (size: 0x4)
    bool bAlwaysEvaluateWorldPositionOffset;                                          // 0x01E4 (size: 0x1)
    FGuid StateId;                                                                    // 0x01EC (size: 0x10)

}; // Size: 0x230

class UMaterialBillboardComponent : public UPrimitiveComponent
{
    TArray<FMaterialSpriteElement> Elements;                                          // 0x0518 (size: 0x10)

    void SetElements(const TArray<FMaterialSpriteElement>& NewElements);
    void AddElement(class UMaterialInterface* Material, class UCurveFloat* DistanceToOpacityCurve, bool bSizeIsInScreenSpace, float BaseSizeX, float BaseSizeY, class UCurveFloat* DistanceToSizeCurve);
}; // Size: 0x530

class UMaterialEditorOnlyData : public UMaterialInterfaceEditorOnlyData
{
    FColorMaterialInput BaseColor;                                                    // 0x0040 (size: 0x30)
    FScalarMaterialInput Metallic;                                                    // 0x0070 (size: 0x30)
    FScalarMaterialInput Specular;                                                    // 0x00A0 (size: 0x30)
    FScalarMaterialInput Roughness;                                                   // 0x00D0 (size: 0x30)
    FScalarMaterialInput Anisotropy;                                                  // 0x0100 (size: 0x30)
    FVectorMaterialInput Normal;                                                      // 0x0130 (size: 0x38)
    FVectorMaterialInput Tangent;                                                     // 0x0168 (size: 0x38)
    FColorMaterialInput EmissiveColor;                                                // 0x01A0 (size: 0x30)
    FScalarMaterialInput Opacity;                                                     // 0x01D0 (size: 0x30)
    FScalarMaterialInput OpacityMask;                                                 // 0x0200 (size: 0x30)
    FVectorMaterialInput WorldPositionOffset;                                         // 0x0230 (size: 0x38)
    FScalarMaterialInput displacement;                                                // 0x0268 (size: 0x30)
    FColorMaterialInput SubsurfaceColor;                                              // 0x0298 (size: 0x30)
    FScalarMaterialInput ClearCoat;                                                   // 0x02C8 (size: 0x30)
    FScalarMaterialInput ClearCoatRoughness;                                          // 0x02F8 (size: 0x30)
    FScalarMaterialInput AmbientOcclusion;                                            // 0x0328 (size: 0x30)
    FScalarMaterialInput Refraction;                                                  // 0x0358 (size: 0x30)
    FVector2MaterialInput CustomizedUVs;                                              // 0x0388 (size: 0x1C0)
    FMaterialAttributesInput MaterialAttributes;                                      // 0x0548 (size: 0x30)
    FScalarMaterialInput PixelDepthOffset;                                            // 0x0578 (size: 0x30)
    FShadingModelMaterialInput ShadingModelFromMaterialExpression;                    // 0x05A8 (size: 0x28)
    FScalarMaterialInput SurfaceThickness;                                            // 0x05D8 (size: 0x30)
    FSubstrateMaterialInput FrontMaterial;                                            // 0x0608 (size: 0x28)
    FMaterialExpressionCollection ExpressionCollection;                               // 0x0638 (size: 0x30)
    TArray<FParameterGroupData> ParameterGroupData;                                   // 0x0668 (size: 0x10)

}; // Size: 0x678

class UMaterialExpression : public UObject
{
    int32 MaterialExpressionEditorX;                                                  // 0x0028 (size: 0x4)
    int32 MaterialExpressionEditorY;                                                  // 0x002C (size: 0x4)
    class UEdGraphNode* GraphNode;                                                    // 0x0030 (size: 0x8)
    class UMaterialExpression* SubgraphExpression;                                    // 0x0038 (size: 0x8)
    FGuid MaterialExpressionGuid;                                                     // 0x0050 (size: 0x10)
    class UMaterial* Material;                                                        // 0x0060 (size: 0x8)
    class UMaterialFunction* Function;                                                // 0x0068 (size: 0x8)
    FString Desc;                                                                     // 0x0070 (size: 0x10)
    uint8 bRealtimePreview;                                                           // 0x0084 (size: 0x1)
    uint8 bNeedToUpdatePreview;                                                       // 0x0084 (size: 0x1)
    uint8 bIsParameterExpression;                                                     // 0x0088 (size: 0x1)
    uint8 bCommentBubbleVisible;                                                      // 0x008C (size: 0x1)
    uint8 bShowOutputNameOnPin;                                                       // 0x008C (size: 0x1)
    uint8 bShowMaskColorsOnPin;                                                       // 0x008C (size: 0x1)
    uint8 bHidePreviewWindow;                                                         // 0x008C (size: 0x1)
    uint8 bCollapsed;                                                                 // 0x008C (size: 0x1)
    uint8 bShaderInputData;                                                           // 0x008C (size: 0x1)
    uint8 bShowInputs;                                                                // 0x008C (size: 0x1)
    uint8 bShowOutputs;                                                               // 0x008C (size: 0x1)
    TArray<FText> MenuCategories;                                                     // 0x0090 (size: 0x10)
    TArray<FExpressionOutput> Outputs;                                                // 0x00A0 (size: 0x10)

}; // Size: 0xB0

class UMaterialExpressionAbs : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionAbsorptionMediumMaterialOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput TransmittanceColor;                                              // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionActorPositionWS : public UMaterialExpression
{
    EPositionOrigin OriginType;                                                       // 0x00B0 (size: 0x1)

}; // Size: 0xB8

class UMaterialExpressionAdd : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)
    float ConstA;                                                                     // 0x0100 (size: 0x4)
    float ConstB;                                                                     // 0x0104 (size: 0x4)

}; // Size: 0x108

class UMaterialExpressionAntialiasedTextureMask : public UMaterialExpressionTextureSampleParameter2D
{
    float Threshold;                                                                  // 0x0220 (size: 0x4)
    TEnumAsByte<ETextureColorChannel> Channel;                                        // 0x0224 (size: 0x1)

}; // Size: 0x228

class UMaterialExpressionAppendVector : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionArccosine : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionArccosineFast : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionArcsine : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionArcsineFast : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionArctangent : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionArctangent2 : public UMaterialExpression
{
    FExpressionInput Y;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput X;                                                               // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionArctangent2Fast : public UMaterialExpression
{
    FExpressionInput Y;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput X;                                                               // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionArctangentFast : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionAtmosphericFogColor : public UMaterialExpression
{
    FExpressionInput WorldPosition;                                                   // 0x00B0 (size: 0x28)
    EPositionOrigin WorldPositionOriginType;                                          // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionAtmosphericLightColor : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionAtmosphericLightVector : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionBentNormalCustomOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionBinaryOp : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)
    float ConstA;                                                                     // 0x0100 (size: 0x4)
    float ConstB;                                                                     // 0x0104 (size: 0x4)

}; // Size: 0x108

class UMaterialExpressionBlackBody : public UMaterialExpression
{
    FExpressionInput Temp;                                                            // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionBlendMaterialAttributes : public UMaterialExpression
{
    FMaterialAttributesInput A;                                                       // 0x00B0 (size: 0x30)
    FMaterialAttributesInput B;                                                       // 0x00E0 (size: 0x30)
    FExpressionInput Alpha;                                                           // 0x0110 (size: 0x28)
    TEnumAsByte<EMaterialAttributeBlend::Type> PixelAttributeBlendType;               // 0x0138 (size: 0x1)
    TEnumAsByte<EMaterialAttributeBlend::Type> VertexAttributeBlendType;              // 0x0139 (size: 0x1)

}; // Size: 0x140

class UMaterialExpressionBounds : public UMaterialExpression
{
    TEnumAsByte<EMaterialExpressionBoundsType> Type;                                  // 0x00B0 (size: 0x1)

}; // Size: 0xB8

class UMaterialExpressionBreakMaterialAttributes : public UMaterialExpression
{
    FMaterialAttributesInput MaterialAttributes;                                      // 0x00B0 (size: 0x30)

}; // Size: 0xE0

class UMaterialExpressionBumpOffset : public UMaterialExpression
{
    FExpressionInput Coordinate;                                                      // 0x00B0 (size: 0x28)
    FExpressionInput Height;                                                          // 0x00D8 (size: 0x28)
    FExpressionInput HeightRatioInput;                                                // 0x0100 (size: 0x28)
    float HeightRatio;                                                                // 0x0128 (size: 0x4)
    float ReferencePlane;                                                             // 0x012C (size: 0x4)
    uint32 ConstCoordinate;                                                           // 0x0130 (size: 0x4)

}; // Size: 0x138

class UMaterialExpressionCameraPositionWS : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionCameraVectorWS : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionCeil : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionChannelMaskParameter : public UMaterialExpressionVectorParameter
{
    TEnumAsByte<EChannelMaskParameterColor::Type> MaskChannel;                        // 0x0130 (size: 0x1)
    FExpressionInput Input;                                                           // 0x0138 (size: 0x28)

}; // Size: 0x160

class UMaterialExpressionClamp : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)
    FExpressionInput Min;                                                             // 0x00D8 (size: 0x28)
    FExpressionInput Max;                                                             // 0x0100 (size: 0x28)
    TEnumAsByte<EClampMode> ClampMode;                                                // 0x0128 (size: 0x1)
    float MinDefault;                                                                 // 0x012C (size: 0x4)
    float MaxDefault;                                                                 // 0x0130 (size: 0x4)

}; // Size: 0x138

class UMaterialExpressionClearCoatNormalCustomOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionCloudSampleAttribute : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionCollectionParameter : public UMaterialExpression
{
    class UMaterialParameterCollection* Collection;                                   // 0x00B0 (size: 0x8)
    FName ParameterName;                                                              // 0x00B8 (size: 0x8)
    FGuid ParameterId;                                                                // 0x00C0 (size: 0x10)

}; // Size: 0xD0

class UMaterialExpressionComment : public UMaterialExpression
{
    int32 SizeX;                                                                      // 0x00B0 (size: 0x4)
    int32 SizeY;                                                                      // 0x00B4 (size: 0x4)
    FString Text;                                                                     // 0x00B8 (size: 0x10)
    FLinearColor CommentColor;                                                        // 0x00C8 (size: 0x10)
    int32 FontSize;                                                                   // 0x00D8 (size: 0x4)
    uint8 bCommentBubbleVisible_InDetailsPanel;                                       // 0x00DC (size: 0x1)
    uint8 bColorCommentBubble;                                                        // 0x00DC (size: 0x1)
    bool bGroupMode;                                                                  // 0x00E0 (size: 0x1)

}; // Size: 0xE8

class UMaterialExpressionComponentMask : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)
    uint8 R;                                                                          // 0x00D8 (size: 0x1)
    uint8 G;                                                                          // 0x00D8 (size: 0x1)
    uint8 B;                                                                          // 0x00D8 (size: 0x1)
    uint8 A;                                                                          // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionComposite : public UMaterialExpression
{
    FString SubgraphName;                                                             // 0x00B0 (size: 0x10)
    class UMaterialExpressionPinBase* InputExpressions;                               // 0x00C0 (size: 0x8)
    class UMaterialExpressionPinBase* OutputExpressions;                              // 0x00C8 (size: 0x8)

}; // Size: 0xD0

class UMaterialExpressionConstant : public UMaterialExpression
{
    float R;                                                                          // 0x00B0 (size: 0x4)

}; // Size: 0xB8

class UMaterialExpressionConstant2Vector : public UMaterialExpression
{
    float R;                                                                          // 0x00B0 (size: 0x4)
    float G;                                                                          // 0x00B4 (size: 0x4)

}; // Size: 0xB8

class UMaterialExpressionConstant3Vector : public UMaterialExpression
{
    FLinearColor Constant;                                                            // 0x00B0 (size: 0x10)

}; // Size: 0xC0

class UMaterialExpressionConstant4Vector : public UMaterialExpression
{
    FLinearColor Constant;                                                            // 0x00B0 (size: 0x10)

}; // Size: 0xC0

class UMaterialExpressionConstantBiasScale : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)
    float Bias;                                                                       // 0x00D8 (size: 0x4)
    float Scale;                                                                      // 0x00DC (size: 0x4)

}; // Size: 0xE0

class UMaterialExpressionConstantDouble : public UMaterialExpressionGenericConstant
{
    double Value;                                                                     // 0x00B0 (size: 0x8)

}; // Size: 0xB8

class UMaterialExpressionCosine : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)
    float Period;                                                                     // 0x00D8 (size: 0x4)

}; // Size: 0xE0

class UMaterialExpressionCrossProduct : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionCurveAtlasRowParameter : public UMaterialExpressionScalarParameter
{
    class UCurveLinearColor* Curve;                                                   // 0x00E8 (size: 0x8)
    class UCurveLinearColorAtlas* Atlas;                                              // 0x00F0 (size: 0x8)
    FExpressionInput InputTime;                                                       // 0x00F8 (size: 0x28)

}; // Size: 0x120

class UMaterialExpressionCustom : public UMaterialExpression
{
    FString Code;                                                                     // 0x00B0 (size: 0x10)
    TEnumAsByte<ECustomMaterialOutputType> OutputType;                                // 0x00C0 (size: 0x1)
    FString Description;                                                              // 0x00C8 (size: 0x10)
    TArray<FCustomInput> Inputs;                                                      // 0x00D8 (size: 0x10)
    TArray<FCustomOutput> AdditionalOutputs;                                          // 0x00E8 (size: 0x10)
    TArray<FCustomDefine> AdditionalDefines;                                          // 0x00F8 (size: 0x10)
    TArray<FString> IncludeFilePaths;                                                 // 0x0108 (size: 0x10)
    bool ShowCode;                                                                    // 0x0118 (size: 0x1)

}; // Size: 0x120

class UMaterialExpressionCustomOutput : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionDBufferTexture : public UMaterialExpression
{
    FExpressionInput Coordinates;                                                     // 0x00B0 (size: 0x28)
    TEnumAsByte<EDBufferTextureId> DBufferTextureId;                                  // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionDDX : public UMaterialExpression
{
    FExpressionInput Value;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionDDY : public UMaterialExpression
{
    FExpressionInput Value;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionDataDrivenShaderPlatformInfoSwitch : public UMaterialExpression
{
    FExpressionInput InputTrue;                                                       // 0x00B0 (size: 0x28)
    FExpressionInput InputFalse;                                                      // 0x00D8 (size: 0x28)
    TArray<FDataDrivenShaderPlatformInfoInput> DDSPIPropertyNames;                    // 0x0100 (size: 0x10)
    uint8 bContainsInvalidProperty;                                                   // 0x0110 (size: 0x1)

    TArray<FString> GetNameOptions();
}; // Size: 0x118

class UMaterialExpressionDecalColor : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionDecalDerivative : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionDecalLifetimeOpacity : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionDecalMipmapLevel : public UMaterialExpression
{
    FExpressionInput TextureSize;                                                     // 0x00B0 (size: 0x28)
    float ConstWidth;                                                                 // 0x00D8 (size: 0x4)
    float ConstHeight;                                                                // 0x00DC (size: 0x4)

}; // Size: 0xE0

class UMaterialExpressionDeltaTime : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionDepthFade : public UMaterialExpression
{
    FExpressionInput InOpacity;                                                       // 0x00B0 (size: 0x28)
    FExpressionInput FadeDistance;                                                    // 0x00D8 (size: 0x28)
    float OpacityDefault;                                                             // 0x0100 (size: 0x4)
    float FadeDistanceDefault;                                                        // 0x0104 (size: 0x4)

}; // Size: 0x108

class UMaterialExpressionDepthOfFieldFunction : public UMaterialExpression
{
    TEnumAsByte<EDepthOfFieldFunctionValue> FunctionValue;                            // 0x00B0 (size: 0x1)
    FExpressionInput Depth;                                                           // 0x00B8 (size: 0x28)

}; // Size: 0xE0

class UMaterialExpressionDeriveNormalZ : public UMaterialExpression
{
    FExpressionInput InXY;                                                            // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionDesaturation : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)
    FExpressionInput Fraction;                                                        // 0x00D8 (size: 0x28)
    FLinearColor LuminanceFactors;                                                    // 0x0100 (size: 0x10)

}; // Size: 0x110

class UMaterialExpressionDistance : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionDistanceCullFade : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionDistanceFieldApproxAO : public UMaterialExpression
{
    FExpressionInput Position;                                                        // 0x00B0 (size: 0x28)
    EPositionOrigin WorldPositionOriginType;                                          // 0x00D8 (size: 0x1)
    FExpressionInput Normal;                                                          // 0x00E0 (size: 0x28)
    FExpressionInput BaseDistance;                                                    // 0x0108 (size: 0x28)
    float BaseDistanceDefault;                                                        // 0x0130 (size: 0x4)
    FExpressionInput Radius;                                                          // 0x0138 (size: 0x28)
    float RadiusDefault;                                                              // 0x0160 (size: 0x4)
    uint32 NumSteps;                                                                  // 0x0164 (size: 0x4)
    float StepScaleDefault;                                                           // 0x0168 (size: 0x4)

}; // Size: 0x170

class UMaterialExpressionDistanceFieldGradient : public UMaterialExpression
{
    FExpressionInput Position;                                                        // 0x00B0 (size: 0x28)
    EPositionOrigin WorldPositionOriginType;                                          // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionDistanceFieldsRenderingSwitch : public UMaterialExpression
{
    FExpressionInput No;                                                              // 0x00B0 (size: 0x28)
    FExpressionInput Yes;                                                             // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionDistanceToNearestSurface : public UMaterialExpression
{
    FExpressionInput Position;                                                        // 0x00B0 (size: 0x28)
    EPositionOrigin WorldPositionOriginType;                                          // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionDivide : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)
    float ConstA;                                                                     // 0x0100 (size: 0x4)
    float ConstB;                                                                     // 0x0104 (size: 0x4)

}; // Size: 0x108

class UMaterialExpressionDotProduct : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionDoubleVectorParameter : public UMaterialExpressionParameter
{
    FVector4d DefaultValue;                                                           // 0x00E0 (size: 0x20)

}; // Size: 0x100

class UMaterialExpressionDynamicParameter : public UMaterialExpression
{
    TArray<FString> ParamNames;                                                       // 0x00B0 (size: 0x10)
    FLinearColor DefaultValue;                                                        // 0x00C0 (size: 0x10)
    uint32 ParameterIndex;                                                            // 0x00D0 (size: 0x4)

}; // Size: 0xD8

class UMaterialExpressionExecBegin : public UMaterialExpression
{
    FExpressionExecOutput Exec;                                                       // 0x00B0 (size: 0x8)

}; // Size: 0xB8

class UMaterialExpressionExecEnd : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionExponential : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionExponential2 : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionEyeAdaptation : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionEyeAdaptationInverse : public UMaterialExpression
{
    FExpressionInput LightValueInput;                                                 // 0x00B0 (size: 0x28)
    FExpressionInput AlphaInput;                                                      // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionFeatureLevelSwitch : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x00B0 (size: 0x28)
    FExpressionInput Inputs;                                                          // 0x00D8 (size: 0xC8)

}; // Size: 0x1A0

class UMaterialExpressionFloor : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionFmod : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionFontSample : public UMaterialExpression
{
    class UFont* Font;                                                                // 0x00B0 (size: 0x8)
    int32 FontTexturePage;                                                            // 0x00B8 (size: 0x4)

}; // Size: 0xC0

class UMaterialExpressionFontSampleParameter : public UMaterialExpressionFontSample
{
    FName ParameterName;                                                              // 0x00C0 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x00C8 (size: 0x10)
    FName Group;                                                                      // 0x00D8 (size: 0x8)
    int32 SortPriority;                                                               // 0x00E0 (size: 0x4)

}; // Size: 0xE8

class UMaterialExpressionForLoop : public UMaterialExpression
{
    FExpressionExecOutput LoopBody;                                                   // 0x00B0 (size: 0x8)
    FExpressionExecOutput Completed;                                                  // 0x00B8 (size: 0x8)
    FExpressionInput StartIndex;                                                      // 0x00C0 (size: 0x28)
    FExpressionInput EndIndex;                                                        // 0x00E8 (size: 0x28)
    FExpressionInput IndexStep;                                                       // 0x0110 (size: 0x28)

}; // Size: 0x138

class UMaterialExpressionFrac : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionFresnel : public UMaterialExpression
{
    FExpressionInput ExponentIn;                                                      // 0x00B0 (size: 0x28)
    float Exponent;                                                                   // 0x00D8 (size: 0x4)
    FExpressionInput BaseReflectFractionIn;                                           // 0x00E0 (size: 0x28)
    float BaseReflectFraction;                                                        // 0x0108 (size: 0x4)
    FExpressionInput Normal;                                                          // 0x0110 (size: 0x28)

}; // Size: 0x138

class UMaterialExpressionFunctionInput : public UMaterialExpression
{
    FExpressionInput Preview;                                                         // 0x00B0 (size: 0x28)
    FName InputName;                                                                  // 0x00D8 (size: 0x8)
    FString Description;                                                              // 0x00E0 (size: 0x10)
    FGuid ID;                                                                         // 0x00F0 (size: 0x10)
    TEnumAsByte<EFunctionInputType> InputType;                                        // 0x0100 (size: 0x1)
    FVector4f PreviewValue;                                                           // 0x0110 (size: 0x10)
    uint8 bUsePreviewValueAsDefault;                                                  // 0x0120 (size: 0x1)
    int32 SortPriority;                                                               // 0x0124 (size: 0x4)
    uint8 bCompilingFunctionPreview;                                                  // 0x0128 (size: 0x1)

}; // Size: 0x160

class UMaterialExpressionFunctionOutput : public UMaterialExpression
{
    FName OutputName;                                                                 // 0x00B0 (size: 0x8)
    FString Description;                                                              // 0x00B8 (size: 0x10)
    int32 SortPriority;                                                               // 0x00C8 (size: 0x4)
    FExpressionInput A;                                                               // 0x00D0 (size: 0x28)
    uint8 bLastPreviewed;                                                             // 0x00F8 (size: 0x1)
    FGuid ID;                                                                         // 0x00FC (size: 0x10)

}; // Size: 0x110

class UMaterialExpressionGIReplace : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x00B0 (size: 0x28)
    FExpressionInput StaticIndirect;                                                  // 0x00D8 (size: 0x28)
    FExpressionInput DynamicIndirect;                                                 // 0x0100 (size: 0x28)

}; // Size: 0x128

class UMaterialExpressionGenericConstant : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionGetLocal : public UMaterialExpression
{
    FName LocalName;                                                                  // 0x00B0 (size: 0x8)

}; // Size: 0xB8

class UMaterialExpressionGetMaterialAttributes : public UMaterialExpression
{
    FMaterialAttributesInput MaterialAttributes;                                      // 0x00B0 (size: 0x30)
    TArray<FGuid> AttributeGetTypes;                                                  // 0x00E0 (size: 0x10)

}; // Size: 0xF0

class UMaterialExpressionHairAttributes : public UMaterialExpression
{
    uint8 bUseTangentSpace;                                                           // 0x00B0 (size: 0x1)

}; // Size: 0xB8

class UMaterialExpressionHairColor : public UMaterialExpression
{
    FExpressionInput Melanin;                                                         // 0x00B0 (size: 0x28)
    FExpressionInput Redness;                                                         // 0x00D8 (size: 0x28)
    FExpressionInput DyeColor;                                                        // 0x0100 (size: 0x28)

}; // Size: 0x128

class UMaterialExpressionHsvToRgb : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionIf : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)
    FExpressionInput AGreaterThanB;                                                   // 0x0100 (size: 0x28)
    FExpressionInput AEqualsB;                                                        // 0x0128 (size: 0x28)
    FExpressionInput ALessThanB;                                                      // 0x0150 (size: 0x28)
    float EqualsThreshold;                                                            // 0x0178 (size: 0x4)
    float ConstB;                                                                     // 0x017C (size: 0x4)
    float ConstAEqualsB;                                                              // 0x0180 (size: 0x4)

}; // Size: 0x188

class UMaterialExpressionIfThenElse : public UMaterialExpression
{
    FExpressionExecOutput Then;                                                       // 0x00B0 (size: 0x8)
    FExpressionExecOutput Else;                                                       // 0x00B8 (size: 0x8)
    FExpressionInput Condition;                                                       // 0x00C0 (size: 0x28)

}; // Size: 0xE8

class UMaterialExpressionInverseLinearInterpolate : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)
    FExpressionInput Value;                                                           // 0x0100 (size: 0x28)
    float ConstA;                                                                     // 0x0128 (size: 0x4)
    float ConstB;                                                                     // 0x012C (size: 0x4)
    float ConstValue;                                                                 // 0x0130 (size: 0x4)
    bool bClampResult;                                                                // 0x0134 (size: 0x1)

}; // Size: 0x138

class UMaterialExpressionIsOrthographic : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionLength : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionLess : public UMaterialExpressionBinaryOp
{
}; // Size: 0x108

class UMaterialExpressionLightVector : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionLightmapUVs : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionLightmassReplace : public UMaterialExpression
{
    FExpressionInput Realtime;                                                        // 0x00B0 (size: 0x28)
    FExpressionInput Lightmass;                                                       // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionLinearInterpolate : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)
    FExpressionInput Alpha;                                                           // 0x0100 (size: 0x28)
    float ConstA;                                                                     // 0x0128 (size: 0x4)
    float ConstB;                                                                     // 0x012C (size: 0x4)
    float ConstAlpha;                                                                 // 0x0130 (size: 0x4)

}; // Size: 0x138

class UMaterialExpressionLogarithm : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionLogarithm10 : public UMaterialExpression
{
    FExpressionInput X;                                                               // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionLogarithm2 : public UMaterialExpression
{
    FExpressionInput X;                                                               // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionMakeMaterialAttributes : public UMaterialExpression
{
    FExpressionInput BaseColor;                                                       // 0x00B0 (size: 0x28)
    FExpressionInput Metallic;                                                        // 0x00D8 (size: 0x28)
    FExpressionInput Specular;                                                        // 0x0100 (size: 0x28)
    FExpressionInput Roughness;                                                       // 0x0128 (size: 0x28)
    FExpressionInput Anisotropy;                                                      // 0x0150 (size: 0x28)
    FExpressionInput EmissiveColor;                                                   // 0x0178 (size: 0x28)
    FExpressionInput Opacity;                                                         // 0x01A0 (size: 0x28)
    FExpressionInput OpacityMask;                                                     // 0x01C8 (size: 0x28)
    FExpressionInput Normal;                                                          // 0x01F0 (size: 0x28)
    FExpressionInput Tangent;                                                         // 0x0218 (size: 0x28)
    FExpressionInput WorldPositionOffset;                                             // 0x0240 (size: 0x28)
    FExpressionInput SubsurfaceColor;                                                 // 0x0268 (size: 0x28)
    FExpressionInput ClearCoat;                                                       // 0x0290 (size: 0x28)
    FExpressionInput ClearCoatRoughness;                                              // 0x02B8 (size: 0x28)
    FExpressionInput AmbientOcclusion;                                                // 0x02E0 (size: 0x28)
    FExpressionInput Refraction;                                                      // 0x0308 (size: 0x28)
    FExpressionInput CustomizedUVs;                                                   // 0x0330 (size: 0x140)
    FExpressionInput PixelDepthOffset;                                                // 0x0470 (size: 0x28)
    FExpressionInput ShadingModel;                                                    // 0x0498 (size: 0x28)
    FExpressionInput displacement;                                                    // 0x04C0 (size: 0x28)

}; // Size: 0x4E8

class UMaterialExpressionMapARPassthroughCameraUV : public UMaterialExpression
{
    FExpressionInput Coordinates;                                                     // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionMaterialAttributeLayers : public UMaterialExpression
{
    FMaterialAttributesInput Input;                                                   // 0x00B0 (size: 0x30)
    FMaterialLayersFunctions DefaultLayers;                                           // 0x00E0 (size: 0x100)
    TArray<class UMaterialExpressionMaterialFunctionCall*> LayerCallers;              // 0x01E0 (size: 0x10)
    int32 NumActiveLayerCallers;                                                      // 0x01F0 (size: 0x4)
    TArray<class UMaterialExpressionMaterialFunctionCall*> BlendCallers;              // 0x01F8 (size: 0x10)
    int32 NumActiveBlendCallers;                                                      // 0x0208 (size: 0x4)
    bool bIsLayerGraphBuilt;                                                          // 0x020C (size: 0x1)

}; // Size: 0x218

class UMaterialExpressionMaterialFunctionCall : public UMaterialExpression
{
    class UMaterialFunctionInterface* MaterialFunction;                               // 0x00B0 (size: 0x8)
    TArray<FFunctionExpressionInput> FunctionInputs;                                  // 0x00B8 (size: 0x10)
    TArray<FFunctionExpressionOutput> FunctionOutputs;                                // 0x00C8 (size: 0x10)
    FMaterialParameterInfo FunctionParameterInfo;                                     // 0x00D8 (size: 0x10)

}; // Size: 0xE8

class UMaterialExpressionMaterialLayerOutput : public UMaterialExpressionFunctionOutput
{
}; // Size: 0x110

class UMaterialExpressionMaterialProxyReplace : public UMaterialExpression
{
    FExpressionInput Realtime;                                                        // 0x00B0 (size: 0x28)
    FExpressionInput MaterialProxy;                                                   // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionMax : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)
    float ConstA;                                                                     // 0x0100 (size: 0x4)
    float ConstB;                                                                     // 0x0104 (size: 0x4)

}; // Size: 0x108

class UMaterialExpressionMin : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)
    float ConstA;                                                                     // 0x0100 (size: 0x4)
    float ConstB;                                                                     // 0x0104 (size: 0x4)

}; // Size: 0x108

class UMaterialExpressionMultiply : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)
    float ConstA;                                                                     // 0x0100 (size: 0x4)
    float ConstB;                                                                     // 0x0104 (size: 0x4)

}; // Size: 0x108

class UMaterialExpressionNamedRerouteBase : public UMaterialExpressionRerouteBase
{
}; // Size: 0xB0

class UMaterialExpressionNamedRerouteDeclaration : public UMaterialExpressionNamedRerouteBase
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)
    FName Name;                                                                       // 0x00D8 (size: 0x8)
    FLinearColor NodeColor;                                                           // 0x00E0 (size: 0x10)
    FGuid VariableGuid;                                                               // 0x00F0 (size: 0x10)

}; // Size: 0x100

class UMaterialExpressionNamedRerouteUsage : public UMaterialExpressionNamedRerouteBase
{
    class UMaterialExpressionNamedRerouteDeclaration* Declaration;                    // 0x00B0 (size: 0x8)
    FGuid DeclarationGuid;                                                            // 0x00B8 (size: 0x10)

}; // Size: 0xC8

class UMaterialExpressionNaniteReplace : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x00B0 (size: 0x28)
    FExpressionInput Nanite;                                                          // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionNeuralNetworkInput : public UMaterialExpressionCustomOutput
{
    FExpressionInput Coordinates;                                                     // 0x00B0 (size: 0x28)
    FExpressionInput Input0;                                                          // 0x00D8 (size: 0x28)
    FExpressionInput Mask;                                                            // 0x0100 (size: 0x28)
    TEnumAsByte<ENeuralIndexType> NeuralIndexType;                                    // 0x0128 (size: 0x1)

}; // Size: 0x130

class UMaterialExpressionNeuralNetworkOutput : public UMaterialExpression
{
    FExpressionInput Coordinates;                                                     // 0x00B0 (size: 0x28)
    TEnumAsByte<ENeuralIndexType> NeuralIndexType;                                    // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionNoise : public UMaterialExpression
{
    FExpressionInput Position;                                                        // 0x00B0 (size: 0x28)
    EPositionOrigin WorldPositionOriginType;                                          // 0x00D8 (size: 0x1)
    FExpressionInput FilterWidth;                                                     // 0x00E0 (size: 0x28)
    float Scale;                                                                      // 0x0108 (size: 0x4)
    int32 Quality;                                                                    // 0x010C (size: 0x4)
    TEnumAsByte<ENoiseFunction> NoiseFunction;                                        // 0x0110 (size: 0x1)
    uint8 bTurbulence;                                                                // 0x0114 (size: 0x1)
    int32 Levels;                                                                     // 0x0118 (size: 0x4)
    float OutputMin;                                                                  // 0x011C (size: 0x4)
    float OutputMax;                                                                  // 0x0120 (size: 0x4)
    float LevelScale;                                                                 // 0x0124 (size: 0x4)
    uint8 bTiling;                                                                    // 0x0128 (size: 0x1)
    uint32 RepeatSize;                                                                // 0x012C (size: 0x4)

}; // Size: 0x130

class UMaterialExpressionNormalize : public UMaterialExpression
{
    FExpressionInput VectorInput;                                                     // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionObjectBounds : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionObjectLocalBounds : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionObjectOrientation : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionObjectPositionWS : public UMaterialExpression
{
    EPositionOrigin OriginType;                                                       // 0x00B0 (size: 0x1)

}; // Size: 0xB8

class UMaterialExpressionObjectRadius : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionOneMinus : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionPanner : public UMaterialExpression
{
    FExpressionInput Coordinate;                                                      // 0x00B0 (size: 0x28)
    FExpressionInput Time;                                                            // 0x00D8 (size: 0x28)
    FExpressionInput Speed;                                                           // 0x0100 (size: 0x28)
    float SpeedX;                                                                     // 0x0128 (size: 0x4)
    float SpeedY;                                                                     // 0x012C (size: 0x4)
    uint32 ConstCoordinate;                                                           // 0x0130 (size: 0x4)
    bool bFractionalPart;                                                             // 0x0134 (size: 0x1)

}; // Size: 0x138

class UMaterialExpressionParameter : public UMaterialExpression
{
    FName ParameterName;                                                              // 0x00B0 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x00B8 (size: 0x10)
    FName Group;                                                                      // 0x00C8 (size: 0x8)
    int32 SortPriority;                                                               // 0x00D0 (size: 0x4)

}; // Size: 0xD8

class UMaterialExpressionParticleColor : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionParticleDirection : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionParticleMacroUV : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionParticleMotionBlurFade : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionParticlePositionWS : public UMaterialExpression
{
    EPositionOrigin OriginType;                                                       // 0x00B0 (size: 0x1)

}; // Size: 0xB8

class UMaterialExpressionParticleRadius : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionParticleRandom : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionParticleRelativeTime : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionParticleSize : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionParticleSpeed : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionParticleSpriteRotation : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionParticleSubUV : public UMaterialExpressionTextureSample
{
    uint8 bBlend;                                                                     // 0x01B8 (size: 0x1)

}; // Size: 0x1C0

class UMaterialExpressionParticleSubUVProperties : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionPathTracingBufferTexture : public UMaterialExpression
{
    FExpressionInput Coordinates;                                                     // 0x00B0 (size: 0x28)
    TEnumAsByte<EPathTracingBufferTextureId> PathTracingBufferTextureId;              // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionPathTracingQualitySwitch : public UMaterialExpression
{
    FExpressionInput Normal;                                                          // 0x00B0 (size: 0x28)
    FExpressionInput PathTraced;                                                      // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionPathTracingRayTypeSwitch : public UMaterialExpression
{
    FExpressionInput Main;                                                            // 0x00B0 (size: 0x28)
    FExpressionInput Shadow;                                                          // 0x00D8 (size: 0x28)
    FExpressionInput IndirectDiffuse;                                                 // 0x0100 (size: 0x28)
    FExpressionInput IndirectSpecular;                                                // 0x0128 (size: 0x28)
    FExpressionInput IndirectVolume;                                                  // 0x0150 (size: 0x28)

}; // Size: 0x178

class UMaterialExpressionPerInstanceCustomData : public UMaterialExpression
{
    FExpressionInput DefaultValue;                                                    // 0x00B0 (size: 0x28)
    float ConstDefaultValue;                                                          // 0x00D8 (size: 0x4)
    uint32 DataIndex;                                                                 // 0x00DC (size: 0x4)

}; // Size: 0xE0

class UMaterialExpressionPerInstanceCustomData3Vector : public UMaterialExpression
{
    FExpressionInput DefaultValue;                                                    // 0x00B0 (size: 0x28)
    FLinearColor ConstDefaultValue;                                                   // 0x00D8 (size: 0x10)
    uint32 DataIndex;                                                                 // 0x00E8 (size: 0x4)

}; // Size: 0xF0

class UMaterialExpressionPerInstanceFadeAmount : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionPerInstanceRandom : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionPinBase : public UMaterialExpression
{
    TArray<FCompositeReroute> ReroutePins;                                            // 0x00B0 (size: 0x10)
    TEnumAsByte<EEdGraphPinDirection> PinDirection;                                   // 0x00C0 (size: 0x1)

}; // Size: 0xC8

class UMaterialExpressionPixelDepth : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionPixelNormalWS : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionPower : public UMaterialExpression
{
    FExpressionInput base;                                                            // 0x00B0 (size: 0x28)
    FExpressionInput Exponent;                                                        // 0x00D8 (size: 0x28)
    float ConstExponent;                                                              // 0x0100 (size: 0x4)

}; // Size: 0x108

class UMaterialExpressionPreSkinnedLocalBounds : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionPreSkinnedNormal : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionPreSkinnedPosition : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionPrecomputedAOMask : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionPreviousFrameSwitch : public UMaterialExpression
{
    FExpressionInput CurrentFrame;                                                    // 0x00B0 (size: 0x28)
    FExpressionInput PreviousFrame;                                                   // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionQualitySwitch : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x00B0 (size: 0x28)
    FExpressionInput Inputs;                                                          // 0x00D8 (size: 0xA0)

}; // Size: 0x178

class UMaterialExpressionRayTracingQualitySwitch : public UMaterialExpression
{
    FExpressionInput Normal;                                                          // 0x00B0 (size: 0x28)
    FExpressionInput RayTraced;                                                       // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionReflectionCapturePassSwitch : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x00B0 (size: 0x28)
    FExpressionInput Reflection;                                                      // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionReflectionVectorWS : public UMaterialExpression
{
    FExpressionInput CustomWorldNormal;                                               // 0x00B0 (size: 0x28)
    uint8 bNormalizeCustomWorldNormal;                                                // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionRequiredSamplersSwitch : public UMaterialExpression
{
    FExpressionInput InputTrue;                                                       // 0x00B0 (size: 0x28)
    FExpressionInput InputFalse;                                                      // 0x00D8 (size: 0x28)
    uint32 RequiredSamplers;                                                          // 0x0100 (size: 0x4)

}; // Size: 0x108

class UMaterialExpressionReroute : public UMaterialExpressionRerouteBase
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionRerouteBase : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionRgbToHsv : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionRotateAboutAxis : public UMaterialExpression
{
    FExpressionInput NormalizedRotationAxis;                                          // 0x00B0 (size: 0x28)
    FExpressionInput RotationAngle;                                                   // 0x00D8 (size: 0x28)
    FExpressionInput PivotPoint;                                                      // 0x0100 (size: 0x28)
    FExpressionInput Position;                                                        // 0x0128 (size: 0x28)
    float Period;                                                                     // 0x0150 (size: 0x4)

}; // Size: 0x158

class UMaterialExpressionRotator : public UMaterialExpression
{
    FExpressionInput Coordinate;                                                      // 0x00B0 (size: 0x28)
    FExpressionInput Time;                                                            // 0x00D8 (size: 0x28)
    float CenterX;                                                                    // 0x0100 (size: 0x4)
    float CenterY;                                                                    // 0x0104 (size: 0x4)
    float Speed;                                                                      // 0x0108 (size: 0x4)
    uint32 ConstCoordinate;                                                           // 0x010C (size: 0x4)

}; // Size: 0x110

class UMaterialExpressionRound : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionRuntimeVirtualTextureOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput BaseColor;                                                       // 0x00B0 (size: 0x28)
    FExpressionInput Specular;                                                        // 0x00D8 (size: 0x28)
    FExpressionInput Roughness;                                                       // 0x0100 (size: 0x28)
    FExpressionInput Normal;                                                          // 0x0128 (size: 0x28)
    FExpressionInput WorldHeight;                                                     // 0x0150 (size: 0x28)
    FExpressionInput Opacity;                                                         // 0x0178 (size: 0x28)
    FExpressionInput Mask;                                                            // 0x01A0 (size: 0x28)
    FExpressionInput displacement;                                                    // 0x01C8 (size: 0x28)

}; // Size: 0x1F0

class UMaterialExpressionRuntimeVirtualTextureReplace : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x00B0 (size: 0x28)
    FExpressionInput VirtualTextureOutput;                                            // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionRuntimeVirtualTextureSample : public UMaterialExpression
{
    FExpressionInput Coordinates;                                                     // 0x00B0 (size: 0x28)
    FExpressionInput WorldPosition;                                                   // 0x00D8 (size: 0x28)
    FExpressionInput MipValue;                                                        // 0x0100 (size: 0x28)
    class URuntimeVirtualTexture* VirtualTexture;                                     // 0x0128 (size: 0x8)
    ERuntimeVirtualTextureMaterialType MaterialType;                                  // 0x0130 (size: 0x1)
    bool bSinglePhysicalSpace;                                                        // 0x0131 (size: 0x1)
    bool bAdaptive;                                                                   // 0x0132 (size: 0x1)
    bool bEnableFeedback;                                                             // 0x0133 (size: 0x1)
    EPositionOrigin WorldPositionOriginType;                                          // 0x0134 (size: 0x1)
    TEnumAsByte<ERuntimeVirtualTextureMipValueMode> MipValueMode;                     // 0x0135 (size: 0x1)
    TEnumAsByte<ERuntimeVirtualTextureTextureAddressMode> TextureAddressMode;         // 0x0136 (size: 0x1)

}; // Size: 0x138

class UMaterialExpressionRuntimeVirtualTextureSampleParameter : public UMaterialExpressionRuntimeVirtualTextureSample
{
    FName ParameterName;                                                              // 0x0138 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x0140 (size: 0x10)
    FName Group;                                                                      // 0x0150 (size: 0x8)
    int32 SortPriority;                                                               // 0x0158 (size: 0x4)

}; // Size: 0x160

class UMaterialExpressionSRGBColorToWorkingColorSpace : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionSamplePhysicsIntegerField : public UMaterialExpression
{
    FExpressionInput WorldPosition;                                                   // 0x00B0 (size: 0x28)
    EPositionOrigin WorldPositionOriginType;                                          // 0x00D8 (size: 0x1)
    TEnumAsByte<EFieldIntegerType> FieldTarget;                                       // 0x00D9 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionSamplePhysicsScalarField : public UMaterialExpression
{
    FExpressionInput WorldPosition;                                                   // 0x00B0 (size: 0x28)
    EPositionOrigin WorldPositionOriginType;                                          // 0x00D8 (size: 0x1)
    TEnumAsByte<EFieldScalarType> FieldTarget;                                        // 0x00D9 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionSamplePhysicsVectorField : public UMaterialExpression
{
    FExpressionInput WorldPosition;                                                   // 0x00B0 (size: 0x28)
    EPositionOrigin WorldPositionOriginType;                                          // 0x00D8 (size: 0x1)
    TEnumAsByte<EFieldVectorType> FieldTarget;                                        // 0x00D9 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionSaturate : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionScalarParameter : public UMaterialExpressionParameter
{
    float DefaultValue;                                                               // 0x00D8 (size: 0x4)
    bool bUseCustomPrimitiveData;                                                     // 0x00DC (size: 0x1)
    uint8 PrimitiveDataIndex;                                                         // 0x00DD (size: 0x1)
    float SliderMin;                                                                  // 0x00E0 (size: 0x4)
    float SliderMax;                                                                  // 0x00E4 (size: 0x4)

}; // Size: 0xE8

class UMaterialExpressionSceneColor : public UMaterialExpression
{
    TEnumAsByte<EMaterialSceneAttributeInputMode::Type> InputMode;                    // 0x00B0 (size: 0x1)
    FExpressionInput Input;                                                           // 0x00B8 (size: 0x28)
    FExpressionInput OffsetFraction;                                                  // 0x00E0 (size: 0x28)
    FVector2D ConstInput;                                                             // 0x0108 (size: 0x10)

}; // Size: 0x118

class UMaterialExpressionSceneDepth : public UMaterialExpression
{
    TEnumAsByte<EMaterialSceneAttributeInputMode::Type> InputMode;                    // 0x00B0 (size: 0x1)
    FExpressionInput Input;                                                           // 0x00B8 (size: 0x28)
    FExpressionInput Coordinates;                                                     // 0x00E0 (size: 0x28)
    FVector2D ConstInput;                                                             // 0x0108 (size: 0x10)

}; // Size: 0x118

class UMaterialExpressionSceneDepthWithoutWater : public UMaterialExpression
{
    TEnumAsByte<EMaterialSceneAttributeInputMode::Type> InputMode;                    // 0x00B0 (size: 0x1)
    FExpressionInput Input;                                                           // 0x00B8 (size: 0x28)
    FVector2D ConstInput;                                                             // 0x00E0 (size: 0x10)
    float FallbackDepth;                                                              // 0x00F0 (size: 0x4)

}; // Size: 0xF8

class UMaterialExpressionSceneTexelSize : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionSceneTexture : public UMaterialExpression
{
    FExpressionInput Coordinates;                                                     // 0x00B0 (size: 0x28)
    TEnumAsByte<ESceneTextureId> SceneTextureId;                                      // 0x00D8 (size: 0x1)
    bool bFiltered;                                                                   // 0x00D9 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionScreenPosition : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionSetLocal : public UMaterialExpression
{
    FExpressionExecOutput Exec;                                                       // 0x00B0 (size: 0x8)
    FExpressionInput Value;                                                           // 0x00B8 (size: 0x28)
    FName LocalName;                                                                  // 0x00E0 (size: 0x8)

}; // Size: 0xE8

class UMaterialExpressionSetMaterialAttributes : public UMaterialExpression
{
    TArray<FExpressionInput> Inputs;                                                  // 0x00B0 (size: 0x10)
    TArray<FGuid> AttributeSetTypes;                                                  // 0x00C0 (size: 0x10)

}; // Size: 0xD0

class UMaterialExpressionShaderStageSwitch : public UMaterialExpression
{
    FExpressionInput PixelShader;                                                     // 0x00B0 (size: 0x28)
    FExpressionInput VertexShader;                                                    // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionShadingModel : public UMaterialExpression
{
    TEnumAsByte<EMaterialShadingModel> ShadingModel;                                  // 0x00B0 (size: 0x1)

}; // Size: 0xB8

class UMaterialExpressionShadingPathSwitch : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x00B0 (size: 0x28)
    FExpressionInput Inputs;                                                          // 0x00D8 (size: 0x78)

}; // Size: 0x150

class UMaterialExpressionShadowReplace : public UMaterialExpression
{
    FExpressionInput Default;                                                         // 0x00B0 (size: 0x28)
    FExpressionInput Shadow;                                                          // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionSign : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionSine : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)
    float Period;                                                                     // 0x00D8 (size: 0x4)

}; // Size: 0xE0

class UMaterialExpressionSingleLayerWaterMaterialOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput ScatteringCoefficients;                                          // 0x00B0 (size: 0x28)
    FExpressionInput AbsorptionCoefficients;                                          // 0x00D8 (size: 0x28)
    FExpressionInput PhaseG;                                                          // 0x0100 (size: 0x28)
    FExpressionInput ColorScaleBehindWater;                                           // 0x0128 (size: 0x28)

}; // Size: 0x150

class UMaterialExpressionSkyAtmosphereAerialPerspective : public UMaterialExpression
{
    FExpressionInput WorldPosition;                                                   // 0x00B0 (size: 0x28)
    EPositionOrigin WorldPositionOriginType;                                          // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionSkyAtmosphereDistantLightScatteredLuminance : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionSkyAtmosphereLightDirection : public UMaterialExpression
{
    int32 LightIndex;                                                                 // 0x00B0 (size: 0x4)

}; // Size: 0xB8

class UMaterialExpressionSkyAtmosphereLightDiskLuminance : public UMaterialExpression
{
    int32 LightIndex;                                                                 // 0x00B0 (size: 0x4)
    FExpressionInput DiskAngularDiameterOverride;                                     // 0x00B8 (size: 0x28)

}; // Size: 0xE0

class UMaterialExpressionSkyAtmosphereLightIlluminance : public UMaterialExpression
{
    int32 LightIndex;                                                                 // 0x00B0 (size: 0x4)
    FExpressionInput WorldPosition;                                                   // 0x00B8 (size: 0x28)
    EPositionOrigin WorldPositionOriginType;                                          // 0x00E0 (size: 0x1)

}; // Size: 0xE8

class UMaterialExpressionSkyAtmosphereLightIlluminanceOnGround : public UMaterialExpression
{
    int32 LightIndex;                                                                 // 0x00B0 (size: 0x4)

}; // Size: 0xB8

class UMaterialExpressionSkyAtmosphereViewLuminance : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionSkyLightEnvMapSample : public UMaterialExpression
{
    FExpressionInput Direction;                                                       // 0x00B0 (size: 0x28)
    FExpressionInput Roughness;                                                       // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionSmoothStep : public UMaterialExpression
{
    FExpressionInput Min;                                                             // 0x00B0 (size: 0x28)
    FExpressionInput Max;                                                             // 0x00D8 (size: 0x28)
    FExpressionInput Value;                                                           // 0x0100 (size: 0x28)
    float ConstMin;                                                                   // 0x0128 (size: 0x4)
    float ConstMax;                                                                   // 0x012C (size: 0x4)
    float ConstValue;                                                                 // 0x0130 (size: 0x4)

}; // Size: 0x138

class UMaterialExpressionSobol : public UMaterialExpression
{
    FExpressionInput Cell;                                                            // 0x00B0 (size: 0x28)
    FExpressionInput Index;                                                           // 0x00D8 (size: 0x28)
    FExpressionInput Seed;                                                            // 0x0100 (size: 0x28)
    uint32 ConstIndex;                                                                // 0x0128 (size: 0x4)
    FVector2D ConstSeed;                                                              // 0x0130 (size: 0x10)

}; // Size: 0x140

class UMaterialExpressionSparseVolumeTextureBase : public UMaterialExpression
{
    class USparseVolumeTexture* SparseVolumeTexture;                                  // 0x00B0 (size: 0x8)

}; // Size: 0xB8

class UMaterialExpressionSparseVolumeTextureObject : public UMaterialExpressionSparseVolumeTextureBase
{
}; // Size: 0xB8

class UMaterialExpressionSparseVolumeTextureObjectParameter : public UMaterialExpressionSparseVolumeTextureSampleParameter
{
}; // Size: 0x160

class UMaterialExpressionSparseVolumeTextureSample : public UMaterialExpressionSparseVolumeTextureBase
{
    FExpressionInput Coordinates;                                                     // 0x00B8 (size: 0x28)
    FExpressionInput TextureObject;                                                   // 0x00E0 (size: 0x28)
    FExpressionInput MipLevel;                                                        // 0x0108 (size: 0x28)
    TEnumAsByte<ESamplerSourceMode> SamplerSource;                                    // 0x0130 (size: 0x1)

}; // Size: 0x138

class UMaterialExpressionSparseVolumeTextureSampleParameter : public UMaterialExpressionSparseVolumeTextureSample
{
    FName ParameterName;                                                              // 0x0138 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x0140 (size: 0x10)
    FName Group;                                                                      // 0x0150 (size: 0x8)
    int32 SortPriority;                                                               // 0x0158 (size: 0x4)

}; // Size: 0x160

class UMaterialExpressionSpeedTree : public UMaterialExpression
{
    FExpressionInput GeometryInput;                                                   // 0x00B0 (size: 0x28)
    FExpressionInput WindInput;                                                       // 0x00D8 (size: 0x28)
    FExpressionInput LODInput;                                                        // 0x0100 (size: 0x28)
    FExpressionInput ExtraBendWS;                                                     // 0x0128 (size: 0x28)
    TEnumAsByte<ESpeedTreeGeometryType> GeometryType;                                 // 0x0150 (size: 0x1)
    TEnumAsByte<ESpeedTreeWindType> WindType;                                         // 0x0151 (size: 0x1)
    TEnumAsByte<ESpeedTreeLODType> LODType;                                           // 0x0152 (size: 0x1)
    float BillboardThreshold;                                                         // 0x0154 (size: 0x4)
    bool bAccurateWindVelocities;                                                     // 0x0158 (size: 0x1)

}; // Size: 0x160

class UMaterialExpressionSphereMask : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)
    FExpressionInput Radius;                                                          // 0x0100 (size: 0x28)
    FExpressionInput Hardness;                                                        // 0x0128 (size: 0x28)
    float AttenuationRadius;                                                          // 0x0150 (size: 0x4)
    float HardnessPercent;                                                            // 0x0154 (size: 0x4)

}; // Size: 0x158

class UMaterialExpressionSphericalParticleOpacity : public UMaterialExpression
{
    FExpressionInput Density;                                                         // 0x00B0 (size: 0x28)
    float ConstantDensity;                                                            // 0x00D8 (size: 0x4)

}; // Size: 0xE0

class UMaterialExpressionSquareRoot : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionStaticBool : public UMaterialExpression
{
    uint8 Value;                                                                      // 0x00B0 (size: 0x1)

}; // Size: 0xB8

class UMaterialExpressionStaticBoolParameter : public UMaterialExpressionParameter
{
    uint8 DefaultValue;                                                               // 0x00D8 (size: 0x1)
    uint8 DynamicBranch;                                                              // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionStaticComponentMaskParameter : public UMaterialExpressionParameter
{
    FExpressionInput Input;                                                           // 0x00D8 (size: 0x28)
    uint8 DefaultR;                                                                   // 0x0100 (size: 0x1)
    uint8 DefaultG;                                                                   // 0x0100 (size: 0x1)
    uint8 DefaultB;                                                                   // 0x0100 (size: 0x1)
    uint8 DefaultA;                                                                   // 0x0100 (size: 0x1)

}; // Size: 0x108

class UMaterialExpressionStaticSwitch : public UMaterialExpression
{
    uint8 DefaultValue;                                                               // 0x00B0 (size: 0x1)
    FExpressionInput A;                                                               // 0x00B8 (size: 0x28)
    FExpressionInput B;                                                               // 0x00E0 (size: 0x28)
    FExpressionInput Value;                                                           // 0x0108 (size: 0x28)

}; // Size: 0x130

class UMaterialExpressionStaticSwitchParameter : public UMaterialExpressionStaticBoolParameter
{
    FExpressionInput A;                                                               // 0x00E0 (size: 0x28)
    FExpressionInput B;                                                               // 0x0108 (size: 0x28)

}; // Size: 0x130

class UMaterialExpressionStep : public UMaterialExpression
{
    FExpressionInput Y;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput X;                                                               // 0x00D8 (size: 0x28)
    float ConstY;                                                                     // 0x0100 (size: 0x4)
    float ConstX;                                                                     // 0x0104 (size: 0x4)

}; // Size: 0x108

class UMaterialExpressionSubstrateAdd : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)
    uint8 bUseParameterBlending;                                                      // 0x0100 (size: 0x1)

}; // Size: 0x108

class UMaterialExpressionSubstrateBSDF : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionSubstrateConvertMaterialAttributes : public UMaterialExpressionSubstrateBSDF
{
    FMaterialAttributesInput MaterialAttributes;                                      // 0x00B0 (size: 0x30)
    FExpressionInput WaterScatteringCoefficients;                                     // 0x00E0 (size: 0x28)
    FExpressionInput WaterAbsorptionCoefficients;                                     // 0x0108 (size: 0x28)
    FExpressionInput WaterPhaseG;                                                     // 0x0130 (size: 0x28)
    FExpressionInput ColorScaleBehindWater;                                           // 0x0158 (size: 0x28)
    class USubsurfaceProfile* SubsurfaceProfile;                                      // 0x0180 (size: 0x8)
    TEnumAsByte<EMaterialShadingModel> ShadingModelOverride;                          // 0x0188 (size: 0x1)

}; // Size: 0x190

class UMaterialExpressionSubstrateConvertToDecal : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput DecalMaterial;                                                   // 0x00B0 (size: 0x28)
    FExpressionInput Coverage;                                                        // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionSubstrateEyeBSDF : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput DiffuseColor;                                                    // 0x00B0 (size: 0x28)
    FExpressionInput Roughness;                                                       // 0x00D8 (size: 0x28)
    FExpressionInput CorneaNormal;                                                    // 0x0100 (size: 0x28)
    FExpressionInput IrisNormal;                                                      // 0x0128 (size: 0x28)
    FExpressionInput IrisPlaneNormal;                                                 // 0x0150 (size: 0x28)
    FExpressionInput IrisMask;                                                        // 0x0178 (size: 0x28)
    FExpressionInput IrisDistance;                                                    // 0x01A0 (size: 0x28)
    FExpressionInput EmissiveColor;                                                   // 0x01C8 (size: 0x28)
    class USubsurfaceProfile* SubsurfaceProfile;                                      // 0x01F0 (size: 0x8)

}; // Size: 0x1F8

class UMaterialExpressionSubstrateHairBSDF : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput BaseColor;                                                       // 0x00B0 (size: 0x28)
    FExpressionInput Scatter;                                                         // 0x00D8 (size: 0x28)
    FExpressionInput Specular;                                                        // 0x0100 (size: 0x28)
    FExpressionInput Roughness;                                                       // 0x0128 (size: 0x28)
    FExpressionInput Backlit;                                                         // 0x0150 (size: 0x28)
    FExpressionInput Tangent;                                                         // 0x0178 (size: 0x28)
    FExpressionInput EmissiveColor;                                                   // 0x01A0 (size: 0x28)

}; // Size: 0x1C8

class UMaterialExpressionSubstrateHazinessToSecondaryRoughness : public UMaterialExpressionSubstrateUtilityBase
{
    FExpressionInput BaseRoughness;                                                   // 0x00B0 (size: 0x28)
    FExpressionInput Haziness;                                                        // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionSubstrateHorizontalMixing : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput Background;                                                      // 0x00B0 (size: 0x28)
    FExpressionInput Foreground;                                                      // 0x00D8 (size: 0x28)
    FExpressionInput Mix;                                                             // 0x0100 (size: 0x28)
    uint8 bUseParameterBlending;                                                      // 0x0128 (size: 0x1)

}; // Size: 0x130

class UMaterialExpressionSubstrateLightFunction : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput Color;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionSubstrateMetalnessToDiffuseAlbedoF0 : public UMaterialExpressionSubstrateUtilityBase
{
    FExpressionInput BaseColor;                                                       // 0x00B0 (size: 0x28)
    FExpressionInput Metallic;                                                        // 0x00D8 (size: 0x28)
    FExpressionInput Specular;                                                        // 0x0100 (size: 0x28)

}; // Size: 0x128

class UMaterialExpressionSubstratePostProcess : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput Color;                                                           // 0x00B0 (size: 0x28)
    FExpressionInput Opacity;                                                         // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionSubstrateShadingModels : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput BaseColor;                                                       // 0x00B0 (size: 0x28)
    FExpressionInput Metallic;                                                        // 0x00D8 (size: 0x28)
    FExpressionInput Specular;                                                        // 0x0100 (size: 0x28)
    FExpressionInput Roughness;                                                       // 0x0128 (size: 0x28)
    FExpressionInput Anisotropy;                                                      // 0x0150 (size: 0x28)
    FExpressionInput EmissiveColor;                                                   // 0x0178 (size: 0x28)
    FExpressionInput Normal;                                                          // 0x01A0 (size: 0x28)
    FExpressionInput Tangent;                                                         // 0x01C8 (size: 0x28)
    FExpressionInput SubsurfaceColor;                                                 // 0x01F0 (size: 0x28)
    FExpressionInput ClearCoat;                                                       // 0x0218 (size: 0x28)
    FExpressionInput ClearCoatRoughness;                                              // 0x0240 (size: 0x28)
    FExpressionInput Opacity;                                                         // 0x0268 (size: 0x28)
    FExpressionInput TransmittanceColor;                                              // 0x0290 (size: 0x28)
    FExpressionInput WaterScatteringCoefficients;                                     // 0x02B8 (size: 0x28)
    FExpressionInput WaterAbsorptionCoefficients;                                     // 0x02E0 (size: 0x28)
    FExpressionInput WaterPhaseG;                                                     // 0x0308 (size: 0x28)
    FExpressionInput ColorScaleBehindWater;                                           // 0x0330 (size: 0x28)
    FExpressionInput ClearCoatNormal;                                                 // 0x0358 (size: 0x28)
    FExpressionInput CustomTangent;                                                   // 0x0380 (size: 0x28)
    FShadingModelMaterialInput ShadingModel;                                          // 0x03A8 (size: 0x28)
    class USubsurfaceProfile* SubsurfaceProfile;                                      // 0x03D8 (size: 0x8)
    TEnumAsByte<EMaterialShadingModel> ShadingModelOverride;                          // 0x03E0 (size: 0x1)

}; // Size: 0x3E8

class UMaterialExpressionSubstrateSimpleClearCoatBSDF : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput DiffuseAlbedo;                                                   // 0x00B0 (size: 0x28)
    FExpressionInput F0;                                                              // 0x00D8 (size: 0x28)
    FExpressionInput Roughness;                                                       // 0x0100 (size: 0x28)
    FExpressionInput ClearCoatCoverage;                                               // 0x0128 (size: 0x28)
    FExpressionInput ClearCoatRoughness;                                              // 0x0150 (size: 0x28)
    FExpressionInput Normal;                                                          // 0x0178 (size: 0x28)
    FExpressionInput EmissiveColor;                                                   // 0x01A0 (size: 0x28)

}; // Size: 0x1C8

class UMaterialExpressionSubstrateSingleLayerWaterBSDF : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput BaseColor;                                                       // 0x00B0 (size: 0x28)
    FExpressionInput Metallic;                                                        // 0x00D8 (size: 0x28)
    FExpressionInput Specular;                                                        // 0x0100 (size: 0x28)
    FExpressionInput Roughness;                                                       // 0x0128 (size: 0x28)
    FExpressionInput Normal;                                                          // 0x0150 (size: 0x28)
    FExpressionInput EmissiveColor;                                                   // 0x0178 (size: 0x28)
    FExpressionInput TopMaterialOpacity;                                              // 0x01A0 (size: 0x28)
    FExpressionInput WaterAlbedo;                                                     // 0x01C8 (size: 0x28)
    FExpressionInput WaterExtinction;                                                 // 0x01F0 (size: 0x28)
    FExpressionInput WaterPhaseG;                                                     // 0x0218 (size: 0x28)
    FExpressionInput ColorScaleBehindWater;                                           // 0x0240 (size: 0x28)

}; // Size: 0x268

class UMaterialExpressionSubstrateSlabBSDF : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput DiffuseAlbedo;                                                   // 0x00B0 (size: 0x28)
    FExpressionInput F0;                                                              // 0x00D8 (size: 0x28)
    FExpressionInput F90;                                                             // 0x0100 (size: 0x28)
    FExpressionInput Roughness;                                                       // 0x0128 (size: 0x28)
    FExpressionInput Anisotropy;                                                      // 0x0150 (size: 0x28)
    FExpressionInput Normal;                                                          // 0x0178 (size: 0x28)
    FExpressionInput Tangent;                                                         // 0x01A0 (size: 0x28)
    FExpressionInput SSSMFP;                                                          // 0x01C8 (size: 0x28)
    FExpressionInput SSSMFPScale;                                                     // 0x01F0 (size: 0x28)
    FExpressionInput SSSPhaseAnisotropy;                                              // 0x0218 (size: 0x28)
    FExpressionInput EmissiveColor;                                                   // 0x0240 (size: 0x28)
    FExpressionInput SecondRoughness;                                                 // 0x0268 (size: 0x28)
    FExpressionInput SecondRoughnessWeight;                                           // 0x0290 (size: 0x28)
    FExpressionInput FuzzRoughness;                                                   // 0x02B8 (size: 0x28)
    FExpressionInput FuzzAmount;                                                      // 0x02E0 (size: 0x28)
    FExpressionInput FuzzColor;                                                       // 0x0308 (size: 0x28)
    FExpressionInput GlintValue;                                                      // 0x0330 (size: 0x28)
    FExpressionInput GlintUV;                                                         // 0x0358 (size: 0x28)
    class USubsurfaceProfile* SubsurfaceProfile;                                      // 0x0380 (size: 0x8)
    class USpecularProfile* SpecularProfile;                                          // 0x0388 (size: 0x8)
    uint8 bUseSSSDiffusion;                                                           // 0x0390 (size: 0x1)

}; // Size: 0x398

class UMaterialExpressionSubstrateThinFilm : public UMaterialExpressionSubstrateUtilityBase
{
    FExpressionInput Normal;                                                          // 0x00B0 (size: 0x28)
    FExpressionInput F0;                                                              // 0x00D8 (size: 0x28)
    FExpressionInput F90;                                                             // 0x0100 (size: 0x28)
    FExpressionInput Thickness;                                                       // 0x0128 (size: 0x28)
    FExpressionInput IOR;                                                             // 0x0150 (size: 0x28)

}; // Size: 0x178

class UMaterialExpressionSubstrateTransmittanceToMFP : public UMaterialExpressionSubstrateUtilityBase
{
    FExpressionInput TransmittanceColor;                                              // 0x00B0 (size: 0x28)
    FExpressionInput Thickness;                                                       // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionSubstrateUI : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput Color;                                                           // 0x00B0 (size: 0x28)
    FExpressionInput Opacity;                                                         // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionSubstrateUnlitBSDF : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput EmissiveColor;                                                   // 0x00B0 (size: 0x28)
    FExpressionInput TransmittanceColor;                                              // 0x00D8 (size: 0x28)
    FExpressionInput Normal;                                                          // 0x0100 (size: 0x28)

}; // Size: 0x128

class UMaterialExpressionSubstrateUtilityBase : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionSubstrateVerticalLayering : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput Top;                                                             // 0x00B0 (size: 0x28)
    FExpressionInput base;                                                            // 0x00D8 (size: 0x28)
    FExpressionInput Thickness;                                                       // 0x0100 (size: 0x28)
    uint8 bUseParameterBlending;                                                      // 0x0128 (size: 0x1)

}; // Size: 0x130

class UMaterialExpressionSubstrateVolumetricFogCloudBSDF : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput Albedo;                                                          // 0x00B0 (size: 0x28)
    FExpressionInput Extinction;                                                      // 0x00D8 (size: 0x28)
    FExpressionInput EmissiveColor;                                                   // 0x0100 (size: 0x28)
    FExpressionInput AmbientOcclusion;                                                // 0x0128 (size: 0x28)

}; // Size: 0x150

class UMaterialExpressionSubstrateWeight : public UMaterialExpressionSubstrateBSDF
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput Weight;                                                          // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionSubsurfaceMediumMaterialOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput MeanFreePath;                                                    // 0x00B0 (size: 0x28)
    FExpressionInput ScatteringDistribution;                                          // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionSubtract : public UMaterialExpression
{
    FExpressionInput A;                                                               // 0x00B0 (size: 0x28)
    FExpressionInput B;                                                               // 0x00D8 (size: 0x28)
    float ConstA;                                                                     // 0x0100 (size: 0x4)
    float ConstB;                                                                     // 0x0104 (size: 0x4)

}; // Size: 0x108

class UMaterialExpressionSwitch : public UMaterialExpression
{
    FString Description;                                                              // 0x00B0 (size: 0x10)
    FExpressionInput SwitchValue;                                                     // 0x00C0 (size: 0x28)
    float ConstSwitchValue;                                                           // 0x00E8 (size: 0x4)
    FExpressionInput Default;                                                         // 0x00F0 (size: 0x28)
    float ConstDefault;                                                               // 0x0118 (size: 0x4)
    TArray<FSwitchCustomInput> Inputs;                                                // 0x0120 (size: 0x10)

}; // Size: 0x130

class UMaterialExpressionTangent : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)
    float Period;                                                                     // 0x00D8 (size: 0x4)

}; // Size: 0xE0

class UMaterialExpressionTangentOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionTemporalSobol : public UMaterialExpression
{
    FExpressionInput Index;                                                           // 0x00B0 (size: 0x28)
    FExpressionInput Seed;                                                            // 0x00D8 (size: 0x28)
    uint32 ConstIndex;                                                                // 0x0100 (size: 0x4)
    FVector2D ConstSeed;                                                              // 0x0108 (size: 0x10)

}; // Size: 0x118

class UMaterialExpressionTextureBase : public UMaterialExpression
{
    class UTexture* Texture;                                                          // 0x00B0 (size: 0x8)
    TEnumAsByte<EMaterialSamplerType> SamplerType;                                    // 0x00B8 (size: 0x1)
    uint8 IsDefaultMeshpaintTexture;                                                  // 0x00B9 (size: 0x1)

}; // Size: 0xC0

class UMaterialExpressionTextureCoordinate : public UMaterialExpression
{
    int32 CoordinateIndex;                                                            // 0x00B0 (size: 0x4)
    float UTiling;                                                                    // 0x00B4 (size: 0x4)
    float VTiling;                                                                    // 0x00B8 (size: 0x4)
    uint8 UnMirrorU;                                                                  // 0x00BC (size: 0x1)
    uint8 UnMirrorV;                                                                  // 0x00BC (size: 0x1)

}; // Size: 0xC0

class UMaterialExpressionTextureObject : public UMaterialExpressionTextureBase
{
}; // Size: 0xC0

class UMaterialExpressionTextureObjectParameter : public UMaterialExpressionTextureSampleParameter
{
}; // Size: 0x220

class UMaterialExpressionTextureProperty : public UMaterialExpression
{
    FExpressionInput TextureObject;                                                   // 0x00B0 (size: 0x28)
    TEnumAsByte<EMaterialExposedTextureProperty> Property;                            // 0x00D8 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionTextureSample : public UMaterialExpressionTextureBase
{
    FExpressionInput Coordinates;                                                     // 0x00C0 (size: 0x28)
    FExpressionInput TextureObject;                                                   // 0x00E8 (size: 0x28)
    FExpressionInput MipValue;                                                        // 0x0110 (size: 0x28)
    FExpressionInput CoordinatesDX;                                                   // 0x0138 (size: 0x28)
    FExpressionInput CoordinatesDY;                                                   // 0x0160 (size: 0x28)
    FExpressionInput AutomaticViewMipBiasValue;                                       // 0x0188 (size: 0x28)
    TEnumAsByte<ETextureMipValueMode> MipValueMode;                                   // 0x01B0 (size: 0x1)
    TEnumAsByte<ESamplerSourceMode> SamplerSource;                                    // 0x01B1 (size: 0x1)
    uint8 AutomaticViewMipBias;                                                       // 0x01B2 (size: 0x1)
    uint8 ConstCoordinate;                                                            // 0x01B3 (size: 0x1)
    int32 ConstMipValue;                                                              // 0x01B4 (size: 0x4)

}; // Size: 0x1B8

class UMaterialExpressionTextureSampleParameter : public UMaterialExpressionTextureSample
{
    FName ParameterName;                                                              // 0x01B8 (size: 0x8)
    FGuid ExpressionGUID;                                                             // 0x01C0 (size: 0x10)
    FName Group;                                                                      // 0x01D0 (size: 0x8)
    int32 SortPriority;                                                               // 0x01D8 (size: 0x4)
    FParameterChannelNames ChannelNames;                                              // 0x01E0 (size: 0x40)

}; // Size: 0x220

class UMaterialExpressionTextureSampleParameter2D : public UMaterialExpressionTextureSampleParameter
{
}; // Size: 0x220

class UMaterialExpressionTextureSampleParameter2DArray : public UMaterialExpressionTextureSampleParameter
{
}; // Size: 0x220

class UMaterialExpressionTextureSampleParameterCube : public UMaterialExpressionTextureSampleParameter
{
}; // Size: 0x220

class UMaterialExpressionTextureSampleParameterCubeArray : public UMaterialExpressionTextureSampleParameter
{
}; // Size: 0x220

class UMaterialExpressionTextureSampleParameterSubUV : public UMaterialExpressionTextureSampleParameter2D
{
    uint8 bBlend;                                                                     // 0x0220 (size: 0x1)

}; // Size: 0x228

class UMaterialExpressionTextureSampleParameterVolume : public UMaterialExpressionTextureSampleParameter
{
}; // Size: 0x220

class UMaterialExpressionThinTranslucentMaterialOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput TransmittanceColor;                                              // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionTime : public UMaterialExpression
{
    uint8 bIgnorePause;                                                               // 0x00B0 (size: 0x1)
    uint8 bOverride_Period;                                                           // 0x00B0 (size: 0x1)
    float Period;                                                                     // 0x00B4 (size: 0x4)

}; // Size: 0xB8

class UMaterialExpressionTransform : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)
    TEnumAsByte<EMaterialVectorCoordTransformSource> TransformSourceType;             // 0x00D8 (size: 0x1)
    TEnumAsByte<EMaterialVectorCoordTransform> TransformType;                         // 0x00D9 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionTransformPosition : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)
    TEnumAsByte<EMaterialPositionTransformSource> TransformSourceType;                // 0x00D8 (size: 0x1)
    TEnumAsByte<EMaterialPositionTransformSource> TransformType;                      // 0x00D9 (size: 0x1)

}; // Size: 0xE0

class UMaterialExpressionTruncate : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionTruncateLWC : public UMaterialExpression
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionTwoSidedSign : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionVectorNoise : public UMaterialExpression
{
    FExpressionInput Position;                                                        // 0x00B0 (size: 0x28)
    EPositionOrigin WorldPositionOriginType;                                          // 0x00D8 (size: 0x1)
    TEnumAsByte<EVectorNoiseFunction> NoiseFunction;                                  // 0x00D9 (size: 0x1)
    int32 Quality;                                                                    // 0x00DC (size: 0x4)
    uint8 bTiling;                                                                    // 0x00E0 (size: 0x1)
    uint32 TileSize;                                                                  // 0x00E4 (size: 0x4)

}; // Size: 0xE8

class UMaterialExpressionVectorParameter : public UMaterialExpressionParameter
{
    FLinearColor DefaultValue;                                                        // 0x00D8 (size: 0x10)
    bool bUseCustomPrimitiveData;                                                     // 0x00E8 (size: 0x1)
    uint8 PrimitiveDataIndex;                                                         // 0x00E9 (size: 0x1)
    FParameterChannelNames ChannelNames;                                              // 0x00F0 (size: 0x40)

}; // Size: 0x130

class UMaterialExpressionVertexColor : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionVertexInterpolator : public UMaterialExpressionCustomOutput
{
    FExpressionInput Input;                                                           // 0x00B0 (size: 0x28)

}; // Size: 0xE8

class UMaterialExpressionVertexNormalWS : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionVertexTangentWS : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionViewProperty : public UMaterialExpression
{
    TEnumAsByte<EMaterialExposedViewProperty> Property;                               // 0x00B0 (size: 0x1)

}; // Size: 0xB8

class UMaterialExpressionViewSize : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionVirtualTextureFeatureSwitch : public UMaterialExpression
{
    FExpressionInput No;                                                              // 0x00B0 (size: 0x28)
    FExpressionInput Yes;                                                             // 0x00D8 (size: 0x28)

}; // Size: 0x100

class UMaterialExpressionVolumetricAdvancedMaterialInput : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionVolumetricAdvancedMaterialOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput PhaseG;                                                          // 0x00B0 (size: 0x28)
    FExpressionInput PhaseG2;                                                         // 0x00D8 (size: 0x28)
    FExpressionInput PhaseBlend;                                                      // 0x0100 (size: 0x28)
    FExpressionInput MultiScatteringContribution;                                     // 0x0128 (size: 0x28)
    FExpressionInput MultiScatteringOcclusion;                                        // 0x0150 (size: 0x28)
    FExpressionInput MultiScatteringEccentricity;                                     // 0x0178 (size: 0x28)
    FExpressionInput ConservativeDensity;                                             // 0x01A0 (size: 0x28)
    float ConstPhaseG;                                                                // 0x01C8 (size: 0x4)
    float ConstPhaseG2;                                                               // 0x01CC (size: 0x4)
    float ConstPhaseBlend;                                                            // 0x01D0 (size: 0x4)
    bool PerSamplePhaseEvaluation;                                                    // 0x01D4 (size: 0x1)
    uint32 MultiScatteringApproximationOctaveCount;                                   // 0x01D8 (size: 0x4)
    float ConstMultiScatteringContribution;                                           // 0x01DC (size: 0x4)
    float ConstMultiScatteringOcclusion;                                              // 0x01E0 (size: 0x4)
    float ConstMultiScatteringEccentricity;                                           // 0x01E4 (size: 0x4)
    bool bGroundContribution;                                                         // 0x01E8 (size: 0x1)
    bool bGrayScaleMaterial;                                                          // 0x01E9 (size: 0x1)
    bool bRayMarchVolumeShadow;                                                       // 0x01EA (size: 0x1)
    bool bClampMultiScatteringContribution;                                           // 0x01EB (size: 0x1)

}; // Size: 0x1F0

class UMaterialExpressionVolumetricCloudEmptySpaceSkippingInput : public UMaterialExpression
{
}; // Size: 0xB0

class UMaterialExpressionVolumetricCloudEmptySpaceSkippingOutput : public UMaterialExpressionCustomOutput
{
    FExpressionInput ContainsMatter;                                                  // 0x00B0 (size: 0x28)

}; // Size: 0xD8

class UMaterialExpressionWhileLoop : public UMaterialExpression
{
    FExpressionExecOutput LoopBody;                                                   // 0x00B0 (size: 0x8)
    FExpressionExecOutput Completed;                                                  // 0x00B8 (size: 0x8)
    FExpressionInput Condition;                                                       // 0x00C0 (size: 0x28)

}; // Size: 0xE8

class UMaterialExpressionWorldPosition : public UMaterialExpression
{
    TEnumAsByte<EWorldPositionIncludedOffsets> WorldPositionShaderOffset;             // 0x00B0 (size: 0x1)

}; // Size: 0xB8

class UMaterialFunction : public UMaterialFunctionInterface
{
    FString Description;                                                              // 0x0040 (size: 0x10)
    FString UserExposedCaption;                                                       // 0x0050 (size: 0x10)
    uint8 bExposeToLibrary;                                                           // 0x0060 (size: 0x1)
    uint8 bPrefixParameterNames;                                                      // 0x0060 (size: 0x1)
    uint8 bEnableExecWire;                                                            // 0x0060 (size: 0x1)
    uint8 bEnableNewHLSLGenerator;                                                    // 0x0060 (size: 0x1)

}; // Size: 0x68

class UMaterialFunctionEditorOnlyData : public UMaterialFunctionInterfaceEditorOnlyData
{
    FMaterialExpressionCollection ExpressionCollection;                               // 0x0028 (size: 0x30)

}; // Size: 0x58

class UMaterialFunctionInstance : public UMaterialFunctionInterface
{
    class UMaterialFunctionInterface* Parent;                                         // 0x0040 (size: 0x8)
    class UMaterialFunctionInterface* base;                                           // 0x0048 (size: 0x8)
    TArray<FScalarParameterValue> ScalarParameterValues;                              // 0x0050 (size: 0x10)
    TArray<FVectorParameterValue> VectorParameterValues;                              // 0x0060 (size: 0x10)
    TArray<FDoubleVectorParameterValue> DoubleVectorParameterValues;                  // 0x0070 (size: 0x10)
    TArray<FTextureParameterValue> TextureParameterValues;                            // 0x0080 (size: 0x10)
    TArray<FFontParameterValue> FontParameterValues;                                  // 0x0090 (size: 0x10)
    TArray<FStaticSwitchParameter> StaticSwitchParameterValues;                       // 0x00A0 (size: 0x10)
    TArray<FStaticComponentMaskParameter> StaticComponentMaskParameterValues;         // 0x00B0 (size: 0x10)
    TArray<FRuntimeVirtualTextureParameterValue> RuntimeVirtualTextureParameterValues; // 0x00C0 (size: 0x10)
    TArray<FSparseVolumeTextureParameterValue> SparseVolumeTextureParameterValues;    // 0x00D0 (size: 0x10)

}; // Size: 0xE0

class UMaterialFunctionInterface : public UObject
{
    FGuid StateId;                                                                    // 0x0028 (size: 0x10)
    EMaterialFunctionUsage MaterialFunctionUsage;                                     // 0x0038 (size: 0x1)

}; // Size: 0x40

class UMaterialFunctionInterfaceEditorOnlyData : public UObject
{
}; // Size: 0x28

class UMaterialFunctionMaterialLayer : public UMaterialFunction
{
}; // Size: 0x68

class UMaterialFunctionMaterialLayerBlend : public UMaterialFunction
{
}; // Size: 0x68

class UMaterialFunctionMaterialLayerBlendInstance : public UMaterialFunctionInstance
{
}; // Size: 0xE0

class UMaterialFunctionMaterialLayerInstance : public UMaterialFunctionInstance
{
}; // Size: 0xE0

class UMaterialInstance : public UMaterialInterface
{
    class UPhysicalMaterial* PhysMaterial;                                            // 0x00C8 (size: 0x8)
    class UPhysicalMaterial* PhysicalMaterialMap;                                     // 0x00D0 (size: 0x40)
    class UMaterialInterface* Parent;                                                 // 0x0110 (size: 0x8)
    FMaterialOverrideNanite NaniteOverrideMaterial;                                   // 0x0118 (size: 0x38)
    uint8 bHasStaticPermutationResource;                                              // 0x0150 (size: 0x1)
    uint8 bOverrideSubsurfaceProfile;                                                 // 0x0150 (size: 0x1)
    TArray<FScalarParameterValue> ScalarParameterValues;                              // 0x0168 (size: 0x10)
    TArray<FVectorParameterValue> VectorParameterValues;                              // 0x0178 (size: 0x10)
    TArray<FDoubleVectorParameterValue> DoubleVectorParameterValues;                  // 0x0188 (size: 0x10)
    TArray<FTextureParameterValue> TextureParameterValues;                            // 0x0198 (size: 0x10)
    TArray<FRuntimeVirtualTextureParameterValue> RuntimeVirtualTextureParameterValues; // 0x01A8 (size: 0x10)
    TArray<FSparseVolumeTextureParameterValue> SparseVolumeTextureParameterValues;    // 0x01B8 (size: 0x10)
    TArray<FFontParameterValue> FontParameterValues;                                  // 0x01C8 (size: 0x10)
    FMaterialInstanceBasePropertyOverrides BasePropertyOverrides;                     // 0x01D8 (size: 0x18)
    FStaticParameterSetRuntimeData StaticParametersRuntime;                           // 0x01F8 (size: 0x38)

}; // Size: 0x260

class UMaterialInstanceConstant : public UMaterialInstance
{
    class UPhysicalMaterialMask* PhysMaterialMask;                                    // 0x0260 (size: 0x8)

    FLinearColor K2_GetVectorParameterValue(FName ParameterName);
    class UTexture* K2_GetTextureParameterValue(FName ParameterName);
    float K2_GetScalarParameterValue(FName ParameterName);
}; // Size: 0x268

class UMaterialInstanceDynamic : public UMaterialInstance
{

    void SetVectorParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo, FLinearColor Value);
    void SetVectorParameterValue(FName ParameterName, FLinearColor Value);
    void SetTextureParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo, class UTexture* Value);
    void SetTextureParameterValue(FName ParameterName, class UTexture* Value);
    void SetSparseVolumeTextureParameterValue(FName ParameterName, class USparseVolumeTexture* Value);
    void SetScalarParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo, float Value);
    void SetScalarParameterValue(FName ParameterName, float Value);
    bool SetScalarParameterByIndex(int32 ParameterIndex, float Value);
    void SetRuntimeVirtualTextureParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo, class URuntimeVirtualTexture* Value);
    void SetRuntimeVirtualTextureParameterValue(FName ParameterName, class URuntimeVirtualTexture* Value);
    void SetDoubleVectorParameterValue(FName ParameterName, FVector4 Value);
    void K2_InterpolateMaterialInstanceParams(class UMaterialInstance* SourceA, class UMaterialInstance* SourceB, float Alpha);
    FLinearColor K2_GetVectorParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo);
    FLinearColor K2_GetVectorParameterValue(FName ParameterName);
    class UTexture* K2_GetTextureParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo);
    class UTexture* K2_GetTextureParameterValue(FName ParameterName);
    float K2_GetScalarParameterValueByInfo(const FMaterialParameterInfo& ParameterInfo);
    float K2_GetScalarParameterValue(FName ParameterName);
    void K2_CopyMaterialInstanceParameters(class UMaterialInterface* Source, bool bQuickParametersOnly);
    bool InitializeScalarParameterAndGetIndex(const FName& ParameterName, float Value, int32& OutParameterIndex);
    void CopyParameterOverrides(class UMaterialInstance* MaterialInstance);
    void CopyInterpParameters(class UMaterialInstance* Source);
}; // Size: 0x2B0

class UMaterialInstanceEditorOnlyData : public UMaterialInterfaceEditorOnlyData
{
    FStaticParameterSetEditorOnlyData StaticParameters;                               // 0x0040 (size: 0xA0)

}; // Size: 0xE0

class UMaterialInterface : public UObject
{
    class USubsurfaceProfile* SubsurfaceProfile;                                      // 0x0038 (size: 0x8)
    TArray<class USpecularProfile*> SpecularProfiles;                                 // 0x0040 (size: 0x10)
    class UNeuralProfile* NeuralProfile;                                              // 0x0050 (size: 0x8)
    uint8 bIncludedInBaseGame;                                                        // 0x0058 (size: 0x1)
    FLightmassMaterialInterfaceSettings LightmassSettings;                            // 0x0080 (size: 0x10)
    TArray<FMaterialTextureInfo> TextureStreamingData;                                // 0x0090 (size: 0x10)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x00A0 (size: 0x10)

    void SetForceMipLevelsToBeResident(bool OverrideForceMiplevelsToBeResident, bool bForceMiplevelsToBeResidentValue, float ForceDuration, int32 CinematicTextureGroups, bool bFastResponse);
    class UPhysicalMaterialMask* GetPhysicalMaterialMask();
    class UPhysicalMaterial* GetPhysicalMaterialFromMap(int32 Index);
    class UPhysicalMaterial* GetPhysicalMaterial();
    FMaterialParameterInfo GetParameterInfo(TEnumAsByte<EMaterialParameterAssociation> Association, FName ParameterName, class UMaterialFunctionInterface* LayerFunction);
    class UMaterialInterface* GetNaniteOverideMaterial();
    TEnumAsByte<EBlendMode> GetBlendMode();
    class UMaterial* GetBaseMaterial();
}; // Size: 0xC8

class UMaterialInterfaceEditorOnlyData : public UObject
{
}; // Size: 0x40

class UMaterialParameterCollection : public UObject
{
    FGuid StateId;                                                                    // 0x0028 (size: 0x10)
    TArray<FCollectionScalarParameter> ScalarParameters;                              // 0x0038 (size: 0x10)
    TArray<FCollectionVectorParameter> VectorParameters;                              // 0x0048 (size: 0x10)

    TArray<FName> GetVectorParameterNames();
    FLinearColor GetVectorParameterDefaultValue(FName ParameterName, bool& bParameterFound);
    TArray<FName> GetScalarParameterNames();
    float GetScalarParameterDefaultValue(FName ParameterName, bool& bParameterFound);
}; // Size: 0x70

class UMaterialParameterCollectionInstance : public UObject
{
    TWeakObjectPtr<class UMaterialParameterCollection> Collection;                    // 0x002C (size: 0x8)

}; // Size: 0x120

class UMeshBudgetProjectSettings : public UDeveloperSettings
{
    bool bEnableStaticMeshBudget;                                                     // 0x0038 (size: 0x1)
    TArray<FStaticMeshBudgetInfo> StaticMeshBudgetInfos;                              // 0x0040 (size: 0x10)

}; // Size: 0x50

class UMeshComponent : public UPrimitiveComponent
{
    TArray<class UMaterialInterface*> OverrideMaterials;                              // 0x0518 (size: 0x10)
    class UMaterialInterface* OverlayMaterial;                                        // 0x0528 (size: 0x8)
    float OverlayMaterialMaxDrawDistance;                                             // 0x0530 (size: 0x4)
    uint8 bEnableMaterialParameterCaching;                                            // 0x0548 (size: 0x1)

    void SetVectorParameterValueOnMaterials(const FName ParameterName, const FVector ParameterValue);
    void SetScalarParameterValueOnMaterials(const FName ParameterName, const float ParameterValue);
    void SetOverlayMaterialMaxDrawDistance(float InMaxDrawDistance);
    void SetOverlayMaterial(class UMaterialInterface* NewOverlayMaterial);
    void PrestreamTextures(float Seconds, bool bPrioritizeCharacterTextures, int32 CinematicTextureGroups);
    bool PrestreamMeshLODs(float Seconds);
    float GetOverlayMaterialMaxDrawDistance();
    class UMaterialInterface* GetOverlayMaterial();
    TArray<class UMaterialInterface*> GetMaterials();
}; // Size: 0x550

class UMeshDeformer : public UObject
{
}; // Size: 0x28

class UMeshDeformerInstance : public UObject
{
}; // Size: 0x28

class UMeshDeformerInstanceSettings : public UObject
{
}; // Size: 0x28

class UMeshDrawCommandStatsSettings : public UDeveloperSettings
{
    TArray<FMeshDrawCommandStatsBudget> Budgets;                                      // 0x0038 (size: 0x10)
    TArray<FMeshDrawCommandStatsBudgetTotals> BudgetTotals;                           // 0x0048 (size: 0x10)
    int32 CollectionForCsvProfiler;                                                   // 0x0058 (size: 0x4)

}; // Size: 0x60

class UMeshSimplificationSettings : public UDeveloperSettings
{
    FName MeshReductionModuleName;                                                    // 0x0038 (size: 0x8)
    bool bMeshReductionBackwardCompatible;                                            // 0x0040 (size: 0x1)

}; // Size: 0x48

class UMeshVertexPainterKismetLibrary : public UBlueprintFunctionLibrary
{

    void RemovePaintedVertices(class UStaticMeshComponent* StaticMeshComponent);
    void PaintVerticesSingleColor(class UStaticMeshComponent* StaticMeshComponent, const FLinearColor& FillColor, bool bConvertToSRGB);
    void PaintVerticesLerpAlongAxis(class UStaticMeshComponent* StaticMeshComponent, const FLinearColor& StartColor, const FLinearColor& EndColor, EVertexPaintAxis Axis, bool bConvertToSRGB);
}; // Size: 0x28

class UMicroTransactionBase : public UPlatformInterfaceBase
{
    TArray<FPurchaseInfo> AvailableProducts;                                          // 0x0038 (size: 0x10)
    FString lastError;                                                                // 0x0048 (size: 0x10)
    FString LastErrorSolution;                                                        // 0x0058 (size: 0x10)

}; // Size: 0x68

class UMirrorDataTable : public UDataTable
{
    TArray<FMirrorFindReplaceExpression> MirrorFindReplaceExpressions;                // 0x00B0 (size: 0x10)
    TEnumAsByte<EAxis::Type> MirrorAxis;                                              // 0x00C0 (size: 0x1)
    bool bMirrorRootMotion;                                                           // 0x00C1 (size: 0x1)
    class USkeleton* Skeleton;                                                        // 0x00C8 (size: 0x8)

}; // Size: 0x1F0

class UModel : public UObject
{
}; // Size: 0x268

class UModelComponent : public UPrimitiveComponent
{
    class UBodySetup* ModelBodySetup;                                                 // 0x0530 (size: 0x8)

}; // Size: 0x560

class UMorphTarget : public UObject
{
    class USkeletalMesh* BaseSkelMesh;                                                // 0x0028 (size: 0x8)

}; // Size: 0x40

class UMovementComponent : public UActorComponent
{
    class USceneComponent* UpdatedComponent;                                          // 0x00A0 (size: 0x8)
    class UPrimitiveComponent* UpdatedPrimitive;                                      // 0x00A8 (size: 0x8)
    FVector Velocity;                                                                 // 0x00B8 (size: 0x18)
    FVector PlaneConstraintNormal;                                                    // 0x00D0 (size: 0x18)
    FVector PlaneConstraintOrigin;                                                    // 0x00E8 (size: 0x18)
    uint8 bUpdateOnlyIfRendered;                                                      // 0x0100 (size: 0x1)
    uint8 bAutoUpdateTickRegistration;                                                // 0x0100 (size: 0x1)
    uint8 bTickBeforeOwner;                                                           // 0x0100 (size: 0x1)
    uint8 bAutoRegisterUpdatedComponent;                                              // 0x0100 (size: 0x1)
    uint8 bConstrainToPlane;                                                          // 0x0100 (size: 0x1)
    uint8 bSnapToPlaneAtStart;                                                        // 0x0100 (size: 0x1)
    uint8 bAutoRegisterPhysicsVolumeUpdates;                                          // 0x0100 (size: 0x1)
    uint8 bComponentShouldUpdatePhysicsVolume;                                        // 0x0100 (size: 0x1)
    EPlaneConstraintAxisSetting PlaneConstraintAxisSetting;                           // 0x0103 (size: 0x1)

    void StopMovementImmediately();
    void SnapUpdatedComponentToPlane();
    void SetUpdatedComponent(class USceneComponent* NewUpdatedComponent);
    void SetPlaneConstraintOrigin(FVector PlaneOrigin);
    void SetPlaneConstraintNormal(FVector PlaneNormal);
    void SetPlaneConstraintFromVectors(FVector Forward, FVector Up);
    void SetPlaneConstraintEnabled(bool bEnabled);
    void SetPlaneConstraintAxisSetting(EPlaneConstraintAxisSetting NewAxisSetting);
    void PhysicsVolumeChanged(class APhysicsVolume* NewVolume);
    bool K2_MoveUpdatedComponent(FVector Delta, FRotator NewRotation, FHitResult& OutHit, bool bSweep, bool bTeleport);
    bool IsExceedingMaxSpeed(float MaxSpeed);
    FVector GetPlaneConstraintOrigin();
    FVector GetPlaneConstraintNormal();
    EPlaneConstraintAxisSetting GetPlaneConstraintAxisSetting();
    class APhysicsVolume* GetPhysicsVolume();
    float GetMaxSpeed();
    float GetGravityZ();
    FVector ConstrainNormalToPlane(FVector Normal);
    FVector ConstrainLocationToPlane(FVector Location);
    FVector ConstrainDirectionToPlane(FVector Direction);
}; // Size: 0x108

class UNavAreaBase : public UObject
{
}; // Size: 0x30

class UNavCollisionBase : public UObject
{
    uint8 bIsDynamicObstacle;                                                         // 0x0028 (size: 0x1)

}; // Size: 0x70

class UNavLinkDefinition : public UObject
{
    TArray<FNavigationLink> links;                                                    // 0x0028 (size: 0x10)
    TArray<FNavigationSegmentLink> SegmentLinks;                                      // 0x0038 (size: 0x10)

}; // Size: 0x50

class UNavMovementComponent : public UMovementComponent
{
    FNavAgentProperties NavAgentProps;                                                // 0x0108 (size: 0x38)
    float FixedPathBrakingDistance;                                                   // 0x0140 (size: 0x4)
    uint8 bUpdateNavAgentWithOwnersCollision;                                         // 0x0144 (size: 0x1)
    uint8 bUseAccelerationForPaths;                                                   // 0x0144 (size: 0x1)
    uint8 bUseFixedBrakingDistanceForPaths;                                           // 0x0144 (size: 0x1)
    FMovementProperties MovementState;                                                // 0x0145 (size: 0x1)
    class UObject* PathFollowingComp;                                                 // 0x0148 (size: 0x8)

    void StopMovementKeepPathing();
    void StopActiveMovement();
    bool IsSwimming();
    bool IsMovingOnGround();
    bool IsFlying();
    bool IsFalling();
    bool IsCrouching();
}; // Size: 0x150

class UNavigationDataChunk : public UObject
{
    FName NavigationDataName;                                                         // 0x0028 (size: 0x8)

}; // Size: 0x30

class UNavigationSystemBase : public UObject
{
}; // Size: 0x28

class UNavigationSystemConfig : public UObject
{
    FSoftClassPath NavigationSystemClass;                                             // 0x0028 (size: 0x20)
    FNavAgentSelector SupportedAgentsMask;                                            // 0x0048 (size: 0x4)
    FName DefaultAgentName;                                                           // 0x004C (size: 0x8)
    uint8 bIsOverriden;                                                               // 0x0054 (size: 0x1)

}; // Size: 0x58

class UNetConnection : public UPlayer
{
    TArray<class UChildConnection*> Children;                                         // 0x0048 (size: 0x10)
    class UNetDriver* Driver;                                                         // 0x0058 (size: 0x8)
    TSubclassOf<class UPackageMap> PackageMapClass;                                   // 0x0060 (size: 0x8)
    class UPackageMap* PackageMap;                                                    // 0x0068 (size: 0x8)
    TArray<class UChannel*> OpenChannels;                                             // 0x0070 (size: 0x10)
    TArray<class AActor*> SentTemporaries;                                            // 0x0080 (size: 0x10)
    class AActor* ViewTarget;                                                         // 0x0090 (size: 0x8)
    class AActor* OwningActor;                                                        // 0x0098 (size: 0x8)
    int32 MaxPacket;                                                                  // 0x00A0 (size: 0x4)
    uint8 InternalAck;                                                                // 0x00A4 (size: 0x1)
    FUniqueNetIdRepl PlayerId;                                                        // 0x0160 (size: 0x30)
    double LastReceiveTime;                                                           // 0x01D8 (size: 0x8)
    int32 DefaultMaxChannelSize;                                                      // 0x13B8 (size: 0x4)
    TArray<class UChannel*> ChannelsToTick;                                           // 0x16F0 (size: 0x10)

}; // Size: 0x1E00

class UNetDriver : public UObject
{
    FString NetConnectionClassName;                                                   // 0x0030 (size: 0x10)
    FString ReplicationDriverClassName;                                               // 0x0040 (size: 0x10)
    FString ReplicationBridgeClassName;                                               // 0x0050 (size: 0x10)
    FNetDriverReplicationSystemConfig ReplicationSystemConfig;                        // 0x0060 (size: 0x1C)
    int32 MaxDownloadSize;                                                            // 0x007C (size: 0x4)
    uint8 bClampListenServerTickRate;                                                 // 0x0080 (size: 0x1)
    int32 NetServerMaxTickRate;                                                       // 0x0084 (size: 0x4)
    int32 MaxNetTickRate;                                                             // 0x00A0 (size: 0x4)
    int32 MaxInternetClientRate;                                                      // 0x00A4 (size: 0x4)
    int32 MaxClientRate;                                                              // 0x00A8 (size: 0x4)
    float ServerTravelPause;                                                          // 0x00AC (size: 0x4)
    float SpawnPrioritySeconds;                                                       // 0x00B0 (size: 0x4)
    float RelevantTimeout;                                                            // 0x00B4 (size: 0x4)
    float KeepAliveTime;                                                              // 0x00B8 (size: 0x4)
    float InitialConnectTimeout;                                                      // 0x00BC (size: 0x4)
    float ConnectionTimeout;                                                          // 0x00C0 (size: 0x4)
    float TimeoutMultiplierForUnoptimizedBuilds;                                      // 0x00C4 (size: 0x4)
    class UNetConnection* ServerConnection;                                           // 0x00C8 (size: 0x8)
    TArray<class UNetConnection*> ClientConnections;                                  // 0x00D0 (size: 0x10)
    int32 RecentlyDisconnectedTrackingTime;                                           // 0x0140 (size: 0x4)
    class UWorld* World;                                                              // 0x0180 (size: 0x8)
    class UPackage* WorldPackage;                                                     // 0x0188 (size: 0x8)
    UClass* NetConnectionClass;                                                       // 0x01B0 (size: 0x8)
    UClass* ReplicationDriverClass;                                                   // 0x01B8 (size: 0x8)
    UClass* ReplicationBridgeClass;                                                   // 0x01C0 (size: 0x8)
    FName NetDriverName;                                                              // 0x01D8 (size: 0x8)
    TArray<FChannelDefinition> ChannelDefinitions;                                    // 0x01E0 (size: 0x10)
    TMap<class FName, class FChannelDefinition> ChannelDefinitionMap;                 // 0x01F0 (size: 0x50)
    TArray<class UChannel*> ActorChannelPool;                                         // 0x0240 (size: 0x10)
    class UNetworkMetricsDatabase* NetworkMetricsDatabase;                            // 0x0260 (size: 0x8)
    TMap<class FName, class UNetworkMetricsBaseListener*> NetworkMetricsListeners;    // 0x0268 (size: 0x50)
    uint8 bNoTimeouts;                                                                // 0x02C9 (size: 0x1)
    uint8 bNeverApplyNetworkEmulationSettings;                                        // 0x02C9 (size: 0x1)
    class UReplicationDriver* ReplicationDriver;                                      // 0x0830 (size: 0x8)

}; // Size: 0x8C8

class UNetFaultConfig : public UEscalationManagerConfig
{
}; // Size: 0x88

class UNetPushModelHelpers : public UBlueprintFunctionLibrary
{

    void MarkPropertyDirtyFromRepIndex(class UObject* Object, int32 RepIndex, FName PropertyName);
    void MarkPropertyDirty(class UObject* Object, FName PropertyName);
}; // Size: 0x28

class UNetworkMetricsBaseListener : public UObject
{
    double IntervalSeconds;                                                           // 0x0028 (size: 0x8)

}; // Size: 0x30

class UNetworkMetricsCSV : public UNetworkMetricsBaseListener
{
}; // Size: 0x38

class UNetworkMetricsCSV_Replication : public UNetworkMetricsCSV
{
}; // Size: 0x38

class UNetworkMetricsConfig : public UObject
{
    TArray<FNetworkMetricConfig> Listeners;                                           // 0x0028 (size: 0x10)

}; // Size: 0x38

class UNetworkMetricsDatabase : public UObject
{
}; // Size: 0x1B8

class UNetworkMetricsPerfCounters : public UNetworkMetricsBaseListener
{
}; // Size: 0x30

class UNetworkMetricsStats : public UNetworkMetricsBaseListener
{
}; // Size: 0x38

class UNetworkPhysicsComponent : public UActorComponent
{
    FNetworkPhysicsRewindDataInputProxy ReplicatedInputs;                             // 0x00A0 (size: 0x10)
    FNetworkPhysicsRewindDataStateProxy ReplicatedStates;                             // 0x00B0 (size: 0x10)

    void ServerReceiveInputsDatas(const FNetworkPhysicsRewindDataInputProxy& ClientInputs);
    void ServerReceiveInputData(const FNetworkPhysicsRewindDataInputProxy& ClientInputs);
    void OnRep_SetReplicatedStates();
    void OnRep_SetReplicatedInputs();
}; // Size: 0x140

class UNetworkPhysicsSettingsComponent : public UActorComponent
{
    FNetworkPhysicsSettings GeneralSettings;                                          // 0x00A0 (size: 0x8)
    FNetworkPhysicsSettingsPredictiveInterpolation PredictiveInterpolationSettings;   // 0x00A8 (size: 0x70)
    FNetworkPhysicsSettingsResimulation ResimulationSettings;                         // 0x0118 (size: 0x58)

}; // Size: 0x178

class UNetworkPhysicsSystem : public UWorldSubsystem
{
}; // Size: 0x40

class UNetworkSettings : public UDeveloperSettings
{
    uint8 bVerifyPeer;                                                                // 0x0038 (size: 0x1)
    uint8 bEnableMultiplayerWorldOriginRebasing;                                      // 0x0038 (size: 0x1)
    TArray<FNetworkEmulationProfileDescription> NetworkEmulationProfiles;             // 0x0040 (size: 0x10)

}; // Size: 0x50

class UNetworkSubsystem : public UWorldSubsystem
{
}; // Size: 0x80

class UNeuralProfile : public UObject
{
    FNeuralProfileStruct Settings;                                                    // 0x0028 (size: 0x48)
    FGuid Guid;                                                                       // 0x0070 (size: 0x10)

}; // Size: 0x80

class UNodeMappingContainer : public UObject
{
    TMap<class FName, class FNodeItem> SourceItems;                                   // 0x0028 (size: 0x50)
    TMap<class FName, class FNodeItem> TargetItems;                                   // 0x0078 (size: 0x50)
    TMap<class FName, class FName> SourceToTarget;                                    // 0x00C8 (size: 0x50)
    TSoftObjectPtr<UObject> SourceAsset;                                              // 0x0118 (size: 0x28)
    TSoftObjectPtr<UObject> TargetAsset;                                              // 0x0140 (size: 0x28)

}; // Size: 0x168

class UNullHLODBuilder : public UHLODBuilder
{
}; // Size: 0x28

class UNullNavSysConfig : public UNavigationSystemConfig
{
}; // Size: 0x58

class UObjectElementAssetDataInterface : public UObject
{
}; // Size: 0x30

class UObjectElementCounterInterface : public UObject
{
}; // Size: 0x30

class UObjectElementObjectInterface : public UObject
{
}; // Size: 0x30

class UObjectElementSelectionInterface : public UObject
{
}; // Size: 0x30

class UObjectLibrary : public UObject
{
    UClass* ObjectBaseClass;                                                          // 0x0028 (size: 0x8)
    bool bHasBlueprintClasses;                                                        // 0x0030 (size: 0x1)
    TArray<class UObject*> Objects;                                                   // 0x0038 (size: 0x10)
    TArray<TWeakObjectPtr<UObject>> WeakObjects;                                      // 0x0048 (size: 0x10)
    bool bUseWeakReferences;                                                          // 0x0058 (size: 0x1)
    bool bIsFullyLoaded;                                                              // 0x0059 (size: 0x1)

}; // Size: 0xA8

class UObjectReferencer : public UObject
{
    TArray<class UObject*> ReferencedObjects;                                         // 0x0028 (size: 0x10)

}; // Size: 0x38

class UObjectTraceWorldSubsystem : public UWorldSubsystem
{
}; // Size: 0x40

class UOnlineBlueprintCallProxyBase : public UBlueprintAsyncActionBase
{
}; // Size: 0x30

class UOnlineEngineInterface : public UObject
{
}; // Size: 0x28

class UOnlineSession : public UObject
{
}; // Size: 0x28

class UPackageMapClient : public UPackageMap
{
}; // Size: 0x408

class UParticleEmitter : public UObject
{
    FName EmitterName;                                                                // 0x0028 (size: 0x8)
    int32 SubUVDataOffset;                                                            // 0x0030 (size: 0x4)
    TEnumAsByte<EEmitterRenderMode> EmitterRenderMode;                                // 0x0034 (size: 0x1)
    EParticleSignificanceLevel SignificanceLevel;                                     // 0x0035 (size: 0x1)
    uint8 bUseLegacySpawningBehavior;                                                 // 0x0037 (size: 0x1)
    uint8 ConvertedModules;                                                           // 0x0037 (size: 0x1)
    uint8 bIsSoloing;                                                                 // 0x0037 (size: 0x1)
    uint8 bCookedOut;                                                                 // 0x0037 (size: 0x1)
    uint8 bDisabledLODsKeepEmitterAlive;                                              // 0x0037 (size: 0x1)
    uint8 bDisableWhenInsignficant;                                                   // 0x0038 (size: 0x1)
    TArray<class UParticleLODLevel*> LODLevels;                                       // 0x0040 (size: 0x10)
    int32 PeakActiveParticles;                                                        // 0x0050 (size: 0x4)
    int32 InitialAllocationCount;                                                     // 0x0054 (size: 0x4)
    float QualityLevelSpawnRateScale;                                                 // 0x0058 (size: 0x4)
    uint32 DetailModeBitmask;                                                         // 0x005C (size: 0x4)

}; // Size: 0x1C0

class UParticleLODLevel : public UObject
{
    int32 Level;                                                                      // 0x0028 (size: 0x4)
    uint8 bEnabled;                                                                   // 0x002C (size: 0x1)
    class UParticleModuleRequired* RequiredModule;                                    // 0x0030 (size: 0x8)
    TArray<class UParticleModule*> Modules;                                           // 0x0038 (size: 0x10)
    class UParticleModuleTypeDataBase* TypeDataModule;                                // 0x0048 (size: 0x8)
    class UParticleModuleSpawn* SpawnModule;                                          // 0x0050 (size: 0x8)
    class UParticleModuleEventGenerator* EventGenerator;                              // 0x0058 (size: 0x8)
    TArray<class UParticleModuleSpawnBase*> SpawningModules;                          // 0x0060 (size: 0x10)
    TArray<class UParticleModule*> SpawnModules;                                      // 0x0070 (size: 0x10)
    TArray<class UParticleModule*> UpdateModules;                                     // 0x0080 (size: 0x10)
    TArray<class UParticleModuleOrbit*> OrbitModules;                                 // 0x0090 (size: 0x10)
    TArray<class UParticleModuleEventReceiverBase*> EventReceiverModules;             // 0x00A0 (size: 0x10)
    uint8 ConvertedModules;                                                           // 0x00B0 (size: 0x1)
    int32 PeakActiveParticles;                                                        // 0x00B4 (size: 0x4)

}; // Size: 0xB8

class UParticleModule : public UObject
{
    uint8 bSpawnModule;                                                               // 0x0028 (size: 0x1)
    uint8 bUpdateModule;                                                              // 0x0028 (size: 0x1)
    uint8 bFinalUpdateModule;                                                         // 0x0028 (size: 0x1)
    uint8 bUpdateForGPUEmitter;                                                       // 0x0028 (size: 0x1)
    uint8 bCurvesAsColor;                                                             // 0x0028 (size: 0x1)
    uint8 b3DDrawMode;                                                                // 0x0028 (size: 0x1)
    uint8 bSupported3DDrawMode;                                                       // 0x0028 (size: 0x1)
    uint8 bEnabled;                                                                   // 0x0028 (size: 0x1)
    uint8 bEditable;                                                                  // 0x0029 (size: 0x1)
    uint8 LODDuplicate;                                                               // 0x0029 (size: 0x1)
    uint8 bSupportsRandomSeed;                                                        // 0x0029 (size: 0x1)
    uint8 bRequiresLoopingNotification;                                               // 0x0029 (size: 0x1)
    uint8 LODValidity;                                                                // 0x002A (size: 0x1)

}; // Size: 0x30

class UParticleModuleAcceleration : public UParticleModuleAccelerationBase
{
    FRawDistributionVector Acceleration;                                              // 0x0038 (size: 0x60)
    uint8 bApplyOwnerScale;                                                           // 0x0098 (size: 0x1)

}; // Size: 0xA0

class UParticleModuleAccelerationBase : public UParticleModule
{
    uint8 bAlwaysInWorldSpace;                                                        // 0x0030 (size: 0x1)

}; // Size: 0x38

class UParticleModuleAccelerationConstant : public UParticleModuleAccelerationBase
{
    FVector Acceleration;                                                             // 0x0038 (size: 0x18)

}; // Size: 0x50

class UParticleModuleAccelerationDrag : public UParticleModuleAccelerationBase
{
    class UDistributionFloat* DragCoefficient;                                        // 0x0038 (size: 0x8)
    FRawDistributionFloat DragCoefficientRaw;                                         // 0x0040 (size: 0x30)

}; // Size: 0x70

class UParticleModuleAccelerationDragScaleOverLife : public UParticleModuleAccelerationBase
{
    class UDistributionFloat* DragScale;                                              // 0x0038 (size: 0x8)
    FRawDistributionFloat DragScaleRaw;                                               // 0x0040 (size: 0x30)

}; // Size: 0x70

class UParticleModuleAccelerationOverLifetime : public UParticleModuleAccelerationBase
{
    FRawDistributionVector AccelOverLife;                                             // 0x0038 (size: 0x60)

}; // Size: 0x98

class UParticleModuleAttractorBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleAttractorLine : public UParticleModuleAttractorBase
{
    FVector EndPoint0;                                                                // 0x0030 (size: 0x18)
    FVector EndPoint1;                                                                // 0x0048 (size: 0x18)
    FRawDistributionFloat Range;                                                      // 0x0060 (size: 0x30)
    FRawDistributionFloat Strength;                                                   // 0x0090 (size: 0x30)

}; // Size: 0xC0

class UParticleModuleAttractorParticle : public UParticleModuleAttractorBase
{
    FName EmitterName;                                                                // 0x0030 (size: 0x8)
    FRawDistributionFloat Range;                                                      // 0x0038 (size: 0x30)
    uint8 bStrengthByDistance;                                                        // 0x0068 (size: 0x1)
    FRawDistributionFloat Strength;                                                   // 0x0070 (size: 0x30)
    uint8 bAffectBaseVelocity;                                                        // 0x00A0 (size: 0x1)
    TEnumAsByte<EAttractorParticleSelectionMethod> SelectionMethod;                   // 0x00A4 (size: 0x1)
    uint8 bRenewSource;                                                               // 0x00A8 (size: 0x1)
    uint8 bInheritSourceVel;                                                          // 0x00A8 (size: 0x1)
    int32 LastSelIndex;                                                               // 0x00AC (size: 0x4)

}; // Size: 0xB0

class UParticleModuleAttractorPoint : public UParticleModuleAttractorBase
{
    FRawDistributionVector Position;                                                  // 0x0030 (size: 0x60)
    FRawDistributionFloat Range;                                                      // 0x0090 (size: 0x30)
    FRawDistributionFloat Strength;                                                   // 0x00C0 (size: 0x30)
    uint8 StrengthByDistance;                                                         // 0x00F0 (size: 0x1)
    uint8 bAffectBaseVelocity;                                                        // 0x00F0 (size: 0x1)
    uint8 bOverrideVelocity;                                                          // 0x00F0 (size: 0x1)
    uint8 bUseWorldSpacePosition;                                                     // 0x00F0 (size: 0x1)
    uint8 Positive_X;                                                                 // 0x00F0 (size: 0x1)
    uint8 Positive_Y;                                                                 // 0x00F0 (size: 0x1)
    uint8 Positive_Z;                                                                 // 0x00F0 (size: 0x1)
    uint8 Negative_X;                                                                 // 0x00F0 (size: 0x1)
    uint8 Negative_Y;                                                                 // 0x00F1 (size: 0x1)
    uint8 Negative_Z;                                                                 // 0x00F1 (size: 0x1)

}; // Size: 0xF8

class UParticleModuleAttractorPointGravity : public UParticleModuleAttractorBase
{
    FVector Position;                                                                 // 0x0030 (size: 0x18)
    float Radius;                                                                     // 0x0048 (size: 0x4)
    class UDistributionFloat* Strength;                                               // 0x0050 (size: 0x8)
    FRawDistributionFloat StrengthRaw;                                                // 0x0058 (size: 0x30)

}; // Size: 0x88

class UParticleModuleBeamBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleBeamModifier : public UParticleModuleBeamBase
{
    TEnumAsByte<BeamModifierType> ModifierType;                                       // 0x0030 (size: 0x1)
    FBeamModifierOptions PositionOptions;                                             // 0x0034 (size: 0x4)
    FRawDistributionVector Position;                                                  // 0x0038 (size: 0x60)
    FBeamModifierOptions TangentOptions;                                              // 0x0098 (size: 0x4)
    FRawDistributionVector Tangent;                                                   // 0x00A0 (size: 0x60)
    uint8 bAbsoluteTangent;                                                           // 0x0100 (size: 0x1)
    FBeamModifierOptions StrengthOptions;                                             // 0x0104 (size: 0x4)
    FRawDistributionFloat Strength;                                                   // 0x0108 (size: 0x30)

}; // Size: 0x138

class UParticleModuleBeamNoise : public UParticleModuleBeamBase
{
    uint8 bLowFreq_Enabled;                                                           // 0x0030 (size: 0x1)
    int32 Frequency;                                                                  // 0x0034 (size: 0x4)
    int32 Frequency_LowRange;                                                         // 0x0038 (size: 0x4)
    FRawDistributionVector NoiseRange;                                                // 0x0040 (size: 0x60)
    FRawDistributionFloat NoiseRangeScale;                                            // 0x00A0 (size: 0x30)
    uint8 bNRScaleEmitterTime;                                                        // 0x00D0 (size: 0x1)
    FRawDistributionVector NoiseSpeed;                                                // 0x00D8 (size: 0x60)
    uint8 bSmooth;                                                                    // 0x0138 (size: 0x1)
    float NoiseLockRadius;                                                            // 0x013C (size: 0x4)
    uint8 bNoiseLock;                                                                 // 0x0140 (size: 0x1)
    uint8 bOscillate;                                                                 // 0x0140 (size: 0x1)
    float NoiseLockTime;                                                              // 0x0144 (size: 0x4)
    float NoiseTension;                                                               // 0x0148 (size: 0x4)
    uint8 bUseNoiseTangents;                                                          // 0x014C (size: 0x1)
    FRawDistributionFloat NoiseTangentStrength;                                       // 0x0150 (size: 0x30)
    int32 NoiseTessellation;                                                          // 0x0180 (size: 0x4)
    uint8 bTargetNoise;                                                               // 0x0184 (size: 0x1)
    float FrequencyDistance;                                                          // 0x0188 (size: 0x4)
    uint8 bApplyNoiseScale;                                                           // 0x018C (size: 0x1)
    FRawDistributionFloat NoiseScale;                                                 // 0x0190 (size: 0x30)

}; // Size: 0x1C0

class UParticleModuleBeamSource : public UParticleModuleBeamBase
{
    TEnumAsByte<Beam2SourceTargetMethod> SourceMethod;                                // 0x0030 (size: 0x1)
    FName SourceName;                                                                 // 0x0034 (size: 0x8)
    uint8 bSourceAbsolute;                                                            // 0x003C (size: 0x1)
    FRawDistributionVector Source;                                                    // 0x0040 (size: 0x60)
    uint8 bLockSource;                                                                // 0x00A0 (size: 0x1)
    TEnumAsByte<Beam2SourceTargetTangentMethod> SourceTangentMethod;                  // 0x00A4 (size: 0x1)
    FRawDistributionVector SourceTangent;                                             // 0x00A8 (size: 0x60)
    uint8 bLockSourceTangent;                                                         // 0x0108 (size: 0x1)
    FRawDistributionFloat SourceStrength;                                             // 0x0110 (size: 0x30)
    uint8 bLockSourceStength;                                                         // 0x0140 (size: 0x1)

}; // Size: 0x148

class UParticleModuleBeamTarget : public UParticleModuleBeamBase
{
    TEnumAsByte<Beam2SourceTargetMethod> TargetMethod;                                // 0x0030 (size: 0x1)
    FName TargetName;                                                                 // 0x0034 (size: 0x8)
    FRawDistributionVector Target;                                                    // 0x0040 (size: 0x60)
    uint8 bTargetAbsolute;                                                            // 0x00A0 (size: 0x1)
    uint8 bLockTarget;                                                                // 0x00A0 (size: 0x1)
    TEnumAsByte<Beam2SourceTargetTangentMethod> TargetTangentMethod;                  // 0x00A4 (size: 0x1)
    FRawDistributionVector TargetTangent;                                             // 0x00A8 (size: 0x60)
    uint8 bLockTargetTangent;                                                         // 0x0108 (size: 0x1)
    FRawDistributionFloat TargetStrength;                                             // 0x0110 (size: 0x30)
    uint8 bLockTargetStength;                                                         // 0x0140 (size: 0x1)
    float LockRadius;                                                                 // 0x0144 (size: 0x4)

}; // Size: 0x150

class UParticleModuleCameraBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleCameraOffset : public UParticleModuleCameraBase
{
    FRawDistributionFloat CameraOffset;                                               // 0x0030 (size: 0x30)
    uint8 bSpawnTimeOnly;                                                             // 0x0060 (size: 0x1)
    TEnumAsByte<EParticleCameraOffsetUpdateMethod> UpdateMethod;                      // 0x0064 (size: 0x1)

}; // Size: 0x68

class UParticleModuleCollision : public UParticleModuleCollisionBase
{
    FRawDistributionVector DampingFactor;                                             // 0x0030 (size: 0x60)
    FRawDistributionVector DampingFactorRotation;                                     // 0x0090 (size: 0x60)
    FRawDistributionFloat MaxCollisions;                                              // 0x00F0 (size: 0x30)
    TEnumAsByte<EParticleCollisionComplete> CollisionCompletionOption;                // 0x0120 (size: 0x1)
    TArray<TEnumAsByte<EObjectTypeQuery>> CollisionTypes;                             // 0x0128 (size: 0x10)
    uint8 bApplyPhysics;                                                              // 0x0140 (size: 0x1)
    uint8 bIgnoreTriggerVolumes;                                                      // 0x0140 (size: 0x1)
    FRawDistributionFloat ParticleMass;                                               // 0x0148 (size: 0x30)
    float DirScalar;                                                                  // 0x0178 (size: 0x4)
    uint8 bPawnsDoNotDecrementCount;                                                  // 0x017C (size: 0x1)
    uint8 bOnlyVerticalNormalsDecrementCount;                                         // 0x017C (size: 0x1)
    float VerticalFudgeFactor;                                                        // 0x0180 (size: 0x4)
    FRawDistributionFloat DelayAmount;                                                // 0x0188 (size: 0x30)
    uint8 bDropDetail;                                                                // 0x01B8 (size: 0x1)
    uint8 bCollideOnlyIfVisible;                                                      // 0x01B8 (size: 0x1)
    uint8 bIgnoreSourceActor;                                                         // 0x01B8 (size: 0x1)
    float MaxCollisionDistance;                                                       // 0x01BC (size: 0x4)

}; // Size: 0x1C0

class UParticleModuleCollisionBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleCollisionGPU : public UParticleModuleCollisionBase
{
    FRawDistributionFloat Resilience;                                                 // 0x0030 (size: 0x30)
    FRawDistributionFloat ResilienceScaleOverLife;                                    // 0x0060 (size: 0x30)
    float Friction;                                                                   // 0x0090 (size: 0x4)
    float RandomSpread;                                                               // 0x0094 (size: 0x4)
    float RandomDistribution;                                                         // 0x0098 (size: 0x4)
    float RadiusScale;                                                                // 0x009C (size: 0x4)
    float RadiusBias;                                                                 // 0x00A0 (size: 0x4)
    TEnumAsByte<EParticleCollisionResponse::Type> Response;                           // 0x00A4 (size: 0x1)
    TEnumAsByte<EParticleCollisionMode::Type> CollisionMode;                          // 0x00A5 (size: 0x1)

}; // Size: 0xA8

class UParticleModuleColor : public UParticleModuleColorBase
{
    FRawDistributionVector StartColor;                                                // 0x0030 (size: 0x60)
    FRawDistributionFloat StartAlpha;                                                 // 0x0090 (size: 0x30)
    uint8 bClampAlpha;                                                                // 0x00C0 (size: 0x1)

}; // Size: 0xC8

class UParticleModuleColorBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleColorOverLife : public UParticleModuleColorBase
{
    FRawDistributionVector ColorOverLife;                                             // 0x0030 (size: 0x60)
    FRawDistributionFloat AlphaOverLife;                                              // 0x0090 (size: 0x30)
    uint8 bClampAlpha;                                                                // 0x00C0 (size: 0x1)

}; // Size: 0xC8

class UParticleModuleColorScaleOverLife : public UParticleModuleColorBase
{
    FRawDistributionVector ColorScaleOverLife;                                        // 0x0030 (size: 0x60)
    FRawDistributionFloat AlphaScaleOverLife;                                         // 0x0090 (size: 0x30)
    uint8 bEmitterTime;                                                               // 0x00C0 (size: 0x1)

}; // Size: 0xC8

class UParticleModuleColor_Seeded : public UParticleModuleColor
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x00C8 (size: 0x20)

}; // Size: 0xE8

class UParticleModuleEventBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleEventGenerator : public UParticleModuleEventBase
{
    TArray<FParticleEvent_GenerateInfo> Events;                                       // 0x0030 (size: 0x10)

}; // Size: 0x40

class UParticleModuleEventReceiverBase : public UParticleModuleEventBase
{
    TEnumAsByte<EParticleEventType> EventGeneratorType;                               // 0x0030 (size: 0x1)
    FName EventName;                                                                  // 0x0034 (size: 0x8)

}; // Size: 0x40

class UParticleModuleEventReceiverKillParticles : public UParticleModuleEventReceiverBase
{
    uint8 bStopSpawning;                                                              // 0x0040 (size: 0x1)

}; // Size: 0x48

class UParticleModuleEventReceiverSpawn : public UParticleModuleEventReceiverBase
{
    FRawDistributionFloat SpawnCount;                                                 // 0x0040 (size: 0x30)
    uint8 bUseParticleTime;                                                           // 0x0070 (size: 0x1)
    uint8 bUsePSysLocation;                                                           // 0x0070 (size: 0x1)
    uint8 bInheritVelocity;                                                           // 0x0070 (size: 0x1)
    FRawDistributionVector InheritVelocityScale;                                      // 0x0078 (size: 0x60)
    TArray<class UPhysicalMaterial*> PhysicalMaterials;                               // 0x00D8 (size: 0x10)
    uint8 bBanPhysicalMaterials;                                                      // 0x00E8 (size: 0x1)

}; // Size: 0xF0

class UParticleModuleEventSendToGame : public UObject
{
}; // Size: 0x28

class UParticleModuleKillBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleKillBox : public UParticleModuleKillBase
{
    FRawDistributionVector LowerLeftCorner;                                           // 0x0030 (size: 0x60)
    FRawDistributionVector UpperRightCorner;                                          // 0x0090 (size: 0x60)
    uint8 bAbsolute;                                                                  // 0x00F0 (size: 0x1)
    uint8 bKillInside;                                                                // 0x00F0 (size: 0x1)
    uint8 bAxisAlignedAndFixedSize;                                                   // 0x00F0 (size: 0x1)

}; // Size: 0xF8

class UParticleModuleKillHeight : public UParticleModuleKillBase
{
    FRawDistributionFloat Height;                                                     // 0x0030 (size: 0x30)
    uint8 bAbsolute;                                                                  // 0x0060 (size: 0x1)
    uint8 bFloor;                                                                     // 0x0060 (size: 0x1)
    uint8 bApplyPSysScale;                                                            // 0x0060 (size: 0x1)

}; // Size: 0x68

class UParticleModuleLifetime : public UParticleModuleLifetimeBase
{
    FRawDistributionFloat Lifetime;                                                   // 0x0030 (size: 0x30)

}; // Size: 0x60

class UParticleModuleLifetimeBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleLifetime_Seeded : public UParticleModuleLifetime
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0060 (size: 0x20)

}; // Size: 0x80

class UParticleModuleLight : public UParticleModuleLightBase
{
    bool bUseInverseSquaredFalloff;                                                   // 0x0030 (size: 0x1)
    bool bAffectsTranslucency;                                                        // 0x0031 (size: 0x1)
    uint8 bOverrideInverseExposureBlend;                                              // 0x0034 (size: 0x1)
    bool bPreviewLightRadius;                                                         // 0x0038 (size: 0x1)
    float SpawnFraction;                                                              // 0x003C (size: 0x4)
    FRawDistributionVector ColorScaleOverLife;                                        // 0x0040 (size: 0x60)
    FRawDistributionFloat BrightnessOverLife;                                         // 0x00A0 (size: 0x30)
    FRawDistributionFloat RadiusScale;                                                // 0x00D0 (size: 0x30)
    FRawDistributionFloat LightExponent;                                              // 0x0100 (size: 0x30)
    float InverseExposureBlend;                                                       // 0x0130 (size: 0x4)
    FLightingChannels LightingChannels;                                               // 0x0134 (size: 0x1)
    float VolumetricScatteringIntensity;                                              // 0x0138 (size: 0x4)
    bool bHighQualityLights;                                                          // 0x013C (size: 0x1)
    bool bShadowCastingLights;                                                        // 0x013D (size: 0x1)

}; // Size: 0x140

class UParticleModuleLightBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleLight_Seeded : public UParticleModuleLight
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0140 (size: 0x20)

}; // Size: 0x160

class UParticleModuleLocation : public UParticleModuleLocationBase
{
    FRawDistributionVector StartLocation;                                             // 0x0030 (size: 0x60)
    float DistributeOverNPoints;                                                      // 0x0090 (size: 0x4)
    float DistributeThreshold;                                                        // 0x0094 (size: 0x4)

}; // Size: 0x98

class UParticleModuleLocationBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleLocationBoneSocket : public UParticleModuleLocationBase
{
    TEnumAsByte<ELocationBoneSocketSource> SourceType;                                // 0x0030 (size: 0x1)
    FVector UniversalOffset;                                                          // 0x0038 (size: 0x18)
    TArray<FLocationBoneSocketInfo> SourceLocations;                                  // 0x0050 (size: 0x10)
    TEnumAsByte<ELocationBoneSocketSelectionMethod> SelectionMethod;                  // 0x0060 (size: 0x1)
    uint8 bUpdatePositionEachFrame;                                                   // 0x0064 (size: 0x1)
    uint8 bOrientMeshEmitters;                                                        // 0x0064 (size: 0x1)
    uint8 bInheritBoneVelocity;                                                       // 0x0064 (size: 0x1)
    float InheritVelocityScale;                                                       // 0x0068 (size: 0x4)
    FName SkelMeshActorParamName;                                                     // 0x006C (size: 0x8)
    int32 NumPreSelectedIndices;                                                      // 0x0074 (size: 0x4)

}; // Size: 0x80

class UParticleModuleLocationDirect : public UParticleModuleLocationBase
{
    FRawDistributionVector Location;                                                  // 0x0030 (size: 0x60)
    FRawDistributionVector LocationOffset;                                            // 0x0090 (size: 0x60)
    FRawDistributionVector ScaleFactor;                                               // 0x00F0 (size: 0x60)
    FRawDistributionVector Direction;                                                 // 0x0150 (size: 0x60)

}; // Size: 0x1B0

class UParticleModuleLocationEmitter : public UParticleModuleLocationBase
{
    FName EmitterName;                                                                // 0x0030 (size: 0x8)
    TEnumAsByte<ELocationEmitterSelectionMethod> SelectionMethod;                     // 0x0038 (size: 0x1)
    uint8 InheritSourceVelocity;                                                      // 0x003C (size: 0x1)
    float InheritSourceVelocityScale;                                                 // 0x0040 (size: 0x4)
    uint8 bInheritSourceRotation;                                                     // 0x0044 (size: 0x1)
    float InheritSourceRotationScale;                                                 // 0x0048 (size: 0x4)

}; // Size: 0x50

class UParticleModuleLocationEmitterDirect : public UParticleModuleLocationBase
{
    FName EmitterName;                                                                // 0x0030 (size: 0x8)

}; // Size: 0x38

class UParticleModuleLocationPrimitiveBase : public UParticleModuleLocationBase
{
    uint8 Positive_X;                                                                 // 0x0030 (size: 0x1)
    uint8 Positive_Y;                                                                 // 0x0030 (size: 0x1)
    uint8 Positive_Z;                                                                 // 0x0030 (size: 0x1)
    uint8 Negative_X;                                                                 // 0x0030 (size: 0x1)
    uint8 Negative_Y;                                                                 // 0x0030 (size: 0x1)
    uint8 Negative_Z;                                                                 // 0x0030 (size: 0x1)
    uint8 SurfaceOnly;                                                                // 0x0030 (size: 0x1)
    uint8 Velocity;                                                                   // 0x0030 (size: 0x1)
    FRawDistributionFloat VelocityScale;                                              // 0x0038 (size: 0x30)
    FRawDistributionVector StartLocation;                                             // 0x0068 (size: 0x60)

}; // Size: 0xC8

class UParticleModuleLocationPrimitiveCylinder : public UParticleModuleLocationPrimitiveBase
{
    uint8 RadialVelocity;                                                             // 0x00C8 (size: 0x1)
    FRawDistributionFloat StartRadius;                                                // 0x00D0 (size: 0x30)
    FRawDistributionFloat StartHeight;                                                // 0x0100 (size: 0x30)
    TEnumAsByte<CylinderHeightAxis> HeightAxis;                                       // 0x0130 (size: 0x1)

}; // Size: 0x138

class UParticleModuleLocationPrimitiveCylinder_Seeded : public UParticleModuleLocationPrimitiveCylinder
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0138 (size: 0x20)

}; // Size: 0x158

class UParticleModuleLocationPrimitiveSphere : public UParticleModuleLocationPrimitiveBase
{
    FRawDistributionFloat StartRadius;                                                // 0x00C8 (size: 0x30)

}; // Size: 0xF8

class UParticleModuleLocationPrimitiveSphere_Seeded : public UParticleModuleLocationPrimitiveSphere
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x00F8 (size: 0x20)

}; // Size: 0x118

class UParticleModuleLocationPrimitiveTriangle : public UParticleModuleLocationBase
{
    FRawDistributionVector StartOffset;                                               // 0x0030 (size: 0x60)
    FRawDistributionFloat Height;                                                     // 0x0090 (size: 0x30)
    FRawDistributionFloat Angle;                                                      // 0x00C0 (size: 0x30)
    FRawDistributionFloat Thickness;                                                  // 0x00F0 (size: 0x30)

}; // Size: 0x120

class UParticleModuleLocationSkelVertSurface : public UParticleModuleLocationBase
{
    TEnumAsByte<ELocationSkelVertSurfaceSource> SourceType;                           // 0x0030 (size: 0x1)
    FVector UniversalOffset;                                                          // 0x0038 (size: 0x18)
    uint8 bUpdatePositionEachFrame;                                                   // 0x0050 (size: 0x1)
    uint8 bOrientMeshEmitters;                                                        // 0x0050 (size: 0x1)
    uint8 bInheritBoneVelocity;                                                       // 0x0050 (size: 0x1)
    float InheritVelocityScale;                                                       // 0x0054 (size: 0x4)
    FName SkelMeshActorParamName;                                                     // 0x0058 (size: 0x8)
    TArray<FName> ValidAssociatedBones;                                               // 0x0060 (size: 0x10)
    uint8 bEnforceNormalCheck;                                                        // 0x0070 (size: 0x1)
    FVector NormalToCompare;                                                          // 0x0078 (size: 0x18)
    float NormalCheckToleranceDegrees;                                                // 0x0090 (size: 0x4)
    float NormalCheckTolerance;                                                       // 0x0094 (size: 0x4)
    TArray<int32> ValidMaterialIndices;                                               // 0x0098 (size: 0x10)
    uint8 bInheritVertexColor;                                                        // 0x00A8 (size: 0x1)
    uint8 bInheritUV;                                                                 // 0x00A8 (size: 0x1)
    uint32 InheritUVChannel;                                                          // 0x00AC (size: 0x4)

}; // Size: 0xB0

class UParticleModuleLocationWorldOffset : public UParticleModuleLocation
{
}; // Size: 0x98

class UParticleModuleLocationWorldOffset_Seeded : public UParticleModuleLocationWorldOffset
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0098 (size: 0x20)

}; // Size: 0xB8

class UParticleModuleLocation_Seeded : public UParticleModuleLocation
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0098 (size: 0x20)

}; // Size: 0xB8

class UParticleModuleMaterialBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleMeshMaterial : public UParticleModuleMaterialBase
{
    TArray<class UMaterialInterface*> MeshMaterials;                                  // 0x0030 (size: 0x10)

}; // Size: 0x40

class UParticleModuleMeshRotation : public UParticleModuleRotationBase
{
    FRawDistributionVector StartRotation;                                             // 0x0030 (size: 0x60)
    uint8 bInheritParent;                                                             // 0x0090 (size: 0x1)

}; // Size: 0x98

class UParticleModuleMeshRotationRate : public UParticleModuleRotationRateBase
{
    FRawDistributionVector StartRotationRate;                                         // 0x0030 (size: 0x60)

}; // Size: 0x90

class UParticleModuleMeshRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
    FRawDistributionVector LifeMultiplier;                                            // 0x0030 (size: 0x60)

}; // Size: 0x90

class UParticleModuleMeshRotationRateOverLife : public UParticleModuleRotationRateBase
{
    FRawDistributionVector RotRate;                                                   // 0x0030 (size: 0x60)
    uint8 bScaleRotRate;                                                              // 0x0090 (size: 0x1)

}; // Size: 0x98

class UParticleModuleMeshRotationRate_Seeded : public UParticleModuleMeshRotationRate
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0090 (size: 0x20)

}; // Size: 0xB0

class UParticleModuleMeshRotation_Seeded : public UParticleModuleMeshRotation
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0098 (size: 0x20)

}; // Size: 0xB8

class UParticleModuleOrbit : public UParticleModuleOrbitBase
{
    TEnumAsByte<EOrbitChainMode> ChainMode;                                           // 0x0038 (size: 0x1)
    FRawDistributionVector OffsetAmount;                                              // 0x0040 (size: 0x60)
    FOrbitOptions OffsetOptions;                                                      // 0x00A0 (size: 0x4)
    FRawDistributionVector RotationAmount;                                            // 0x00A8 (size: 0x60)
    FOrbitOptions RotationOptions;                                                    // 0x0108 (size: 0x4)
    FRawDistributionVector RotationRateAmount;                                        // 0x0110 (size: 0x60)
    FOrbitOptions RotationRateOptions;                                                // 0x0170 (size: 0x4)

}; // Size: 0x178

class UParticleModuleOrbitBase : public UParticleModule
{
    uint8 bUseEmitterTime;                                                            // 0x0030 (size: 0x1)

}; // Size: 0x38

class UParticleModuleOrientationAxisLock : public UParticleModuleOrientationBase
{
    TEnumAsByte<EParticleAxisLock> LockAxisFlags;                                     // 0x0030 (size: 0x1)

}; // Size: 0x38

class UParticleModuleOrientationBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleParameterBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleParameterDynamic : public UParticleModuleParameterBase
{
    TArray<FEmitterDynamicParameter> DynamicParams;                                   // 0x0030 (size: 0x10)
    int32 UpdateFlags;                                                                // 0x0040 (size: 0x4)
    uint8 bUsesVelocity;                                                              // 0x0044 (size: 0x1)

}; // Size: 0x48

class UParticleModuleParameterDynamic_Seeded : public UParticleModuleParameterDynamic
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0048 (size: 0x20)

}; // Size: 0x68

class UParticleModulePivotOffset : public UParticleModuleLocationBase
{
    FVector2D PivotOffset;                                                            // 0x0030 (size: 0x10)

}; // Size: 0x40

class UParticleModuleRequired : public UParticleModule
{
    class UMaterialInterface* Material;                                               // 0x0030 (size: 0x8)
    float MinFacingCameraBlendDistance;                                               // 0x0038 (size: 0x4)
    float MaxFacingCameraBlendDistance;                                               // 0x003C (size: 0x4)
    FVector EmitterOrigin;                                                            // 0x0040 (size: 0x18)
    FRotator EmitterRotation;                                                         // 0x0058 (size: 0x18)
    TEnumAsByte<EParticleScreenAlignment> ScreenAlignment;                            // 0x0070 (size: 0x1)
    uint8 bUseLocalSpace;                                                             // 0x0071 (size: 0x1)
    uint8 bKillOnDeactivate;                                                          // 0x0071 (size: 0x1)
    uint8 bKillOnCompleted;                                                           // 0x0071 (size: 0x1)
    TEnumAsByte<EParticleSortMode> SortMode;                                          // 0x0072 (size: 0x1)
    uint8 bUseLegacyEmitterTime;                                                      // 0x0073 (size: 0x1)
    uint8 bRemoveHMDRoll;                                                             // 0x0073 (size: 0x1)
    uint8 bSupportLargeWorldCoordinates;                                              // 0x0073 (size: 0x1)
    uint8 bEmitterDurationUseRange;                                                   // 0x0073 (size: 0x1)
    uint8 bOverrideUseVelocityForMotionBlur;                                          // 0x0073 (size: 0x1)
    uint8 bUseVelocityForMotionBlur;                                                  // 0x0073 (size: 0x1)
    float EmitterDuration;                                                            // 0x0074 (size: 0x4)
    FRawDistributionFloat SpawnRate;                                                  // 0x0078 (size: 0x30)
    TArray<FParticleBurst> BurstList;                                                 // 0x00A8 (size: 0x10)
    float EmitterDelay;                                                               // 0x00B8 (size: 0x4)
    float EmitterDelayLow;                                                            // 0x00BC (size: 0x4)
    uint8 bDelayFirstLoopOnly;                                                        // 0x00C0 (size: 0x1)
    TEnumAsByte<EParticleSubUVInterpMethod> InterpolationMethod;                      // 0x00C1 (size: 0x1)
    uint8 bScaleUV;                                                                   // 0x00C2 (size: 0x1)
    uint8 bEmitterDelayUseRange;                                                      // 0x00C2 (size: 0x1)
    TEnumAsByte<EParticleBurstMethod> ParticleBurstMethod;                            // 0x00C3 (size: 0x1)
    uint8 bOverrideSystemMacroUV;                                                     // 0x00C4 (size: 0x1)
    uint8 bUseMaxDrawCount;                                                           // 0x00C4 (size: 0x1)
    TEnumAsByte<EOpacitySourceMode> OpacitySourceMode;                                // 0x00C5 (size: 0x1)
    TEnumAsByte<EEmitterNormalsMode> EmitterNormalsMode;                              // 0x00C6 (size: 0x1)
    uint8 bOrbitModuleAffectsVelocityAlignment;                                       // 0x00C7 (size: 0x1)
    int32 SubImages_Horizontal;                                                       // 0x00C8 (size: 0x4)
    int32 SubImages_Vertical;                                                         // 0x00CC (size: 0x4)
    float RandomImageTime;                                                            // 0x00D0 (size: 0x4)
    int32 RandomImageChanges;                                                         // 0x00D4 (size: 0x4)
    FVector MacroUVPosition;                                                          // 0x00D8 (size: 0x18)
    float MacroUVRadius;                                                              // 0x00F0 (size: 0x4)
    EParticleUVFlipMode UVFlippingMode;                                               // 0x00F4 (size: 0x1)
    TEnumAsByte<ESubUVBoundingVertexCount> BoundingMode;                              // 0x00F5 (size: 0x1)
    uint8 bDurationRecalcEachLoop;                                                    // 0x00F6 (size: 0x1)
    FVector NormalsSphereCenter;                                                      // 0x00F8 (size: 0x18)
    float AlphaThreshold;                                                             // 0x0110 (size: 0x4)
    int32 EmitterLoops;                                                               // 0x0114 (size: 0x4)
    class UTexture2D* CutoutTexture;                                                  // 0x0118 (size: 0x8)
    int32 MaxDrawCount;                                                               // 0x0120 (size: 0x4)
    float EmitterDurationLow;                                                         // 0x0124 (size: 0x4)
    FVector NormalsCylinderDirection;                                                 // 0x0128 (size: 0x18)
    TArray<FName> NamedMaterialOverrides;                                             // 0x0140 (size: 0x10)

}; // Size: 0x170

class UParticleModuleRotation : public UParticleModuleRotationBase
{
    FRawDistributionFloat StartRotation;                                              // 0x0030 (size: 0x30)

}; // Size: 0x60

class UParticleModuleRotationBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleRotationOverLifetime : public UParticleModuleRotationBase
{
    FRawDistributionFloat RotationOverLife;                                           // 0x0030 (size: 0x30)
    uint8 Scale;                                                                      // 0x0060 (size: 0x1)

}; // Size: 0x68

class UParticleModuleRotationRate : public UParticleModuleRotationRateBase
{
    FRawDistributionFloat StartRotationRate;                                          // 0x0030 (size: 0x30)

}; // Size: 0x60

class UParticleModuleRotationRateBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
    FRawDistributionFloat LifeMultiplier;                                             // 0x0030 (size: 0x30)

}; // Size: 0x60

class UParticleModuleRotationRate_Seeded : public UParticleModuleRotationRate
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0060 (size: 0x20)

}; // Size: 0x80

class UParticleModuleRotation_Seeded : public UParticleModuleRotation
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0060 (size: 0x20)

}; // Size: 0x80

class UParticleModuleSize : public UParticleModuleSizeBase
{
    FRawDistributionVector StartSize;                                                 // 0x0030 (size: 0x60)

}; // Size: 0x90

class UParticleModuleSizeBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleSizeMultiplyLife : public UParticleModuleSizeBase
{
    FRawDistributionVector LifeMultiplier;                                            // 0x0030 (size: 0x60)
    uint8 MultiplyX;                                                                  // 0x0090 (size: 0x1)
    uint8 MultiplyY;                                                                  // 0x0090 (size: 0x1)
    uint8 MultiplyZ;                                                                  // 0x0090 (size: 0x1)

}; // Size: 0x98

class UParticleModuleSizeScale : public UParticleModuleSizeBase
{
    FRawDistributionVector SizeScale;                                                 // 0x0030 (size: 0x60)
    uint8 EnableX;                                                                    // 0x0090 (size: 0x1)
    uint8 EnableY;                                                                    // 0x0090 (size: 0x1)
    uint8 EnableZ;                                                                    // 0x0090 (size: 0x1)

}; // Size: 0x98

class UParticleModuleSizeScaleBySpeed : public UParticleModuleSizeBase
{
    FVector2D SpeedScale;                                                             // 0x0030 (size: 0x10)
    FVector2D MaxScale;                                                               // 0x0040 (size: 0x10)

}; // Size: 0x50

class UParticleModuleSize_Seeded : public UParticleModuleSize
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x0090 (size: 0x20)

}; // Size: 0xB0

class UParticleModuleSourceMovement : public UParticleModuleLocationBase
{
    FRawDistributionVector SourceMovementScale;                                       // 0x0030 (size: 0x60)

}; // Size: 0x90

class UParticleModuleSpawn : public UParticleModuleSpawnBase
{
    FRawDistributionFloat Rate;                                                       // 0x0038 (size: 0x30)
    FRawDistributionFloat RateScale;                                                  // 0x0068 (size: 0x30)
    TArray<FParticleBurst> BurstList;                                                 // 0x0098 (size: 0x10)
    FRawDistributionFloat BurstScale;                                                 // 0x00A8 (size: 0x30)
    TEnumAsByte<EParticleBurstMethod> ParticleBurstMethod;                            // 0x00D8 (size: 0x1)
    uint8 bApplyGlobalSpawnRateScale;                                                 // 0x00DC (size: 0x1)

}; // Size: 0xE0

class UParticleModuleSpawnBase : public UParticleModule
{
    uint8 bProcessSpawnRate;                                                          // 0x0030 (size: 0x1)
    uint8 bProcessBurstList;                                                          // 0x0030 (size: 0x1)

}; // Size: 0x38

class UParticleModuleSpawnPerUnit : public UParticleModuleSpawnBase
{
    float UnitScalar;                                                                 // 0x0038 (size: 0x4)
    float MovementTolerance;                                                          // 0x003C (size: 0x4)
    FRawDistributionFloat SpawnPerUnit;                                               // 0x0040 (size: 0x30)
    float MaxFrameDistance;                                                           // 0x0070 (size: 0x4)
    uint8 bIgnoreSpawnRateWhenMoving;                                                 // 0x0074 (size: 0x1)
    uint8 bIgnoreMovementAlongX;                                                      // 0x0074 (size: 0x1)
    uint8 bIgnoreMovementAlongY;                                                      // 0x0074 (size: 0x1)
    uint8 bIgnoreMovementAlongZ;                                                      // 0x0074 (size: 0x1)

}; // Size: 0x78

class UParticleModuleSubUV : public UParticleModuleSubUVBase
{
    class USubUVAnimation* Animation;                                                 // 0x0030 (size: 0x8)
    FRawDistributionFloat SubImageIndex;                                              // 0x0038 (size: 0x30)
    uint8 bUseRealTime;                                                               // 0x0068 (size: 0x1)

}; // Size: 0x70

class UParticleModuleSubUVBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleSubUVMovie : public UParticleModuleSubUV
{
    uint8 bUseEmitterTime;                                                            // 0x0070 (size: 0x1)
    FRawDistributionFloat FrameRate;                                                  // 0x0078 (size: 0x30)
    int32 StartingFrame;                                                              // 0x00A8 (size: 0x4)

}; // Size: 0xB0

class UParticleModuleTrailBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleTrailSource : public UParticleModuleTrailBase
{
    TEnumAsByte<ETrail2SourceMethod> SourceMethod;                                    // 0x0030 (size: 0x1)
    FName SourceName;                                                                 // 0x0034 (size: 0x8)
    FRawDistributionFloat SourceStrength;                                             // 0x0040 (size: 0x30)
    uint8 bLockSourceStength;                                                         // 0x0070 (size: 0x1)
    int32 SourceOffsetCount;                                                          // 0x0074 (size: 0x4)
    TArray<FVector> SourceOffsetDefaults;                                             // 0x0078 (size: 0x10)
    TEnumAsByte<EParticleSourceSelectionMethod> SelectionMethod;                      // 0x0088 (size: 0x1)
    uint8 bInheritRotation;                                                           // 0x008C (size: 0x1)

}; // Size: 0x90

class UParticleModuleTypeDataAnimTrail : public UParticleModuleTypeDataBase
{
    uint8 bDeadTrailsOnDeactivate;                                                    // 0x0030 (size: 0x1)
    uint8 bEnablePreviousTangentRecalculation;                                        // 0x0030 (size: 0x1)
    uint8 bTangentRecalculationEveryFrame;                                            // 0x0030 (size: 0x1)
    float TilingDistance;                                                             // 0x0034 (size: 0x4)
    float DistanceTessellationStepSize;                                               // 0x0038 (size: 0x4)
    float TangentTessellationStepSize;                                                // 0x003C (size: 0x4)
    float WidthTessellationStepSize;                                                  // 0x0040 (size: 0x4)

}; // Size: 0x48

class UParticleModuleTypeDataBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleTypeDataBeam2 : public UParticleModuleTypeDataBase
{
    TEnumAsByte<EBeam2Method> BeamMethod;                                             // 0x0030 (size: 0x1)
    int32 TextureTile;                                                                // 0x0034 (size: 0x4)
    float TextureTileDistance;                                                        // 0x0038 (size: 0x4)
    int32 Sheets;                                                                     // 0x003C (size: 0x4)
    int32 MaxBeamCount;                                                               // 0x0040 (size: 0x4)
    float Speed;                                                                      // 0x0044 (size: 0x4)
    int32 InterpolationPoints;                                                        // 0x0048 (size: 0x4)
    uint8 bAlwaysOn;                                                                  // 0x004C (size: 0x1)
    int32 UpVectorStepSize;                                                           // 0x0050 (size: 0x4)
    FName BranchParentName;                                                           // 0x0054 (size: 0x8)
    FRawDistributionFloat Distance;                                                   // 0x0060 (size: 0x30)
    TEnumAsByte<EBeamTaperMethod> TaperMethod;                                        // 0x0090 (size: 0x1)
    FRawDistributionFloat TaperFactor;                                                // 0x0098 (size: 0x30)
    FRawDistributionFloat TaperScale;                                                 // 0x00C8 (size: 0x30)
    uint8 RenderGeometry;                                                             // 0x00F8 (size: 0x1)
    uint8 RenderDirectLine;                                                           // 0x00F8 (size: 0x1)
    uint8 RenderLines;                                                                // 0x00F8 (size: 0x1)
    uint8 RenderTessellation;                                                         // 0x00F8 (size: 0x1)

}; // Size: 0x150

class UParticleModuleTypeDataGpu : public UParticleModuleTypeDataBase
{
    FGPUSpriteEmitterInfo EmitterInfo;                                                // 0x0030 (size: 0x350)
    FGPUSpriteResourceData ResourceData;                                              // 0x0380 (size: 0x240)
    float CameraMotionBlurAmount;                                                     // 0x05C0 (size: 0x4)
    uint8 bClearExistingParticlesOnInit;                                              // 0x05C4 (size: 0x1)

}; // Size: 0x5D0

class UParticleModuleTypeDataMesh : public UParticleModuleTypeDataBase
{
    class UStaticMesh* Mesh;                                                          // 0x0030 (size: 0x8)
    float LODSizeScale;                                                               // 0x0040 (size: 0x4)
    uint8 bUseStaticMeshLODs;                                                         // 0x0044 (size: 0x1)
    uint8 CastShadows;                                                                // 0x0044 (size: 0x1)
    uint8 DoCollisions;                                                               // 0x0044 (size: 0x1)
    TEnumAsByte<EMeshScreenAlignment> MeshAlignment;                                  // 0x0045 (size: 0x1)
    uint8 bOverrideMaterial;                                                          // 0x0046 (size: 0x1)
    uint8 bOverrideDefaultMotionBlurSettings;                                         // 0x0046 (size: 0x1)
    uint8 bEnableMotionBlur;                                                          // 0x0046 (size: 0x1)
    FRawDistributionVector RollPitchYawRange;                                         // 0x0048 (size: 0x60)
    TEnumAsByte<EParticleAxisLock> AxisLockOption;                                    // 0x00A8 (size: 0x1)
    uint8 bCameraFacing;                                                              // 0x00A9 (size: 0x1)
    TEnumAsByte<EMeshCameraFacingUpAxis> CameraFacingUpAxisOption;                    // 0x00AA (size: 0x1)
    TEnumAsByte<EMeshCameraFacingOptions> CameraFacingOption;                         // 0x00AB (size: 0x1)
    uint8 bApplyParticleRotationAsSpin;                                               // 0x00AC (size: 0x1)
    uint8 bFaceCameraDirectionRatherThanPosition;                                     // 0x00AC (size: 0x1)
    uint8 bCollisionsConsiderPartilceSize;                                            // 0x00AC (size: 0x1)

}; // Size: 0xB0

class UParticleModuleTypeDataRibbon : public UParticleModuleTypeDataBase
{
    int32 MaxTessellationBetweenParticles;                                            // 0x0030 (size: 0x4)
    int32 SheetsPerTrail;                                                             // 0x0034 (size: 0x4)
    int32 MaxTrailCount;                                                              // 0x0038 (size: 0x4)
    int32 MaxParticleInTrailCount;                                                    // 0x003C (size: 0x4)
    uint8 bDeadTrailsOnDeactivate;                                                    // 0x0040 (size: 0x1)
    uint8 bDeadTrailsOnSourceLoss;                                                    // 0x0040 (size: 0x1)
    uint8 bClipSourceSegement;                                                        // 0x0040 (size: 0x1)
    uint8 bEnablePreviousTangentRecalculation;                                        // 0x0040 (size: 0x1)
    uint8 bTangentRecalculationEveryFrame;                                            // 0x0040 (size: 0x1)
    uint8 bSpawnInitialParticle;                                                      // 0x0040 (size: 0x1)
    TEnumAsByte<ETrailsRenderAxisOption> RenderAxis;                                  // 0x0044 (size: 0x1)
    float TangentSpawningScalar;                                                      // 0x0048 (size: 0x4)
    uint8 bRenderGeometry;                                                            // 0x004C (size: 0x1)
    uint8 bRenderSpawnPoints;                                                         // 0x004C (size: 0x1)
    uint8 bRenderTangents;                                                            // 0x004C (size: 0x1)
    uint8 bRenderTessellation;                                                        // 0x004C (size: 0x1)
    float TilingDistance;                                                             // 0x0050 (size: 0x4)
    float DistanceTessellationStepSize;                                               // 0x0054 (size: 0x4)
    uint8 bEnableTangentDiffInterpScale;                                              // 0x0058 (size: 0x1)
    float TangentTessellationScalar;                                                  // 0x005C (size: 0x4)

}; // Size: 0x60

class UParticleModuleVectorFieldBase : public UParticleModule
{
}; // Size: 0x30

class UParticleModuleVectorFieldGlobal : public UParticleModuleVectorFieldBase
{
    uint8 bOverrideGlobalVectorFieldTightness;                                        // 0x0030 (size: 0x1)
    float GlobalVectorFieldScale;                                                     // 0x0034 (size: 0x4)
    float GlobalVectorFieldTightness;                                                 // 0x0038 (size: 0x4)

}; // Size: 0x40

class UParticleModuleVectorFieldLocal : public UParticleModuleVectorFieldBase
{
    class UVectorField* VectorField;                                                  // 0x0030 (size: 0x8)
    FVector RelativeTranslation;                                                      // 0x0038 (size: 0x18)
    FRotator RelativeRotation;                                                        // 0x0050 (size: 0x18)
    FVector RelativeScale3D;                                                          // 0x0068 (size: 0x18)
    float Intensity;                                                                  // 0x0080 (size: 0x4)
    float Tightness;                                                                  // 0x0084 (size: 0x4)
    uint8 bIgnoreComponentTransform;                                                  // 0x0088 (size: 0x1)
    uint8 bTileX;                                                                     // 0x0088 (size: 0x1)
    uint8 bTileY;                                                                     // 0x0088 (size: 0x1)
    uint8 bTileZ;                                                                     // 0x0088 (size: 0x1)
    uint8 bUseFixDT;                                                                  // 0x0088 (size: 0x1)

}; // Size: 0x90

class UParticleModuleVectorFieldRotation : public UParticleModuleVectorFieldBase
{
    FVector MinInitialRotation;                                                       // 0x0030 (size: 0x18)
    FVector MaxInitialRotation;                                                       // 0x0048 (size: 0x18)

}; // Size: 0x60

class UParticleModuleVectorFieldRotationRate : public UParticleModuleVectorFieldBase
{
    FVector RotationRate;                                                             // 0x0030 (size: 0x18)

}; // Size: 0x48

class UParticleModuleVectorFieldScale : public UParticleModuleVectorFieldBase
{
    class UDistributionFloat* VectorFieldScale;                                       // 0x0030 (size: 0x8)
    FRawDistributionFloat VectorFieldScaleRaw;                                        // 0x0038 (size: 0x30)

}; // Size: 0x68

class UParticleModuleVectorFieldScaleOverLife : public UParticleModuleVectorFieldBase
{
    class UDistributionFloat* VectorFieldScaleOverLife;                               // 0x0030 (size: 0x8)
    FRawDistributionFloat VectorFieldScaleOverLifeRaw;                                // 0x0038 (size: 0x30)

}; // Size: 0x68

class UParticleModuleVelocity : public UParticleModuleVelocityBase
{
    FRawDistributionVector StartVelocity;                                             // 0x0038 (size: 0x60)
    FRawDistributionFloat StartVelocityRadial;                                        // 0x0098 (size: 0x30)

}; // Size: 0xC8

class UParticleModuleVelocityBase : public UParticleModule
{
    uint8 bInWorldSpace;                                                              // 0x0030 (size: 0x1)
    uint8 bApplyOwnerScale;                                                           // 0x0030 (size: 0x1)

}; // Size: 0x38

class UParticleModuleVelocityCone : public UParticleModuleVelocityBase
{
    FRawDistributionFloat Angle;                                                      // 0x0038 (size: 0x30)
    FRawDistributionFloat Velocity;                                                   // 0x0068 (size: 0x30)
    FVector Direction;                                                                // 0x0098 (size: 0x18)

}; // Size: 0xB0

class UParticleModuleVelocityInheritParent : public UParticleModuleVelocityBase
{
    FRawDistributionVector Scale;                                                     // 0x0038 (size: 0x60)

}; // Size: 0x98

class UParticleModuleVelocityOverLifetime : public UParticleModuleVelocityBase
{
    FRawDistributionVector VelOverLife;                                               // 0x0038 (size: 0x60)
    uint8 Absolute;                                                                   // 0x0098 (size: 0x1)

}; // Size: 0xA0

class UParticleModuleVelocity_Seeded : public UParticleModuleVelocity
{
    FParticleRandomSeedInfo RandomSeedInfo;                                           // 0x00C8 (size: 0x20)

}; // Size: 0xE8

class UParticleSpriteEmitter : public UParticleEmitter
{
}; // Size: 0x1C0

class UParticleSystem : public UFXSystemAsset
{
    float UpdateTime_FPS;                                                             // 0x0048 (size: 0x4)
    float UpdateTime_Delta;                                                           // 0x004C (size: 0x4)
    float WarmupTime;                                                                 // 0x0050 (size: 0x4)
    float WarmupTickRate;                                                             // 0x0054 (size: 0x4)
    TArray<class UParticleEmitter*> Emitters;                                         // 0x0058 (size: 0x10)
    class UParticleSystemComponent* PreviewComponent;                                 // 0x0068 (size: 0x8)
    class UInterpCurveEdSetup* CurveEdSetup;                                          // 0x0070 (size: 0x8)
    float LODDistanceCheckTime;                                                       // 0x0078 (size: 0x4)
    float MacroUVRadius;                                                              // 0x007C (size: 0x4)
    TArray<float> LODDistances;                                                       // 0x0080 (size: 0x10)
    TArray<FParticleSystemLOD> LODSettings;                                           // 0x0090 (size: 0x10)
    FBox FixedRelativeBoundingBox;                                                    // 0x00A0 (size: 0x38)
    float SecondsBeforeInactive;                                                      // 0x00D8 (size: 0x4)
    float Delay;                                                                      // 0x00DC (size: 0x4)
    float DelayLow;                                                                   // 0x00E0 (size: 0x4)
    uint8 bOrientZAxisTowardCamera;                                                   // 0x00E4 (size: 0x1)
    uint8 bUseFixedRelativeBoundingBox;                                               // 0x00E4 (size: 0x1)
    uint8 bShouldResetPeakCounts;                                                     // 0x00E4 (size: 0x1)
    uint8 bHasPhysics;                                                                // 0x00E4 (size: 0x1)
    uint8 bUseRealtimeThumbnail;                                                      // 0x00E4 (size: 0x1)
    uint8 ThumbnailImageOutOfDate;                                                    // 0x00E4 (size: 0x1)
    uint8 bUseDelayRange;                                                             // 0x00E5 (size: 0x1)
    uint8 bAllowManagedTicking;                                                       // 0x00E5 (size: 0x1)
    uint8 bAutoDeactivate;                                                            // 0x00E5 (size: 0x1)
    uint8 bRegenerateLODDuplicate;                                                    // 0x00E5 (size: 0x1)
    TEnumAsByte<EParticleSystemUpdateMode> SystemUpdateMode;                          // 0x00E6 (size: 0x1)
    TEnumAsByte<ParticleSystemLODMethod> LODMethod;                                   // 0x00E7 (size: 0x1)
    EParticleSystemInsignificanceReaction InsignificantReaction;                      // 0x00E8 (size: 0x1)
    TEnumAsByte<EParticleSystemOcclusionBoundsMethod> OcclusionBoundsMethod;          // 0x00E9 (size: 0x1)
    EParticleSignificanceLevel MaxSignificanceLevel;                                  // 0x00EB (size: 0x1)
    uint32 MinTimeBetweenTicks;                                                       // 0x00EC (size: 0x4)
    float InsignificanceDelay;                                                        // 0x00F0 (size: 0x4)
    FVector MacroUVPosition;                                                          // 0x00F8 (size: 0x18)
    FBox CustomOcclusionBounds;                                                       // 0x0110 (size: 0x38)
    TArray<FLODSoloTrack> SoloTracking;                                               // 0x0148 (size: 0x10)
    TArray<FNamedEmitterMaterial> NamedMaterialSlots;                                 // 0x0158 (size: 0x10)

    bool ContainsEmitterType(UClass* TypeData);
}; // Size: 0x170

class UParticleSystemComponent : public UFXSystemComponent
{
    class UParticleSystem* Template;                                                  // 0x0518 (size: 0x8)
    TArray<class UMaterialInterface*> EmitterMaterials;                               // 0x0520 (size: 0x10)
    TArray<class USkeletalMeshComponent*> SkelMeshComponents;                         // 0x0530 (size: 0x10)
    uint8 bResetOnDetach;                                                             // 0x0541 (size: 0x1)
    uint8 bUpdateOnDedicatedServer;                                                   // 0x0541 (size: 0x1)
    uint8 bAllowRecycling;                                                            // 0x0541 (size: 0x1)
    uint8 bAutoManageAttachment;                                                      // 0x0541 (size: 0x1)
    uint8 bAutoAttachWeldSimulatedBodies;                                             // 0x0541 (size: 0x1)
    uint8 bWarmingUp;                                                                 // 0x0542 (size: 0x1)
    uint8 bOverrideLODMethod;                                                         // 0x0542 (size: 0x1)
    uint8 bSkipUpdateDynamicDataDuringTick;                                           // 0x0542 (size: 0x1)
    TEnumAsByte<ParticleSystemLODMethod> LODMethod;                                   // 0x054D (size: 0x1)
    EParticleSignificanceLevel RequiredSignificance;                                  // 0x054E (size: 0x1)
    TArray<FParticleSysParam> InstanceParameters;                                     // 0x0550 (size: 0x10)
    FParticleSystemComponentOnParticleSpawn OnParticleSpawn;                          // 0x0560 (size: 0x10)
    void ParticleSpawnSignature(FName EventName, float EmitterTime, FVector Location, FVector Velocity);
    FParticleSystemComponentOnParticleBurst OnParticleBurst;                          // 0x0570 (size: 0x10)
    void ParticleBurstSignature(FName EventName, float EmitterTime, int32 ParticleCount);
    FParticleSystemComponentOnParticleDeath OnParticleDeath;                          // 0x0580 (size: 0x10)
    void ParticleDeathSignature(FName EventName, float EmitterTime, int32 ParticleTime, FVector Location, FVector Velocity, FVector Direction);
    FParticleSystemComponentOnParticleCollide OnParticleCollide;                      // 0x0590 (size: 0x10)
    void ParticleCollisionSignature(FName EventName, float EmitterTime, int32 ParticleTime, FVector Location, FVector Velocity, FVector Direction, FVector Normal, FName BoneName, class UPhysicalMaterial* PhysMat);
    bool bOldPositionValid;                                                           // 0x05A0 (size: 0x1)
    FVector OldPosition;                                                              // 0x05A8 (size: 0x18)
    FVector PartSysVelocity;                                                          // 0x05C0 (size: 0x18)
    float WarmupTime;                                                                 // 0x05D8 (size: 0x4)
    float WarmupTickRate;                                                             // 0x05DC (size: 0x4)
    float SecondsBeforeInactive;                                                      // 0x05E4 (size: 0x4)
    float MaxTimeBeforeForceUpdateTransform;                                          // 0x05EC (size: 0x4)
    TArray<class UParticleSystemReplay*> ReplayClips;                                 // 0x0610 (size: 0x10)
    float CustomTimeDilation;                                                         // 0x0628 (size: 0x4)
    TWeakObjectPtr<class USceneComponent> AutoAttachParent;                           // 0x0680 (size: 0x8)
    FName AutoAttachSocketName;                                                       // 0x0688 (size: 0x8)
    EAttachmentRule AutoAttachLocationRule;                                           // 0x0690 (size: 0x1)
    EAttachmentRule AutoAttachRotationRule;                                           // 0x0691 (size: 0x1)
    EAttachmentRule AutoAttachScaleRule;                                              // 0x0692 (size: 0x1)
    FParticleSystemComponentOnSystemFinished OnSystemFinished;                        // 0x06E8 (size: 0x10)
    void OnSystemFinished(class UParticleSystemComponent* PSystem);

    void SetTrailSourceData(FName InFirstSocketName, FName InSecondSocketName, TEnumAsByte<ETrailWidthMode> InWidthMode, float InWidth);
    void SetTemplate(class UParticleSystem* NewTemplate);
    void SetMaterialParameter(FName ParameterName, class UMaterialInterface* Param);
    void SetBeamTargetTangent(int32 EmitterIndex, FVector NewTangentPoint, int32 TargetIndex);
    void SetBeamTargetStrength(int32 EmitterIndex, float NewTargetStrength, int32 TargetIndex);
    void SetBeamTargetPoint(int32 EmitterIndex, FVector NewTargetPoint, int32 TargetIndex);
    void SetBeamSourceTangent(int32 EmitterIndex, FVector NewTangentPoint, int32 SourceIndex);
    void SetBeamSourceStrength(int32 EmitterIndex, float NewSourceStrength, int32 SourceIndex);
    void SetBeamSourcePoint(int32 EmitterIndex, FVector NewSourcePoint, int32 SourceIndex);
    void SetBeamEndPoint(int32 EmitterIndex, FVector NewEndPoint);
    void SetAutoAttachParams(class USceneComponent* Parent, FName SocketName, TEnumAsByte<EAttachLocation::Type> LocationType);
    int32 GetNumActiveParticles();
    class UMaterialInterface* GetNamedMaterial(FName InName);
    bool GetBeamTargetTangent(int32 EmitterIndex, int32 TargetIndex, FVector& OutTangentPoint);
    bool GetBeamTargetStrength(int32 EmitterIndex, int32 TargetIndex, float& OutTargetStrength);
    bool GetBeamTargetPoint(int32 EmitterIndex, int32 TargetIndex, FVector& OutTargetPoint);
    bool GetBeamSourceTangent(int32 EmitterIndex, int32 SourceIndex, FVector& OutTangentPoint);
    bool GetBeamSourceStrength(int32 EmitterIndex, int32 SourceIndex, float& OutSourceStrength);
    bool GetBeamSourcePoint(int32 EmitterIndex, int32 SourceIndex, FVector& OutSourcePoint);
    bool GetBeamEndPoint(int32 EmitterIndex, FVector& OutEndPoint);
    void GenerateParticleEvent(const FName InEventName, const float InEmitterTime, const FVector InLocation, const FVector InDirection, const FVector InVelocity);
    void EndTrails();
    class UMaterialInstanceDynamic* CreateNamedDynamicMaterialInstance(FName InName, class UMaterialInterface* SourceMaterial);
    void BeginTrails(FName InFirstSocketName, FName InSecondSocketName, TEnumAsByte<ETrailWidthMode> InWidthMode, float InWidth);
}; // Size: 0x830

class UParticleSystemReplay : public UObject
{
    int32 ClipIDNumber;                                                               // 0x0028 (size: 0x4)

}; // Size: 0x40

class UPawnMovementComponent : public UNavMovementComponent
{
    class APawn* PawnOwner;                                                           // 0x0150 (size: 0x8)

    void ServerAsyncPhysicsStateAction(const class UPrimitiveComponent* ActionComponent, const FName BoneName, const FAsyncPhysicsTimestamp Timestamp, const EPhysicsStateAction ActionType, const FVector ActionDatas, const FVector ActionPosition);
    void MulticastAsyncPhysicsStateAction(const class UPrimitiveComponent* ActionComponent, const FName BoneName, const FAsyncPhysicsTimestamp Timestamp, const EPhysicsStateAction ActionType, const FVector ActionDatas, const FVector ActionPosition);
    bool IsMoveInputIgnored();
    FVector GetPendingInputVector();
    class APawn* GetPawnOwner();
    FVector GetLastInputVector();
    FVector ConsumeInputVector();
    void AddInputVector(FVector WorldVector, bool bForce);
}; // Size: 0x158

class UPawnNoiseEmitterComponent : public UActorComponent
{
    uint8 bAIPerceptionSystemCompatibilityMode;                                       // 0x00A0 (size: 0x1)
    FVector LastRemoteNoisePosition;                                                  // 0x00A8 (size: 0x18)
    float NoiseLifetime;                                                              // 0x00C0 (size: 0x4)
    float LastRemoteNoiseVolume;                                                      // 0x00C4 (size: 0x4)
    float LastRemoteNoiseTime;                                                        // 0x00C8 (size: 0x4)
    float LastLocalNoiseVolume;                                                       // 0x00CC (size: 0x4)
    float LastLocalNoiseTime;                                                         // 0x00D0 (size: 0x4)

    void MakeNoise(class AActor* NoiseMaker, float Loudness, const FVector& NoiseLocation);
}; // Size: 0xD8

class UPendingNetGame : public UObject
{
    class UNetDriver* NetDriver;                                                      // 0x0030 (size: 0x8)
    class UDemoNetDriver* DemoNetDriver;                                              // 0x0038 (size: 0x8)

}; // Size: 0xC0

class UPhysicalAnimationComponent : public UActorComponent
{
    float StrengthMultiplyer;                                                         // 0x00A0 (size: 0x4)
    class USkeletalMeshComponent* SkeletalMeshComponent;                              // 0x00A8 (size: 0x8)

    void SetStrengthMultiplyer(float InStrengthMultiplyer);
    void SetSkeletalMeshComponent(class USkeletalMeshComponent* InSkeletalMeshComponent);
    FTransform GetBodyTargetTransform(FName BodyName);
    void ApplyPhysicalAnimationSettingsBelow(FName BodyName, const FPhysicalAnimationData& PhysicalAnimationData, bool bIncludeSelf);
    void ApplyPhysicalAnimationSettings(FName BodyName, const FPhysicalAnimationData& PhysicalAnimationData);
    void ApplyPhysicalAnimationProfileBelow(FName BodyName, FName ProfileName, bool bIncludeSelf, bool bClearNotFound);
}; // Size: 0xE0

class UPhysicalMaterialMask : public UObject
{
    int32 UVChannelIndex;                                                             // 0x0028 (size: 0x4)
    TEnumAsByte<TextureAddress> AddressX;                                             // 0x002C (size: 0x1)
    TEnumAsByte<TextureAddress> AddressY;                                             // 0x002D (size: 0x1)

}; // Size: 0x38

class UPhysicsAsset : public UObject
{
    TArray<int32> BoundsBodies;                                                       // 0x0030 (size: 0x10)
    TArray<class USkeletalBodySetup*> SkeletalBodySetups;                             // 0x0040 (size: 0x10)
    TArray<class UPhysicsConstraintTemplate*> ConstraintSetup;                        // 0x0050 (size: 0x10)
    FPhysicsAssetSolverSettings SolverSettings;                                       // 0x0060 (size: 0x1C)
    FSolverIterations SolverIterations;                                               // 0x007C (size: 0x18)
    EPhysicsAssetSolverType SolverType;                                               // 0x0094 (size: 0x1)
    uint8 bNotForDedicatedServer;                                                     // 0x0095 (size: 0x1)
    class UThumbnailInfo* ThumbnailInfo;                                              // 0x0138 (size: 0x8)
    TArray<class UBodySetup*> BodySetup;                                              // 0x0140 (size: 0x10)

}; // Size: 0x150

class UPhysicsCollisionHandler : public UObject
{
    float ImpactThreshold;                                                            // 0x0028 (size: 0x4)
    float ImpactReFireDelay;                                                          // 0x002C (size: 0x4)
    class USoundBase* DefaultImpactSound;                                             // 0x0030 (size: 0x8)
    float LastImpactSoundTime;                                                        // 0x0038 (size: 0x4)

}; // Size: 0x40

class UPhysicsConstraintComponent : public USceneComponent
{
    class AActor* ConstraintActor1;                                                   // 0x0230 (size: 0x8)
    FConstrainComponentPropName ComponentName1;                                       // 0x0238 (size: 0x8)
    class AActor* ConstraintActor2;                                                   // 0x0240 (size: 0x8)
    FConstrainComponentPropName ComponentName2;                                       // 0x0248 (size: 0x8)
    class UPhysicsConstraintTemplate* ConstraintSetup;                                // 0x0260 (size: 0x8)
    FPhysicsConstraintComponentOnConstraintBroken OnConstraintBroken;                 // 0x0268 (size: 0x10)
    void ConstraintBrokenSignature(int32 ConstraintIndex);
    FPhysicsConstraintComponentOnPlasticDeformation OnPlasticDeformation;             // 0x0278 (size: 0x10)
    void PlasticDeformationEventSignature(int32 ConstraintIndex);
    FConstraintInstance ConstraintInstance;                                           // 0x0288 (size: 0x270)

    void SetProjectionParams(float ProjectionLinearAlpha, float ProjectionAngularAlpha, float ProjectionLinearTolerance, float ProjectionAngularTolerance);
    void SetProjectionEnabled(bool bProjectionEnabled);
    void SetOrientationDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive);
    void SetOrientationDriveSLERP(bool bEnableSLERP);
    void SetLinearZLimit(TEnumAsByte<ELinearConstraintMotion> ConstraintType, float LimitSize);
    void SetLinearYLimit(TEnumAsByte<ELinearConstraintMotion> ConstraintType, float LimitSize);
    void SetLinearXLimit(TEnumAsByte<ELinearConstraintMotion> ConstraintType, float LimitSize);
    void SetLinearVelocityTarget(const FVector& InVelTarget);
    void SetLinearVelocityDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ);
    void SetLinearPositionTarget(const FVector& InPosTarget);
    void SetLinearPositionDrive(bool bEnableDriveX, bool bEnableDriveY, bool bEnableDriveZ);
    void SetLinearPlasticity(bool bLinearPlasticity, float LinearPlasticityThreshold, TEnumAsByte<EConstraintPlasticityType> PlasticityType);
    void SetLinearDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit);
    void SetLinearBreakable(bool bLinearBreakable, float LinearBreakThreshold);
    void SetDisableCollision(bool bDisableCollision);
    void SetContactTransferScale(float ContactTransferScale);
    void SetConstraintReferencePosition(TEnumAsByte<EConstraintFrame::Type> Frame, const FVector& RefPosition);
    void SetConstraintReferenceOrientation(TEnumAsByte<EConstraintFrame::Type> Frame, const FVector& PriAxis, const FVector& SecAxis);
    void SetConstraintReferenceFrame(TEnumAsByte<EConstraintFrame::Type> Frame, const FTransform& RefFrame);
    void SetConstrainedComponents(class UPrimitiveComponent* Component1, FName BoneName1, class UPrimitiveComponent* Component2, FName BoneName2);
    void SetAngularVelocityTarget(const FVector& InVelTarget);
    void SetAngularVelocityDriveTwistAndSwing(bool bEnableTwistDrive, bool bEnableSwingDrive);
    void SetAngularVelocityDriveSLERP(bool bEnableSLERP);
    void SetAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive);
    void SetAngularTwistLimit(TEnumAsByte<EAngularConstraintMotion> ConstraintType, float TwistLimitAngle);
    void SetAngularSwing2Limit(TEnumAsByte<EAngularConstraintMotion> MotionType, float Swing2LimitAngle);
    void SetAngularSwing1Limit(TEnumAsByte<EAngularConstraintMotion> MotionType, float Swing1LimitAngle);
    void SetAngularPlasticity(bool bAngularPlasticity, float AngularPlasticityThreshold);
    void SetAngularOrientationTarget(const FRotator& InPosTarget);
    void SetAngularOrientationDrive(bool bEnableSwingDrive, bool bEnableTwistDrive);
    void SetAngularDriveParams(float PositionStrength, float VelocityStrength, float InForceLimit);
    void SetAngularDriveMode(TEnumAsByte<EAngularDriveMode::Type> DriveMode);
    void SetAngularBreakable(bool bAngularBreakable, float AngularBreakThreshold);
    bool IsProjectionEnabled();
    bool IsBroken();
    float GetCurrentTwist();
    float GetCurrentSwing2();
    float GetCurrentSwing1();
    void GetConstraintForce(FVector& OutLinearForce, FVector& OutAngularForce);
    FConstraintInstanceAccessor GetConstraint();
    void GetConstrainedComponents(class UPrimitiveComponent*& OutComponent1, FName& OutBoneName1, class UPrimitiveComponent*& OutComponent2, FName& OutBoneName2);
    void BreakConstraint();
}; // Size: 0x500

class UPhysicsConstraintTemplate : public UObject
{
    FConstraintInstance DefaultInstance;                                              // 0x0028 (size: 0x270)
    TArray<FPhysicsConstraintProfileHandle> ProfileHandles;                           // 0x0298 (size: 0x10)
    FConstraintProfileProperties DefaultProfile;                                      // 0x02A8 (size: 0x158)

}; // Size: 0x400

class UPhysicsFieldComponent : public USceneComponent
{
}; // Size: 0x310

class UPhysicsFieldStatics : public UBlueprintFunctionLibrary
{

    FVector EvalPhysicsVectorField(const class UObject* WorldContextObject, const FVector& WorldPosition, const TEnumAsByte<EFieldVectorType> VectorType);
    float EvalPhysicsScalarField(const class UObject* WorldContextObject, const FVector& WorldPosition, const TEnumAsByte<EFieldScalarType> ScalarType);
    int32 EvalPhysicsIntegerField(const class UObject* WorldContextObject, const FVector& WorldPosition, const TEnumAsByte<EFieldIntegerType> IntegerType);
}; // Size: 0x28

class UPhysicsHandleComponent : public UActorComponent
{
    class UPrimitiveComponent* GrabbedComponent;                                      // 0x00A0 (size: 0x8)
    uint8 bSoftAngularConstraint;                                                     // 0x00B0 (size: 0x1)
    uint8 bSoftLinearConstraint;                                                      // 0x00B0 (size: 0x1)
    uint8 bInterpolateTarget;                                                         // 0x00B0 (size: 0x1)
    float LinearDamping;                                                              // 0x00B4 (size: 0x4)
    float LinearStiffness;                                                            // 0x00B8 (size: 0x4)
    float AngularDamping;                                                             // 0x00BC (size: 0x4)
    float AngularStiffness;                                                           // 0x00C0 (size: 0x4)
    float InterpolationSpeed;                                                         // 0x0190 (size: 0x4)

    void SetTargetRotation(FRotator NewRotation);
    void SetTargetLocationAndRotation(FVector NewLocation, FRotator NewRotation);
    void SetTargetLocation(FVector NewLocation);
    void SetLinearStiffness(float NewLinearStiffness);
    void SetLinearDamping(float NewLinearDamping);
    void SetInterpolationSpeed(float NewInterpolationSpeed);
    void SetAngularStiffness(float NewAngularStiffness);
    void SetAngularDamping(float NewAngularDamping);
    void ReleaseComponent();
    void GrabComponentAtLocationWithRotation(class UPrimitiveComponent* Component, FName InBoneName, FVector Location, FRotator Rotation);
    void GrabComponentAtLocation(class UPrimitiveComponent* Component, FName InBoneName, FVector GrabLocation);
    void GrabComponent(class UPrimitiveComponent* Component, FName InBoneName, FVector GrabLocation, bool bConstrainRotation);
    void GetTargetLocationAndRotation(FVector& TargetLocation, FRotator& TargetRotation);
    class UPrimitiveComponent* GetGrabbedComponent();
}; // Size: 0x4D0

class UPhysicsObjectBlueprintLibrary : public UBlueprintFunctionLibrary
{

    FTransform GetPhysicsObjectWorldTransform(class UPrimitiveComponent* Component, FName BoneName);
    FClosestPhysicsObjectResult GetClosestPhysicsObjectFromWorldLocation(class UPrimitiveComponent* Component, const FVector& WorldLocation);
    bool ExtractClosestPhysicsObjectResults(const FClosestPhysicsObjectResult& Result, FName& OutName);
    void ApplyRadialImpulse(class UPrimitiveComponent* Component, FVector Origin, float Radius, float Strength, TEnumAsByte<ERadialImpulseFalloff> Falloff, bool bApplyStrain, float Strain, bool bVelChange, float MinValue, float MaxValue);
}; // Size: 0x28

class UPhysicsSettings : public UPhysicsSettingsCore
{
    FPhysicsPredictionSettings PhysicsPrediction;                                     // 0x00E8 (size: 0xC)
    FRigidBodyErrorCorrection PhysicErrorCorrection;                                  // 0x00F4 (size: 0x34)
    TEnumAsByte<ESettingsLockedAxis::Type> LockedAxis;                                // 0x0128 (size: 0x1)
    TEnumAsByte<ESettingsDOF::Type> DefaultDegreesOfFreedom;                          // 0x0129 (size: 0x1)
    bool bSuppressFaceRemapTable;                                                     // 0x012A (size: 0x1)
    bool bSupportUVFromHitResults;                                                    // 0x012B (size: 0x1)
    bool bDisableActiveActors;                                                        // 0x012C (size: 0x1)
    bool bDisableKinematicStaticPairs;                                                // 0x012D (size: 0x1)
    bool bDisableKinematicKinematicPairs;                                             // 0x012E (size: 0x1)
    bool bDisableCCD;                                                                 // 0x012F (size: 0x1)
    float AnimPhysicsMinDeltaTime;                                                    // 0x0130 (size: 0x4)
    bool bSimulateAnimPhysicsAfterReset;                                              // 0x0134 (size: 0x1)
    float MinPhysicsDeltaTime;                                                        // 0x0138 (size: 0x4)
    float MaxPhysicsDeltaTime;                                                        // 0x013C (size: 0x4)
    bool bSubstepping;                                                                // 0x0140 (size: 0x1)
    bool bSubsteppingAsync;                                                           // 0x0141 (size: 0x1)
    bool bTickPhysicsAsync;                                                           // 0x0142 (size: 0x1)
    float AsyncFixedTimeStepSize;                                                     // 0x0144 (size: 0x4)
    float MaxSubstepDeltaTime;                                                        // 0x0148 (size: 0x4)
    int32 MaxSubsteps;                                                                // 0x014C (size: 0x4)
    float SyncSceneSmoothingFactor;                                                   // 0x0150 (size: 0x4)
    float InitialAverageFrameRate;                                                    // 0x0154 (size: 0x4)
    int32 PhysXTreeRebuildRate;                                                       // 0x0158 (size: 0x4)
    TArray<FPhysicalSurfaceName> PhysicalSurfaces;                                    // 0x0160 (size: 0x10)
    FBroadphaseSettings DefaultBroadphaseSettings;                                    // 0x0170 (size: 0x80)
    float MinDeltaVelocityForHitEvents;                                               // 0x01F0 (size: 0x4)
    FChaosPhysicsSettings ChaosSettings;                                              // 0x01F4 (size: 0x3)

    int32 GetPhysicsHistoryCount();
}; // Size: 0x1F8

class UPhysicsSpringComponent : public USceneComponent
{
    float SpringStiffness;                                                            // 0x0230 (size: 0x4)
    float SpringDamping;                                                              // 0x0234 (size: 0x4)
    float SpringLengthAtRest;                                                         // 0x0238 (size: 0x4)
    float SpringRadius;                                                               // 0x023C (size: 0x4)
    TEnumAsByte<ECollisionChannel> SpringChannel;                                     // 0x0240 (size: 0x1)
    bool bIgnoreSelf;                                                                 // 0x0241 (size: 0x1)
    float SpringCompression;                                                          // 0x0244 (size: 0x4)

    FVector GetSpringRestingPoint();
    FVector GetSpringDirection();
    FVector GetSpringCurrentEndPoint();
    float GetNormalizedCompressionScalar();
}; // Size: 0x260

class UPhysicsThreadLibrary : public UBlueprintFunctionLibrary
{

    void AddForce(FBodyInstanceAsyncPhysicsTickHandle Handle, FVector Force, bool bAccelChange);
}; // Size: 0x28

class UPhysicsThrusterComponent : public USceneComponent
{
    float ThrustStrength;                                                             // 0x0230 (size: 0x4)

}; // Size: 0x240

class UPieFixupTestObject : public UObject
{
    FSoftObjectPath Path;                                                             // 0x0028 (size: 0x20)
    TSoftObjectPtr<AActor> TypedPtr;                                                  // 0x0048 (size: 0x28)
    FPieFixupStructWithSoftObjectPath Struct;                                         // 0x0070 (size: 0x48)
    TArray<FPieFixupStructWithSoftObjectPath> Array;                                  // 0x00B8 (size: 0x10)

}; // Size: 0xC8

class UPlanarReflectionComponent : public USceneCaptureComponent
{
    class UBoxComponent* PreviewBox;                                                  // 0x02E8 (size: 0x8)
    float NormalDistortionStrength;                                                   // 0x02F0 (size: 0x4)
    float PrefilterRoughness;                                                         // 0x02F4 (size: 0x4)
    float PrefilterRoughnessDistance;                                                 // 0x02F8 (size: 0x4)
    int32 ScreenPercentage;                                                           // 0x02FC (size: 0x4)
    float ExtraFOV;                                                                   // 0x0300 (size: 0x4)
    float DistanceFromPlaneFadeStart;                                                 // 0x0304 (size: 0x4)
    float DistanceFromPlaneFadeEnd;                                                   // 0x0308 (size: 0x4)
    float DistanceFromPlaneFadeoutStart;                                              // 0x030C (size: 0x4)
    float DistanceFromPlaneFadeoutEnd;                                                // 0x0310 (size: 0x4)
    float AngleFromPlaneFadeStart;                                                    // 0x0314 (size: 0x4)
    float AngleFromPlaneFadeEnd;                                                      // 0x0318 (size: 0x4)
    bool bShowPreviewPlane;                                                           // 0x031C (size: 0x1)
    bool bRenderSceneTwoSided;                                                        // 0x031D (size: 0x1)

}; // Size: 0x450

class UPlaneReflectionCaptureComponent : public UReflectionCaptureComponent
{
    float InfluenceRadiusScale;                                                       // 0x0298 (size: 0x4)
    class UDrawSphereComponent* PreviewInfluenceRadius;                               // 0x02A0 (size: 0x8)
    class UBoxComponent* PreviewCaptureBox;                                           // 0x02A8 (size: 0x8)

}; // Size: 0x2B0

class UPlatformEventsComponent : public UActorComponent
{
    FPlatformEventsComponentPlatformChangedToLaptopModeDelegate PlatformChangedToLaptopModeDelegate; // 0x00A0 (size: 0x10)
    void PlatformEventDelegate();
    FPlatformEventsComponentPlatformChangedToTabletModeDelegate PlatformChangedToTabletModeDelegate; // 0x00B0 (size: 0x10)
    void PlatformEventDelegate();

    bool SupportsConvertibleLaptops();
    void PlatformEventDelegate__DelegateSignature();
    bool IsInTabletMode();
    bool IsInLaptopMode();
}; // Size: 0xC0

class UPlatformGameInstance : public UGameInstance
{
    FPlatformGameInstanceApplicationWillDeactivateDelegate ApplicationWillDeactivateDelegate; // 0x01C0 (size: 0x10)
    void PlatformDelegate();
    FPlatformGameInstanceApplicationHasReactivatedDelegate ApplicationHasReactivatedDelegate; // 0x01D0 (size: 0x10)
    void PlatformDelegate();
    FPlatformGameInstanceApplicationWillEnterBackgroundDelegate ApplicationWillEnterBackgroundDelegate; // 0x01E0 (size: 0x10)
    void PlatformDelegate();
    FPlatformGameInstanceApplicationHasEnteredForegroundDelegate ApplicationHasEnteredForegroundDelegate; // 0x01F0 (size: 0x10)
    void PlatformDelegate();
    FPlatformGameInstanceApplicationWillTerminateDelegate ApplicationWillTerminateDelegate; // 0x0200 (size: 0x10)
    void PlatformDelegate();
    FPlatformGameInstanceApplicationShouldUnloadResourcesDelegate ApplicationShouldUnloadResourcesDelegate; // 0x0210 (size: 0x10)
    void PlatformDelegate();
    FPlatformGameInstanceApplicationReceivedStartupArgumentsDelegate ApplicationReceivedStartupArgumentsDelegate; // 0x0220 (size: 0x10)
    void PlatformStartupArgumentsDelegate(const TArray<FString>& StartupArguments);
    FPlatformGameInstanceApplicationRegisteredForRemoteNotificationsDelegate ApplicationRegisteredForRemoteNotificationsDelegate; // 0x0230 (size: 0x10)
    void PlatformRegisteredForRemoteNotificationsDelegate(const TArray<uint8>& inArray);
    FPlatformGameInstanceApplicationRegisteredForUserNotificationsDelegate ApplicationRegisteredForUserNotificationsDelegate; // 0x0240 (size: 0x10)
    void PlatformRegisteredForUserNotificationsDelegate(int32 inInt);
    FPlatformGameInstanceApplicationFailedToRegisterForRemoteNotificationsDelegate ApplicationFailedToRegisterForRemoteNotificationsDelegate; // 0x0250 (size: 0x10)
    void PlatformFailedToRegisterForRemoteNotificationsDelegate(FString InString);
    FPlatformGameInstanceApplicationReceivedRemoteNotificationDelegate ApplicationReceivedRemoteNotificationDelegate; // 0x0260 (size: 0x10)
    void PlatformReceivedRemoteNotificationDelegate(FString InString, TEnumAsByte<EApplicationState::Type> inAppState);
    FPlatformGameInstanceApplicationReceivedLocalNotificationDelegate ApplicationReceivedLocalNotificationDelegate; // 0x0270 (size: 0x10)
    void PlatformReceivedLocalNotificationDelegate(FString InString, int32 inInt, TEnumAsByte<EApplicationState::Type> inAppState);
    FPlatformGameInstanceApplicationReceivedScreenOrientationChangedNotificationDelegate ApplicationReceivedScreenOrientationChangedNotificationDelegate; // 0x0280 (size: 0x10)
    void PlatformScreenOrientationChangedDelegate(TEnumAsByte<EScreenOrientation::Type> inScreenOrientation);

    void PlatformStartupArgumentsDelegate__DelegateSignature(const TArray<FString>& StartupArguments);
    void PlatformScreenOrientationChangedDelegate__DelegateSignature(TEnumAsByte<EScreenOrientation::Type> inScreenOrientation);
    void PlatformRegisteredForUserNotificationsDelegate__DelegateSignature(int32 inInt);
    void PlatformRegisteredForRemoteNotificationsDelegate__DelegateSignature(const TArray<uint8>& inArray);
    void PlatformReceivedRemoteNotificationDelegate__DelegateSignature(FString InString, TEnumAsByte<EApplicationState::Type> inAppState);
    void PlatformReceivedLocalNotificationDelegate__DelegateSignature(FString InString, int32 inInt, TEnumAsByte<EApplicationState::Type> inAppState);
    void PlatformFailedToRegisterForRemoteNotificationsDelegate__DelegateSignature(FString InString);
    void PlatformDelegate__DelegateSignature();
}; // Size: 0x290

class UPlatformInterfaceBase : public UObject
{
    TArray<FDelegateArray> AllDelegates;                                              // 0x0028 (size: 0x10)

}; // Size: 0x38

class UPlatformInterfaceWebResponse : public UObject
{
    FString OriginalURL;                                                              // 0x0028 (size: 0x10)
    int32 ResponseCode;                                                               // 0x0038 (size: 0x4)
    int32 Tag;                                                                        // 0x003C (size: 0x4)
    FString StringResponse;                                                           // 0x0040 (size: 0x10)
    TArray<uint8> BinaryResponse;                                                     // 0x0050 (size: 0x10)

    int32 GetNumHeaders();
    FString GetHeaderValue(FString HeaderName);
    void GetHeader(int32 HeaderIndex, FString& Header, FString& Value);
}; // Size: 0xB0

class UPlayer : public UObject
{
    class APlayerController* PlayerController;                                        // 0x0030 (size: 0x8)
    int32 CurrentNetSpeed;                                                            // 0x0038 (size: 0x4)
    int32 ConfiguredInternetSpeed;                                                    // 0x003C (size: 0x4)
    int32 ConfiguredLanSpeed;                                                         // 0x0040 (size: 0x4)

}; // Size: 0x48

class UPlayerInput : public UObject
{
    TArray<FKeyBind> DebugExecBindings;                                               // 0x01A0 (size: 0x10)
    TArray<FName> InvertedAxis;                                                       // 0x01E0 (size: 0x10)

    void SetMouseSensitivity(const float Sensitivity);
    void SetBind(FName BindName, FString Command);
    void InvertAxisKey(const FKey AxisKey);
    void InvertAxis(const FName AxisName);
    class APlayerController* GetOuterAPlayerController();
    void ClearSmoothing();
}; // Size: 0x498

class UPlayerStateCountLimiterConfig : public UNetObjectCountLimiterConfig
{
}; // Size: 0x40

class UPluginBlueprintLibrary : public UBlueprintFunctionLibrary
{

    bool IsPluginMounted(FString PluginName);
    bool GetPluginVersionName(FString PluginName, FString& OutVersionName);
    bool GetPluginVersion(FString PluginName, int32& OutVersion);
    bool GetPluginNameForObjectPath(const FSoftObjectPath& ObjectPath, FString& OutPluginName);
    bool GetPluginMountedAssetPath(FString PluginName, FString& OutAssetPath);
    bool GetPluginEditorCustomVirtualPath(FString PluginName, FString& OutVirtualPath);
    bool GetPluginDescriptorFilePath(FString PluginName, FString& OutFilePath);
    bool GetPluginDescription(FString PluginName, FString& OutDescription);
    bool GetPluginContentDir(FString PluginName, FString& OutContentDir);
    bool GetPluginBaseDir(FString PluginName, FString& OutBaseDir);
    TArray<FString> GetEnabledPluginNames();
    TArray<FString> GetAdditionalProjectPluginSearchPaths();
    TArray<FString> GetAdditionalPluginSearchPaths();
}; // Size: 0x28

class UPluginCommandlet : public UCommandlet
{
}; // Size: 0xA0

class UPointLightComponent : public ULocalLightComponent
{
    uint8 bUseInverseSquaredFalloff;                                                  // 0x0390 (size: 0x1)
    float LightFalloffExponent;                                                       // 0x0394 (size: 0x4)
    float SourceRadius;                                                               // 0x0398 (size: 0x4)
    float SoftSourceRadius;                                                           // 0x039C (size: 0x4)
    float SourceLength;                                                               // 0x03A0 (size: 0x4)

    void SetUseInverseSquaredFalloff(bool bNewValue);
    void SetSourceRadius(float bNewValue);
    void SetSourceLength(float NewValue);
    void SetSoftSourceRadius(float bNewValue);
    void SetLightFalloffExponent(float NewLightFalloffExponent);
    void SetInverseExposureBlend(float NewInverseExposureBlend);
}; // Size: 0x3B0

class UPolys : public UObject
{
}; // Size: 0x38

class UPoseAsset : public UAnimationAsset
{
    FPoseDataContainer PoseContainer;                                                 // 0x0080 (size: 0x70)
    bool bAdditivePose;                                                               // 0x00F0 (size: 0x1)
    int32 BasePoseIndex;                                                              // 0x00F4 (size: 0x4)
    FName RetargetSource;                                                             // 0x00F8 (size: 0x8)
    TArray<FTransform> RetargetSourceAssetReferencePose;                              // 0x0100 (size: 0x10)

}; // Size: 0x110

class UPoseWatch : public UObject
{
}; // Size: 0x28

class UPoseWatchElement : public UObject
{
}; // Size: 0x28

class UPoseWatchFolder : public UObject
{
}; // Size: 0x28

class UPoseWatchPoseElement : public UPoseWatchElement
{
}; // Size: 0x28

class UPoseableMeshComponent : public USkinnedMeshComponent
{

    void SetBoneTransformByName(FName BoneName, const FTransform& InTransform, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    void SetBoneScaleByName(FName BoneName, FVector InScale3D, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    void SetBoneRotationByName(FName BoneName, FRotator InRotation, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    void SetBoneLocationByName(FName BoneName, FVector InLocation, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    void ResetBoneTransformByName(FName BoneName);
    FTransform GetBoneTransformByName(FName BoneName, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    FVector GetBoneScaleByName(FName BoneName, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    FRotator GetBoneRotationByName(FName BoneName, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    FVector GetBoneLocationByName(FName BoneName, TEnumAsByte<EBoneSpaces::Type> BoneSpace);
    void CopyPoseFromSkeletalComponent(class USkeletalMeshComponent* InComponentToCopy);
}; // Size: 0xA20

class UPostProcessComponent : public USceneComponent
{
    FPostProcessSettings Settings;                                                    // 0x0240 (size: 0x6F0)
    float Priority;                                                                   // 0x0930 (size: 0x4)
    float BlendRadius;                                                                // 0x0934 (size: 0x4)
    float BlendWeight;                                                                // 0x0938 (size: 0x4)
    uint8 bEnabled;                                                                   // 0x093C (size: 0x1)
    uint8 bUnbound;                                                                   // 0x093C (size: 0x1)

    void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
}; // Size: 0x940

class UPreviewMeshCollection : public UDataAsset
{
    class USkeleton* Skeleton;                                                        // 0x0038 (size: 0x8)
    TArray<FPreviewMeshCollectionEntry> SkeletalMeshes;                               // 0x0040 (size: 0x10)

}; // Size: 0x50

class UPrimaryAssetLabel : public UPrimaryDataAsset
{
    FPrimaryAssetRules Rules;                                                         // 0x0030 (size: 0xC)
    uint8 bLabelAssetsInMyDirectory;                                                  // 0x003C (size: 0x1)
    uint8 bIsRuntimeLabel;                                                            // 0x003C (size: 0x1)
    uint8 bIncludeRedirectors;                                                        // 0x003C (size: 0x1)
    TArray<TSoftObjectPtr<UObject>> ExplicitAssets;                                   // 0x0040 (size: 0x10)
    TArray<TSoftClassPtr<UObject>> ExplicitBlueprints;                                // 0x0050 (size: 0x10)
    FCollectionReference AssetCollection;                                             // 0x0060 (size: 0x8)

}; // Size: 0x68

class UPrimaryDataAsset : public UDataAsset
{
}; // Size: 0x30

class UPrimitiveComponent : public USceneComponent
{
    float MinDrawDistance;                                                            // 0x0248 (size: 0x4)
    float LDMaxDrawDistance;                                                          // 0x024C (size: 0x4)
    float CachedMaxDrawDistance;                                                      // 0x0250 (size: 0x4)
    TEnumAsByte<ESceneDepthPriorityGroup> DepthPriorityGroup;                         // 0x0254 (size: 0x1)
    TEnumAsByte<ESceneDepthPriorityGroup> ViewOwnerDepthPriorityGroup;                // 0x0255 (size: 0x1)
    TEnumAsByte<EIndirectLightingCacheQuality> IndirectLightingCacheQuality;          // 0x0256 (size: 0x1)
    ELightmapType LightmapType;                                                       // 0x0257 (size: 0x1)
    EHLODBatchingPolicy HLODBatchingPolicy;                                           // 0x0258 (size: 0x1)
    uint8 bEnableAutoLODGeneration;                                                   // 0x0259 (size: 0x1)
    uint8 bIsActorTextureStreamingBuiltData;                                          // 0x0259 (size: 0x1)
    uint8 bIsValidTextureStreamingBuiltData;                                          // 0x0259 (size: 0x1)
    uint8 bNeverDistanceCull;                                                         // 0x0259 (size: 0x1)
    uint8 bAlwaysCreatePhysicsState;                                                  // 0x025A (size: 0x1)
    uint8 bGenerateOverlapEvents;                                                     // 0x025A (size: 0x1)
    uint8 bMultiBodyOverlap;                                                          // 0x025A (size: 0x1)
    uint8 bTraceComplexOnMove;                                                        // 0x025A (size: 0x1)
    uint8 bReturnMaterialOnMove;                                                      // 0x025A (size: 0x1)
    uint8 bUseViewOwnerDepthPriorityGroup;                                            // 0x025A (size: 0x1)
    uint8 bAllowCullDistanceVolume;                                                   // 0x025B (size: 0x1)
    uint8 bVisibleInReflectionCaptures;                                               // 0x025B (size: 0x1)
    uint8 bVisibleInRealTimeSkyCaptures;                                              // 0x025B (size: 0x1)
    uint8 bVisibleInRayTracing;                                                       // 0x025B (size: 0x1)
    uint8 bRenderInMainPass;                                                          // 0x025B (size: 0x1)
    uint8 bRenderInDepthPass;                                                         // 0x025B (size: 0x1)
    uint8 bReceivesDecals;                                                            // 0x025B (size: 0x1)
    uint8 bHoldout;                                                                   // 0x025B (size: 0x1)
    uint8 bOwnerNoSee;                                                                // 0x025C (size: 0x1)
    uint8 bOnlyOwnerSee;                                                              // 0x025C (size: 0x1)
    uint8 bTreatAsBackgroundForOcclusion;                                             // 0x025C (size: 0x1)
    uint8 bUseAsOccluder;                                                             // 0x025C (size: 0x1)
    uint8 bSelectable;                                                                // 0x025C (size: 0x1)
    uint8 bForceMipStreaming;                                                         // 0x025C (size: 0x1)
    uint8 bHasPerInstanceHitProxies;                                                  // 0x025C (size: 0x1)
    uint8 CastShadow;                                                                 // 0x025C (size: 0x1)
    uint8 bEmissiveLightSource;                                                       // 0x025D (size: 0x1)
    uint8 bAffectDynamicIndirectLighting;                                             // 0x025D (size: 0x1)
    uint8 bAffectIndirectLightingWhileHidden;                                         // 0x025D (size: 0x1)
    uint8 bAffectDistanceFieldLighting;                                               // 0x025D (size: 0x1)
    uint8 bCastDynamicShadow;                                                         // 0x025D (size: 0x1)
    uint8 bCastStaticShadow;                                                          // 0x025D (size: 0x1)
    EShadowCacheInvalidationBehavior ShadowCacheInvalidationBehavior;                 // 0x025E (size: 0x1)
    uint8 bCastVolumetricTranslucentShadow;                                           // 0x025F (size: 0x1)
    uint8 bCastContactShadow;                                                         // 0x025F (size: 0x1)
    uint8 bSelfShadowOnly;                                                            // 0x025F (size: 0x1)
    uint8 bCastFarShadow;                                                             // 0x025F (size: 0x1)
    uint8 bCastInsetShadow;                                                           // 0x025F (size: 0x1)
    uint8 bCastCinematicShadow;                                                       // 0x025F (size: 0x1)
    uint8 bCastHiddenShadow;                                                          // 0x025F (size: 0x1)
    uint8 bCastShadowAsTwoSided;                                                      // 0x025F (size: 0x1)
    uint8 bLightAsIfStatic;                                                           // 0x0260 (size: 0x1)
    uint8 bLightAttachmentsAsGroup;                                                   // 0x0260 (size: 0x1)
    uint8 bExcludeFromLightAttachmentGroup;                                           // 0x0260 (size: 0x1)
    uint8 bReceiveMobileCSMShadows;                                                   // 0x0260 (size: 0x1)
    uint8 bSingleSampleShadowFromStationaryLights;                                    // 0x0260 (size: 0x1)
    uint8 bIgnoreRadialImpulse;                                                       // 0x0260 (size: 0x1)
    uint8 bIgnoreRadialForce;                                                         // 0x0260 (size: 0x1)
    uint8 bApplyImpulseOnDamage;                                                      // 0x0260 (size: 0x1)
    uint8 bReplicatePhysicsToAutonomousProxy;                                         // 0x0261 (size: 0x1)
    uint8 bFillCollisionUnderneathForNavmesh;                                         // 0x0261 (size: 0x1)
    uint8 AlwaysLoadOnClient;                                                         // 0x0261 (size: 0x1)
    uint8 AlwaysLoadOnServer;                                                         // 0x0261 (size: 0x1)
    uint8 bUseEditorCompositing;                                                      // 0x0261 (size: 0x1)
    uint8 bIsBeingMovedByEditor;                                                      // 0x0261 (size: 0x1)
    uint8 bRenderCustomDepth;                                                         // 0x0261 (size: 0x1)
    uint8 bVisibleInSceneCaptureOnly;                                                 // 0x0261 (size: 0x1)
    uint8 bHiddenInSceneCapture;                                                      // 0x0262 (size: 0x1)
    uint8 bRayTracingFarField;                                                        // 0x0262 (size: 0x1)
    uint8 bHasNoStreamableTextures;                                                   // 0x0262 (size: 0x1)
    uint8 bStaticWhenNotMoveable;                                                     // 0x0262 (size: 0x1)
    TEnumAsByte<EHasCustomNavigableGeometry::Type> bHasCustomNavigableGeometry;       // 0x0281 (size: 0x1)
    TEnumAsByte<ECanBeCharacterBase> CanCharacterStepUpOn;                            // 0x0283 (size: 0x1)
    FLightingChannels LightingChannels;                                               // 0x0284 (size: 0x1)
    int32 RayTracingGroupId;                                                          // 0x0288 (size: 0x4)
    int32 VisibilityId;                                                               // 0x028C (size: 0x4)
    int32 CustomDepthStencilValue;                                                    // 0x0290 (size: 0x4)
    FCustomPrimitiveData CustomPrimitiveData;                                         // 0x0298 (size: 0x10)
    FCustomPrimitiveData CustomPrimitiveDataInternal;                                 // 0x02A8 (size: 0x10)
    int32 TranslucencySortPriority;                                                   // 0x02C0 (size: 0x4)
    float TranslucencySortDistanceOffset;                                             // 0x02C4 (size: 0x4)
    TArray<class URuntimeVirtualTexture*> RuntimeVirtualTextures;                     // 0x02C8 (size: 0x10)
    int8 VirtualTextureLodBias;                                                       // 0x02D8 (size: 0x1)
    int8 VirtualTextureCullMips;                                                      // 0x02D9 (size: 0x1)
    int8 VirtualTextureMinCoverage;                                                   // 0x02DA (size: 0x1)
    ERuntimeVirtualTextureMainPassType VirtualTextureRenderPassType;                  // 0x02DB (size: 0x1)
    float BoundsScale;                                                                // 0x02E4 (size: 0x4)
    TArray<class AActor*> MoveIgnoreActors;                                           // 0x0318 (size: 0x10)
    TArray<class UPrimitiveComponent*> MoveIgnoreComponents;                          // 0x0328 (size: 0x10)
    FBodyInstance BodyInstance;                                                       // 0x0348 (size: 0x198)
    FPrimitiveComponentOnComponentHit OnComponentHit;                                 // 0x04E0 (size: 0x1)
    void ComponentHitSignature(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, FVector NormalImpulse, const FHitResult& hit);
    FPrimitiveComponentOnComponentBeginOverlap OnComponentBeginOverlap;               // 0x04E1 (size: 0x1)
    void ComponentBeginOverlapSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult& SweepResult);
    FPrimitiveComponentOnComponentEndOverlap OnComponentEndOverlap;                   // 0x04E2 (size: 0x1)
    void ComponentEndOverlapSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
    FPrimitiveComponentOnComponentWake OnComponentWake;                               // 0x04E3 (size: 0x1)
    void ComponentWakeSignature(class UPrimitiveComponent* WakingComponent, FName BoneName);
    FPrimitiveComponentOnComponentSleep OnComponentSleep;                             // 0x04E4 (size: 0x1)
    void ComponentSleepSignature(class UPrimitiveComponent* SleepingComponent, FName BoneName);
    FPrimitiveComponentOnComponentPhysicsStateChanged OnComponentPhysicsStateChanged; // 0x04E6 (size: 0x1)
    void ComponentPhysicsStateChanged(class UPrimitiveComponent* ChangedComponent, EComponentPhysicsStateChange StateChange);
    FPrimitiveComponentOnBeginCursorOver OnBeginCursorOver;                           // 0x04E7 (size: 0x1)
    void ComponentBeginCursorOverSignature(class UPrimitiveComponent* TouchedComponent);
    FPrimitiveComponentOnEndCursorOver OnEndCursorOver;                               // 0x04E8 (size: 0x1)
    void ComponentEndCursorOverSignature(class UPrimitiveComponent* TouchedComponent);
    FPrimitiveComponentOnClicked OnClicked;                                           // 0x04E9 (size: 0x1)
    void ComponentOnClickedSignature(class UPrimitiveComponent* TouchedComponent, FKey ButtonPressed);
    FPrimitiveComponentOnReleased OnReleased;                                         // 0x04EA (size: 0x1)
    void ComponentOnReleasedSignature(class UPrimitiveComponent* TouchedComponent, FKey ButtonReleased);
    FPrimitiveComponentOnInputTouchBegin OnInputTouchBegin;                           // 0x04EB (size: 0x1)
    void ComponentOnInputTouchBeginSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class UPrimitiveComponent* TouchedComponent);
    FPrimitiveComponentOnInputTouchEnd OnInputTouchEnd;                               // 0x04EC (size: 0x1)
    void ComponentOnInputTouchEndSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class UPrimitiveComponent* TouchedComponent);
    FPrimitiveComponentOnInputTouchEnter OnInputTouchEnter;                           // 0x04ED (size: 0x1)
    void ComponentBeginTouchOverSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class UPrimitiveComponent* TouchedComponent);
    FPrimitiveComponentOnInputTouchLeave OnInputTouchLeave;                           // 0x04EE (size: 0x1)
    void ComponentEndTouchOverSignature(TEnumAsByte<ETouchIndex::Type> FingerIndex, class UPrimitiveComponent* TouchedComponent);
    ERayTracingGroupCullingPriority RayTracingGroupCullingPriority;                   // 0x04EF (size: 0x1)
    ERendererStencilMask CustomDepthStencilWriteMask;                                 // 0x04F0 (size: 0x1)
    uint8 ExcludeFromHLODLevels;                                                      // 0x0508 (size: 0x1)
    class UPrimitiveComponent* LODParentPrimitive;                                    // 0x0510 (size: 0x8)

    bool WasRecentlyRendered(float Tolerance);
    void WakeRigidBody(FName BoneName);
    void WakeAllRigidBodies();
    void SetWalkableSlopeOverride(const FWalkableSlopeOverride& NewOverride);
    void SetVisibleInSceneCaptureOnly(bool bValue);
    void SetVisibleInRayTracing(bool bNewVisibleInRayTracing);
    void SetVectorParameterForDefaultCustomPrimitiveData(FName ParameterName, FVector4 Value);
    void SetVectorParameterForCustomPrimitiveData(FName ParameterName, FVector4 Value);
    void SetUseCCD(bool InUseCCD, FName BoneName);
    void SetUpdateKinematicFromSimulation(bool bUpdateKinematicFromSimulation);
    void SetTranslucentSortPriority(int32 NewTranslucentSortPriority);
    void SetTranslucencySortDistanceOffset(float NewTranslucencySortDistanceOffset);
    void SetStaticWhenNotMoveable(bool bInStaticWhenNotMoveable);
    void SetSingleSampleShadowFromStationaryLights(bool bNewSingleSampleShadowFromStationaryLights);
    void SetSimulatePhysics(bool bSimulate);
    void SetScalarParameterForDefaultCustomPrimitiveData(FName ParameterName, float Value);
    void SetScalarParameterForCustomPrimitiveData(FName ParameterName, float Value);
    void SetRenderInMainPass(bool bValue);
    void SetRenderInDepthPass(bool bValue);
    void SetRenderCustomDepth(bool bValue);
    void SetReceivesDecals(bool bNewReceivesDecals);
    void SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial);
    void SetPhysicsMaxAngularVelocityInRadians(float NewMaxAngVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsMaxAngularVelocityInDegrees(float NewMaxAngVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsLinearVelocity(FVector NewVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsAngularVelocityInRadians(FVector NewAngVel, bool bAddToCurrent, FName BoneName);
    void SetPhysicsAngularVelocityInDegrees(FVector NewAngVel, bool bAddToCurrent, FName BoneName);
    void SetOwnerNoSee(bool bNewOwnerNoSee);
    void SetOnlyOwnerSee(bool bNewOnlyOwnerSee);
    void SetNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision);
    void SetMaxDepenetrationVelocity(FName BoneName, float InMaxDepenetrationVelocity);
    void SetMaterialByName(FName MaterialSlotName, class UMaterialInterface* Material);
    void SetMaterial(int32 ElementIndex, class UMaterialInterface* Material);
    void SetMassScale(FName BoneName, float InMassScale);
    void SetMassOverrideInKg(FName BoneName, float MassInKg, bool bOverrideMass);
    void SetLinearDamping(float InDamping);
    void SetLightingChannels(bool bChannel0, bool bChannel1, bool bChannel2);
    void SetLightAttachmentsAsGroup(bool bInLightAttachmentsAsGroup);
    void SetIgnoreBoundsForEditorFocus(bool bIgnore);
    void SetHoldout(bool bNewHoldout);
    void SetHiddenInSceneCapture(bool bValue);
    void SetGenerateOverlapEvents(bool bInGenerateOverlapEvents);
    void SetExcludeFromLightAttachmentGroup(bool bInExcludeFromLightAttachmentGroup);
    void SetExcludeForSpecificHLODLevels(const TArray<int32>& InExcludeForSpecificHLODLevels);
    void SetExcludedFromHLODLevel(EHLODLevelExclusion HLODLevel, bool bExcluded);
    void SetEnableGravity(bool bGravityEnabled);
    void SetEmissiveLightSource(bool NewEmissiveLightSource);
    void SetDefaultCustomPrimitiveDataVector4(int32 DataIndex, FVector4 Value);
    void SetDefaultCustomPrimitiveDataVector3(int32 DataIndex, FVector Value);
    void SetDefaultCustomPrimitiveDataVector2(int32 DataIndex, FVector2D Value);
    void SetDefaultCustomPrimitiveDataFloat(int32 DataIndex, float Value);
    void SetCustomPrimitiveDataVector4(int32 DataIndex, FVector4 Value);
    void SetCustomPrimitiveDataVector3(int32 DataIndex, FVector Value);
    void SetCustomPrimitiveDataVector2(int32 DataIndex, FVector2D Value);
    void SetCustomPrimitiveDataFloat(int32 DataIndex, float Value);
    void SetCustomDepthStencilWriteMask(ERendererStencilMask WriteMaskBit);
    void SetCustomDepthStencilValue(int32 Value);
    void SetCullDistance(float NewCullDistance);
    void SetConstraintMode(TEnumAsByte<EDOFMode::Type> ConstraintMode);
    void SetCollisionResponseToChannel(TEnumAsByte<ECollisionChannel> Channel, TEnumAsByte<ECollisionResponse> NewResponse);
    void SetCollisionResponseToAllChannels(TEnumAsByte<ECollisionResponse> NewResponse);
    void SetCollisionProfileName(FName InCollisionProfileName, bool bUpdateOverlaps);
    void SetCollisionObjectType(TEnumAsByte<ECollisionChannel> Channel);
    void SetCollisionEnabled(TEnumAsByte<ECollisionEnabled::Type> NewType);
    void SetCenterOfMass(FVector CenterOfMassOffset, FName BoneName);
    void SetCastShadow(bool NewCastShadow);
    void SetCastInsetShadow(bool bInCastInsetShadow);
    void SetCastHiddenShadow(bool NewCastHiddenShadow);
    void SetCastContactShadow(bool bInCastContactShadow);
    void SetBoundsScale(float NewBoundsScale);
    void SetAngularDamping(float InDamping);
    void SetAllUseCCD(bool InUseCCD);
    void SetAllPhysicsLinearVelocity(FVector NewVel, bool bAddToCurrent);
    void SetAllPhysicsAngularVelocityInRadians(const FVector& NewAngVel, bool bAddToCurrent);
    void SetAllPhysicsAngularVelocityInDegrees(const FVector& NewAngVel, bool bAddToCurrent);
    void SetAllMassScale(float InMassScale);
    void SetAffectIndirectLightingWhileHidden(bool bNewAffectIndirectLightingWhileHidden);
    void SetAffectDynamicIndirectLighting(bool bNewAffectDynamicIndirectLighting);
    void SetAffectDistanceFieldLighting(bool NewAffectDistanceFieldLighting);
    FVector ScaleByMomentOfInertia(FVector InputVector, FName BoneName);
    void PutRigidBodyToSleep(FName BoneName);
    bool K2_SphereTraceComponent(FVector TraceStart, FVector TraceEnd, float SphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, FVector& HitLocation, FVector& HitNormal, FName& BoneName, FHitResult& OutHit);
    bool K2_SphereOverlapComponent(FVector InSphereCentre, float InSphereRadius, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, FVector& HitLocation, FVector& HitNormal, FName& BoneName, FHitResult& OutHit);
    bool K2_LineTraceComponent(FVector TraceStart, FVector TraceEnd, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, FVector& HitLocation, FVector& HitNormal, FName& BoneName, FHitResult& OutHit);
    bool K2_IsQueryCollisionEnabled();
    bool K2_IsPhysicsCollisionEnabled();
    bool K2_IsCollisionEnabled();
    bool K2_BoxOverlapComponent(FVector InBoxCentre, const FBox InBox, bool bTraceComplex, bool bShowTrace, bool bPersistentShowTrace, FVector& HitLocation, FVector& HitNormal, FName& BoneName, FHitResult& OutHit);
    bool IsOverlappingComponent(const class UPrimitiveComponent* OtherComp);
    bool IsOverlappingActor(const class AActor* Other);
    bool IsMaterialSlotNameValid(FName MaterialSlotName);
    bool IsGravityEnabled();
    bool IsExcludedFromHLODLevel(EHLODLevelExclusion HLODLevel);
    bool IsAnyRigidBodyAwake();
    void InvalidateLumenSurfaceCache();
    void IgnoreComponentWhenMoving(class UPrimitiveComponent* Component, bool bShouldIgnore);
    void IgnoreActorWhenMoving(class AActor* Actor, bool bShouldIgnore);
    FWalkableSlopeOverride GetWalkableSlopeOverride();
    bool GetUpdateKinematicFromSimulation();
    bool GetStaticWhenNotMoveable();
    FVector GetPhysicsLinearVelocityAtPoint(FVector Point, FName BoneName);
    FVector GetPhysicsLinearVelocity(FName BoneName);
    FVector GetPhysicsAngularVelocityInRadians(FName BoneName);
    FVector GetPhysicsAngularVelocityInDegrees(FName BoneName);
    void GetOverlappingComponents(TArray<class UPrimitiveComponent*>& OutOverlappingComponents);
    void GetOverlappingActors(TArray<class AActor*>& OverlappingActors, TSubclassOf<class AActor> ClassFilter);
    int32 GetNumMaterials();
    float GetMaxDepenetrationVelocity(FName BoneName);
    TArray<FName> GetMaterialSlotNames();
    int32 GetMaterialIndex(FName MaterialSlotName);
    class UMaterialInterface* GetMaterialFromCollisionFaceIndex(int32 FaceIndex, int32& SectionIndex);
    class UMaterialInterface* GetMaterialByName(FName MaterialSlotName);
    class UMaterialInterface* GetMaterial(int32 ElementIndex);
    float GetMassScale(FName BoneName);
    float GetMass();
    float GetLinearDamping();
    FVector GetInertiaTensor(FName BoneName);
    bool GetIgnoreBoundsForEditorFocus();
    bool GetGenerateOverlapEvents();
    TArray<int32> GetExcludeForSpecificHLODLevels();
    int32 GetCustomPrimitiveDataIndexForVectorParameter(FName ParameterName);
    int32 GetCustomPrimitiveDataIndexForScalarParameter(FName ParameterName);
    TEnumAsByte<ECollisionResponse> GetCollisionResponseToChannel(TEnumAsByte<ECollisionChannel> Channel);
    FName GetCollisionProfileName();
    TEnumAsByte<ECollisionChannel> GetCollisionObjectType();
    TEnumAsByte<ECollisionEnabled::Type> GetCollisionEnabled();
    float GetClosestPointOnCollision(const FVector& Point, FVector& OutPointOnBody, FName BoneName);
    FVector GetCenterOfMass(FName BoneName);
    FBodyInstanceAsyncPhysicsTickHandle GetBodyInstanceAsyncPhysicsTickHandle(FName BoneName, bool bGetWelded, int32 Index);
    float GetAngularDamping();
    class UMaterialInstanceDynamic* CreateDynamicMaterialInstance(int32 ElementIndex, class UMaterialInterface* SourceMaterial, FName OptionalName);
    class UMaterialInstanceDynamic* CreateAndSetMaterialInstanceDynamicFromMaterial(int32 ElementIndex, class UMaterialInterface* Parent);
    class UMaterialInstanceDynamic* CreateAndSetMaterialInstanceDynamic(int32 ElementIndex);
    TArray<class UPrimitiveComponent*> CopyArrayOfMoveIgnoreComponents();
    TArray<class AActor*> CopyArrayOfMoveIgnoreActors();
    void ClearMoveIgnoreComponents();
    void ClearMoveIgnoreActors();
    bool CanCharacterStepUp(class APawn* Pawn);
    void AddVelocityChangeImpulseAtLocation(FVector Impulse, FVector Location, FName BoneName);
    void AddTorqueInRadians(FVector Torque, FName BoneName, bool bAccelChange);
    void AddTorqueInDegrees(FVector Torque, FName BoneName, bool bAccelChange);
    void AddRadialImpulse(FVector Origin, float Radius, float Strength, TEnumAsByte<ERadialImpulseFalloff> Falloff, bool bVelChange);
    void AddRadialForce(FVector Origin, float Radius, float Strength, TEnumAsByte<ERadialImpulseFalloff> Falloff, bool bAccelChange);
    void AddImpulseAtLocation(FVector Impulse, FVector Location, FName BoneName);
    void AddImpulse(FVector Impulse, FName BoneName, bool bVelChange);
    void AddForceAtLocationLocal(FVector Force, FVector Location, FName BoneName);
    void AddForceAtLocation(FVector Force, FVector Location, FName BoneName);
    void AddForce(FVector Force, FName BoneName, bool bAccelChange);
    void AddAngularImpulseInRadians(FVector Impulse, FName BoneName, bool bVelChange);
    void AddAngularImpulseInDegrees(FVector Impulse, FName BoneName, bool bVelChange);
}; // Size: 0x520

class UProjectileMovementComponent : public UMovementComponent
{
    float InitialSpeed;                                                               // 0x0108 (size: 0x4)
    float MaxSpeed;                                                                   // 0x010C (size: 0x4)
    uint8 bRotationFollowsVelocity;                                                   // 0x0110 (size: 0x1)
    uint8 bRotationRemainsVertical;                                                   // 0x0110 (size: 0x1)
    uint8 bShouldBounce;                                                              // 0x0110 (size: 0x1)
    uint8 bInitialVelocityInLocalSpace;                                               // 0x0110 (size: 0x1)
    uint8 bForceSubStepping;                                                          // 0x0110 (size: 0x1)
    uint8 bSimulationEnabled;                                                         // 0x0110 (size: 0x1)
    uint8 bSweepCollision;                                                            // 0x0110 (size: 0x1)
    uint8 bIsHomingProjectile;                                                        // 0x0110 (size: 0x1)
    uint8 bBounceAngleAffectsFriction;                                                // 0x0111 (size: 0x1)
    uint8 bIsSliding;                                                                 // 0x0111 (size: 0x1)
    uint8 bInterpMovement;                                                            // 0x0111 (size: 0x1)
    uint8 bInterpRotation;                                                            // 0x0111 (size: 0x1)
    uint8 bThrottleInterpolation;                                                     // 0x0111 (size: 0x1)
    uint8 bSimulationUseScopedMovement;                                               // 0x0118 (size: 0x1)
    uint8 bInterpolationUseScopedMovement;                                            // 0x0118 (size: 0x1)
    float PreviousHitTime;                                                            // 0x011C (size: 0x4)
    FVector PreviousHitNormal;                                                        // 0x0120 (size: 0x18)
    float ProjectileGravityScale;                                                     // 0x0138 (size: 0x4)
    float Buoyancy;                                                                   // 0x013C (size: 0x4)
    float Bounciness;                                                                 // 0x0140 (size: 0x4)
    float Friction;                                                                   // 0x0144 (size: 0x4)
    float BounceVelocityStopSimulatingThreshold;                                      // 0x0148 (size: 0x4)
    float MinFrictionFraction;                                                        // 0x014C (size: 0x4)
    FProjectileMovementComponentOnProjectileBounce OnProjectileBounce;                // 0x0150 (size: 0x10)
    void OnProjectileBounceDelegate(const FHitResult& ImpactResult, const FVector& ImpactVelocity);
    FProjectileMovementComponentOnProjectileStop OnProjectileStop;                    // 0x0160 (size: 0x10)
    void OnProjectileStopDelegate(const FHitResult& ImpactResult);
    float HomingAccelerationMagnitude;                                                // 0x0170 (size: 0x4)
    TWeakObjectPtr<class USceneComponent> HomingTargetComponent;                      // 0x0174 (size: 0x8)
    float MaxSimulationTimeStep;                                                      // 0x017C (size: 0x4)
    int32 MaxSimulationIterations;                                                    // 0x0180 (size: 0x4)
    int32 BounceAdditionalIterations;                                                 // 0x0184 (size: 0x4)
    float InterpLocationTime;                                                         // 0x0188 (size: 0x4)
    float InterpRotationTime;                                                         // 0x018C (size: 0x4)
    float InterpLocationMaxLagDistance;                                               // 0x0190 (size: 0x4)
    float InterpLocationSnapToTargetDistance;                                         // 0x0194 (size: 0x4)
    float ThrottleInterpolationThresholdNotRenderedShortTime;                         // 0x0198 (size: 0x4)
    float ThrottleInterpolationThresholdNotRenderedLongTime;                          // 0x019C (size: 0x4)
    int32 ThrottleInterpolationSkipFramesRecent;                                      // 0x01A0 (size: 0x4)
    int32 ThrottleInterpolationSkipFramesNotRecent;                                   // 0x01A4 (size: 0x4)

    void StopSimulating(const FHitResult& HitResult);
    void SetVelocityInLocalSpace(FVector NewVelocity);
    void SetInterpolatedComponent(class USceneComponent* Component);
    void ResetInterpolation();
    void OnProjectileStopDelegate__DelegateSignature(const FHitResult& ImpactResult);
    void OnProjectileBounceDelegate__DelegateSignature(const FHitResult& ImpactResult, const FVector& ImpactVelocity);
    void MoveInterpolationTarget(const FVector& NewLocation, const FRotator& NewRotation);
    FVector LimitVelocity(FVector NewVelocity);
    bool IsVelocityUnderSimulationThreshold();
    bool IsInterpolationComplete();
}; // Size: 0x260

class UProxyLODMeshSimplificationSettings : public UDeveloperSettings
{
    FName ProxyLODMeshReductionModuleName;                                            // 0x0038 (size: 0x8)

}; // Size: 0x40

class URPCDoSDetectionConfig : public UObject
{
    bool bRPCDoSDetection;                                                            // 0x0028 (size: 0x1)
    bool bRPCDoSAnalytics;                                                            // 0x0029 (size: 0x1)
    int32 HitchTimeQuotaMS;                                                           // 0x002C (size: 0x4)
    int32 HitchSuspendDetectionTimeMS;                                                // 0x0030 (size: 0x4)
    TArray<FString> DetectionSeverity;                                                // 0x0038 (size: 0x10)
    int32 InitialConnectToleranceMS;                                                  // 0x0048 (size: 0x4)
    TArray<FName> RPCBlockWhitelist;                                                  // 0x0050 (size: 0x10)
    TArray<FName> RPCBlockAllowlist;                                                  // 0x0060 (size: 0x10)
    TArray<FRPCAnalyticsThreshold> RPCAnalyticsThresholds;                            // 0x0070 (size: 0x10)
    double RPCAnalyticsOverrideChance;                                                // 0x0080 (size: 0x8)

}; // Size: 0x88

class URadialForceComponent : public USceneComponent
{
    float Radius;                                                                     // 0x0230 (size: 0x4)
    TEnumAsByte<ERadialImpulseFalloff> Falloff;                                       // 0x0234 (size: 0x1)
    float ImpulseStrength;                                                            // 0x0238 (size: 0x4)
    uint8 bImpulseVelChange;                                                          // 0x023C (size: 0x1)
    uint8 bIgnoreOwningActor;                                                         // 0x023C (size: 0x1)
    float ForceStrength;                                                              // 0x0240 (size: 0x4)
    float DestructibleDamage;                                                         // 0x0244 (size: 0x4)
    TArray<TEnumAsByte<EObjectTypeQuery>> ObjectTypesToAffect;                        // 0x0248 (size: 0x10)

    void RemoveObjectTypeToAffect(TEnumAsByte<EObjectTypeQuery> ObjectType);
    void FireImpulse();
    void AddObjectTypeToAffect(TEnumAsByte<EObjectTypeQuery> ObjectType);
}; // Size: 0x260

class URawAnimSequenceTrackExtensions : public UBlueprintFunctionLibrary
{

    TArray<FVector> GetScaleKeys(const FRawAnimSequenceTrack& Track);
    TArray<FQuat> GetRotationalKeys(const FRawAnimSequenceTrack& Track);
    TArray<FVector> GetPositionalKeys(const FRawAnimSequenceTrack& Track);
}; // Size: 0x28

class URectLightComponent : public ULocalLightComponent
{
    float SourceWidth;                                                                // 0x0390 (size: 0x4)
    float SourceHeight;                                                               // 0x0394 (size: 0x4)
    float BarnDoorAngle;                                                              // 0x0398 (size: 0x4)
    float BarnDoorLength;                                                             // 0x039C (size: 0x4)
    class UTexture* SourceTexture;                                                    // 0x03A0 (size: 0x8)

    void SetSourceWidth(float NewValue);
    void SetSourceTexture(class UTexture* NewValue);
    void SetSourceHeight(float NewValue);
    void SetBarnDoorLength(float NewValue);
    void SetBarnDoorAngle(float NewValue);
}; // Size: 0x3B0

class UReflectionCaptureComponent : public USceneComponent
{
    class UBillboardComponent* CaptureOffsetComponent;                                // 0x0230 (size: 0x8)
    EReflectionSourceType ReflectionSourceType;                                       // 0x0238 (size: 0x1)
    class UTextureCube* Cubemap;                                                      // 0x0240 (size: 0x8)
    float SourceCubemapAngle;                                                         // 0x0248 (size: 0x4)
    float Brightness;                                                                 // 0x024C (size: 0x4)
    FVector CaptureOffset;                                                            // 0x0250 (size: 0x18)
    FGuid MapBuildDataId;                                                             // 0x0268 (size: 0x10)

}; // Size: 0x2A0

class URendererOverrideSettings : public UDeveloperSettings
{
    uint8 bSupportAllShaderPermutations;                                              // 0x0038 (size: 0x1)

}; // Size: 0x40

class URendererSettings : public UDeveloperSettings
{
    TEnumAsByte<EMobileShadingPath::Type> MobileShadingPath;                          // 0x0038 (size: 0x1)
    uint8 bMobileSupportDeferredOnOpenGL;                                             // 0x003C (size: 0x1)
    uint8 bMobileSupportGPUScene;                                                     // 0x003C (size: 0x1)
    TEnumAsByte<EMobileAntiAliasingMethod::Type> MobileAntiAliasing;                  // 0x0040 (size: 0x1)
    TEnumAsByte<EMobileFloatPrecisionMode::Type> MobileFloatPrecisionMode;            // 0x0041 (size: 0x1)
    uint8 bMobileAllowDitheredLODTransition;                                          // 0x0044 (size: 0x1)
    uint8 bMobileVirtualTextures;                                                     // 0x0044 (size: 0x1)
    uint8 bDiscardUnusedQualityLevels;                                                // 0x0044 (size: 0x1)
    TEnumAsByte<EShaderCompressionFormat::Type> ShaderCompressionFormat;              // 0x0048 (size: 0x1)
    uint8 bOcclusionCulling;                                                          // 0x004C (size: 0x1)
    float MinScreenRadiusForLights;                                                   // 0x0050 (size: 0x4)
    float MinScreenRadiusForEarlyZPass;                                               // 0x0054 (size: 0x4)
    float MinScreenRadiusForCSMdepth;                                                 // 0x0058 (size: 0x4)
    uint8 bPrecomputedVisibilityWarning;                                              // 0x005C (size: 0x1)
    uint8 bTextureStreaming;                                                          // 0x005C (size: 0x1)
    uint8 bUseDXT5NormalMaps;                                                         // 0x005C (size: 0x1)
    uint8 bVirtualTextures;                                                           // 0x005C (size: 0x1)
    uint8 bVirtualTextureEnableAutoImport;                                            // 0x005C (size: 0x1)
    uint8 bVirtualTexturedLightmaps;                                                  // 0x005C (size: 0x1)
    uint8 bVirtualTextureAnisotropicFiltering;                                        // 0x005C (size: 0x1)
    uint8 bEnableVirtualTextureOpacityMask;                                           // 0x005C (size: 0x1)
    uint32 VirtualTextureTileSize;                                                    // 0x0060 (size: 0x4)
    uint32 VirtualTextureTileBorderSize;                                              // 0x0064 (size: 0x4)
    uint32 VirtualTextureFeedbackFactor;                                              // 0x0068 (size: 0x4)
    TEnumAsByte<EWorkingColorSpace::Type> WorkingColorSpaceChoice;                    // 0x006C (size: 0x1)
    FVector2D RedChromaticityCoordinate;                                              // 0x0070 (size: 0x10)
    FVector2D GreenChromaticityCoordinate;                                            // 0x0080 (size: 0x10)
    FVector2D BlueChromaticityCoordinate;                                             // 0x0090 (size: 0x10)
    FVector2D WhiteChromaticityCoordinate;                                            // 0x00A0 (size: 0x10)
    uint8 bClearCoatEnableSecondNormal;                                               // 0x00B0 (size: 0x1)
    TEnumAsByte<EDynamicGlobalIlluminationMethod::Type> DynamicGlobalIllumination;    // 0x00B4 (size: 0x1)
    TEnumAsByte<EReflectionMethod::Type> Reflections;                                 // 0x00B5 (size: 0x1)
    int32 ReflectionCaptureResolution;                                                // 0x00B8 (size: 0x4)
    uint8 ReflectionEnvironmentLightmapMixBasedOnRoughness;                           // 0x00BC (size: 0x1)
    uint8 bUseHardwareRayTracingForLumen;                                             // 0x00BC (size: 0x1)
    ELumenRayLightingMode LumenRayLightingMode;                                       // 0x00C0 (size: 0x1)
    uint8 LumenFrontLayerTranslucencyReflections;                                     // 0x00C4 (size: 0x1)
    TEnumAsByte<ELumenSoftwareTracingMode::Type> LumenSoftwareTracingMode;            // 0x00C8 (size: 0x1)
    uint8 LumenRayTracedTranslucentRefractions;                                       // 0x00CC (size: 0x1)
    TEnumAsByte<EShadowMapMethod::Type> ShadowMapMethod;                              // 0x00D0 (size: 0x1)
    uint8 bEnableRayTracing;                                                          // 0x00D4 (size: 0x1)
    uint8 bEnableRayTracingShadows;                                                   // 0x00D4 (size: 0x1)
    uint8 bEnableRayTracingSkylight;                                                  // 0x00D4 (size: 0x1)
    uint8 bEnableRayTracingTextureLOD;                                                // 0x00D4 (size: 0x1)
    uint8 bEnablePathTracing;                                                         // 0x00D4 (size: 0x1)
    uint8 bGenerateMeshDistanceFields;                                                // 0x00D4 (size: 0x1)
    float DistanceFieldVoxelDensity;                                                  // 0x00D8 (size: 0x4)
    uint8 bNanite;                                                                    // 0x00DC (size: 0x1)
    uint8 bAllowStaticLighting;                                                       // 0x00DC (size: 0x1)
    uint8 bUseNormalMapsForStaticLighting;                                            // 0x00DC (size: 0x1)
    uint8 bForwardShading;                                                            // 0x00DC (size: 0x1)
    uint8 bVertexFoggingForOpaque;                                                    // 0x00DC (size: 0x1)
    uint8 bSeparateTranslucency;                                                      // 0x00DC (size: 0x1)
    TEnumAsByte<ETranslucentSortPolicy::Type> TranslucentSortPolicy;                  // 0x00E0 (size: 0x1)
    FVector TranslucentSortAxis;                                                      // 0x00E8 (size: 0x18)
    uint8 bLocalFogVolumeApplyOnTranslucent;                                          // 0x0100 (size: 0x1)
    TEnumAsByte<EFixedFoveationLevels::Type> FoveationLevel;                          // 0x0104 (size: 0x1)
    uint8 bDynamicFoveation;                                                          // 0x0108 (size: 0x1)
    TEnumAsByte<ECustomDepthStencil::Type> CustomDepthStencil;                        // 0x010C (size: 0x1)
    uint8 bCustomDepthTaaJitter;                                                      // 0x0110 (size: 0x1)
    TEnumAsByte<EAlphaChannelMode::Type> bEnableAlphaChannelInPostProcessing;         // 0x0114 (size: 0x1)
    uint8 bDefaultFeatureBloom;                                                       // 0x0118 (size: 0x1)
    uint8 bDefaultFeatureAmbientOcclusion;                                            // 0x0118 (size: 0x1)
    uint8 bDefaultFeatureAmbientOcclusionStaticFraction;                              // 0x0118 (size: 0x1)
    uint8 bDefaultFeatureAutoExposure;                                                // 0x0118 (size: 0x1)
    TEnumAsByte<EAutoExposureMethodUI::Type> DefaultFeatureAutoExposure;              // 0x011C (size: 0x1)
    float DefaultFeatureAutoExposureBias;                                             // 0x0120 (size: 0x4)
    uint8 bExtendDefaultLuminanceRangeInAutoExposureSettings;                         // 0x0124 (size: 0x1)
    float DefaultFeatureLocalExposureHighlightContrast;                               // 0x0128 (size: 0x4)
    float DefaultFeatureLocalExposureShadowContrast;                                  // 0x012C (size: 0x4)
    uint8 bDefaultFeatureMotionBlur;                                                  // 0x0130 (size: 0x1)
    uint8 bDefaultFeatureLensFlare;                                                   // 0x0130 (size: 0x1)
    uint8 bTemporalUpsampling;                                                        // 0x0130 (size: 0x1)
    TEnumAsByte<EAntiAliasingMethod> DefaultFeatureAntiAliasing;                      // 0x0134 (size: 0x1)
    TEnumAsByte<ECompositingSampleCount::Type> MSAASampleCount;                       // 0x0135 (size: 0x1)
    ELightUnits DefaultLightUnits;                                                    // 0x0136 (size: 0x1)
    TEnumAsByte<EDefaultBackBufferPixelFormat::Type> DefaultBackBufferPixelFormat;    // 0x0137 (size: 0x1)
    float DefaultManualScreenPercentage;                                              // 0x0138 (size: 0x4)
    EScreenPercentageMode DefaultScreenPercentageDesktopMode;                         // 0x013C (size: 0x4)
    EScreenPercentageMode DefaultScreenPercentageMobileMode;                          // 0x0140 (size: 0x4)
    EScreenPercentageMode DefaultScreenPercentageVRMode;                              // 0x0144 (size: 0x4)
    EScreenPercentageMode DefaultScreenPercentagePathTracerMode;                      // 0x0148 (size: 0x4)
    uint8 bRenderUnbuiltPreviewShadowsInGame;                                         // 0x014C (size: 0x1)
    uint8 bStencilForLODDither;                                                       // 0x014C (size: 0x1)
    TEnumAsByte<EEarlyZPass::Type> EarlyZPass;                                        // 0x0150 (size: 0x1)
    uint8 bEarlyZPassOnlyMaterialMasking;                                             // 0x0154 (size: 0x1)
    uint8 bEnableCSMCaching;                                                          // 0x0154 (size: 0x1)
    uint8 bDBuffer;                                                                   // 0x0154 (size: 0x1)
    TEnumAsByte<EClearSceneOptions::Type> ClearSceneMethod;                           // 0x0158 (size: 0x1)
    TEnumAsByte<EVelocityOutputPass::Type> VelocityPass;                              // 0x0159 (size: 0x1)
    TEnumAsByte<EVertexDeformationOutputsVelocity::Type> VertexDeformationOutputsVelocity; // 0x015A (size: 0x1)
    uint8 bSelectiveBasePassOutputs;                                                  // 0x015C (size: 0x1)
    uint8 bDefaultParticleCutouts;                                                    // 0x015C (size: 0x1)
    int32 GPUSimulationTextureSizeX;                                                  // 0x0160 (size: 0x4)
    int32 GPUSimulationTextureSizeY;                                                  // 0x0164 (size: 0x4)
    uint8 bGlobalClipPlane;                                                           // 0x0168 (size: 0x1)
    TEnumAsByte<EGBufferFormat::Type> GBufferFormat;                                  // 0x016C (size: 0x1)
    uint8 bUseGPUMorphTargets;                                                        // 0x0170 (size: 0x1)
    float MorphTargetMaxBlendWeight;                                                  // 0x0174 (size: 0x4)
    uint8 bSupportSkyAtmosphere;                                                      // 0x0178 (size: 0x1)
    uint8 bSupportSkyAtmosphereAffectsHeightFog;                                      // 0x0178 (size: 0x1)
    uint8 bSupportLocalFogVolumes;                                                    // 0x0178 (size: 0x1)
    uint8 bSupportCloudShadowOnForwardLitTranslucent;                                 // 0x0178 (size: 0x1)
    TEnumAsByte<ELightFunctionAtlasPixelFormat::Type> LightFunctionAtlasPixelFormat;  // 0x017C (size: 0x1)
    uint8 bVolumetricFogUsesLightFunctionAtlas;                                       // 0x0180 (size: 0x1)
    uint8 bDeferredLightingUsesLightFunctionAtlas;                                    // 0x0180 (size: 0x1)
    uint8 bSingleLayerWaterUsesLightFunctionAtlas;                                    // 0x0180 (size: 0x1)
    uint8 bTranslucentUsesLightFunctionAtlas;                                         // 0x0180 (size: 0x1)
    uint8 bSupportIESProfileOnTranslucent;                                            // 0x0180 (size: 0x1)
    uint8 bSupportRectLightOnTranslucent;                                             // 0x0180 (size: 0x1)
    uint8 bNvidiaAftermathEnabled;                                                    // 0x0180 (size: 0x1)
    uint8 bMultiView;                                                                 // 0x0180 (size: 0x1)
    uint8 bMobilePostProcessing;                                                      // 0x0181 (size: 0x1)
    uint8 bMobileMultiView;                                                           // 0x0181 (size: 0x1)
    uint8 bMobileUseHWsRGBEncoding;                                                   // 0x0181 (size: 0x1)
    uint8 bRoundRobinOcclusion;                                                       // 0x0181 (size: 0x1)
    uint8 bMeshStreaming;                                                             // 0x0181 (size: 0x1)
    uint8 bEnableHeterogeneousVolumes;                                                // 0x0181 (size: 0x1)
    uint8 bShouldHeterogeneousVolumesCastShadows;                                     // 0x0181 (size: 0x1)
    uint8 bCompositeHeterogeneousVolumesWithTranslucency;                             // 0x0181 (size: 0x1)
    float WireframeCullThreshold;                                                     // 0x0184 (size: 0x4)
    uint8 bSupportStationarySkylight;                                                 // 0x0188 (size: 0x1)
    uint8 bSupportLowQualityLightmaps;                                                // 0x0188 (size: 0x1)
    uint8 bSupportPointLightWholeSceneShadows;                                        // 0x0188 (size: 0x1)
    uint8 bSupportTranslucentPerObjectShadow;                                         // 0x0188 (size: 0x1)
    uint8 bSupportCloudShadowOnSingleLayerWater;                                      // 0x0188 (size: 0x1)
    uint8 bEnableSubstrate;                                                           // 0x0188 (size: 0x1)
    uint8 SubstrateOpaqueMaterialRoughRefraction;                                     // 0x0188 (size: 0x1)
    uint8 SubstrateDebugAdvancedVisualizationShaders;                                 // 0x0188 (size: 0x1)
    uint8 bMaterialRoughDiffuse;                                                      // 0x0189 (size: 0x1)
    uint8 bMaterialEnergyConservation;                                                // 0x0189 (size: 0x1)
    uint8 bOrderedIndependentTransparencyEnable;                                      // 0x0189 (size: 0x1)
    uint8 bUseHairStrandsAutoLODMode;                                                 // 0x0189 (size: 0x1)
    uint8 bSupportSkinCacheShaders;                                                   // 0x0189 (size: 0x1)
    uint8 bSkipCompilingGPUSkinVF;                                                    // 0x0189 (size: 0x1)
    ESkinCacheDefaultBehavior DefaultSkinCacheBehavior;                               // 0x018C (size: 0x1)
    float SkinCacheSceneMemoryLimitInMB;                                              // 0x0190 (size: 0x4)
    uint8 bMobileEnableStaticAndCSMShadowReceivers;                                   // 0x0194 (size: 0x1)
    uint8 bMobileEnableMovableLightCSMShaderCulling;                                  // 0x0194 (size: 0x1)
    TEnumAsByte<EMobileLocalLightSetting> MobileLocalLightSetting;                    // 0x0198 (size: 0x1)
    uint8 bMobileForwardEnableClusteredReflections;                                   // 0x019C (size: 0x1)
    uint8 bMobileEnableNoPrecomputedLightingCSMShader;                                // 0x019C (size: 0x1)
    uint8 bMobileAllowDistanceFieldShadows;                                           // 0x019C (size: 0x1)
    uint8 bMobileAllowMovableDirectionalLights;                                       // 0x019C (size: 0x1)
    uint8 bMobileAllowMovableSpotlightShadows;                                        // 0x019C (size: 0x1)
    uint8 bSupport16BitBoneIndex;                                                     // 0x019C (size: 0x1)
    uint8 bGPUSkinLimit2BoneInfluences;                                               // 0x019C (size: 0x1)
    uint8 bSupportDepthOnlyIndexBuffers;                                              // 0x019C (size: 0x1)
    uint8 bSupportReversedIndexBuffers;                                               // 0x019D (size: 0x1)
    uint8 bMobileAmbientOcclusion;                                                    // 0x019D (size: 0x1)
    uint8 bMobileDBuffer;                                                             // 0x019D (size: 0x1)
    uint8 bUseUnlimitedBoneInfluences;                                                // 0x019D (size: 0x1)
    uint8 bAlwaysUseDeformerForUnlimitedBoneInfluences;                               // 0x019D (size: 0x1)
    int32 UnlimitedBonInfluencesThreshold;                                            // 0x01A0 (size: 0x4)
    FPerPlatformInt DefaultBoneInfluenceLimit;                                        // 0x01A4 (size: 0x4)
    FPerPlatformInt MaxSkinBones;                                                     // 0x01A8 (size: 0x4)
    TEnumAsByte<EMobilePlanarReflectionMode::Type> MobilePlanarReflectionMode;        // 0x01AC (size: 0x1)
    uint8 bMobileSupportsGen4TAA;                                                     // 0x01B0 (size: 0x1)
    FPerPlatformBool bStreamSkeletalMeshLODs;                                         // 0x01B4 (size: 0x1)
    FPerPlatformBool bDiscardSkeletalMeshOptionalLODs;                                // 0x01B5 (size: 0x1)
    FSoftObjectPath VisualizeCalibrationColorMaterialPath;                            // 0x01B8 (size: 0x20)
    FSoftObjectPath VisualizeCalibrationCustomMaterialPath;                           // 0x01D8 (size: 0x20)
    FSoftObjectPath VisualizeCalibrationGrayscaleMaterialPath;                        // 0x01F8 (size: 0x20)

}; // Size: 0x218

class UReplayNetConnection : public UNetConnection
{
}; // Size: 0x2880

class UReplaySubsystem : public UGameInstanceSubsystem
{
    bool bLoadDefaultMapOnStop;                                                       // 0x0030 (size: 0x1)

    void RequestCheckpoint();
    bool IsRecording();
    bool IsPlaying();
    float GetReplayCurrentTime();
    FString GetActiveReplayName();
}; // Size: 0x40

class UReplicationConnectionDriver : public UObject
{
}; // Size: 0x28

class UReplicationDriver : public UObject
{
}; // Size: 0x28

class UReporterBase : public UObject
{
}; // Size: 0x30

class UReporterGraph : public UReporterBase
{
}; // Size: 0xC8

class UReverbEffect : public UObject
{
    bool bBypassEarlyReflections;                                                     // 0x0028 (size: 0x1)
    float ReflectionsDelay;                                                           // 0x002C (size: 0x4)
    float GainHF;                                                                     // 0x0030 (size: 0x4)
    float ReflectionsGain;                                                            // 0x0034 (size: 0x4)
    bool bBypassLateReflections;                                                      // 0x0038 (size: 0x1)
    float LateDelay;                                                                  // 0x003C (size: 0x4)
    float DecayTime;                                                                  // 0x0040 (size: 0x4)
    float Density;                                                                    // 0x0044 (size: 0x4)
    float Diffusion;                                                                  // 0x0048 (size: 0x4)
    float AirAbsorptionGainHF;                                                        // 0x004C (size: 0x4)
    float DecayHFRatio;                                                               // 0x0050 (size: 0x4)
    float LateGain;                                                                   // 0x0054 (size: 0x4)
    float Gain;                                                                       // 0x0058 (size: 0x4)
    float RoomRolloffFactor;                                                          // 0x005C (size: 0x4)

}; // Size: 0x60

class URotatingMovementComponent : public UMovementComponent
{
    FRotator RotationRate;                                                            // 0x0108 (size: 0x18)
    FVector PivotTranslation;                                                         // 0x0120 (size: 0x18)
    uint8 bRotationInLocalSpace;                                                      // 0x0138 (size: 0x1)

}; // Size: 0x140

class URuntimeHashExternalStreamingObjectBase : public UObject
{
    TMap<class FName, class FName> SubObjectsToCellRemapping;                         // 0x0038 (size: 0x50)
    FWorldPartitionRuntimeContainerResolver ContainerResolver;                        // 0x0088 (size: 0x58)
    TSoftObjectPtr<UWorld> OuterWorld;                                                // 0x00F0 (size: 0x28)
    TMap<class FName, class FWorldPartitionRuntimeCellStreamingData> CellToStreamingData; // 0x0118 (size: 0x50)
    TSet<UDataLayerInstance*> DataLayerInstances;                                     // 0x0168 (size: 0x50)
    class UExternalDataLayerInstance* RootExternalDataLayerInstance;                  // 0x01B8 (size: 0x8)

}; // Size: 0x1C0

class URuntimeHashSetExternalStreamingObject : public URuntimeHashExternalStreamingObjectBase
{
    TArray<FRuntimePartitionStreamingData> RuntimeStreamingData;                      // 0x01C0 (size: 0x10)

}; // Size: 0x1D0

class URuntimeOptionsBase : public UObject
{
}; // Size: 0x38

class URuntimePartition : public UObject
{
}; // Size: 0x28

class URuntimePartitionLHGrid : public URuntimePartition
{
}; // Size: 0x28

class URuntimePartitionLevelStreaming : public URuntimePartition
{
}; // Size: 0x28

class URuntimePartitionPersistent : public URuntimePartition
{
}; // Size: 0x28

class URuntimeSpatialHashExternalStreamingObject : public URuntimeHashExternalStreamingObjectBase
{
    TArray<FSpatialHashStreamingGrid> StreamingGrids;                                 // 0x01C0 (size: 0x10)

}; // Size: 0x1D0

class URuntimeVirtualTexture : public UObject
{
    int32 TileCount;                                                                  // 0x0028 (size: 0x4)
    int32 TileSize;                                                                   // 0x002C (size: 0x4)
    int32 TileBorderSize;                                                             // 0x0030 (size: 0x4)
    ERuntimeVirtualTextureMaterialType MaterialType;                                  // 0x0034 (size: 0x1)
    bool bCompressTextures;                                                           // 0x0035 (size: 0x1)
    bool bUseLowQualityCompression;                                                   // 0x0036 (size: 0x1)
    bool bClearTextures;                                                              // 0x0037 (size: 0x1)
    bool bSinglePhysicalSpace;                                                        // 0x0038 (size: 0x1)
    bool bPrivateSpace;                                                               // 0x0039 (size: 0x1)
    bool bAdaptive;                                                                   // 0x003A (size: 0x1)
    bool bContinuousUpdate;                                                           // 0x003B (size: 0x1)
    int32 RemoveLowMips;                                                              // 0x003C (size: 0x4)
    TEnumAsByte<TextureGroup> LODGroup;                                               // 0x0040 (size: 0x1)
    int32 Size;                                                                       // 0x0044 (size: 0x4)
    class URuntimeVirtualTextureStreamingProxy* StreamingTexture;                     // 0x0048 (size: 0x8)

    int32 GetTileSize();
    int32 GetTileCount();
    int32 GetTileBorderSize();
    int32 GetSize();
    int32 GetPageTableSize();
}; // Size: 0xE0

class URuntimeVirtualTextureComponent : public USceneComponent
{
    TSoftObjectPtr<AActor> BoundsAlignActor;                                          // 0x0230 (size: 0x28)
    bool bSetBoundsButton;                                                            // 0x0258 (size: 0x1)
    bool bSnapBoundsToLandscape;                                                      // 0x0259 (size: 0x1)
    float ExpandBounds;                                                               // 0x025C (size: 0x4)
    class URuntimeVirtualTexture* VirtualTexture;                                     // 0x0260 (size: 0x8)
    FPerPlatformBool EnableInGamePerPlatform;                                         // 0x0268 (size: 0x1)
    bool bEnableForNaniteOnly;                                                        // 0x0269 (size: 0x1)
    bool bEnableScalability;                                                          // 0x026A (size: 0x1)
    uint32 ScalabilityGroup;                                                          // 0x026C (size: 0x4)
    bool bHidePrimitives;                                                             // 0x0270 (size: 0x1)
    class UVirtualTextureBuilder* StreamingTexture;                                   // 0x0278 (size: 0x8)
    int32 StreamLowMips;                                                              // 0x0280 (size: 0x4)
    bool bBuildStreamingMipsButton;                                                   // 0x0284 (size: 0x1)
    TEnumAsByte<ETextureLossyCompressionAmount> LossyCompressionAmount;               // 0x0285 (size: 0x1)
    bool bUseStreamingMipsFixedColor;                                                 // 0x0286 (size: 0x1)
    FLinearColor StreamingMipsFixedColor;                                             // 0x0288 (size: 0x10)
    bool bUseStreamingLowMipsInEditor;                                                // 0x0298 (size: 0x1)

    void Invalidate(const FBoxSphereBounds& WorldBounds);
}; // Size: 0x2D0

class URuntimeVirtualTextureStreamingProxy : public UTexture2D
{
}; // Size: 0x150

class USCS_Node : public UObject
{
    UClass* ComponentClass;                                                           // 0x0028 (size: 0x8)
    class UActorComponent* ComponentTemplate;                                         // 0x0030 (size: 0x8)
    FBlueprintCookedComponentInstancingData CookedComponentInstancingData;            // 0x0038 (size: 0x48)
    FName AttachToName;                                                               // 0x0080 (size: 0x8)
    FName ParentComponentOrVariableName;                                              // 0x0088 (size: 0x8)
    FName ParentComponentOwnerClassName;                                              // 0x0090 (size: 0x8)
    bool bIsParentComponentNative;                                                    // 0x0098 (size: 0x1)
    TArray<class USCS_Node*> ChildNodes;                                              // 0x00A0 (size: 0x10)
    TArray<FBPVariableMetaDataEntry> MetaDataArray;                                   // 0x00B0 (size: 0x10)
    FGuid VariableGuid;                                                               // 0x00C0 (size: 0x10)
    FName InternalVariableName;                                                       // 0x00D0 (size: 0x8)

}; // Size: 0xD8

class USMInstanceElementAssetDataInterface : public UObject
{
}; // Size: 0x30

class USMInstanceElementHierarchyInterface : public UObject
{
}; // Size: 0x30

class USMInstanceElementIdMapTransactor : public UObject
{
}; // Size: 0x28

class USMInstanceElementPrimitiveCustomDataInterface : public UObject
{
}; // Size: 0x30

class USMInstanceElementSelectionInterface : public UObject
{
}; // Size: 0x30

class USMInstanceElementWorldInterface : public UObject
{
}; // Size: 0x30

class USaveGame : public UObject
{
}; // Size: 0x28

class UScene : public UObject
{
}; // Size: 0x28

class USceneCaptureComponent : public USceneComponent
{
    ESceneCapturePrimitiveRenderMode PrimitiveRenderMode;                             // 0x0230 (size: 0x1)
    TEnumAsByte<ESceneCaptureSource> CaptureSource;                                   // 0x0231 (size: 0x1)
    uint8 bCaptureEveryFrame;                                                         // 0x0232 (size: 0x1)
    uint8 bCaptureOnMovement;                                                         // 0x0232 (size: 0x1)
    bool bAlwaysPersistRenderingState;                                                // 0x0233 (size: 0x1)
    TArray<TWeakObjectPtr<UPrimitiveComponent>> HiddenComponents;                     // 0x0238 (size: 0x10)
    TArray<class AActor*> HiddenActors;                                               // 0x0248 (size: 0x10)
    TArray<TWeakObjectPtr<UPrimitiveComponent>> ShowOnlyComponents;                   // 0x0258 (size: 0x10)
    TArray<class AActor*> ShowOnlyActors;                                             // 0x0268 (size: 0x10)
    float LODDistanceFactor;                                                          // 0x0278 (size: 0x4)
    float MaxViewDistanceOverride;                                                    // 0x027C (size: 0x4)
    int32 CaptureSortPriority;                                                        // 0x0280 (size: 0x4)
    bool bUseRayTracingIfEnabled;                                                     // 0x0284 (size: 0x1)
    TArray<FEngineShowFlagsSetting> ShowFlagSettings;                                 // 0x0288 (size: 0x10)
    FString ProfilingEventName;                                                       // 0x02C8 (size: 0x10)

    void ShowOnlyComponent(class UPrimitiveComponent* InComponent);
    void ShowOnlyActorComponents(class AActor* InActor, const bool bIncludeFromChildActors);
    void SetCaptureSortPriority(int32 NewCaptureSortPriority);
    void RemoveShowOnlyComponent(class UPrimitiveComponent* InComponent);
    void RemoveShowOnlyActorComponents(class AActor* InActor, const bool bIncludeFromChildActors);
    void HideComponent(class UPrimitiveComponent* InComponent);
    void HideActorComponents(class AActor* InActor, const bool bIncludeFromChildActors);
    void ClearShowOnlyComponents();
    void ClearHiddenComponents();
}; // Size: 0x2F0

class USceneCaptureComponent2D : public USceneCaptureComponent
{
    TEnumAsByte<ECameraProjectionMode::Type> ProjectionType;                          // 0x02E8 (size: 0x1)
    float FOVAngle;                                                                   // 0x02EC (size: 0x4)
    float OrthoWidth;                                                                 // 0x02F0 (size: 0x4)
    bool bAutoCalculateOrthoPlanes;                                                   // 0x02F4 (size: 0x1)
    float AutoPlaneShift;                                                             // 0x02F8 (size: 0x4)
    bool bUpdateOrthoPlanes;                                                          // 0x02FC (size: 0x1)
    bool bUseCameraHeightAsViewTarget;                                                // 0x02FD (size: 0x1)
    class UTextureRenderTarget2D* TextureTarget;                                      // 0x0300 (size: 0x8)
    TEnumAsByte<ESceneCaptureCompositeMode> CompositeMode;                            // 0x0308 (size: 0x1)
    FPostProcessSettings PostProcessSettings;                                         // 0x0310 (size: 0x6F0)
    float PostProcessBlendWeight;                                                     // 0x0A00 (size: 0x4)
    uint8 bOverride_CustomNearClippingPlane;                                          // 0x0A04 (size: 0x1)
    float CustomNearClippingPlane;                                                    // 0x0A08 (size: 0x4)
    bool bUseCustomProjectionMatrix;                                                  // 0x0A0C (size: 0x1)
    FMatrix CustomProjectionMatrix;                                                   // 0x0A10 (size: 0x80)
    bool bUseFauxOrthoViewPos;                                                        // 0x0A90 (size: 0x1)
    bool bEnableOrthographicTiling;                                                   // 0x0A91 (size: 0x1)
    int32 NumXTiles;                                                                  // 0x0A94 (size: 0x4)
    int32 NumYTiles;                                                                  // 0x0A98 (size: 0x4)
    bool bEnableClipPlane;                                                            // 0x0A9C (size: 0x1)
    FVector ClipPlaneBase;                                                            // 0x0AA0 (size: 0x18)
    FVector ClipPlaneNormal;                                                          // 0x0AB8 (size: 0x18)
    bool bRenderInMainRenderer;                                                       // 0x0AD0 (size: 0x1)
    uint8 bCameraCutThisFrame;                                                        // 0x0AD4 (size: 0x1)
    uint8 bConsiderUnrenderedOpaquePixelAsFullyTranslucent;                           // 0x0AD4 (size: 0x1)

    void RemoveBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject);
    void CaptureScene();
    void AddOrUpdateBlendable(TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
}; // Size: 0xAF0

class USceneCaptureComponentCube : public USceneCaptureComponent
{
    class UTextureRenderTargetCube* TextureTarget;                                    // 0x02E8 (size: 0x8)
    bool bCaptureRotation;                                                            // 0x02F0 (size: 0x1)

    void CaptureScene();
}; // Size: 0x300

class USceneComponent : public UActorComponent
{
    TWeakObjectPtr<class APhysicsVolume> PhysicsVolume;                               // 0x00A8 (size: 0x8)
    class USceneComponent* AttachParent;                                              // 0x00B0 (size: 0x8)
    FName AttachSocketName;                                                           // 0x00B8 (size: 0x8)
    TArray<class USceneComponent*> AttachChildren;                                    // 0x00C8 (size: 0x10)
    TArray<class USceneComponent*> ClientAttachedChildren;                            // 0x00D8 (size: 0x10)
    FVector RelativeLocation;                                                         // 0x0128 (size: 0x18)
    FRotator RelativeRotation;                                                        // 0x0140 (size: 0x18)
    FVector RelativeScale3D;                                                          // 0x0158 (size: 0x18)
    FVector ComponentVelocity;                                                        // 0x0170 (size: 0x18)
    uint8 bComponentToWorldUpdated;                                                   // 0x0188 (size: 0x1)
    uint8 bAbsoluteLocation;                                                          // 0x0188 (size: 0x1)
    uint8 bAbsoluteRotation;                                                          // 0x0188 (size: 0x1)
    uint8 bAbsoluteScale;                                                             // 0x0188 (size: 0x1)
    uint8 bVisible;                                                                   // 0x0188 (size: 0x1)
    uint8 bShouldBeAttached;                                                          // 0x0188 (size: 0x1)
    uint8 bShouldSnapLocationWhenAttached;                                            // 0x0188 (size: 0x1)
    uint8 bShouldSnapRotationWhenAttached;                                            // 0x0189 (size: 0x1)
    uint8 bShouldSnapScaleWhenAttached;                                               // 0x0189 (size: 0x1)
    uint8 bShouldUpdatePhysicsVolume;                                                 // 0x0189 (size: 0x1)
    uint8 bHiddenInGame;                                                              // 0x0189 (size: 0x1)
    uint8 bBoundsChangeTriggersStreamingDataRebuild;                                  // 0x0189 (size: 0x1)
    uint8 bUseAttachParentBound;                                                      // 0x0189 (size: 0x1)
    uint8 bComputeFastLocalBounds;                                                    // 0x0189 (size: 0x1)
    uint8 bComputeBoundsOnceForGame;                                                  // 0x0189 (size: 0x1)
    uint8 bComputedBoundsOnceForGame;                                                 // 0x018A (size: 0x1)
    uint8 bIsNotRenderAttachmentRoot;                                                 // 0x018A (size: 0x1)
    TEnumAsByte<EComponentMobility::Type> Mobility;                                   // 0x018B (size: 0x1)
    TEnumAsByte<EDetailMode> DetailMode;                                              // 0x018C (size: 0x1)
    FSceneComponentPhysicsVolumeChangedDelegate PhysicsVolumeChangedDelegate;         // 0x018D (size: 0x1)
    void PhysicsVolumeChanged(class APhysicsVolume* NewVolume);

    void ToggleVisibility(bool bPropagateToChildren);
    void SetWorldScale3D(FVector NewScale);
    void SetVisibility(bool bNewVisibility, bool bPropagateToChildren);
    void SetShouldUpdatePhysicsVolume(bool bInShouldUpdatePhysicsVolume);
    void SetRelativeScale3D(FVector NewScale3D);
    void SetMobility(TEnumAsByte<EComponentMobility::Type> NewMobility);
    void SetHiddenInGame(bool NewHidden, bool bPropagateToChildren);
    void SetAbsolute(bool bNewAbsoluteLocation, bool bNewAbsoluteRotation, bool bNewAbsoluteScale);
    void ResetRelativeTransform();
    void OnRep_Visibility(bool OldValue);
    void OnRep_Transform();
    void OnRep_AttachSocketName();
    void OnRep_AttachParent();
    void OnRep_AttachChildren();
    void K2_SetWorldTransform(const FTransform& NewTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetWorldRotation(FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetWorldLocationAndRotation(FVector NewLocation, FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetWorldLocation(FVector NewLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetRelativeTransform(const FTransform& NewTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetRelativeRotation(FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetRelativeLocationAndRotation(FVector NewLocation, FRotator NewRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_SetRelativeLocation(FVector NewLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    FTransform K2_GetComponentToWorld();
    FVector K2_GetComponentScale();
    FRotator K2_GetComponentRotation();
    FVector K2_GetComponentLocation();
    void K2_DetachFromComponent(EDetachmentRule LocationRule, EDetachmentRule RotationRule, EDetachmentRule ScaleRule, bool bCallModify);
    bool K2_AttachToComponent(class USceneComponent* Parent, FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
    bool K2_AttachTo(class USceneComponent* InParent, FName InSocketName, TEnumAsByte<EAttachLocation::Type> AttachType, bool bWeldSimulatedBodies);
    void K2_AddWorldTransformKeepScale(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddWorldTransform(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddWorldRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddWorldOffset(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddRelativeRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddRelativeLocation(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddLocalTransform(const FTransform& DeltaTransform, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddLocalRotation(FRotator DeltaRotation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    void K2_AddLocalOffset(FVector DeltaLocation, bool bSweep, FHitResult& SweepHitResult, bool bTeleport);
    bool IsVisible();
    bool IsSimulatingPhysics(FName BoneName);
    bool IsAnySimulatingPhysics();
    FVector GetUpVector();
    FTransform GetSocketTransform(FName InSocketName, TEnumAsByte<ERelativeTransformSpace> TransformSpace);
    FRotator GetSocketRotation(FName InSocketName);
    FQuat GetSocketQuaternion(FName InSocketName);
    FVector GetSocketLocation(FName InSocketName);
    bool GetShouldUpdatePhysicsVolume();
    FVector GetRightVector();
    FTransform GetRelativeTransform();
    class APhysicsVolume* GetPhysicsVolume();
    void GetParentComponents(TArray<class USceneComponent*>& Parents);
    int32 GetNumChildrenComponents();
    FVector GetForwardVector();
    FVector GetComponentVelocity();
    void GetChildrenComponents(bool bIncludeAllDescendants, TArray<class USceneComponent*>& Children);
    class USceneComponent* GetChildComponent(int32 ChildIndex);
    FName GetAttachSocketName();
    class USceneComponent* GetAttachParent();
    TArray<FName> GetAllSocketNames();
    bool DoesSocketExist(FName InSocketName);
    void DetachFromParent(bool bMaintainWorldPosition, bool bCallModify);
}; // Size: 0x230

class UScriptViewportClient : public UObject
{
}; // Size: 0x38

class UShadowMapTexture2D : public UTexture2D
{
    TEnumAsByte<EShadowMapFlags> ShadowmapFlags;                                      // 0x0150 (size: 0x1)

}; // Size: 0x158

class UShapeComponent : public UPrimitiveComponent
{
    class UBodySetup* ShapeBodySetup;                                                 // 0x0518 (size: 0x8)
    FColor ShapeColor;                                                                // 0x0520 (size: 0x4)
    uint8 bDrawOnlyIfSelected;                                                        // 0x0524 (size: 0x1)
    uint8 bShouldCollideWhenPlacing;                                                  // 0x0524 (size: 0x1)
    uint8 bDynamicObstacle;                                                           // 0x0524 (size: 0x1)
    TSubclassOf<class UNavAreaBase> AreaClassOverride;                                // 0x0528 (size: 0x8)
    uint8 bUseSystemDefaultObstacleAreaClass;                                         // 0x0530 (size: 0x1)
    float LineThickness;                                                              // 0x0534 (size: 0x4)

    void SetLineThickness(float Thickness);
}; // Size: 0x540

class USimpleConstructionScript : public UObject
{
    TArray<class USCS_Node*> RootNodes;                                               // 0x0028 (size: 0x10)
    TArray<class USCS_Node*> AllNodes;                                                // 0x0038 (size: 0x10)
    class USCS_Node* DefaultSceneRootNode;                                            // 0x0048 (size: 0x8)

}; // Size: 0xB0

class USimulatedClientNetConnection : public UNetConnection
{
}; // Size: 0x1E00

class USkeletalBodySetup : public UBodySetup
{
    bool bSkipScaleFromAnimation;                                                     // 0x0320 (size: 0x1)
    TArray<FPhysicalAnimationProfile> PhysicalAnimationData;                          // 0x0328 (size: 0x10)

}; // Size: 0x338

class USkeletalMesh : public USkinnedAsset
{
    class USkeleton* Skeleton;                                                        // 0x00F0 (size: 0x8)
    FBoxSphereBounds ImportedBounds;                                                  // 0x00F8 (size: 0x38)
    FBoxSphereBounds ExtendedBounds;                                                  // 0x0130 (size: 0x38)
    FVector PositiveBoundsExtension;                                                  // 0x0168 (size: 0x18)
    FVector NegativeBoundsExtension;                                                  // 0x0180 (size: 0x18)
    TArray<FSkeletalMaterial> Materials;                                              // 0x0198 (size: 0x10)
    TArray<FSkeletalMeshLODInfo> LODInfo;                                             // 0x01A8 (size: 0x10)
    FPerQualityLevelInt MinQualityLevelLOD;                                           // 0x0208 (size: 0x68)
    FPerPlatformInt MinLOD;                                                           // 0x0270 (size: 0x4)
    FPerPlatformBool DisableBelowMinLodStripping;                                     // 0x0274 (size: 0x1)
    uint8 bUseFullPrecisionUVs;                                                       // 0x0275 (size: 0x1)
    uint8 bUseHighPrecisionTangentBasis;                                              // 0x0275 (size: 0x1)
    uint8 bHasBeenSimplified;                                                         // 0x0275 (size: 0x1)
    uint8 bHasVertexColors;                                                           // 0x0275 (size: 0x1)
    uint8 bEnablePerPolyCollision;                                                    // 0x0275 (size: 0x1)
    class UBodySetup* BodySetup;                                                      // 0x0278 (size: 0x8)
    class UPhysicsAsset* PhysicsAsset;                                                // 0x0280 (size: 0x8)
    class UPhysicsAsset* ShadowPhysicsAsset;                                          // 0x0288 (size: 0x8)
    TArray<class UNodeMappingContainer*> NodeMappingData;                             // 0x0290 (size: 0x10)
    uint8 bSupportRayTracing;                                                         // 0x02A0 (size: 0x1)
    int32 RayTracingMinLOD;                                                           // 0x02A4 (size: 0x4)
    EClothLODBiasMode ClothLODBiasMode;                                               // 0x02A8 (size: 0x1)
    TArray<class UMorphTarget*> MorphTargets;                                         // 0x02B0 (size: 0x10)
    TSubclassOf<class UAnimInstance> PostProcessAnimBlueprint;                        // 0x0430 (size: 0x8)
    int32 PostProcessAnimBPLODThreshold;                                              // 0x0438 (size: 0x4)
    TArray<class UClothingAssetBase*> MeshClothingAssets;                             // 0x0440 (size: 0x10)
    FSkeletalMeshSamplingInfo SamplingInfo;                                           // 0x0450 (size: 0x30)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0480 (size: 0x10)
    TArray<class USkeletalMeshSocket*> Sockets;                                       // 0x0490 (size: 0x10)
    TArray<FSkinWeightProfileInfo> SkinWeightProfiles;                                // 0x04B0 (size: 0x10)
    class UMeshDeformer* DefaultMeshDeformer;                                         // 0x04C0 (size: 0x8)
    class UMaterialInterface* OverlayMaterial;                                        // 0x04C8 (size: 0x8)
    float OverlayMaterialMaxDrawDistance;                                             // 0x04D0 (size: 0x4)

    void SetSkeleton(class USkeleton* InSkeleton);
    void SetOverlayMaterialMaxDrawDistance(float InMaxDrawDistance);
    void SetOverlayMaterial(class UMaterialInterface* NewOverlayMaterial);
    void SetMorphTargets(const TArray<class UMorphTarget*>& InMorphTargets);
    void SetMinLODForQualityLevels(const TMap<EPerQualityLevels, int32>& QualityLevelMinimumLODs, int32 Default);
    void SetMeshClothingAssets(const TArray<class UClothingAssetBase*>& InMeshClothingAssets);
    void SetMaterials(const TArray<FSkeletalMaterial>& InMaterials);
    void SetLODSettings(class USkeletalMeshLODSettings* InLODSettings);
    void SetDefaultAnimatingRig(TSoftObjectPtr<UObject> InAnimatingRig);
    int32 NumSockets();
    TArray<FString> K2_GetAllMorphTargetNames();
    bool IsSectionUsingCloth(int32 InSectionIndex, bool bCheckCorrespondingSections);
    class USkeletalMeshSocket* GetSocketByIndex(int32 Index);
    class USkeleton* GetSkeleton();
    class UPhysicsAsset* GetShadowPhysicsAsset();
    class UPhysicsAsset* GetPhysicsAsset();
    float GetOverlayMaterialMaxDrawDistance();
    class UMaterialInterface* GetOverlayMaterial();
    TArray<class UNodeMappingContainer*> GetNodeMappingData();
    class UNodeMappingContainer* GetNodeMappingContainer(class UBlueprint* SourceAsset);
    TArray<class UMorphTarget*> GetMorphTargetsPtrConv();
    void GetMinLODForQualityLevels(TMap<EPerQualityLevels, int32>& QualityLevelMinimumLODs, int32& Default);
    TArray<class UClothingAssetBase*> GetMeshClothingAssets();
    TArray<FSkeletalMaterial> GetMaterials();
    class USkeletalMeshLODSettings* GetLODSettings();
    FBoxSphereBounds GetImportedBounds();
    class UMeshDeformer* GetDefaultMeshDeformer();
    TSoftObjectPtr<UObject> GetDefaultAnimatingRig();
    FBoxSphereBounds GetBounds();
    class USkeletalMeshSocket* FindSocketAndIndex(FName InSocketName, int32& OutIndex);
}; // Size: 0x4D8

class USkeletalMeshComponent : public USkinnedMeshComponent
{
    UClass* AnimBlueprintGeneratedClass;                                              // 0x08C0 (size: 0x8)
    TSubclassOf<class UAnimInstance> AnimClass;                                       // 0x08C8 (size: 0x8)
    class UAnimInstance* AnimScriptInstance;                                          // 0x08D0 (size: 0x8)
    class UAnimInstance* PostProcessAnimInstance;                                     // 0x08D8 (size: 0x8)
    FSingleAnimationPlayData AnimationData;                                           // 0x08E0 (size: 0x18)
    FVector RootBoneTranslation;                                                      // 0x0908 (size: 0x18)
    FVector LineCheckBoundsScale;                                                     // 0x0920 (size: 0x18)
    TArray<class UAnimInstance*> LinkedInstances;                                     // 0x0958 (size: 0x10)
    TArray<FTransform> CachedBoneSpaceTransforms;                                     // 0x0978 (size: 0x10)
    TArray<FTransform> CachedComponentSpaceTransforms;                                // 0x0988 (size: 0x10)
    float GlobalAnimRateScale;                                                        // 0x0A38 (size: 0x4)
    TEnumAsByte<EKinematicBonesUpdateToPhysics::Type> KinematicBonesUpdateType;       // 0x0A3C (size: 0x1)
    TEnumAsByte<EPhysicsTransformUpdateMode::Type> PhysicsTransformUpdateMode;        // 0x0A3D (size: 0x1)
    TEnumAsByte<EAnimationMode::Type> AnimationMode;                                  // 0x0A3F (size: 0x1)
    uint8 bDisablePostProcessBlueprint;                                               // 0x0A41 (size: 0x1)
    uint8 bUpdateOverlapsOnAnimationFinalize;                                         // 0x0A41 (size: 0x1)
    uint8 bHasValidBodies;                                                            // 0x0A41 (size: 0x1)
    uint8 bBlendPhysics;                                                              // 0x0A41 (size: 0x1)
    uint8 bEnablePhysicsOnDedicatedServer;                                            // 0x0A41 (size: 0x1)
    uint8 bUpdateMeshWhenKinematic;                                                   // 0x0A41 (size: 0x1)
    uint8 bUpdateJointsFromAnimation;                                                 // 0x0A42 (size: 0x1)
    uint8 bAllowClothActors;                                                          // 0x0A42 (size: 0x1)
    uint8 bDisableClothSimulation;                                                    // 0x0A42 (size: 0x1)
    uint8 bDisableRigidBodyAnimNode;                                                  // 0x0A48 (size: 0x1)
    uint8 bAllowAnimCurveEvaluation;                                                  // 0x0A48 (size: 0x1)
    uint8 bCollideWithEnvironment;                                                    // 0x0A48 (size: 0x1)
    uint8 bCollideWithAttachedChildren;                                               // 0x0A48 (size: 0x1)
    uint8 bForceCollisionUpdate;                                                      // 0x0A48 (size: 0x1)
    float ClothVelocityScale;                                                         // 0x0A4C (size: 0x4)
    uint8 bResetAfterTeleport;                                                        // 0x0A50 (size: 0x1)
    uint8 bDeferKinematicBoneUpdate;                                                  // 0x0A50 (size: 0x1)
    uint8 bNoSkeletonUpdate;                                                          // 0x0A50 (size: 0x1)
    uint8 bPauseAnims;                                                                // 0x0A50 (size: 0x1)
    uint8 bUseRefPoseOnInitAnim;                                                      // 0x0A50 (size: 0x1)
    uint8 bEnablePerPolyCollision;                                                    // 0x0A50 (size: 0x1)
    uint8 bForceRefpose;                                                              // 0x0A50 (size: 0x1)
    uint8 bOnlyAllowAutonomousTickPose;                                               // 0x0A51 (size: 0x1)
    uint8 bIsAutonomousTickPose;                                                      // 0x0A51 (size: 0x1)
    uint8 bOldForceRefPose;                                                           // 0x0A51 (size: 0x1)
    uint8 bShowPrePhysBones;                                                          // 0x0A51 (size: 0x1)
    uint8 bRequiredBonesUpToDate;                                                     // 0x0A51 (size: 0x1)
    uint8 bAnimTreeInitialised;                                                       // 0x0A51 (size: 0x1)
    uint8 bIncludeComponentLocationIntoBounds;                                        // 0x0A51 (size: 0x1)
    uint8 bEnableLineCheckWithBounds;                                                 // 0x0A51 (size: 0x1)
    uint8 bPropagateCurvesToFollowers;                                                // 0x0A52 (size: 0x1)
    uint8 bSkipKinematicUpdateWhenInterpolating;                                      // 0x0A52 (size: 0x1)
    uint8 bSkipBoundsUpdateWhenInterpolating;                                         // 0x0A52 (size: 0x1)
    uint8 bNeedsQueuedAnimEventsDispatched;                                           // 0x0A52 (size: 0x1)
    uint16 CachedAnimCurveUidVersion;                                                 // 0x0A54 (size: 0x2)
    float ClothBlendWeight;                                                           // 0x0A58 (size: 0x4)
    bool bWaitForParallelClothTask;                                                   // 0x0A5C (size: 0x1)
    bool bFilteredAnimCurvesIsAllowList;                                              // 0x0A5D (size: 0x1)
    uint16 CachedMeshCurveMetaDataVersion;                                            // 0x0A5E (size: 0x2)
    TArray<FName> FilteredAnimCurves;                                                 // 0x0A60 (size: 0x10)
    class UBodySetup* BodySetup;                                                      // 0x0A70 (size: 0x8)
    float ClothMaxDistanceScale;                                                      // 0x0A7C (size: 0x4)
    FSkeletalMeshComponentOnConstraintBroken OnConstraintBroken;                      // 0x0A80 (size: 0x10)
    void ConstraintBrokenSignature(int32 ConstraintIndex);
    FSkeletalMeshComponentOnPlasticDeformation OnPlasticDeformation;                  // 0x0A90 (size: 0x10)
    void PlasticDeformationEventSignature(int32 ConstraintIndex);
    TSubclassOf<class UClothingSimulationFactory> ClothingSimulationFactory;          // 0x0AA0 (size: 0x8)
    float TeleportDistanceThreshold;                                                  // 0x0BA0 (size: 0x4)
    float TeleportRotationThreshold;                                                  // 0x0BA4 (size: 0x4)
    class UClothingSimulationInteractor* ClothingInteractor;                          // 0x0C40 (size: 0x8)
    FSkeletalMeshComponentOnAnimInitialized OnAnimInitialized;                        // 0x0D00 (size: 0x10)
    void OnAnimInitialized();
    uint32 LastPoseTickFrame;                                                         // 0x0F60 (size: 0x4)

    void UnlinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass);
    void UnbindClothFromLeaderPoseComponent(bool bRestoreSimulationSpace);
    void ToggleDisablePostProcessBlueprint();
    void TermBodiesBelow(FName ParentBoneName);
    void SuspendClothingSimulation();
    void Stop();
    void SnapshotPose(FPoseSnapshot& Snapshot);
    void SetUpdateClothInEditor(const bool NewUpdateState);
    void SetUpdateAnimationInEditor(const bool NewUpdateState);
    void SetTeleportRotationThreshold(float Threshold);
    void SetTeleportDistanceThreshold(float Threshold);
    void SetSkeletalMeshAsset(class USkeletalMesh* NewMesh);
    void SetPosition(float InPos, bool bFireNotifies);
    void SetPlayRate(float Rate);
    void SetPhysicsBlendWeight(float PhysicsBlendWeight);
    void SetNotifyRigidBodyCollisionBelow(bool bNewNotifyRigidBodyCollision, FName BoneName, bool bIncludeSelf);
    void SetMorphTarget(FName MorphTargetName, float Value, bool bRemoveZeroWeight);
    void SetEnablePhysicsBlending(bool bNewBlendPhysics);
    void SetEnableGravityOnAllBodiesBelow(bool bEnableGravity, FName BoneName, bool bIncludeSelf);
    void SetEnableBodyGravity(bool bEnableGravity, FName BoneName);
    void SetDisablePostProcessBlueprint(bool bInDisablePostProcess);
    void SetDisableAnimCurves(bool bInDisableAnimCurves);
    void SetConstraintProfileForAll(FName ProfileName, bool bDefaultIfNotFound);
    void SetConstraintProfile(FName JointName, FName ProfileName, bool bDefaultIfNotFound);
    void SetClothMaxDistanceScale(float Scale);
    void SetBodySimulatePhysics(const FName& InBoneName, bool bSimulate);
    void SetBodyNotifyRigidBodyCollision(bool bNewNotifyRigidBodyCollision, FName BoneName);
    void SetAnimClass(UClass* NewClass);
    void SetAnimationMode(TEnumAsByte<EAnimationMode::Type> InAnimationMode, bool bForceInitAnimScriptInstance);
    void SetAnimation(class UAnimationAsset* NewAnimToPlay);
    void SetAngularLimits(FName InBoneName, float Swing1LimitAngle, float TwistLimitAngle, float Swing2LimitAngle);
    void SetAllowRigidBodyAnimNode(bool bInAllow, bool bReinitAnim);
    void SetAllowedAnimCurvesEvaluation(const TArray<FName>& List, bool bAllow);
    void SetAllowClothActors(bool bInAllow);
    void SetAllowAnimCurveEvaluation(bool bInAllow);
    void SetAllMotorsAngularVelocityDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType);
    void SetAllMotorsAngularPositionDrive(bool bEnableSwingDrive, bool bEnableTwistDrive, bool bSkipCustomPhysicsType);
    void SetAllMotorsAngularDriveParams(float InSpring, float InDamping, float InForceLimit, bool bSkipCustomPhysicsType);
    void SetAllBodiesSimulatePhysics(bool bNewSimulate);
    void SetAllBodiesPhysicsBlendWeight(float PhysicsBlendWeight, bool bSkipCustomPhysicsType);
    void SetAllBodiesBelowSimulatePhysics(const FName& InBoneName, bool bNewSimulate, bool bIncludeSelf);
    void SetAllBodiesBelowPhysicsDisabled(const FName& InBoneName, bool bDisabled, bool bIncludeSelf);
    void SetAllBodiesBelowPhysicsBlendWeight(const FName& InBoneName, float PhysicsBlendWeight, bool bSkipCustomPhysicsType, bool bIncludeSelf);
    void SetAllBodiesBelowLinearVelocity(const FName& InBoneName, const FVector& LinearVelocity, bool bIncludeSelf);
    void ResumeClothingSimulation();
    void ResetClothTeleportMode();
    void ResetAnimInstanceDynamics(ETeleportType InTeleportType);
    void ResetAllowedAnimCurveEvaluation();
    void ResetAllBodiesSimulatePhysics();
    void PlayAnimation(class UAnimationAsset* NewAnimToPlay, bool bLooping);
    void Play(bool bLooping);
    void OverrideAnimationData(class UAnimationAsset* InAnimToPlay, bool bIsLooping, bool bIsPlaying, float Position, float PlayRate);
    void LinkAnimGraphByTag(FName InTag, TSubclassOf<class UAnimInstance> InClass);
    void LinkAnimClassLayers(TSubclassOf<class UAnimInstance> InClass);
    bool K2_GetClosestPointOnPhysicsAsset(const FVector& WorldPosition, FVector& ClosestWorldPosition, FVector& Normal, FName& BoneName, float& Distance);
    bool IsPlaying();
    bool IsClothingSimulationSuspended();
    bool IsBodyGravityEnabled(FName BoneName);
    bool HasValidAnimationInstance();
    bool GetTransformAttribute_Ref(const FName& BoneName, const FName& AttributeName, FTransform& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetTransformAttribute(const FName& BoneName, const FName& AttributeName, FTransform DefaultValue, FTransform& OutValue, ECustomBoneAttributeLookup LookupType);
    float GetTeleportRotationThreshold();
    float GetTeleportDistanceThreshold();
    bool GetStringAttribute_Ref(const FName& BoneName, const FName& AttributeName, FString& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetStringAttribute(const FName& BoneName, const FName& AttributeName, FString DefaultValue, FString& OutValue, ECustomBoneAttributeLookup LookupType);
    class USkeletalMesh* GetSkeletalMeshAsset();
    FVector GetSkeletalCenterOfMass();
    class UAnimInstance* GetPostProcessInstance();
    float GetPosition();
    float GetPlayRate();
    float GetMorphTarget(FName MorphTargetName);
    class UAnimInstance* GetLinkedAnimLayerInstanceByGroup(FName InGroup);
    class UAnimInstance* GetLinkedAnimLayerInstanceByClass(TSubclassOf<class UAnimInstance> InClass);
    void GetLinkedAnimGraphInstancesByTag(FName InTag, TArray<class UAnimInstance*>& OutLinkedInstances);
    class UAnimInstance* GetLinkedAnimGraphInstanceByTag(FName InTag);
    bool GetIntegerAttribute_Ref(const FName& BoneName, const FName& AttributeName, int32& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetIntegerAttribute(const FName& BoneName, const FName& AttributeName, int32 DefaultValue, int32& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetFloatAttribute_Ref(const FName& BoneName, const FName& AttributeName, float& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetFloatAttribute(const FName& BoneName, const FName& AttributeName, float DefaultValue, float& OutValue, ECustomBoneAttributeLookup LookupType);
    bool GetDisablePostProcessBlueprint();
    bool GetDisableAnimCurves();
    void GetCurrentJointAngles(FName InBoneName, float& Swing1Angle, float& TwistAngle, float& Swing2Angle);
    void GetConstraintsFromBody(FName BodyName, bool bParentConstraints, bool bChildConstraints, bool bIncludesTerminated, TArray<FConstraintInstanceAccessor>& OutConstraints);
    void GetConstraints(bool bIncludesTerminated, TArray<FConstraintInstanceAccessor>& OutConstraints);
    FConstraintInstanceAccessor GetConstraintByName(FName ConstraintName, bool bIncludesTerminated);
    float GetClothMaxDistanceScale();
    class UClothingSimulationInteractor* GetClothingSimulationInteractor();
    float GetBoneMass(FName BoneName, bool bScaleMass);
    FVector GetBoneLinearVelocity(const FName& InBoneName);
    class UAnimInstance* GetAnimInstance();
    UClass* GetAnimClass();
    TEnumAsByte<EAnimationMode::Type> GetAnimationMode();
    bool GetAllowRigidBodyAnimNode();
    bool GetAllowedAnimCurveEvaluate();
    bool GetAllowClothActors();
    void ForceClothNextUpdateTeleportAndReset();
    void ForceClothNextUpdateTeleport();
    FName FindConstraintBoneName(int32 ConstraintIndex);
    void ClearMorphTargets();
    void BreakConstraint(FVector Impulse, FVector HitLocation, FName InBoneName);
    void BindClothToLeaderPoseComponent();
    void AllowAnimCurveEvaluation(FName NameOfCurve, bool bAllow);
    void AddImpulseToAllBodiesBelow(FVector Impulse, FName BoneName, bool bVelChange, bool bIncludeSelf);
    void AddForceToAllBodiesBelow(FVector Force, FName BoneName, bool bAccelChange, bool bIncludeSelf);
    void AccumulateAllBodiesBelowPhysicsBlendWeight(const FName& InBoneName, float AddPhysicsBlendWeight, bool bSkipCustomPhysicsType);
}; // Size: 0xF70

class USkeletalMeshDescriptionBulkData : public UMeshDescriptionBaseBulkData
{
}; // Size: 0x28

class USkeletalMeshEditorData : public UObject
{
}; // Size: 0x28

class USkeletalMeshLODSettings : public UDataAsset
{
    FPerQualityLevelInt MinQualityLevelLOD;                                           // 0x0030 (size: 0x68)
    FPerPlatformInt MinLOD;                                                           // 0x0098 (size: 0x4)
    FPerPlatformBool DisableBelowMinLodStripping;                                     // 0x009C (size: 0x1)
    bool bOverrideLODStreamingSettings;                                               // 0x009D (size: 0x1)
    FPerPlatformBool bSupportLODStreaming;                                            // 0x009E (size: 0x1)
    FPerPlatformInt MaxNumStreamedLODs;                                               // 0x00A0 (size: 0x4)
    FPerPlatformInt MaxNumOptionalLODs;                                               // 0x00A4 (size: 0x4)
    TArray<FSkeletalMeshLODGroupSettings> LODGroups;                                  // 0x00A8 (size: 0x10)

}; // Size: 0xB8

class USkeletalMeshSimplificationSettings : public UDeveloperSettings
{
    FName SkeletalMeshReductionModuleName;                                            // 0x0038 (size: 0x8)

}; // Size: 0x40

class USkeletalMeshSocket : public UObject
{
    FName SocketName;                                                                 // 0x0028 (size: 0x8)
    FName BoneName;                                                                   // 0x0030 (size: 0x8)
    FVector RelativeLocation;                                                         // 0x0038 (size: 0x18)
    FRotator RelativeRotation;                                                        // 0x0050 (size: 0x18)
    FVector RelativeScale;                                                            // 0x0068 (size: 0x18)
    bool bForceAlwaysAnimated;                                                        // 0x0080 (size: 0x1)

    void InitializeSocketFromLocation(const class USkeletalMeshComponent* SkelComp, FVector WorldLocation, FVector WorldNormal);
    FVector GetSocketLocation(const class USkeletalMeshComponent* SkelComp);
}; // Size: 0x88

class USkeleton : public UObject
{
    TArray<FBoneNode> BoneTree;                                                       // 0x0038 (size: 0x10)
    FGuid VirtualBoneGuid;                                                            // 0x0160 (size: 0x10)
    TArray<FVirtualBone> VirtualBones;                                                // 0x0170 (size: 0x10)
    TArray<TSoftObjectPtr<USkeleton>> CompatibleSkeletons;                            // 0x0180 (size: 0x10)
    TArray<class USkeletalMeshSocket*> Sockets;                                       // 0x0190 (size: 0x10)
    FSmartNameContainer SmartNames;                                                   // 0x01F0 (size: 0x50)
    TArray<class UBlendProfile*> BlendProfiles;                                       // 0x0250 (size: 0x10)
    TArray<FAnimSlotGroup> SlotGroups;                                                // 0x0260 (size: 0x10)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0448 (size: 0x10)

    class UBlendProfile* GetBlendProfile(const FName& InProfileName);
    void AddCompatibleSkeletonSoft(const TSoftObjectPtr<USkeleton>& SourceSkeleton);
    void AddCompatibleSkeleton(const class USkeleton* SourceSkeleton);
}; // Size: 0x458

class USkinnedAsset : public UStreamableRenderAsset
{

    class USkeletalMeshSocket* FindSocketInfo(FName InSocketName, FTransform& OutTransform, int32& OutBoneIndex, int32& OutIndex);
    class USkeletalMeshSocket* FindSocket(FName InSocketName);
}; // Size: 0xD0

class USkinnedMeshComponent : public UMeshComponent
{
    class USkeletalMesh* SkeletalMesh;                                                // 0x0558 (size: 0x8)
    class USkinnedAsset* SkinnedAsset;                                                // 0x0560 (size: 0x8)
    TWeakObjectPtr<class USkinnedMeshComponent> LeaderPoseComponent;                  // 0x0568 (size: 0x8)
    TArray<ESkinCacheUsage> SkinCacheUsage;                                           // 0x0570 (size: 0x10)
    bool bSetMeshDeformer;                                                            // 0x0580 (size: 0x1)
    class UMeshDeformer* MeshDeformer;                                                // 0x0588 (size: 0x8)
    class UMeshDeformerInstanceSettings* MeshDeformerInstanceSettings;                // 0x0590 (size: 0x8)
    FMeshDeformerInstanceSet MeshDeformerInstances;                                   // 0x0598 (size: 0x20)
    class UPhysicsAsset* PhysicsAssetOverride;                                        // 0x0738 (size: 0x8)
    int32 ForcedLodModel;                                                             // 0x0740 (size: 0x4)
    int32 MinLodModel;                                                                // 0x0748 (size: 0x4)
    float StreamingDistanceMultiplier;                                                // 0x0754 (size: 0x4)
    TArray<FSkelMeshComponentLODInfo> LODInfo;                                        // 0x0760 (size: 0x10)
    EVisibilityBasedAnimTickOption VisibilityBasedAnimTickOption;                     // 0x0794 (size: 0x1)
    uint8 bOverrideMinLOD;                                                            // 0x0796 (size: 0x1)
    uint8 bUseBoundsFromLeaderPoseComponent;                                          // 0x0796 (size: 0x1)
    uint8 bForceWireframe;                                                            // 0x0796 (size: 0x1)
    uint8 bDisableMorphTarget;                                                        // 0x0796 (size: 0x1)
    uint8 bHideSkin;                                                                  // 0x0796 (size: 0x1)
    uint8 bPerBoneMotionBlur;                                                         // 0x0797 (size: 0x1)
    uint8 bComponentUseFixedSkelBounds;                                               // 0x0797 (size: 0x1)
    uint8 bConsiderAllBodiesForBounds;                                                // 0x0797 (size: 0x1)
    uint8 bSyncAttachParentLOD;                                                       // 0x0797 (size: 0x1)
    uint8 bCanHighlightSelectedSections;                                              // 0x0797 (size: 0x1)
    uint8 bRecentlyRendered;                                                          // 0x0797 (size: 0x1)
    uint8 bCastCapsuleDirectShadow;                                                   // 0x0797 (size: 0x1)
    uint8 bCastCapsuleIndirectShadow;                                                 // 0x0797 (size: 0x1)
    uint8 bCPUSkinning;                                                               // 0x0798 (size: 0x1)
    uint8 bEnableUpdateRateOptimizations;                                             // 0x0798 (size: 0x1)
    uint8 bDisplayDebugUpdateRateOptimizations;                                       // 0x0798 (size: 0x1)
    uint8 bRenderStatic;                                                              // 0x0798 (size: 0x1)
    uint8 bIgnoreLeaderPoseComponentLOD;                                              // 0x0798 (size: 0x1)
    uint8 bCachedLocalBoundsUpToDate;                                                 // 0x0798 (size: 0x1)
    uint8 bCachedWorldSpaceBoundsUpToDate;                                            // 0x0799 (size: 0x1)
    uint8 bForceMeshObjectUpdate;                                                     // 0x0799 (size: 0x1)
    uint8 bForceUpdateDynamicDataImmediately;                                         // 0x0799 (size: 0x1)
    uint8 bFollowerShouldTickPose;                                                    // 0x079A (size: 0x1)
    float CapsuleIndirectShadowMinVisibility;                                         // 0x079C (size: 0x4)
    FBoxSphereBounds CachedWorldOrLocalSpaceBounds;                                   // 0x07E0 (size: 0x38)
    FMatrix CachedWorldToLocalTransform;                                              // 0x0820 (size: 0x80)

    void UnsetMeshDeformer();
    void UnloadSkinWeightProfile(FName InProfileName);
    void UnHideBoneByName(FName BoneName);
    void TransformToBoneSpace(FName BoneName, FVector InPosition, FRotator InRotation, FVector& OutPosition, FRotator& OutRotation);
    void TransformFromBoneSpace(FName BoneName, FVector InPosition, FRotator InRotation, FVector& OutPosition, FRotator& OutRotation);
    void ShowMaterialSection(int32 MaterialID, int32 SectionIndex, bool bShow, int32 LODIndex);
    void ShowAllMaterialSections(int32 LODIndex);
    void SetVertexOffsetUsage(int32 LODIndex, int32 Usage);
    void SetVertexColorOverride_LinearColor(int32 LODIndex, const TArray<FLinearColor>& VertexColors);
    bool SetSkinWeightProfile(FName InProfileName);
    void SetSkinWeightOverride(int32 LODIndex, const TArray<FSkelMeshSkinWeightInfo>& SkinWeights);
    void SetSkinnedAssetAndUpdate(class USkinnedAsset* NewMesh, bool bReinitPose);
    void SetRenderStatic(bool bNewValue);
    void SetPreSkinningOffsets(int32 LODIndex, TArray<FVector> Offsets);
    void SetPostSkinningOffsets(int32 LODIndex, TArray<FVector> Offsets);
    void SetPhysicsAsset(class UPhysicsAsset* NewPhysicsAsset, bool bForceReInit);
    void SetMinLOD(int32 InNewMinLOD);
    void SetMeshDeformer(class UMeshDeformer* InMeshDeformer);
    void SetLeaderPoseComponent(class USkinnedMeshComponent* NewLeaderBoneComponent, bool bForceUpdate, bool bInFollowerShouldTickPose);
    void SetForcedLOD(int32 InNewForcedLOD);
    void SetCastCapsuleIndirectShadow(bool bNewValue);
    void SetCastCapsuleDirectShadow(bool bNewValue);
    void SetCapsuleIndirectShadowMinVisibility(float NewValue);
    void OverrideMinLOD(int32 InNewMinLOD);
    bool IsUsingSkinWeightProfile();
    bool IsMaterialSectionShown(int32 MaterialID, int32 LODIndex);
    bool IsBoneHiddenByName(FName BoneName);
    void HideBoneByName(FName BoneName, TEnumAsByte<EPhysBodyOp> PhysBodyOption);
    int32 GetVertexOffsetUsage(int32 LODIndex);
    bool GetTwistAndSwingAngleOfDeltaRotationFromRefPose(FName BoneName, float& OutTwistAngle, float& OutSwingAngle);
    FName GetSocketBoneName(FName InSocketName);
    class USkinnedAsset* GetSkinnedAsset();
    class USkeletalMesh* GetSkeletalMesh_DEPRECATED();
    FTransform GetRefPoseTransform(int32 BoneIndex);
    FVector GetRefPosePosition(int32 BoneIndex);
    int32 GetPredictedLODLevel();
    FName GetParentBone(FName BoneName);
    int32 GetNumLODs();
    int32 GetNumBones();
    class UMeshDeformerInstance* GetMeshDeformerInstance();
    int32 GetForcedLOD();
    FTransform GetDeltaTransformFromRefPose(FName BoneName, FName BaseName);
    FName GetCurrentSkinWeightProfileName();
    FTransform GetBoneTransform(FName InBoneName, TEnumAsByte<ERelativeTransformSpace> TransformSpace);
    FName GetBoneName(int32 BoneIndex);
    int32 GetBoneIndex(FName BoneName);
    FName FindClosestBone_K2(FVector TestLocation, FVector& BoneLocation, float IgnoreScale, bool bRequirePhysicsAsset);
    void ClearVertexColorOverride(int32 LODIndex);
    void ClearSkinWeightProfile();
    void ClearSkinWeightOverride(int32 LODIndex);
    bool BoneIsChildOf(FName BoneName, FName ParentBoneName);
}; // Size: 0x8C0

class USkyAtmosphereComponent : public USceneComponent
{
    ESkyAtmosphereTransformMode TransformMode;                                        // 0x0230 (size: 0x1)
    float BottomRadius;                                                               // 0x0234 (size: 0x4)
    FColor GroundAlbedo;                                                              // 0x0238 (size: 0x4)
    float AtmosphereHeight;                                                           // 0x023C (size: 0x4)
    float MultiScatteringFactor;                                                      // 0x0240 (size: 0x4)
    float TraceSampleCountScale;                                                      // 0x0244 (size: 0x4)
    float RayleighScatteringScale;                                                    // 0x0248 (size: 0x4)
    FLinearColor RayleighScattering;                                                  // 0x024C (size: 0x10)
    float RayleighExponentialDistribution;                                            // 0x025C (size: 0x4)
    float MieScatteringScale;                                                         // 0x0260 (size: 0x4)
    FLinearColor MieScattering;                                                       // 0x0264 (size: 0x10)
    float MieAbsorptionScale;                                                         // 0x0274 (size: 0x4)
    FLinearColor MieAbsorption;                                                       // 0x0278 (size: 0x10)
    float MieAnisotropy;                                                              // 0x0288 (size: 0x4)
    float MieExponentialDistribution;                                                 // 0x028C (size: 0x4)
    float OtherAbsorptionScale;                                                       // 0x0290 (size: 0x4)
    FLinearColor OtherAbsorption;                                                     // 0x0294 (size: 0x10)
    FTentDistribution OtherTentDistribution;                                          // 0x02A4 (size: 0xC)
    FLinearColor SkyLuminanceFactor;                                                  // 0x02B0 (size: 0x10)
    float AerialPespectiveViewDistanceScale;                                          // 0x02C0 (size: 0x4)
    float HeightFogContribution;                                                      // 0x02C4 (size: 0x4)
    float TransmittanceMinLightElevationAngle;                                        // 0x02C8 (size: 0x4)
    float AerialPerspectiveStartDepth;                                                // 0x02CC (size: 0x4)
    uint8 bHoldout;                                                                   // 0x02D0 (size: 0x1)
    uint8 bRenderInMainPass;                                                          // 0x02D0 (size: 0x1)
    FGuid bStaticLightingBuiltGUID;                                                   // 0x0318 (size: 0x10)

    void SetSkyLuminanceFactor(FLinearColor NewValue);
    void SetRenderInMainPass(bool bValue);
    void SetRayleighScatteringScale(float NewValue);
    void SetRayleighScattering(FLinearColor NewValue);
    void SetRayleighExponentialDistribution(float NewValue);
    void SetOtherAbsorptionScale(float NewValue);
    void SetOtherAbsorption(FLinearColor NewValue);
    void SetMultiScatteringFactor(float NewValue);
    void SetMieScatteringScale(float NewValue);
    void SetMieScattering(FLinearColor NewValue);
    void SetMieExponentialDistribution(float NewValue);
    void SetMieAnisotropy(float NewValue);
    void SetMieAbsorptionScale(float NewValue);
    void SetMieAbsorption(FLinearColor NewValue);
    void SetHoldout(bool bNewHoldout);
    void SetHeightFogContribution(float NewValue);
    void SetGroundAlbedo(const FColor& NewValue);
    void SetBottomRadius(float NewValue);
    void SetAtmosphereHeight(float NewValue);
    void SetAerialPespectiveViewDistanceScale(float NewValue);
    void ResetAtmosphereLightDirectionOverride(int32 AtmosphereLightIndex);
    void OverrideAtmosphereLightDirection(int32 AtmosphereLightIndex, const FVector& LightDirection);
    bool IsAtmosphereLightDirectionOverriden(int32 AtmosphereLightIndex);
    FVector GetOverridenAtmosphereLightDirection(int32 AtmosphereLightIndex);
    FLinearColor GetAtmosphereTransmitanceOnGroundAtPlanetTop(class UDirectionalLightComponent* DirectionalLight);
}; // Size: 0x330

class USkyLightComponent : public ULightComponentBase
{
    bool bRealTimeCapture;                                                            // 0x0268 (size: 0x1)
    TEnumAsByte<ESkyLightSourceType> SourceType;                                      // 0x0269 (size: 0x1)
    class UTextureCube* Cubemap;                                                      // 0x0270 (size: 0x8)
    float SourceCubemapAngle;                                                         // 0x0278 (size: 0x4)
    int32 CubemapResolution;                                                          // 0x027C (size: 0x4)
    float SkyDistanceThreshold;                                                       // 0x0280 (size: 0x4)
    bool bCaptureEmissiveOnly;                                                        // 0x0284 (size: 0x1)
    bool bLowerHemisphereIsBlack;                                                     // 0x0285 (size: 0x1)
    FLinearColor LowerHemisphereColor;                                                // 0x0288 (size: 0x10)
    float OcclusionMaxDistance;                                                       // 0x0298 (size: 0x4)
    float Contrast;                                                                   // 0x029C (size: 0x4)
    float OcclusionExponent;                                                          // 0x02A0 (size: 0x4)
    float MinOcclusion;                                                               // 0x02A4 (size: 0x4)
    FColor OcclusionTint;                                                             // 0x02A8 (size: 0x4)
    uint8 bCloudAmbientOcclusion;                                                     // 0x02AC (size: 0x1)
    float CloudAmbientOcclusionStrength;                                              // 0x02B0 (size: 0x4)
    float CloudAmbientOcclusionExtent;                                                // 0x02B4 (size: 0x4)
    float CloudAmbientOcclusionMapResolutionScale;                                    // 0x02B8 (size: 0x4)
    float CloudAmbientOcclusionApertureScale;                                         // 0x02BC (size: 0x4)
    TEnumAsByte<EOcclusionCombineMode> OcclusionCombineMode;                          // 0x02C0 (size: 0x1)
    class UTextureCube* BlendDestinationCubemap;                                      // 0x0368 (size: 0x8)

    void SetVolumetricScatteringIntensity(float NewIntensity);
    void SetSourceCubemapAngle(float NewValue);
    void SetOcclusionTint(const FColor& InTint);
    void SetOcclusionExponent(float InOcclusionExponent);
    void SetOcclusionContrast(float InOcclusionContrast);
    void SetMinOcclusion(float InMinOcclusion);
    void SetLowerHemisphereColor(const FLinearColor& InLowerHemisphereColor);
    void SetLightColor(FLinearColor NewLightColor);
    void SetIntensity(float NewIntensity);
    void SetIndirectLightingIntensity(float NewIntensity);
    void SetCubemapBlend(class UTextureCube* SourceCubemap, class UTextureCube* DestinationCubemap, float InBlendFraction);
    void SetCubemap(class UTextureCube* NewCubemap);
    void RecaptureSky();
}; // Size: 0x440

class USlateBrushAsset : public UObject
{
    FSlateBrush Brush;                                                                // 0x0030 (size: 0xD0)

}; // Size: 0x100

class USmokeTestCommandlet : public UCommandlet
{
}; // Size: 0x80

class USoundAttenuation : public UObject
{
    FSoundAttenuationSettings Attenuation;                                            // 0x0028 (size: 0x3D0)

}; // Size: 0x3F8

class USoundAttenuationEditorSettings : public UObject
{
    bool bEnableReverbSend;                                                           // 0x0028 (size: 0x1)
    bool bEnableSendToAudioLink;                                                      // 0x0029 (size: 0x1)

}; // Size: 0x30

class USoundBase : public UObject
{
    class USoundClass* SoundClassObject;                                              // 0x0030 (size: 0x8)
    uint8 bDebug;                                                                     // 0x0038 (size: 0x1)
    uint8 bOverrideConcurrency;                                                       // 0x0038 (size: 0x1)
    uint8 bEnableBusSends;                                                            // 0x0038 (size: 0x1)
    uint8 bEnableBaseSubmix;                                                          // 0x0038 (size: 0x1)
    uint8 bEnableSubmixSends;                                                         // 0x0038 (size: 0x1)
    uint8 bHasDelayNode;                                                              // 0x0038 (size: 0x1)
    uint8 bHasConcatenatorNode;                                                       // 0x0038 (size: 0x1)
    uint8 bBypassVolumeScaleForPriority;                                              // 0x0038 (size: 0x1)
    EVirtualizationMode VirtualizationMode;                                           // 0x0039 (size: 0x1)
    TSet<USoundConcurrency*> ConcurrencySet;                                          // 0x0090 (size: 0x50)
    FSoundConcurrencySettings ConcurrencyOverrides;                                   // 0x00E0 (size: 0x20)
    float Duration;                                                                   // 0x0100 (size: 0x4)
    float MaxDistance;                                                                // 0x0104 (size: 0x4)
    float TotalSamples;                                                               // 0x0108 (size: 0x4)
    float Priority;                                                                   // 0x010C (size: 0x4)
    class USoundAttenuation* AttenuationSettings;                                     // 0x0110 (size: 0x8)
    class USoundSubmixBase* SoundSubmixObject;                                        // 0x0118 (size: 0x8)
    TArray<FSoundSubmixSendInfo> SoundSubmixSends;                                    // 0x0120 (size: 0x10)
    class USoundEffectSourcePresetChain* SourceEffectChain;                           // 0x0130 (size: 0x8)
    TArray<FSoundSourceBusSendInfo> BusSends;                                         // 0x0138 (size: 0x10)
    TArray<FSoundSourceBusSendInfo> PreEffectBusSends;                                // 0x0148 (size: 0x10)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0158 (size: 0x10)

    bool IsAttenuationSettingsEditable();
}; // Size: 0x168

class USoundClass : public UObject
{
    FSoundClassProperties Properties;                                                 // 0x0028 (size: 0x198)
    TArray<class USoundClass*> ChildClasses;                                          // 0x01C0 (size: 0x10)
    TArray<FPassiveSoundMixModifier> PassiveSoundMixModifiers;                        // 0x01D0 (size: 0x10)
    class USoundClass* ParentClass;                                                   // 0x01E0 (size: 0x8)

}; // Size: 0x1E8

class USoundConcurrency : public UObject
{
    FSoundConcurrencySettings Concurrency;                                            // 0x0028 (size: 0x20)

}; // Size: 0x48

class USoundCue : public USoundBase
{
    class USoundNode* FirstNode;                                                      // 0x0168 (size: 0x8)
    float VolumeMultiplier;                                                           // 0x0170 (size: 0x4)
    float PitchMultiplier;                                                            // 0x0174 (size: 0x4)
    FSoundAttenuationSettings AttenuationOverrides;                                   // 0x0178 (size: 0x3D0)
    float SubtitlePriority;                                                           // 0x0548 (size: 0x4)
    uint8 bPrimeOnLoad;                                                               // 0x0550 (size: 0x1)
    uint8 bOverrideAttenuation;                                                       // 0x0550 (size: 0x1)
    uint8 bExcludeFromRandomNodeBranchCulling;                                        // 0x0550 (size: 0x1)
    uint8 bHasPlayWhenSilent;                                                         // 0x0550 (size: 0x1)
    int32 CookedQualityIndex;                                                         // 0x0554 (size: 0x4)

}; // Size: 0x560

class USoundEffectPreset : public UObject
{
}; // Size: 0x68

class USoundEffectSourcePreset : public USoundEffectPreset
{
}; // Size: 0x68

class USoundEffectSourcePresetChain : public UObject
{
    TArray<FSourceEffectChainEntry> Chain;                                            // 0x0028 (size: 0x10)
    uint8 bPlayEffectChainTails;                                                      // 0x0038 (size: 0x1)

}; // Size: 0x40

class USoundEffectSubmixPreset : public USoundEffectPreset
{
}; // Size: 0x68

class USoundGroups : public UObject
{
    TArray<FSoundGroup> SoundGroupProfiles;                                           // 0x0028 (size: 0x10)

}; // Size: 0x88

class USoundMix : public UObject
{
    uint8 bApplyEQ;                                                                   // 0x0028 (size: 0x1)
    float EQPriority;                                                                 // 0x002C (size: 0x4)
    FAudioEQEffect EQSettings;                                                        // 0x0030 (size: 0x40)
    TArray<FSoundClassAdjuster> SoundClassEffects;                                    // 0x0070 (size: 0x10)
    float InitialDelay;                                                               // 0x0080 (size: 0x4)
    float FadeInTime;                                                                 // 0x0084 (size: 0x4)
    float Duration;                                                                   // 0x0088 (size: 0x4)
    float FadeOutTime;                                                                // 0x008C (size: 0x4)

}; // Size: 0x90

class USoundNode : public UObject
{
    TArray<class USoundNode*> ChildNodes;                                             // 0x0028 (size: 0x10)

}; // Size: 0x48

class USoundNodeAssetReferencer : public USoundNode
{
}; // Size: 0x48

class USoundNodeAttenuation : public USoundNode
{
    class USoundAttenuation* AttenuationSettings;                                     // 0x0048 (size: 0x8)
    FSoundAttenuationSettings AttenuationOverrides;                                   // 0x0050 (size: 0x3D0)
    uint8 bOverrideAttenuation;                                                       // 0x0420 (size: 0x1)

}; // Size: 0x428

class USoundNodeBranch : public USoundNode
{
    FName BoolParameterName;                                                          // 0x0048 (size: 0x8)

}; // Size: 0x50

class USoundNodeConcatenator : public USoundNode
{
    TArray<float> InputVolume;                                                        // 0x0048 (size: 0x10)

}; // Size: 0x58

class USoundNodeDelay : public USoundNode
{
    float DelayMin;                                                                   // 0x0048 (size: 0x4)
    float DelayMax;                                                                   // 0x004C (size: 0x4)

}; // Size: 0x50

class USoundNodeDialoguePlayer : public USoundNode
{
    FDialogueWaveParameter DialogueWaveParameter;                                     // 0x0048 (size: 0x20)
    uint8 bLooping;                                                                   // 0x0068 (size: 0x1)

}; // Size: 0x70

class USoundNodeDistanceCrossFade : public USoundNode
{
    TArray<FDistanceDatum> CrossFadeInput;                                            // 0x0048 (size: 0x10)

}; // Size: 0x58

class USoundNodeDoppler : public USoundNode
{
    float DopplerIntensity;                                                           // 0x0048 (size: 0x4)
    bool bUseSmoothing;                                                               // 0x004C (size: 0x1)
    float SmoothingInterpSpeed;                                                       // 0x0050 (size: 0x4)

}; // Size: 0x58

class USoundNodeEnveloper : public USoundNode
{
    float LoopStart;                                                                  // 0x0048 (size: 0x4)
    float LoopEnd;                                                                    // 0x004C (size: 0x4)
    float DurationAfterLoop;                                                          // 0x0050 (size: 0x4)
    int32 LoopCount;                                                                  // 0x0054 (size: 0x4)
    uint8 bLoopIndefinitely;                                                          // 0x0058 (size: 0x1)
    uint8 bLoop;                                                                      // 0x0058 (size: 0x1)
    class UDistributionFloatConstantCurve* VolumeInterpCurve;                         // 0x0060 (size: 0x8)
    class UDistributionFloatConstantCurve* PitchInterpCurve;                          // 0x0068 (size: 0x8)
    FRuntimeFloatCurve VolumeCurve;                                                   // 0x0070 (size: 0x88)
    FRuntimeFloatCurve PitchCurve;                                                    // 0x00F8 (size: 0x88)
    float PitchMin;                                                                   // 0x0180 (size: 0x4)
    float PitchMax;                                                                   // 0x0184 (size: 0x4)
    float VolumeMin;                                                                  // 0x0188 (size: 0x4)
    float VolumeMax;                                                                  // 0x018C (size: 0x4)

}; // Size: 0x190

class USoundNodeGroupControl : public USoundNode
{
    TArray<int32> GroupSizes;                                                         // 0x0048 (size: 0x10)

}; // Size: 0x58

class USoundNodeLooping : public USoundNode
{
    int32 LoopCount;                                                                  // 0x0048 (size: 0x4)
    uint8 bLoopIndefinitely;                                                          // 0x004C (size: 0x1)

}; // Size: 0x50

class USoundNodeMature : public USoundNode
{
}; // Size: 0x48

class USoundNodeMixer : public USoundNode
{
    TArray<float> InputVolume;                                                        // 0x0048 (size: 0x10)

}; // Size: 0x58

class USoundNodeModulator : public USoundNode
{
    float PitchMin;                                                                   // 0x0048 (size: 0x4)
    float PitchMax;                                                                   // 0x004C (size: 0x4)
    float VolumeMin;                                                                  // 0x0050 (size: 0x4)
    float VolumeMax;                                                                  // 0x0054 (size: 0x4)

}; // Size: 0x58

class USoundNodeModulatorContinuous : public USoundNode
{
    FModulatorContinuousParams PitchModulationParams;                                 // 0x0048 (size: 0x20)
    FModulatorContinuousParams VolumeModulationParams;                                // 0x0068 (size: 0x20)

}; // Size: 0x88

class USoundNodeOscillator : public USoundNode
{
    uint8 bModulateVolume;                                                            // 0x0048 (size: 0x1)
    uint8 bModulatePitch;                                                             // 0x0048 (size: 0x1)
    float AmplitudeMin;                                                               // 0x004C (size: 0x4)
    float AmplitudeMax;                                                               // 0x0050 (size: 0x4)
    float FrequencyMin;                                                               // 0x0054 (size: 0x4)
    float FrequencyMax;                                                               // 0x0058 (size: 0x4)
    float OffsetMin;                                                                  // 0x005C (size: 0x4)
    float OffsetMax;                                                                  // 0x0060 (size: 0x4)
    float CenterMin;                                                                  // 0x0064 (size: 0x4)
    float CenterMax;                                                                  // 0x0068 (size: 0x4)

}; // Size: 0x70

class USoundNodeParamCrossFade : public USoundNodeDistanceCrossFade
{
    FName ParamName;                                                                  // 0x0058 (size: 0x8)

}; // Size: 0x60

class USoundNodeQualityLevel : public USoundNode
{
    int32 CookedQualityLevelIndex;                                                    // 0x0048 (size: 0x4)

}; // Size: 0x50

class USoundNodeRandom : public USoundNode
{
    TArray<float> Weights;                                                            // 0x0048 (size: 0x10)
    TArray<bool> HasBeenUsed;                                                         // 0x0058 (size: 0x10)
    int32 NumRandomUsed;                                                              // 0x0068 (size: 0x4)
    int32 PreselectAtLevelLoad;                                                       // 0x006C (size: 0x4)
    uint8 bShouldExcludeFromBranchCulling;                                            // 0x0070 (size: 0x1)
    uint8 bSoundCueExcludedFromBranchCulling;                                         // 0x0070 (size: 0x1)
    uint8 bRandomizeWithoutReplacement;                                               // 0x0070 (size: 0x1)

}; // Size: 0x78

class USoundNodeSoundClass : public USoundNode
{
    class USoundClass* SoundClassOverride;                                            // 0x0048 (size: 0x8)

}; // Size: 0x58

class USoundNodeSwitch : public USoundNode
{
    FName IntParameterName;                                                           // 0x0048 (size: 0x8)

}; // Size: 0x50

class USoundNodeWaveParam : public USoundNode
{
    FName WaveParameterName;                                                          // 0x0048 (size: 0x8)

}; // Size: 0x50

class USoundNodeWavePlayer : public USoundNodeAssetReferencer
{
    TSoftObjectPtr<USoundWave> SoundWaveAssetPtr;                                     // 0x0048 (size: 0x28)
    class USoundWave* SoundWave;                                                      // 0x0070 (size: 0x8)
    uint8 bLooping;                                                                   // 0x0078 (size: 0x1)

}; // Size: 0x80

class USoundSourceBus : public USoundWave
{
    ESourceBusChannels SourceBusChannels;                                             // 0x0420 (size: 0x1)
    float SourceBusDuration;                                                          // 0x0424 (size: 0x4)
    class UAudioBus* AudioBus;                                                        // 0x0428 (size: 0x8)
    uint8 bAutoDeactivateWhenSilent;                                                  // 0x0430 (size: 0x1)

}; // Size: 0x438

class USoundSubmix : public USoundSubmixWithParentBase
{
    uint8 bMuteWhenBackgrounded;                                                      // 0x00F0 (size: 0x1)
    TArray<class USoundEffectSubmixPreset*> SubmixEffectChain;                        // 0x00F8 (size: 0x10)
    class USoundfieldEncodingSettingsBase* AmbisonicsPluginSettings;                  // 0x0108 (size: 0x8)
    int32 EnvelopeFollowerAttackTime;                                                 // 0x0110 (size: 0x4)
    int32 EnvelopeFollowerReleaseTime;                                                // 0x0114 (size: 0x4)
    FSoundModulationDestinationSettings OutputVolumeModulation;                       // 0x0118 (size: 0x58)
    FSoundModulationDestinationSettings WetLevelModulation;                           // 0x0170 (size: 0x58)
    FSoundModulationDestinationSettings DryLevelModulation;                           // 0x01C8 (size: 0x58)
    uint8 bSendToAudioLink;                                                           // 0x0220 (size: 0x1)
    class UAudioLinkSettingsAbstract* AudioLinkSettings;                              // 0x0228 (size: 0x8)
    FSoundSubmixOnSubmixRecordedFileDone OnSubmixRecordedFileDone;                    // 0x0230 (size: 0x10)
    void OnSubmixRecordedFileDone(const class USoundWave* ResultingSoundWave);

    void StopSpectralAnalysis(const class UObject* WorldContextObject);
    void StopRecordingOutput(const class UObject* WorldContextObject, EAudioRecordingExportType ExportType, FString Name, FString Path, class USoundWave* ExistingSoundWaveToOverwrite);
    void StopEnvelopeFollowing(const class UObject* WorldContextObject);
    void StartSpectralAnalysis(const class UObject* WorldContextObject, EFFTSize FFTSize, EFFTPeakInterpolationMethod InterpolationMethod, EFFTWindowType WindowType, float HopSize, EAudioSpectrumType SpectrumType);
    void StartRecordingOutput(const class UObject* WorldContextObject, float ExpectedDuration);
    void StartEnvelopeFollowing(const class UObject* WorldContextObject);
    void SetWetVolumeModulation(const FSoundModulationDestinationSettings& InVolMod);
    void SetSubmixWetLevel(const class UObject* WorldContextObject, float InWetLevel);
    void SetSubmixOutputVolume(const class UObject* WorldContextObject, float InOutputVolume);
    void SetSubmixDryLevel(const class UObject* WorldContextObject, float InDryLevel);
    void SetOutputVolumeModulation(const FSoundModulationDestinationSettings& InVolMod);
    void SetDryVolumeModulation(const FSoundModulationDestinationSettings& InVolMod);
    void RemoveSpectralAnalysisDelegate(const class UObject* WorldContextObject, const FRemoveSpectralAnalysisDelegateOnSubmixSpectralAnalysisBP& OnSubmixSpectralAnalysisBP);
    void AddSpectralAnalysisDelegate(const class UObject* WorldContextObject, const TArray<FSoundSubmixSpectralAnalysisBandSettings>& InBandSettings, const FAddSpectralAnalysisDelegateOnSubmixSpectralAnalysisBP& OnSubmixSpectralAnalysisBP, float UpdateRate, float DecibelNoiseFloor, bool bDoNormalize, bool bDoAutoRange, float AutoRangeAttackTime, float AutoRangeReleaseTime);
    void AddEnvelopeFollowerDelegate(const class UObject* WorldContextObject, const FAddEnvelopeFollowerDelegateOnSubmixEnvelopeBP& OnSubmixEnvelopeBP);
}; // Size: 0x248

class USoundSubmixBase : public UObject
{
    bool bAutoDisable;                                                                // 0x0028 (size: 0x1)
    float AutoDisableTime;                                                            // 0x002C (size: 0x4)
    TArray<class USoundSubmixBase*> ChildSubmixes;                                    // 0x0030 (size: 0x10)
    TMap<uint32, FDynamicChildSubmix> DynamicChildSubmixes;                           // 0x0040 (size: 0x50)

    class USoundSubmixBase* FindDynamicAncestor();
    bool DynamicDisconnect(const class UObject* WorldContextObject);
    bool DynamicConnect(const class UObject* WorldContextObject, class USoundSubmixBase* InParent);
}; // Size: 0x90

class USoundSubmixWithParentBase : public USoundSubmixBase
{
    class USoundSubmixBase* ParentSubmix;                                             // 0x0090 (size: 0x8)
    TMap<uint32, USoundSubmixBase*> DynamicParentSubmix;                              // 0x0098 (size: 0x50)
    uint8 bIsDynamic;                                                                 // 0x00E8 (size: 0x1)

}; // Size: 0xF0

class USoundWave : public USoundBase
{
    int32 CompressionQuality;                                                         // 0x0178 (size: 0x4)
    int32 StreamingPriority;                                                          // 0x017C (size: 0x4)
    ESoundwaveSampleRateSettings SampleRateQuality;                                   // 0x0180 (size: 0x1)
    TEnumAsByte<ESoundGroup> SoundGroup;                                              // 0x0182 (size: 0x1)
    uint8 bLooping;                                                                   // 0x0183 (size: 0x1)
    uint8 bStreaming;                                                                 // 0x0183 (size: 0x1)
    ESoundAssetCompressionType SoundAssetCompressionType;                             // 0x0184 (size: 0x1)
    uint8 bSeekableStreaming;                                                         // 0x0185 (size: 0x1)
    uint8 bUseBinkAudio;                                                              // 0x0185 (size: 0x1)
    FSoundModulationDefaultRoutingSettings ModulationSettings;                        // 0x01A0 (size: 0x168)
    TArray<float> FrequenciesToAnalyze;                                               // 0x0308 (size: 0x10)
    TArray<FSoundWaveSpectralTimeData> CookedSpectralTimeData;                        // 0x0318 (size: 0x10)
    TArray<FSoundWaveEnvelopeTimeData> CookedEnvelopeTimeData;                        // 0x0328 (size: 0x10)
    int32 InitialChunkSize;                                                           // 0x0338 (size: 0x4)
    uint8 bMature;                                                                    // 0x037C (size: 0x1)
    uint8 bManualWordWrap;                                                            // 0x037C (size: 0x1)
    uint8 bSingleLine;                                                                // 0x037C (size: 0x1)
    uint8 bIsAmbisonics;                                                              // 0x037D (size: 0x1)
    ESoundWaveLoadingBehavior LoadingBehavior;                                        // 0x037E (size: 0x1)
    FString SpokenText;                                                               // 0x0380 (size: 0x10)
    float SubtitlePriority;                                                           // 0x0390 (size: 0x4)
    float Volume;                                                                     // 0x0394 (size: 0x4)
    float Pitch;                                                                      // 0x0398 (size: 0x4)
    int32 NumChannels;                                                                // 0x039C (size: 0x4)
    int32 SampleRate;                                                                 // 0x03A0 (size: 0x4)
    TArray<FSubtitleCue> Subtitles;                                                   // 0x03B0 (size: 0x10)
    class UCurveTable* Curves;                                                        // 0x03C0 (size: 0x8)
    class UCurveTable* InternalCurves;                                                // 0x03C8 (size: 0x8)

    void SetSoundAssetCompressionType(ESoundAssetCompressionType InSoundAssetCompressionType, bool bMarkDirty);
    ESoundAssetCompressionType GetSoundAssetCompressionType();
    TArray<FSoundWaveCuePoint> GetLoopRegions();
    TArray<FSoundWaveCuePoint> GetCuePoints();
}; // Size: 0x420

class USoundWaveProcedural : public USoundWave
{
}; // Size: 0x470

class USoundfieldEndpointSubmix : public USoundSubmixBase
{
    FName SoundfieldEndpointType;                                                     // 0x0090 (size: 0x8)
    TSubclassOf<class UAudioEndpointSettingsBase> EndpointSettingsClass;              // 0x0098 (size: 0x8)
    class USoundfieldEndpointSettingsBase* EndpointSettings;                          // 0x00A0 (size: 0x8)
    TSubclassOf<class USoundfieldEncodingSettingsBase> EncodingSettingsClass;         // 0x00A8 (size: 0x8)
    class USoundfieldEncodingSettingsBase* EncodingSettings;                          // 0x00B0 (size: 0x8)
    TArray<class USoundfieldEffectBase*> SoundfieldEffectChain;                       // 0x00B8 (size: 0x10)

}; // Size: 0xC8

class USoundfieldSubmix : public USoundSubmixWithParentBase
{
    FName SoundfieldEncodingFormat;                                                   // 0x00F0 (size: 0x8)
    class USoundfieldEncodingSettingsBase* EncodingSettings;                          // 0x00F8 (size: 0x8)
    TArray<class USoundfieldEffectBase*> SoundfieldEffectChain;                       // 0x0100 (size: 0x10)
    TSubclassOf<class USoundfieldEncodingSettingsBase> EncodingSettingsClass;         // 0x0110 (size: 0x8)

}; // Size: 0x118

class USparseVolumeTexture : public UObject
{

    int32 GetSizeZ();
    int32 GetSizeY();
    int32 GetSizeX();
    int32 GetNumMipLevels();
    int32 GetNumFrames();
    FTransform GetFrameTransform();
}; // Size: 0x28

class USparseVolumeTextureFrame : public USparseVolumeTexture
{
    class USparseVolumeTexture* Owner;                                                // 0x0028 (size: 0x8)
    int32 FrameIndex;                                                                 // 0x0030 (size: 0x4)
    FTransform Transform;                                                             // 0x0040 (size: 0x60)

}; // Size: 0x1D0

class USpectatorPawnMovement : public UFloatingPawnMovement
{
    uint8 bIgnoreTimeDilation;                                                        // 0x0170 (size: 0x1)

}; // Size: 0x178

class USpecularProfile : public UObject
{
    FSpecularProfileStruct Settings;                                                  // 0x0028 (size: 0x420)
    FGuid Guid;                                                                       // 0x0448 (size: 0x10)

}; // Size: 0x458

class USphereComponent : public UShapeComponent
{
    float SphereRadius;                                                               // 0x0540 (size: 0x4)

    void SetSphereRadius(float InSphereRadius, bool bUpdateOverlaps);
    float GetUnscaledSphereRadius();
    float GetShapeScale();
    float GetScaledSphereRadius();
}; // Size: 0x550

class USphereReflectionCaptureComponent : public UReflectionCaptureComponent
{
    float InfluenceRadius;                                                            // 0x0298 (size: 0x4)
    float CaptureDistanceScale;                                                       // 0x029C (size: 0x4)
    class UDrawSphereComponent* PreviewInfluenceRadius;                               // 0x02A0 (size: 0x8)

}; // Size: 0x2B0

class USplineComponent : public UPrimitiveComponent
{
    FSplineCurves SplineCurves;                                                       // 0x0518 (size: 0x70)
    FInterpCurveVector SplineInfo;                                                    // 0x0588 (size: 0x18)
    FInterpCurveQuat SplineRotInfo;                                                   // 0x05A0 (size: 0x18)
    FInterpCurveVector SplineScaleInfo;                                               // 0x05B8 (size: 0x18)
    FInterpCurveFloat SplineReparamTable;                                             // 0x05D0 (size: 0x18)
    bool bAllowSplineEditingPerInstance;                                              // 0x05E8 (size: 0x1)
    int32 ReparamStepsPerSegment;                                                     // 0x05EC (size: 0x4)
    float Duration;                                                                   // 0x05F0 (size: 0x4)
    bool bStationaryEndpoints;                                                        // 0x05F4 (size: 0x1)
    bool bSplineHasBeenEdited;                                                        // 0x05F5 (size: 0x1)
    bool bModifiedByConstructionScript;                                               // 0x05F6 (size: 0x1)
    bool bInputSplinePointsToConstructionScript;                                      // 0x05F7 (size: 0x1)
    bool bDrawDebug;                                                                  // 0x05F8 (size: 0x1)
    bool bClosedLoop;                                                                 // 0x05F9 (size: 0x1)
    bool bLoopPositionOverride;                                                       // 0x05FA (size: 0x1)
    float LoopPosition;                                                               // 0x05FC (size: 0x4)
    FVector DefaultUpVector;                                                          // 0x0600 (size: 0x18)

    void UpdateSpline();
    void SetWorldLocationAtSplinePoint(int32 PointIndex, const FVector& InLocation);
    void SetUpVectorAtSplinePoint(int32 PointIndex, const FVector& InUpVector, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void SetUnselectedSplineSegmentColor(const FLinearColor& SegmentColor);
    void SetTangentsAtSplinePoint(int32 PointIndex, const FVector& InArriveTangent, const FVector& InLeaveTangent, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void SetTangentColor(const FLinearColor& TangentColor);
    void SetTangentAtSplinePoint(int32 PointIndex, const FVector& InTangent, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void SetSplineWorldPoints(const TArray<FVector>& Points);
    void SetSplinePointType(int32 PointIndex, TEnumAsByte<ESplinePointType::Type> Type, bool bUpdateSpline);
    void SetSplinePoints(const TArray<FVector>& Points, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void SetSplineLocalPoints(const TArray<FVector>& Points);
    void SetSelectedSplineSegmentColor(const FLinearColor& SegmentColor);
    void SetScaleAtSplinePoint(int32 PointIndex, const FVector& InScaleVector, bool bUpdateSpline);
    void SetRotationAtSplinePoint(int32 PointIndex, const FRotator& InRotation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void SetLocationAtSplinePoint(int32 PointIndex, const FVector& InLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void SetDrawDebug(bool bShow);
    void SetDefaultUpVector(const FVector& UpVector, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    void SetClosedLoopAtPosition(bool bInClosedLoop, float Key, bool bUpdateSpline);
    void SetClosedLoop(bool bInClosedLoop, bool bUpdateSpline);
    void RemoveSplinePoint(int32 Index, bool bUpdateSpline);
    bool IsClosedLoop();
    FVector GetWorldTangentAtDistanceAlongSpline(float Distance);
    FRotator GetWorldRotationAtTime(float Time, bool bUseConstantVelocity);
    FRotator GetWorldRotationAtDistanceAlongSpline(float Distance);
    FVector GetWorldLocationAtTime(float Time, bool bUseConstantVelocity);
    FVector GetWorldLocationAtSplinePoint(int32 PointIndex);
    FVector GetWorldLocationAtDistanceAlongSpline(float Distance);
    FVector GetWorldDirectionAtTime(float Time, bool bUseConstantVelocity);
    FVector GetWorldDirectionAtDistanceAlongSpline(float Distance);
    FVector GetVectorPropertyAtSplinePoint(int32 Index, FName PropertyName);
    FVector GetVectorPropertyAtSplineInputKey(float InKey, FName PropertyName);
    FVector GetUpVectorAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    FVector GetUpVectorAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetUpVectorAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetUpVectorAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FTransform GetTransformAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity, bool bUseScale);
    FTransform GetTransformAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseScale);
    FTransform GetTransformAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseScale);
    FTransform GetTransformAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseScale);
    float GetTimeAtDistanceAlongSpline(float Distance);
    FVector GetTangentAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    FVector GetTangentAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetTangentAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetTangentAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    TEnumAsByte<ESplinePointType::Type> GetSplinePointType(int32 PointIndex);
    FSplinePoint GetSplinePointAt(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    float GetSplineLength();
    FVector GetScaleAtTime(float Time, bool bUseConstantVelocity);
    FVector GetScaleAtSplinePoint(int32 PointIndex);
    FVector GetScaleAtSplineInputKey(float InKey);
    FVector GetScaleAtDistanceAlongSpline(float Distance);
    FRotator GetRotationAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    FRotator GetRotationAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FRotator GetRotationAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FRotator GetRotationAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    float GetRollAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    float GetRollAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    float GetRollAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    float GetRollAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetRightVectorAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    FVector GetRightVectorAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetRightVectorAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetRightVectorAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    int32 GetNumberOfSplineSegments();
    int32 GetNumberOfSplinePoints();
    FVector GetLocationAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    FVector GetLocationAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetLocationAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetLocationAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    void GetLocationAndTangentAtSplinePoint(int32 PointIndex, FVector& Location, FVector& Tangent, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    void GetLocalLocationAndTangentAtSplinePoint(int32 PointIndex, FVector& LocalLocation, FVector& LocalTangent);
    FVector GetLeaveTangentAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    float GetInputKeyValueAtSplinePoint(int32 PointIndex);
    float GetInputKeyValueAtDistanceAlongSpline(float Distance);
    float GetInputKeyAtDistanceAlongSpline(float Distance);
    float GetFloatPropertyAtSplinePoint(int32 Index, FName PropertyName);
    float GetFloatPropertyAtSplineInputKey(float InKey, FName PropertyName);
    float GetDistanceAlongSplineAtSplinePoint(int32 PointIndex);
    float GetDistanceAlongSplineAtSplineInputKey(float InKey);
    float GetDistanceAlongSplineAtLocation(const FVector& InLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetDirectionAtTime(float Time, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseConstantVelocity);
    FVector GetDirectionAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetDirectionAtSplineInputKey(float InKey, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetDirectionAtDistanceAlongSpline(float Distance, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetDefaultUpVector(TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector GetArriveTangentAtSplinePoint(int32 PointIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector FindUpVectorClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FTransform FindTransformClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUseScale);
    FVector FindTangentClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector FindScaleClosestToWorldLocation(const FVector& WorldLocation);
    FRotator FindRotationClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    float FindRollClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector FindRightVectorClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    FVector FindLocationClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    float FindInputKeyClosestToWorldLocation(const FVector& WorldLocation);
    FVector FindDirectionClosestToWorldLocation(const FVector& WorldLocation, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace);
    bool DivideSplineIntoPolylineRecursiveWithDistances(float StartDistanceAlongSpline, float EndDistanceAlongSpline, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, const float MaxSquareDistanceFromSpline, TArray<FVector>& OutPoints, TArray<double>& OutDistancesAlongSpline);
    bool DivideSplineIntoPolylineRecursive(float StartDistanceAlongSpline, float EndDistanceAlongSpline, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, const float MaxSquareDistanceFromSpline, TArray<FVector>& OutPoints);
    bool ConvertSplineToPolyLineWithDistances(TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, const float MaxSquareDistanceFromSpline, TArray<FVector>& OutPoints, TArray<double>& OutDistancesAlongSpline);
    bool ConvertSplineToPolyline_InTimeRange(TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, const float MaxSquareDistanceFromSpline, float StartTimeAlongSpline, float EndTimeAlongSpline, bool bUseConstantVelocity, TArray<FVector>& OutPoints, TArray<double>& OutDistancesAlongSpline, bool bAllowWrappingIfClosed);
    bool ConvertSplineToPolyline_InDistanceRange(TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, const float MaxSquareDistanceFromSpline, float StartDistAlongSpline, float EndDistAlongSpline, TArray<FVector>& OutPoints, TArray<double>& OutDistancesAlongSpline, bool bAllowWrappingIfClosed);
    bool ConvertSplineToPolyLine(TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, const float MaxSquareDistanceFromSpline, TArray<FVector>& OutPoints);
    bool ConvertSplineSegmentToPolyLine(int32 SplinePointStartIndex, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, const float MaxSquareDistanceFromSpline, TArray<FVector>& OutPoints);
    void ClearSplinePoints(bool bUpdateSpline);
    void AddSplineWorldPoint(const FVector& Position);
    void AddSplinePointAtIndex(const FVector& Position, int32 Index, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void AddSplinePoint(const FVector& Position, TEnumAsByte<ESplineCoordinateSpace::Type> CoordinateSpace, bool bUpdateSpline);
    void AddSplineLocalPoint(const FVector& Position);
    void AddPoints(const TArray<FSplinePoint>& Points, bool bUpdateSpline);
    void AddPoint(const FSplinePoint& Point, bool bUpdateSpline);
}; // Size: 0x620

class USplineMeshComponent : public UStaticMeshComponent
{
    FSplineMeshParams SplineParams;                                                   // 0x05E0 (size: 0xB8)
    FVector SplineUpDir;                                                              // 0x0698 (size: 0x18)
    float SplineBoundaryMin;                                                          // 0x06B0 (size: 0x4)
    FGuid CachedMeshBodySetupGuid;                                                    // 0x06B4 (size: 0x10)
    class UBodySetup* BodySetup;                                                      // 0x0700 (size: 0x8)
    float SplineBoundaryMax;                                                          // 0x0708 (size: 0x4)
    uint8 bAllowSplineEditingPerInstance;                                             // 0x070C (size: 0x1)
    uint8 bSmoothInterpRollScale;                                                     // 0x070C (size: 0x1)
    uint8 bMeshDirty;                                                                 // 0x070C (size: 0x1)
    TEnumAsByte<ESplineMeshAxis::Type> ForwardAxis;                                   // 0x070D (size: 0x1)
    float VirtualTextureMainPassMaxDrawDistance;                                      // 0x0710 (size: 0x4)
    uint8 bNeverNeedsCookedCollisionData;                                             // 0x0714 (size: 0x1)

    void UpdateMesh();
    void SetStartTangent(FVector StartTangent, bool bUpdateMesh);
    void SetStartScale(FVector2D StartScale, bool bUpdateMesh);
    void SetStartRollDegrees(float StartRollDegrees, bool bUpdateMesh);
    void SetStartRoll(float StartRoll, bool bUpdateMesh);
    void SetStartPosition(FVector StartPos, bool bUpdateMesh);
    void SetStartOffset(FVector2D StartOffset, bool bUpdateMesh);
    void SetStartAndEnd(FVector StartPos, FVector StartTangent, FVector EndPos, FVector EndTangent, bool bUpdateMesh);
    void SetSplineUpDir(const FVector& InSplineUpDir, bool bUpdateMesh);
    void SetForwardAxis(TEnumAsByte<ESplineMeshAxis::Type> InForwardAxis, bool bUpdateMesh);
    void SetEndTangent(FVector EndTangent, bool bUpdateMesh);
    void SetEndScale(FVector2D EndScale, bool bUpdateMesh);
    void SetEndRollDegrees(float EndRollDegrees, bool bUpdateMesh);
    void SetEndRoll(float EndRoll, bool bUpdateMesh);
    void SetEndPosition(FVector EndPos, bool bUpdateMesh);
    void SetEndOffset(FVector2D EndOffset, bool bUpdateMesh);
    void SetBoundaryMin(float InBoundaryMin, bool bUpdateMesh);
    void SetBoundaryMax(float InBoundaryMax, bool bUpdateMesh);
    FVector GetStartTangent();
    FVector2D GetStartScale();
    float GetStartRoll();
    FVector GetStartPosition();
    FVector2D GetStartOffset();
    FVector GetSplineUpDir();
    TEnumAsByte<ESplineMeshAxis::Type> GetForwardAxis();
    FVector GetEndTangent();
    FVector2D GetEndScale();
    float GetEndRoll();
    FVector GetEndPosition();
    FVector2D GetEndOffset();
    float GetBoundaryMin();
    float GetBoundaryMax();
}; // Size: 0x720

class USplineMetadata : public UObject
{
}; // Size: 0x28

class USpotLightComponent : public UPointLightComponent
{
    float InnerConeAngle;                                                             // 0x03A8 (size: 0x4)
    float OuterConeAngle;                                                             // 0x03AC (size: 0x4)

    void SetOuterConeAngle(float NewOuterConeAngle);
    void SetInnerConeAngle(float NewInnerConeAngle);
}; // Size: 0x3B0

class USpringArmComponent : public USceneComponent
{
    float TargetArmLength;                                                            // 0x0230 (size: 0x4)
    FVector SocketOffset;                                                             // 0x0238 (size: 0x18)
    FVector TargetOffset;                                                             // 0x0250 (size: 0x18)
    float ProbeSize;                                                                  // 0x0268 (size: 0x4)
    TEnumAsByte<ECollisionChannel> ProbeChannel;                                      // 0x026C (size: 0x1)
    uint8 bDoCollisionTest;                                                           // 0x0270 (size: 0x1)
    uint8 bUsePawnControlRotation;                                                    // 0x0270 (size: 0x1)
    uint8 bInheritPitch;                                                              // 0x0270 (size: 0x1)
    uint8 bInheritYaw;                                                                // 0x0270 (size: 0x1)
    uint8 bInheritRoll;                                                               // 0x0270 (size: 0x1)
    uint8 bEnableCameraLag;                                                           // 0x0270 (size: 0x1)
    uint8 bEnableCameraRotationLag;                                                   // 0x0270 (size: 0x1)
    uint8 bUseCameraLagSubstepping;                                                   // 0x0270 (size: 0x1)
    uint8 bDrawDebugLagMarkers;                                                       // 0x0271 (size: 0x1)
    float CameraLagSpeed;                                                             // 0x0274 (size: 0x4)
    float CameraRotationLagSpeed;                                                     // 0x0278 (size: 0x4)
    float CameraLagMaxTimeStep;                                                       // 0x027C (size: 0x4)
    float CameraLagMaxDistance;                                                       // 0x0280 (size: 0x4)
    uint8 bClampToMaxPhysicsDeltaTime;                                                // 0x0284 (size: 0x1)

    bool IsCollisionFixApplied();
    FVector GetUnfixedCameraPosition();
    FRotator GetTargetRotation();
}; // Size: 0x330

class UStaticMesh : public UStreamableRenderAsset
{
    FPerQualityLevelInt MinQualityLevelLOD;                                           // 0x00E8 (size: 0x68)
    FPerPlatformInt MinLOD;                                                           // 0x0150 (size: 0x4)
    TArray<FStaticMaterial> StaticMaterials;                                          // 0x0158 (size: 0x10)
    float LightmapUVDensity;                                                          // 0x0168 (size: 0x4)
    int32 LightMapResolution;                                                         // 0x016C (size: 0x4)
    int32 LightMapCoordinateIndex;                                                    // 0x0170 (size: 0x4)
    float DistanceFieldSelfShadowBias;                                                // 0x0174 (size: 0x4)
    class UBodySetup* BodySetup;                                                      // 0x0178 (size: 0x8)
    int32 LODForCollision;                                                            // 0x0180 (size: 0x4)
    uint8 bGenerateMeshDistanceField;                                                 // 0x0184 (size: 0x1)
    uint8 bStripComplexCollisionForConsole;                                           // 0x0184 (size: 0x1)
    uint8 bHasNavigationData;                                                         // 0x0184 (size: 0x1)
    uint8 bSupportUniformlyDistributedSampling;                                       // 0x0184 (size: 0x1)
    uint8 bSupportPhysicalMaterialMasks;                                              // 0x0184 (size: 0x1)
    uint8 bSupportRayTracing;                                                         // 0x0184 (size: 0x1)
    uint8 bDoFastBuild;                                                               // 0x0184 (size: 0x1)
    uint8 bIsBuiltAtRuntime;                                                          // 0x0184 (size: 0x1)
    uint8 bAllowCPUAccess;                                                            // 0x0185 (size: 0x1)
    uint8 bSupportGpuUniformlyDistributedSampling;                                    // 0x0185 (size: 0x1)
    TArray<class UStaticMeshSocket*> Sockets;                                         // 0x01A0 (size: 0x10)
    FVector PositiveBoundsExtension;                                                  // 0x01C0 (size: 0x18)
    FVector NegativeBoundsExtension;                                                  // 0x01D8 (size: 0x18)
    FBoxSphereBounds ExtendedBounds;                                                  // 0x01F0 (size: 0x38)
    int32 ElementToIgnoreForTexFactor;                                                // 0x0228 (size: 0x4)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0230 (size: 0x10)
    class UNavCollisionBase* NavCollision;                                            // 0x0240 (size: 0x8)

    void SetStaticMaterials(const TArray<FStaticMaterial>& InStaticMaterials);
    void SetMinLODForQualityLevels(const TMap<EPerQualityLevels, int32>& QualityLevelMinimumLODs, int32 Default);
    void SetMinimumLODForPlatforms(const TMap<FName, int32>& PlatformMinimumLODs);
    void SetMinimumLODForPlatform(const FName& PlatformName, int32 InMinLOD);
    void RemoveSocket(class UStaticMeshSocket* Socket);
    class UStaticMeshDescription* GetStaticMeshDescription(int32 LODIndex);
    TArray<FStaticMaterial> GetStaticMaterials();
    TArray<class UStaticMeshSocket*> GetSocketsByTag(FString InSocketTag);
    int32 GetNumTriangles(int32 LODIndex);
    int32 GetNumSections(int32 InLOD);
    int32 GetNumLODs();
    void GetMinLODForQualityLevels(TMap<EPerQualityLevels, int32>& QualityLevelMinimumLODs, int32& Default);
    void GetMinimumLODForQualityLevels(TMap<FName, int32>& QualityLevelMinimumLODs);
    int32 GetMinimumLODForQualityLevel(const FName& QualityLevel);
    void GetMinimumLODForPlatforms(TMap<FName, int32>& PlatformMinimumLODs);
    int32 GetMinimumLODForPlatform(const FName& PlatformName);
    int32 GetMaterialIndex(FName MaterialSlotName);
    class UMaterialInterface* GetMaterial(int32 MaterialIndex);
    FBoxSphereBounds GetBounds();
    FBox GetBoundingBox();
    class UStaticMeshSocket* FindSocket(FName InSocketName);
    class UStaticMeshDescription* CreateStaticMeshDescription(class UObject* Outer);
    void BuildFromStaticMeshDescriptions(const TArray<class UStaticMeshDescription*>& StaticMeshDescriptions, bool bBuildSimpleCollision, bool bFastBuild);
    void AddSocket(class UStaticMeshSocket* Socket);
    FName AddMaterial(class UMaterialInterface* Material);
}; // Size: 0x248

class UStaticMeshComponent : public UMeshComponent
{
    int32 ForcedLodModel;                                                             // 0x0550 (size: 0x4)
    int32 PreviousLODLevel;                                                           // 0x0554 (size: 0x4)
    int32 MinLOD;                                                                     // 0x0558 (size: 0x4)
    int32 SubDivisionStepSize;                                                        // 0x055C (size: 0x4)
    class UStaticMesh* StaticMesh;                                                    // 0x0560 (size: 0x8)
    FColor WireframeColorOverride;                                                    // 0x0568 (size: 0x4)
    uint8 bForceNaniteForMasked;                                                      // 0x056C (size: 0x1)
    uint8 bDisallowNanite;                                                            // 0x056C (size: 0x1)
    uint8 bForceDisableNanite;                                                        // 0x056C (size: 0x1)
    uint8 bEvaluateWorldPositionOffset;                                               // 0x056C (size: 0x1)
    uint8 bWorldPositionOffsetWritesVelocity;                                         // 0x056C (size: 0x1)
    uint8 bEvaluateWorldPositionOffsetInRayTracing;                                   // 0x056C (size: 0x1)
    int32 WorldPositionOffsetDisableDistance;                                         // 0x0570 (size: 0x4)
    uint8 bOverrideWireframeColor;                                                    // 0x0574 (size: 0x1)
    uint8 bOverrideMinLOD;                                                            // 0x0574 (size: 0x1)
    uint8 bOverrideNavigationExport;                                                  // 0x0574 (size: 0x1)
    uint8 bForceNavigationObstacle;                                                   // 0x0574 (size: 0x1)
    uint8 bDisallowMeshPaintPerInstance;                                              // 0x0574 (size: 0x1)
    uint8 bIgnoreInstanceForTextureStreaming;                                         // 0x0574 (size: 0x1)
    uint8 bOverrideLightMapRes;                                                       // 0x0575 (size: 0x1)
    uint8 bCastDistanceFieldIndirectShadow;                                           // 0x0575 (size: 0x1)
    uint8 bOverrideDistanceFieldSelfShadowBias;                                       // 0x0575 (size: 0x1)
    uint8 bUseSubDivisions;                                                           // 0x0575 (size: 0x1)
    uint8 bUseDefaultCollision;                                                       // 0x0575 (size: 0x1)
    uint8 bSortTriangles;                                                             // 0x0575 (size: 0x1)
    uint8 bReverseCulling;                                                            // 0x0575 (size: 0x1)
    int32 OverriddenLightMapRes;                                                      // 0x0578 (size: 0x4)
    float DistanceFieldIndirectShadowMinVisibility;                                   // 0x057C (size: 0x4)
    float DistanceFieldSelfShadowBias;                                                // 0x0580 (size: 0x4)
    float StreamingDistanceMultiplier;                                                // 0x0584 (size: 0x4)
    TArray<FStaticMeshComponentLODInfo> LODData;                                      // 0x0588 (size: 0x10)
    TArray<FStreamingTextureBuildInfo> StreamingTextureData;                          // 0x0598 (size: 0x10)
    FLightmassPrimitiveSettings LightmassSettings;                                    // 0x05A8 (size: 0x18)

    void UpdateInitialEvaluateWorldPositionOffset();
    void SetWorldPositionOffsetDisableDistance(int32 NewValue);
    bool SetStaticMesh(class UStaticMesh* NewMesh);
    void SetReverseCulling(bool ReverseCulling);
    void SetForcedLodModel(int32 NewForcedLodModel);
    void SetForceDisableNanite(bool bInForceDisableNanite);
    void SetEvaluateWorldPositionOffsetInRayTracing(bool NewValue);
    void SetEvaluateWorldPositionOffset(bool NewValue);
    void SetDistanceFieldSelfShadowBias(float NewValue);
    void OnRep_StaticMesh(class UStaticMesh* OldStaticMesh);
    void GetLocalBounds(FVector& Min, FVector& Max);
    bool GetInitialEvaluateWorldPositionOffset();
}; // Size: 0x5E0

class UStaticMeshDescriptionBulkData : public UMeshDescriptionBaseBulkData
{
}; // Size: 0x28

class UStaticMeshSocket : public UObject
{
    FName SocketName;                                                                 // 0x0028 (size: 0x8)
    FVector RelativeLocation;                                                         // 0x0030 (size: 0x18)
    FRotator RelativeRotation;                                                        // 0x0048 (size: 0x18)
    FVector RelativeScale;                                                            // 0x0060 (size: 0x18)
    FString Tag;                                                                      // 0x0078 (size: 0x10)

}; // Size: 0x88

class UStaticSparseVolumeTexture : public UStreamableSparseVolumeTexture
{
}; // Size: 0xB0

class UStereoLayerComponent : public USceneComponent
{
    uint8 bLiveTexture;                                                               // 0x0230 (size: 0x1)
    uint8 bSupportsDepth;                                                             // 0x0230 (size: 0x1)
    uint8 bNoAlphaChannel;                                                            // 0x0230 (size: 0x1)
    class UTexture* Texture;                                                          // 0x0238 (size: 0x8)
    class UTexture* LeftTexture;                                                      // 0x0240 (size: 0x8)
    uint8 bQuadPreserveTextureRatio;                                                  // 0x0248 (size: 0x1)
    TArray<FName> AdditionalFlags;                                                    // 0x0250 (size: 0x10)
    FVector2D QuadSize;                                                               // 0x0260 (size: 0x10)
    FBox2D UVRect;                                                                    // 0x0270 (size: 0x28)
    float CylinderRadius;                                                             // 0x0298 (size: 0x4)
    float CylinderOverlayArc;                                                         // 0x029C (size: 0x4)
    int32 CylinderHeight;                                                             // 0x02A0 (size: 0x4)
    FEquirectProps EquirectProps;                                                     // 0x02A8 (size: 0x98)
    TEnumAsByte<EStereoLayerType> StereoLayerType;                                    // 0x0340 (size: 0x1)
    TEnumAsByte<EStereoLayerShape> StereoLayerShape;                                  // 0x0341 (size: 0x1)
    class UStereoLayerShape* Shape;                                                   // 0x0348 (size: 0x8)
    int32 Priority;                                                                   // 0x0350 (size: 0x4)

    void SetUVRect(FBox2D InUVRect);
    void SetTexture(class UTexture* InTexture);
    void SetQuadSize(FVector2D InQuadSize);
    void SetPriority(int32 InPriority);
    void SetLeftTexture(class UTexture* InTexture);
    void SetEquirectProps(FEquirectProps InEquirectProps);
    void MarkTextureForUpdate();
    FBox2D GetUVRect();
    class UTexture* GetTexture();
    FVector2D GetQuadSize();
    int32 GetPriority();
    class UTexture* GetLeftTexture();
}; // Size: 0x3D0

class UStereoLayerFunctionLibrary : public UBlueprintFunctionLibrary
{

    void ShowSplashScreen();
    void SetSplashScreen(class UTexture* Texture, FVector2D Scale, FVector Offset, bool bShowLoadingMovie, bool bShowOnSet);
    void HideSplashScreen();
    void EnableAutoLoadingSplashScreen(bool InAutoShowEnabled);
}; // Size: 0x28

class UStereoLayerShape : public UObject
{
}; // Size: 0x28

class UStereoLayerShapeCubemap : public UStereoLayerShape
{
}; // Size: 0x28

class UStereoLayerShapeCylinder : public UStereoLayerShape
{
    float Radius;                                                                     // 0x0028 (size: 0x4)
    float OverlayArc;                                                                 // 0x002C (size: 0x4)
    int32 Height;                                                                     // 0x0030 (size: 0x4)

    void SetRadius(float InRadius);
    void SetOverlayArc(float InOverlayArc);
    void SetHeight(int32 InHeight);
}; // Size: 0x38

class UStereoLayerShapeEquirect : public UStereoLayerShape
{
    FBox2D LeftUVRect;                                                                // 0x0028 (size: 0x28)
    FBox2D RightUVRect;                                                               // 0x0050 (size: 0x28)
    FVector2D LeftScale;                                                              // 0x0078 (size: 0x10)
    FVector2D RightScale;                                                             // 0x0088 (size: 0x10)
    FVector2D LeftBias;                                                               // 0x0098 (size: 0x10)
    FVector2D RightBias;                                                              // 0x00A8 (size: 0x10)
    float Radius;                                                                     // 0x00B8 (size: 0x4)

    void SetEquirectProps(FEquirectProps InScaleBiases);
}; // Size: 0xC0

class UStereoLayerShapeQuad : public UStereoLayerShape
{
}; // Size: 0x28

class UStreamableRenderAsset : public UObject
{
    double ForceMipLevelsToBeResidentTimestamp;                                       // 0x0040 (size: 0x8)
    int32 NumCinematicMipLevels;                                                      // 0x0048 (size: 0x4)
    FPerQualityLevelInt NoRefStreamingLODBias;                                        // 0x0050 (size: 0x68)
    int32 StreamingIndex;                                                             // 0x00B8 (size: 0x4)
    uint8 NeverStream;                                                                // 0x00BC (size: 0x1)
    uint8 bGlobalForceMipLevelsToBeResident;                                          // 0x00BC (size: 0x1)
    uint8 bHasStreamingUpdatePending;                                                 // 0x00BC (size: 0x1)
    uint8 bForceMiplevelsToBeResident;                                                // 0x00BC (size: 0x1)
    uint8 bIgnoreStreamingMipBias;                                                    // 0x00BC (size: 0x1)
    uint8 bUseCinematicMipLevels;                                                     // 0x00BC (size: 0x1)

    void SetForceMipLevelsToBeResident(float Seconds, int32 CinematicLODGroupMask);
}; // Size: 0xC8

class UStreamableSparseVolumeTexture : public USparseVolumeTexture
{
    FIntVector VolumeResolution;                                                      // 0x0030 (size: 0xC)
    int32 NumMipLevels;                                                               // 0x003C (size: 0x4)
    int32 NumFrames;                                                                  // 0x0040 (size: 0x4)
    TEnumAsByte<EPixelFormat> FormatA;                                                // 0x0044 (size: 0x1)
    TEnumAsByte<EPixelFormat> FormatB;                                                // 0x0045 (size: 0x1)
    FVector4f FallbackValueA;                                                         // 0x0050 (size: 0x10)
    FVector4f FallbackValueB;                                                         // 0x0060 (size: 0x10)
    TEnumAsByte<TextureAddress> AddressX;                                             // 0x0070 (size: 0x1)
    TEnumAsByte<TextureAddress> AddressY;                                             // 0x0071 (size: 0x1)
    TEnumAsByte<TextureAddress> AddressZ;                                             // 0x0072 (size: 0x1)
    bool bLocalDDCOnly;                                                               // 0x0073 (size: 0x1)
    float StreamingPoolSizeFactor;                                                    // 0x0074 (size: 0x4)
    int32 NumberOfPrefetchFrames;                                                     // 0x0078 (size: 0x4)
    float PrefetchPercentageStepSize;                                                 // 0x007C (size: 0x4)
    float PrefetchPercentageBias;                                                     // 0x0080 (size: 0x4)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0088 (size: 0x10)
    TArray<class USparseVolumeTextureFrame*> Frames;                                  // 0x0098 (size: 0x10)

}; // Size: 0xB0

class UStreamingSettings : public UDeveloperSettings
{
    uint8 AsyncLoadingThreadEnabled;                                                  // 0x0038 (size: 0x1)
    uint8 WarnIfTimeLimitExceeded;                                                    // 0x0038 (size: 0x1)
    float TimeLimitExceededMultiplier;                                                // 0x003C (size: 0x4)
    float TimeLimitExceededMinTime;                                                   // 0x0040 (size: 0x4)
    int32 MinBulkDataSizeForAsyncLoading;                                             // 0x0044 (size: 0x4)
    uint8 UseBackgroundLevelStreaming;                                                // 0x0048 (size: 0x1)
    uint8 AsyncLoadingUseFullTimeLimit;                                               // 0x0048 (size: 0x1)
    float AsyncLoadingTimeLimit;                                                      // 0x004C (size: 0x4)
    float PriorityAsyncLoadingExtraTime;                                              // 0x0050 (size: 0x4)
    float LevelStreamingActorsUpdateTimeLimit;                                        // 0x0054 (size: 0x4)
    float PriorityLevelStreamingActorsUpdateExtraTime;                                // 0x0058 (size: 0x4)
    int32 LevelStreamingComponentsRegistrationGranularity;                            // 0x005C (size: 0x4)
    int32 LevelStreamingAddPrimitiveGranularity;                                      // 0x0060 (size: 0x4)
    float LevelStreamingUnregisterComponentsTimeLimit;                                // 0x0064 (size: 0x4)
    int32 LevelStreamingComponentsUnregistrationGranularity;                          // 0x0068 (size: 0x4)
    uint8 FlushStreamingOnExit;                                                       // 0x006C (size: 0x1)
    uint8 EventDrivenLoaderEnabled;                                                   // 0x006C (size: 0x1)

}; // Size: 0x70

class UStringTable : public UObject
{
}; // Size: 0x40

class USubUVAnimation : public UObject
{
    class UTexture2D* SubUVTexture;                                                   // 0x0028 (size: 0x8)
    int32 SubImages_Horizontal;                                                       // 0x0030 (size: 0x4)
    int32 SubImages_Vertical;                                                         // 0x0034 (size: 0x4)
    TEnumAsByte<ESubUVBoundingVertexCount> BoundingMode;                              // 0x0038 (size: 0x1)
    TEnumAsByte<EOpacitySourceMode> OpacitySourceMode;                                // 0x0039 (size: 0x1)
    float AlphaThreshold;                                                             // 0x003C (size: 0x4)

}; // Size: 0x60

class USubsurfaceProfile : public UObject
{
    FSubsurfaceProfileStruct Settings;                                                // 0x0028 (size: 0x9C)

}; // Size: 0xC8

class USubsystem : public UObject
{
}; // Size: 0x30

class USubsystemBlueprintLibrary : public UBlueprintFunctionLibrary
{

    class UWorldSubsystem* GetWorldSubsystem(class UObject* ContextObject, TSubclassOf<class UWorldSubsystem> Class);
    class ULocalPlayerSubsystem* GetLocalPlayerSubSystemFromPlayerController(class APlayerController* PlayerController, TSubclassOf<class ULocalPlayerSubsystem> Class);
    class ULocalPlayerSubsystem* GetLocalPlayerSubsystem(class UObject* ContextObject, TSubclassOf<class ULocalPlayerSubsystem> Class);
    class UGameInstanceSubsystem* GetGameInstanceSubsystem(class UObject* ContextObject, TSubclassOf<class UGameInstanceSubsystem> Class);
    class UEngineSubsystem* GetEngineSubsystem(TSubclassOf<class UEngineSubsystem> Class);
    class UAudioEngineSubsystem* GetAudioEngineSubsystem(class UObject* ContextObject, TSubclassOf<class UAudioEngineSubsystem> Class);
}; // Size: 0x28

class USystemTimeTimecodeProvider : public UTimecodeProvider
{
    FFrameRate FrameRate;                                                             // 0x0030 (size: 0x8)
    bool bGenerateFullFrame;                                                          // 0x0038 (size: 0x1)
    bool bUseHighPerformanceClock;                                                    // 0x0039 (size: 0x1)

}; // Size: 0x40

class UTextPropertyTestObject : public UObject
{
    FText DefaultedText;                                                              // 0x0028 (size: 0x10)
    FText UndefaultedText;                                                            // 0x0038 (size: 0x10)
    FText TransientText;                                                              // 0x0048 (size: 0x10)

}; // Size: 0x58

class UTextRenderComponent : public UPrimitiveComponent
{
    FText Text;                                                                       // 0x0518 (size: 0x10)
    class UMaterialInterface* TextMaterial;                                           // 0x0528 (size: 0x8)
    class UFont* Font;                                                                // 0x0530 (size: 0x8)
    TEnumAsByte<EHorizTextAligment> HorizontalAlignment;                              // 0x0538 (size: 0x1)
    TEnumAsByte<EVerticalTextAligment> VerticalAlignment;                             // 0x0539 (size: 0x1)
    FColor TextRenderColor;                                                           // 0x053C (size: 0x4)
    float XScale;                                                                     // 0x0540 (size: 0x4)
    float YScale;                                                                     // 0x0544 (size: 0x4)
    float WorldSize;                                                                  // 0x0548 (size: 0x4)
    float InvDefaultSize;                                                             // 0x054C (size: 0x4)
    float HorizSpacingAdjust;                                                         // 0x0550 (size: 0x4)
    float VertSpacingAdjust;                                                          // 0x0554 (size: 0x4)
    uint8 bAlwaysRenderAsText;                                                        // 0x0558 (size: 0x1)

    void SetYScale(float Value);
    void SetXScale(float Value);
    void SetWorldSize(float Value);
    void SetVertSpacingAdjust(float Value);
    void SetVerticalAlignment(TEnumAsByte<EVerticalTextAligment> Value);
    void SetTextRenderColor(FColor Value);
    void SetTextMaterial(class UMaterialInterface* Material);
    void SetText(const FText& Value);
    void SetHorizSpacingAdjust(float Value);
    void SetHorizontalAlignment(TEnumAsByte<EHorizTextAligment> Value);
    void SetFont(class UFont* Value);
    void K2_SetText(const FText& Value);
    FVector GetTextWorldSize();
    FVector GetTextLocalSize();
}; // Size: 0x560

class UTexture : public UStreamableRenderAsset
{
    FGuid LightingGuid;                                                               // 0x00D8 (size: 0x10)
    int32 LevelIndex;                                                                 // 0x00E8 (size: 0x4)
    int32 LODBias;                                                                    // 0x00EC (size: 0x4)
    TEnumAsByte<TextureCompressionSettings> CompressionSettings;                      // 0x00F0 (size: 0x1)
    TEnumAsByte<TextureFilter> Filter;                                                // 0x00F1 (size: 0x1)
    ETextureMipLoadOptions MipLoadOptions;                                            // 0x00F2 (size: 0x1)
    TEnumAsByte<TextureCookPlatformTilingSettings> CookPlatformTilingSettings;        // 0x00F3 (size: 0x1)
    bool bOodlePreserveExtremes;                                                      // 0x00F4 (size: 0x1)
    TEnumAsByte<TextureGroup> LODGroup;                                               // 0x00F5 (size: 0x1)
    FPerPlatformFloat Downscale;                                                      // 0x00F8 (size: 0x4)
    ETextureDownscaleOptions DownscaleOptions;                                        // 0x00FC (size: 0x1)
    ETextureAvailability Availability;                                                // 0x00FD (size: 0x1)
    uint8 SRGB;                                                                       // 0x00FE (size: 0x1)
    uint8 bNoTiling;                                                                  // 0x00FE (size: 0x1)
    uint8 VirtualTextureStreaming;                                                    // 0x00FE (size: 0x1)
    uint8 CompressionYCoCg;                                                           // 0x00FE (size: 0x1)
    uint8 bNotOfflineProcessed;                                                       // 0x00FE (size: 0x1)
    uint8 bAsyncResourceReleaseHasBeenStarted;                                        // 0x00FE (size: 0x1)
    TArray<class UAssetUserData*> AssetUserData;                                      // 0x0100 (size: 0x10)

    bool ComputeTextureSourceChannelMinMax(FLinearColor& OutColorMin, FLinearColor& OutColorMax);
    void Blueprint_GetTextureSourceDiskAndMemorySize(int64& OutDiskSize, int64& OutMemorySize);
    int64 Blueprint_GetMemorySize();
    bool AreDownscalePropertiesEditable();
}; // Size: 0x130

class UTexture2D : public UTexture
{
    int32 FirstResourceMemMip;                                                        // 0x0130 (size: 0x4)
    uint8 bTemporarilyDisableStreaming;                                               // 0x0134 (size: 0x1)
    TEnumAsByte<TextureAddress> AddressX;                                             // 0x0135 (size: 0x1)
    TEnumAsByte<TextureAddress> AddressY;                                             // 0x0136 (size: 0x1)
    FIntPoint ImportedSize;                                                           // 0x0138 (size: 0x8)

    int32 Blueprint_GetSizeY();
    int32 Blueprint_GetSizeX();
    FSharedImageConstRefBlueprint Blueprint_GetCPUCopy();
}; // Size: 0x150

class UTexture2DArray : public UTexture
{
    TEnumAsByte<TextureAddress> AddressX;                                             // 0x0138 (size: 0x1)
    TEnumAsByte<TextureAddress> AddressY;                                             // 0x0139 (size: 0x1)
    TEnumAsByte<TextureAddress> AddressZ;                                             // 0x013A (size: 0x1)

}; // Size: 0x140

class UTexture2DDynamic : public UTexture
{
    TEnumAsByte<EPixelFormat> Format;                                                 // 0x0138 (size: 0x1)

}; // Size: 0x148

class UTextureAllMipDataProviderFactory : public UTextureMipDataProviderFactory
{
}; // Size: 0x28

class UTextureCube : public UTexture
{
}; // Size: 0x138

class UTextureCubeArray : public UTexture
{
}; // Size: 0x138

class UTextureEncodingProjectSettings : public UDeveloperSettings
{
    uint8 bSharedLinearTextureEncoding;                                               // 0x0038 (size: 0x1)
    uint8 bFinalUsesRDO;                                                              // 0x0038 (size: 0x1)
    int8 FinalRDOLambda;                                                              // 0x003C (size: 0x1)
    ETextureEncodeEffort FinalEffortLevel;                                            // 0x003D (size: 0x1)
    ETextureUniversalTiling FinalUniversalTiling;                                     // 0x003E (size: 0x1)
    uint8 bFastUsesRDO;                                                               // 0x0040 (size: 0x1)
    int8 FastRDOLambda;                                                               // 0x0044 (size: 0x1)
    ETextureEncodeEffort FastEffortLevel;                                             // 0x0045 (size: 0x1)
    ETextureUniversalTiling FastUniversalTiling;                                      // 0x0046 (size: 0x1)
    ETextureEncodeSpeed CookUsesSpeed;                                                // 0x0047 (size: 0x1)
    ETextureEncodeSpeed EditorUsesSpeed;                                              // 0x0048 (size: 0x1)

}; // Size: 0x50

class UTextureEncodingUserSettings : public UDeveloperSettings
{
    ETextureEncodeSpeedOverride ForceEncodeSpeed;                                     // 0x0038 (size: 0x1)

}; // Size: 0x40

class UTextureLODSettings : public UObject
{
    TArray<FTextureLODGroup> TextureLODGroups;                                        // 0x0028 (size: 0x10)

}; // Size: 0x38

class UTextureLightProfile : public UTexture2D
{
    float Brightness;                                                                 // 0x0150 (size: 0x4)
    float TextureMultiplier;                                                          // 0x0154 (size: 0x4)

}; // Size: 0x158

class UTextureMipDataProviderFactory : public UAssetUserData
{
}; // Size: 0x28

class UTextureRenderTarget : public UTexture
{
    float TargetGamma;                                                                // 0x0130 (size: 0x4)

}; // Size: 0x138

class UTextureRenderTarget2D : public UTextureRenderTarget
{
    int32 SizeX;                                                                      // 0x0138 (size: 0x4)
    int32 SizeY;                                                                      // 0x013C (size: 0x4)
    FLinearColor ClearColor;                                                          // 0x0140 (size: 0x10)
    TEnumAsByte<TextureAddress> AddressX;                                             // 0x0150 (size: 0x1)
    TEnumAsByte<TextureAddress> AddressY;                                             // 0x0151 (size: 0x1)
    uint8 bForceLinearGamma;                                                          // 0x0152 (size: 0x1)
    uint8 bHDR;                                                                       // 0x0152 (size: 0x1)
    uint8 bGPUSharedFlag;                                                             // 0x0152 (size: 0x1)
    TEnumAsByte<ETextureRenderTargetFormat> RenderTargetFormat;                       // 0x0153 (size: 0x1)
    uint8 bAutoGenerateMips;                                                          // 0x0154 (size: 0x1)
    TEnumAsByte<TextureFilter> MipsSamplerFilter;                                     // 0x0155 (size: 0x1)
    TEnumAsByte<TextureAddress> MipsAddressU;                                         // 0x0156 (size: 0x1)
    TEnumAsByte<TextureAddress> MipsAddressV;                                         // 0x0157 (size: 0x1)
    TEnumAsByte<EPixelFormat> OverrideFormat;                                         // 0x0158 (size: 0x1)

}; // Size: 0x160

class UTextureRenderTarget2DArray : public UTextureRenderTarget
{
    int32 SizeX;                                                                      // 0x0138 (size: 0x4)
    int32 SizeY;                                                                      // 0x013C (size: 0x4)
    int32 Slices;                                                                     // 0x0140 (size: 0x4)
    FLinearColor ClearColor;                                                          // 0x0144 (size: 0x10)
    TEnumAsByte<EPixelFormat> OverrideFormat;                                         // 0x0154 (size: 0x1)
    uint8 bHDR;                                                                       // 0x0155 (size: 0x1)
    uint8 bForceLinearGamma;                                                          // 0x0155 (size: 0x1)

}; // Size: 0x158

class UTextureRenderTargetCube : public UTextureRenderTarget
{
    int32 SizeX;                                                                      // 0x0138 (size: 0x4)
    FLinearColor ClearColor;                                                          // 0x013C (size: 0x10)
    TEnumAsByte<EPixelFormat> OverrideFormat;                                         // 0x014C (size: 0x1)
    uint8 bHDR;                                                                       // 0x014D (size: 0x1)
    uint8 bForceLinearGamma;                                                          // 0x014D (size: 0x1)

}; // Size: 0x150

class UTextureRenderTargetVolume : public UTextureRenderTarget
{
    int32 SizeX;                                                                      // 0x0138 (size: 0x4)
    int32 SizeY;                                                                      // 0x013C (size: 0x4)
    int32 SizeZ;                                                                      // 0x0140 (size: 0x4)
    FLinearColor ClearColor;                                                          // 0x0144 (size: 0x10)
    TEnumAsByte<EPixelFormat> OverrideFormat;                                         // 0x0154 (size: 0x1)
    uint8 bHDR;                                                                       // 0x0155 (size: 0x1)
    uint8 bForceLinearGamma;                                                          // 0x0155 (size: 0x1)

}; // Size: 0x158

class UThumbnailInfo : public UObject
{
}; // Size: 0x28

class UTickableWorldSubsystem : public UWorldSubsystem
{
}; // Size: 0x40

class UTimecodeProvider : public UObject
{
    float FrameDelay;                                                                 // 0x0028 (size: 0x4)

    FTimecode GetTimecode();
    ETimecodeProviderSynchronizationState GetSynchronizationState();
    FQualifiedFrameTime GetQualifiedFrameTime();
    FFrameRate GetFrameRate();
    FTimecode GetDelayedTimecode();
    FQualifiedFrameTime GetDelayedQualifiedFrameTime();
    bool FetchTimecode(FQualifiedFrameTime& OutFrameTime);
    void FetchAndUpdate();
}; // Size: 0x30

class UTimelineComponent : public UActorComponent
{
    FTimeline TheTimeline;                                                            // 0x00A0 (size: 0x98)
    uint8 bIgnoreTimeDilation;                                                        // 0x0138 (size: 0x1)

    void Stop();
    void SetVectorCurve(class UCurveVector* NewVectorCurve, FName VectorTrackName);
    void SetTimelinePostUpdateFunc(FSetTimelinePostUpdateFuncNewTimelinePostUpdateFunc NewTimelinePostUpdateFunc);
    void SetTimelineLengthMode(TEnumAsByte<ETimelineLengthMode> NewLengthMode);
    void SetTimelineLength(float NewLength);
    void SetTimelineFinishedFunc(FSetTimelineFinishedFuncNewTimelineFinishedFunc NewTimelineFinishedFunc);
    void SetPlayRate(float NewRate);
    void SetPlaybackPosition(float NewPosition, bool bFireEvents, bool bFireUpdate);
    void SetNewTime(float NewTime);
    void SetLooping(bool bNewLooping);
    void SetLinearColorCurve(class UCurveLinearColor* NewLinearColorCurve, FName LinearColorTrackName);
    void SetIgnoreTimeDilation(bool bNewIgnoreTimeDilation);
    void SetFloatCurve(class UCurveFloat* NewFloatCurve, FName FloatTrackName);
    void ReverseFromEnd();
    void Reverse();
    void PlayFromStart();
    void Play();
    void OnRep_Timeline(FTimeline& OldTimeline);
    bool IsReversing();
    bool IsPlaying();
    bool IsLooping();
    float GetTimelineLength();
    float GetScaledTimelineLength();
    float GetPlayRate();
    float GetPlaybackPosition();
    bool GetIgnoreTimeDilation();
    void AddInterpVector(class UCurveVector* VectorCurve, FAddInterpVectorInterpFunc InterpFunc, FName PropertyName, FName TrackName);
    void AddInterpLinearColor(class UCurveLinearColor* LinearColorCurve, FAddInterpLinearColorInterpFunc InterpFunc, FName PropertyName, FName TrackName);
    void AddInterpFloat(class UCurveFloat* FloatCurve, FAddInterpFloatInterpFunc InterpFunc, FName PropertyName, FName TrackName);
    void AddEvent(float Time, FAddEventEventFunc EventFunc);
}; // Size: 0x140

class UTimelineTemplate : public UObject
{
    float TimelineLength;                                                             // 0x0028 (size: 0x4)
    TEnumAsByte<ETimelineLengthMode> LengthMode;                                      // 0x002C (size: 0x1)
    uint8 bAutoPlay;                                                                  // 0x002D (size: 0x1)
    uint8 bLoop;                                                                      // 0x002D (size: 0x1)
    uint8 bReplicated;                                                                // 0x002D (size: 0x1)
    uint8 bIgnoreTimeDilation;                                                        // 0x002D (size: 0x1)
    TArray<FTTEventTrack> EventTracks;                                                // 0x0030 (size: 0x10)
    TArray<FTTFloatTrack> FloatTracks;                                                // 0x0040 (size: 0x10)
    TArray<FTTVectorTrack> VectorTracks;                                              // 0x0050 (size: 0x10)
    TArray<FTTLinearColorTrack> LinearColorTracks;                                    // 0x0060 (size: 0x10)
    TArray<FBPVariableMetaDataEntry> MetaDataArray;                                   // 0x0070 (size: 0x10)
    FGuid TimelineGuid;                                                               // 0x0080 (size: 0x10)
    TEnumAsByte<ETickingGroup> TimelineTickGroup;                                     // 0x0090 (size: 0x1)
    FName VariableName;                                                               // 0x0094 (size: 0x8)
    FName DirectionPropertyName;                                                      // 0x009C (size: 0x8)
    FName UpdateFunctionName;                                                         // 0x00A4 (size: 0x8)
    FName FinishedFunctionName;                                                       // 0x00AC (size: 0x8)

}; // Size: 0xB8

class UTireType : public UDataAsset
{
    float FrictionScale;                                                              // 0x0030 (size: 0x4)

}; // Size: 0x38

class UTouchInterface : public UObject
{
    TArray<FTouchInputControl> Controls;                                              // 0x0028 (size: 0x10)
    float ActiveOpacity;                                                              // 0x0038 (size: 0x4)
    float InactiveOpacity;                                                            // 0x003C (size: 0x4)
    float TimeUntilDeactive;                                                          // 0x0040 (size: 0x4)
    float TimeUntilReset;                                                             // 0x0044 (size: 0x4)
    float ActivationDelay;                                                            // 0x0048 (size: 0x4)
    bool bPreventRecenter;                                                            // 0x004C (size: 0x1)
    float StartupDelay;                                                               // 0x0050 (size: 0x4)

}; // Size: 0x58

class UTransactionDiffingTestObject : public UObject
{
    TArray<FName> NamesArray;                                                         // 0x0028 (size: 0x10)
    FName AdditionalName;                                                             // 0x0038 (size: 0x8)
    TArray<class UObject*> ObjectsArray;                                              // 0x0040 (size: 0x10)
    class UObject* AdditionalObject;                                                  // 0x0050 (size: 0x8)
    TArray<TSoftObjectPtr<UObject>> SoftObjectsArray;                                 // 0x0058 (size: 0x10)
    TSoftObjectPtr<UObject> AdditionalSoftObject;                                     // 0x0068 (size: 0x28)
    int32 PropertyData;                                                               // 0x0090 (size: 0x4)

}; // Size: 0x98

class UTwitterIntegrationBase : public UPlatformInterfaceBase
{

    bool TwitterRequest(FString URL, const TArray<FString>& ParamKeysAndValues, TEnumAsByte<ETwitterRequestMethod> RequestMethod, int32 AccountIndex);
    bool ShowTweetUI(FString InitialMessage, FString URL, FString Picture);
    void Init();
    int32 GetNumAccounts();
    FString GetAccountName(int32 AccountIndex);
    bool CanShowTweetUI();
    bool AuthorizeAccounts();
}; // Size: 0x38

class UTypedElementCommonActions : public UObject
{

    TArray<FScriptTypedElementHandle> PasteNormalizedElementsFromString(const FScriptTypedElementListProxy& ElementList, class UWorld* World, const FTypedElementPasteOptions& PasteOption, FString InputString);
    TArray<FScriptTypedElementHandle> PasteElementsFromString(class UTypedElementSelectionSet* SelectionSet, class UWorld* World, const FTypedElementPasteOptions& PasteOption, FString InputString);
    TArray<FScriptTypedElementHandle> K2_PasteNormalizedElements(const FScriptTypedElementListProxy& ElementList, class UWorld* World, const FTypedElementPasteOptions& PasteOption);
    TArray<FScriptTypedElementHandle> K2_PasteElements(class UTypedElementSelectionSet* SelectionSet, class UWorld* World, const FTypedElementPasteOptions& PasteOption);
    TArray<FScriptTypedElementHandle> K2_DuplicateSelectedElements(const class UTypedElementSelectionSet* SelectionSet, class UWorld* World, const FVector& LocationOffset);
    TArray<FScriptTypedElementHandle> DuplicateNormalizedElements(const FScriptTypedElementListProxy ElementList, class UWorld* World, const FVector& LocationOffset);
    bool DeleteSelectedElements(class UTypedElementSelectionSet* SelectionSet, class UWorld* World, const FTypedElementDeletionOptions& DeletionOptions);
    bool DeleteNormalizedElements(const FScriptTypedElementListProxy ElementList, class UWorld* World, class UTypedElementSelectionSet* InSelectionSet, const FTypedElementDeletionOptions& DeletionOptions);
    bool CopySelectedElementsToString(class UTypedElementSelectionSet* SelectionSet, FString& OutputString);
    bool CopySelectedElements(class UTypedElementSelectionSet* SelectionSet);
    bool CopyNormalizedElementsToString(const FScriptTypedElementListProxy& ElementList, FString& OutputString);
    bool CopyNormalizedElements(const FScriptTypedElementListProxy& ElementList);
}; // Size: 0x828

class UUniversalObjectLocatorScriptingExtensions : public UBlueprintFunctionLibrary
{

    FUniversalObjectLocator UniversalObjectLocatorFromString(FString InString);
    FString ToString(const FUniversalObjectLocator& Locator);
    void SyncUnload(const FUniversalObjectLocator& Locator, class UObject* Context);
    class UObject* SyncLoad(const FUniversalObjectLocator& Locator, class UObject* Context);
    class UObject* SyncFind(const FUniversalObjectLocator& Locator, class UObject* Context);
    FUniversalObjectLocator MakeUniversalObjectLocator(class UObject* Object, class UObject* Context);
    bool IsEmpty(const FUniversalObjectLocator& Locator);
}; // Size: 0x28

class UUserDefinedEnum : public UEnum
{
    TMap<class FName, class FText> DisplayNameMap;                                    // 0x0068 (size: 0x50)

}; // Size: 0xB8

class UUserDefinedStruct : public UScriptStruct
{
    TEnumAsByte<EUserDefinedStructureStatus> Status;                                  // 0x00C0 (size: 0x1)
    FGuid Guid;                                                                       // 0x00C4 (size: 0x10)

}; // Size: 0x108

class UUserInterfaceSettings : public UDeveloperSettings
{
    ERenderFocusRule RenderFocusRule;                                                 // 0x0038 (size: 0x1)
    TMap<TEnumAsByte<EMouseCursor::Type>, FHardwareCursorReference> HardwareCursors;  // 0x0040 (size: 0x50)
    TMap<TEnumAsByte<EMouseCursor::Type>, FSoftClassPath> SoftwareCursors;            // 0x0090 (size: 0x50)
    FSoftClassPath DefaultCursor;                                                     // 0x00E0 (size: 0x20)
    FSoftClassPath TextEditBeamCursor;                                                // 0x0100 (size: 0x20)
    FSoftClassPath CrosshairsCursor;                                                  // 0x0120 (size: 0x20)
    FSoftClassPath HandCursor;                                                        // 0x0140 (size: 0x20)
    FSoftClassPath GrabHandCursor;                                                    // 0x0160 (size: 0x20)
    FSoftClassPath GrabHandClosedCursor;                                              // 0x0180 (size: 0x20)
    FSoftClassPath SlashedCircleCursor;                                               // 0x01A0 (size: 0x20)
    float ApplicationScale;                                                           // 0x01C0 (size: 0x4)
    EUIScalingRule UIScaleRule;                                                       // 0x01C4 (size: 0x1)
    FSoftClassPath CustomScalingRuleClass;                                            // 0x01C8 (size: 0x20)
    FRuntimeFloatCurve UIScaleCurve;                                                  // 0x01E8 (size: 0x88)
    bool bAllowHighDPIInGameMode;                                                     // 0x0270 (size: 0x1)
    FIntPoint DesignScreenSize;                                                       // 0x0274 (size: 0x8)
    bool bLoadWidgetsOnDedicatedServer;                                               // 0x027C (size: 0x1)
    bool bAuthorizeAutomaticWidgetVariableCreation;                                   // 0x027D (size: 0x1)
    TArray<class UObject*> CursorClasses;                                             // 0x0280 (size: 0x10)
    UClass* CustomScalingRuleClassInstance;                                           // 0x0290 (size: 0x8)
    class UDPICustomScalingRule* CustomScalingRule;                                   // 0x0298 (size: 0x8)

}; // Size: 0x2B0

class UVOIPStatics : public UBlueprintFunctionLibrary
{

    void SetMicThreshold(float InThreshold);
}; // Size: 0x28

class UVOIPTalker : public UActorComponent
{
    FVoiceSettings Settings;                                                          // 0x00A0 (size: 0x18)

    void RegisterWithPlayerState(class APlayerState* OwningState);
    float GetVoiceLevel();
    class UVOIPTalker* CreateTalkerForPlayer(class APlayerState* OwningState);
    void BPOnTalkingEnd();
    void BPOnTalkingBegin(class UAudioComponent* AudioComponent);
}; // Size: 0xE0

class UVariableFrameStrippingSettings : public UObject
{
    FPerPlatformBool UseVariableFrameStripping;                                       // 0x0028 (size: 0x1)
    FPerPlatformInt FrameStrippingRate;                                               // 0x002C (size: 0x4)

}; // Size: 0x30

class UVectorField : public UObject
{
    FBox Bounds;                                                                      // 0x0028 (size: 0x38)
    float Intensity;                                                                  // 0x0060 (size: 0x4)

}; // Size: 0x68

class UVectorFieldAnimated : public UVectorField
{
    class UTexture2D* Texture;                                                        // 0x0068 (size: 0x8)
    TEnumAsByte<EVectorFieldConstructionOp> ConstructionOp;                           // 0x0070 (size: 0x1)
    int32 VolumeSizeX;                                                                // 0x0074 (size: 0x4)
    int32 VolumeSizeY;                                                                // 0x0078 (size: 0x4)
    int32 VolumeSizeZ;                                                                // 0x007C (size: 0x4)
    int32 SubImagesX;                                                                 // 0x0080 (size: 0x4)
    int32 SubImagesY;                                                                 // 0x0084 (size: 0x4)
    int32 FrameCount;                                                                 // 0x0088 (size: 0x4)
    float FramesPerSecond;                                                            // 0x008C (size: 0x4)
    uint8 bLoop;                                                                      // 0x0090 (size: 0x1)
    class UVectorFieldStatic* NoiseField;                                             // 0x0098 (size: 0x8)
    float NoiseScale;                                                                 // 0x00A0 (size: 0x4)
    float NoiseMax;                                                                   // 0x00A4 (size: 0x4)

}; // Size: 0xA8

class UVectorFieldComponent : public UPrimitiveComponent
{
    class UVectorField* VectorField;                                                  // 0x0518 (size: 0x8)
    float Intensity;                                                                  // 0x0520 (size: 0x4)
    float Tightness;                                                                  // 0x0524 (size: 0x4)
    uint8 bPreviewVectorField;                                                        // 0x0528 (size: 0x1)

    void SetIntensity(float NewIntensity);
}; // Size: 0x540

class UVectorFieldStatic : public UVectorField
{
    int32 SizeX;                                                                      // 0x0068 (size: 0x4)
    int32 SizeY;                                                                      // 0x006C (size: 0x4)
    int32 SizeZ;                                                                      // 0x0070 (size: 0x4)
    bool bAllowCPUAccess;                                                             // 0x0074 (size: 0x1)

}; // Size: 0xB8

class UViewModeUtils : public UObject
{
}; // Size: 0x28

class UViewportStatsSubsystem : public UWorldSubsystem
{

    void RemoveDisplayDelegate(const int32 IndexToRemove);
    void AddTimedDisplay(FText Text, FLinearColor Color, float Duration, const FVector2D& DisplayOffset);
    int32 AddDisplayDelegate(const FAddDisplayDelegateDelegate& Delegate);
}; // Size: 0x50

class UVirtualTexture : public UObject
{
}; // Size: 0x28

class UVirtualTexture2D : public UTexture2D
{
    FVirtualTextureBuildSettings Settings;                                            // 0x0150 (size: 0x8)
    bool bContinuousUpdate;                                                           // 0x0158 (size: 0x1)
    bool bSinglePhysicalSpace;                                                        // 0x0159 (size: 0x1)

}; // Size: 0x160

class UVirtualTextureBuilder : public UObject
{
    class UVirtualTexture2D* Texture;                                                 // 0x0028 (size: 0x8)
    class UVirtualTexture2D* TextureMobile;                                           // 0x0030 (size: 0x8)
    uint64 BuildHash;                                                                 // 0x0038 (size: 0x8)
    bool bSeparateTextureForMobile;                                                   // 0x0040 (size: 0x1)
    FPerPlatformBool EnableCookPerPlatform;                                           // 0x0041 (size: 0x1)

}; // Size: 0x48

class UVirtualTexturePoolConfig : public UDeveloperSettings
{
    int32 DefaultSizeInMegabyte;                                                      // 0x0038 (size: 0x4)
    bool bPoolAutoGrowInEditor;                                                       // 0x003C (size: 0x1)
    TArray<FVirtualTextureSpacePoolConfig> Pools;                                     // 0x0040 (size: 0x10)
    TArray<FVirtualTextureSpacePoolConfig> TransientPools;                            // 0x0050 (size: 0x10)

}; // Size: 0x60

class UVisualLoggerAutomationTests : public UObject
{
}; // Size: 0x28

class UVisualLoggerKismetLibrary : public UBlueprintFunctionLibrary
{

    void RedirectVislog(class UObject* SourceOwner, class UObject* DestinationOwner);
    void LogText(class UObject* WorldContextObject, FString Text, FName LogCategory, bool bAddToMessageLog);
    void LogSphere(class UObject* WorldContextObject, FVector Center, float Radius, FString Text, FLinearColor ObjectColor, FName LogCategory, bool bAddToMessageLog, bool bWireframe);
    void LogSegment(class UObject* WorldContextObject, const FVector SegmentStart, const FVector SegmentEnd, FString Text, FLinearColor ObjectColor, const float Thickness, FName CategoryName, bool bAddToMessageLog);
    void LogOrientedBox(class UObject* WorldContextObject, FBox BoxShape, FTransform Transform, FString Text, FLinearColor ObjectColor, FName LogCategory, bool bAddToMessageLog, bool bWireframe);
    void LogLocation(class UObject* WorldContextObject, FVector Location, FString Text, FLinearColor ObjectColor, float Radius, FName LogCategory, bool bAddToMessageLog);
    void LogCylinder(class UObject* WorldContextObject, FVector Start, FVector End, float Radius, FString Text, FLinearColor ObjectColor, FName LogCategory, bool bAddToMessageLog, bool bWireframe);
    void LogCone(class UObject* WorldContextObject, FVector Origin, FVector Direction, float Length, float Angle, FString Text, FLinearColor ObjectColor, FName LogCategory, bool bAddToMessageLog, bool bWireframe);
    void LogCircle(class UObject* WorldContextObject, FVector Center, FVector UpAxis, float Radius, FString Text, FLinearColor ObjectColor, const float Thickness, FName CategoryName, bool bAddToMessageLog);
    void LogCapsule(class UObject* WorldContextObject, FVector base, float HalfHeight, float Radius, FQuat Rotation, FString Text, FLinearColor ObjectColor, FName LogCategory, bool bAddToMessageLog, bool bWireframe);
    void LogBox(class UObject* WorldContextObject, FBox BoxShape, FString Text, FLinearColor ObjectColor, FName LogCategory, bool bAddToMessageLog, bool bWireframe);
    void LogArrow(class UObject* WorldContextObject, const FVector SegmentStart, const FVector SegmentEnd, FString Text, FLinearColor ObjectColor, FName CategoryName, bool bAddToMessageLog);
    void EnableRecording(bool bEnabled);
}; // Size: 0x28

class UVoiceChannel : public UChannel
{
}; // Size: 0x78

class UVolumeTexture : public UTexture
{
    TEnumAsByte<TextureAddress> AddressMode;                                          // 0x0138 (size: 0x1)

}; // Size: 0x140

class UVolumetricCloudComponent : public USceneComponent
{
    float LayerBottomAltitude;                                                        // 0x0230 (size: 0x4)
    float LayerHeight;                                                                // 0x0234 (size: 0x4)
    float TracingStartMaxDistance;                                                    // 0x0238 (size: 0x4)
    float TracingStartDistanceFromCamera;                                             // 0x023C (size: 0x4)
    EVolumetricCloudTracingMaxDistanceMode TracingMaxDistanceMode;                    // 0x0240 (size: 0x1)
    float TracingMaxDistance;                                                         // 0x0244 (size: 0x4)
    float PlanetRadius;                                                               // 0x0248 (size: 0x4)
    FColor GroundAlbedo;                                                              // 0x024C (size: 0x4)
    class UMaterialInterface* Material;                                               // 0x0250 (size: 0x8)
    uint8 bUsePerSampleAtmosphericLightTransmittance;                                 // 0x0258 (size: 0x1)
    float SkyLightCloudBottomOcclusion;                                               // 0x025C (size: 0x4)
    float ViewSampleCountScale;                                                       // 0x0260 (size: 0x4)
    float ReflectionViewSampleCountScaleValue;                                        // 0x0264 (size: 0x4)
    float ReflectionViewSampleCountScale;                                             // 0x0268 (size: 0x4)
    float ReflectionSampleCountScale;                                                 // 0x026C (size: 0x4)
    float ShadowViewSampleCountScale;                                                 // 0x0270 (size: 0x4)
    float ShadowReflectionViewSampleCountScaleValue;                                  // 0x0274 (size: 0x4)
    float ShadowReflectionViewSampleCountScale;                                       // 0x0278 (size: 0x4)
    float ShadowReflectionSampleCountScale;                                           // 0x027C (size: 0x4)
    float ShadowTracingDistance;                                                      // 0x0280 (size: 0x4)
    float StopTracingTransmittanceThreshold;                                          // 0x0284 (size: 0x4)
    float AerialPespectiveRayleighScatteringStartDistance;                            // 0x0288 (size: 0x4)
    float AerialPespectiveRayleighScatteringFadeDistance;                             // 0x028C (size: 0x4)
    float AerialPespectiveMieScatteringStartDistance;                                 // 0x0290 (size: 0x4)
    float AerialPespectiveMieScatteringFadeDistance;                                  // 0x0294 (size: 0x4)
    uint8 bHoldout;                                                                   // 0x0298 (size: 0x1)
    uint8 bRenderInMainPass;                                                          // 0x0298 (size: 0x1)

    void SetViewSampleCountScale(float NewValue);
    void SetTracingStartMaxDistance(float NewValue);
    void SetTracingStartDistanceFromCamera(float NewValue);
    void SetTracingMaxDistance(float NewValue);
    void SetStopTracingTransmittanceThreshold(float NewValue);
    void SetSkyLightCloudBottomOcclusion(float NewValue);
    void SetShadowViewSampleCountScale(float NewValue);
    void SetShadowTracingDistance(float NewValue);
    void SetShadowReflectionViewSampleCountScale(float NewValue);
    void SetShadowReflectionSampleCountScale(float NewValue);
    void SetRenderInMainPass(bool bValue);
    void SetReflectionViewSampleCountScale(float NewValue);
    void SetReflectionSampleCountScale(float NewValue);
    void SetPlanetRadius(float NewValue);
    void SetMaterial(class UMaterialInterface* NewValue);
    void SetLayerHeight(float NewValue);
    void SetLayerBottomAltitude(float NewValue);
    void SetHoldout(bool bNewHoldout);
    void SetGroundAlbedo(FColor NewValue);
    void SetbUsePerSampleAtmosphericLightTransmittance(bool NewValue);
}; // Size: 0x2B0

class UWindDirectionalSourceComponent : public USceneComponent
{
    float Strength;                                                                   // 0x0230 (size: 0x4)
    float Speed;                                                                      // 0x0234 (size: 0x4)
    float MinGustAmount;                                                              // 0x0238 (size: 0x4)
    float MaxGustAmount;                                                              // 0x023C (size: 0x4)
    float Radius;                                                                     // 0x0240 (size: 0x4)
    uint8 bPointWind;                                                                 // 0x0244 (size: 0x1)

    void SetWindType(EWindSourceType InNewType);
    void SetStrength(float InNewStrength);
    void SetSpeed(float InNewSpeed);
    void SetRadius(float InNewRadius);
    void SetMinimumGustAmount(float InNewMinGust);
    void SetMaximumGustAmount(float InNewMaxGust);
}; // Size: 0x250

class UWorld : public UObject
{
    class ULevel* PersistentLevel;                                                    // 0x0030 (size: 0x8)
    class UNetDriver* NetDriver;                                                      // 0x0038 (size: 0x8)
    class ULineBatchComponent* LineBatcher;                                           // 0x0040 (size: 0x8)
    class ULineBatchComponent* PersistentLineBatcher;                                 // 0x0048 (size: 0x8)
    class ULineBatchComponent* ForegroundLineBatcher;                                 // 0x0050 (size: 0x8)
    class AGameNetworkManager* NetworkManager;                                        // 0x0058 (size: 0x8)
    class UPhysicsCollisionHandler* PhysicsCollisionHandler;                          // 0x0060 (size: 0x8)
    TArray<class UObject*> ExtraReferencedObjects;                                    // 0x0068 (size: 0x10)
    TArray<class UObject*> PerModuleDataObjects;                                      // 0x0078 (size: 0x10)
    TArray<class ULevelStreaming*> StreamingLevels;                                   // 0x0088 (size: 0x10)
    FStreamingLevelsToConsider StreamingLevelsToConsider;                             // 0x0098 (size: 0x28)
    class AServerStreamingLevelsVisibility* ServerStreamingLevelsVisibility;          // 0x00C0 (size: 0x8)
    FString StreamingLevelsPrefix;                                                    // 0x00C8 (size: 0x10)
    class ULevel* CurrentLevelPendingVisibility;                                      // 0x00E0 (size: 0x8)
    class ULevel* CurrentLevelPendingInvisibility;                                    // 0x00E8 (size: 0x8)
    class UDemoNetDriver* DemoNetDriver;                                              // 0x00F0 (size: 0x8)
    class AParticleEventManager* MyParticleEventManager;                              // 0x00F8 (size: 0x8)
    class APhysicsVolume* DefaultPhysicsVolume;                                       // 0x0100 (size: 0x8)
    uint8 bAreConstraintsDirty;                                                       // 0x013E (size: 0x1)
    class UNavigationSystemBase* NavigationSystem;                                    // 0x0150 (size: 0x8)
    class AGameModeBase* AuthorityGameMode;                                           // 0x0158 (size: 0x8)
    class AGameStateBase* GameState;                                                  // 0x0160 (size: 0x8)
    class UAISystemBase* AISystem;                                                    // 0x0168 (size: 0x8)
    class UAvoidanceManager* AvoidanceManager;                                        // 0x0170 (size: 0x8)
    TArray<class ULevel*> Levels;                                                     // 0x0178 (size: 0x10)
    TArray<FLevelCollection> LevelCollections;                                        // 0x0188 (size: 0x10)
    class UGameInstance* OwningGameInstance;                                          // 0x01D8 (size: 0x8)
    TArray<class UMaterialParameterCollectionInstance*> ParameterCollectionInstances; // 0x01E0 (size: 0x10)
    class UCanvas* CanvasForRenderingToTarget;                                        // 0x01F0 (size: 0x8)
    class UCanvas* CanvasForDrawMaterialToRenderTarget;                               // 0x01F8 (size: 0x8)
    class UPhysicsFieldComponent* PhysicsField;                                       // 0x0270 (size: 0x8)
    TSet<UActorComponent*> ComponentsThatNeedPreEndOfFrameSync;                       // 0x0278 (size: 0x50)
    TArray<class UActorComponent*> ComponentsThatNeedEndOfFrameUpdate;                // 0x02C8 (size: 0x10)
    TArray<class UActorComponent*> ComponentsThatNeedEndOfFrameUpdate_OnGameThread;   // 0x02D8 (size: 0x10)
    class UWorldComposition* WorldComposition;                                        // 0x0728 (size: 0x8)
    class UContentBundleManager* ContentBundleManager;                                // 0x0730 (size: 0x8)
    FWorldPSCPool PSCPool;                                                            // 0x07E0 (size: 0x58)

    class AWorldSettings* K2_GetWorldSettings();
    void HandleTimelineScrubbed();
    class UDataLayerManager* GetDataLayerManager();
}; // Size: 0x8F8

class UWorldComposition : public UObject
{
    TArray<class ULevelStreaming*> TilesStreaming;                                    // 0x0048 (size: 0x10)
    double TilesStreamingTimeThreshold;                                               // 0x0058 (size: 0x8)
    bool bLoadAllTilesDuringCinematic;                                                // 0x0060 (size: 0x1)
    bool bRebaseOriginIn3DSpace;                                                      // 0x0061 (size: 0x1)
    float RebaseOriginDistance;                                                       // 0x0064 (size: 0x4)

}; // Size: 0x68

class UWorldPartition : public UObject
{
    class UWorldPartitionRuntimeHash* RuntimeHash;                                    // 0x0030 (size: 0x8)
    bool bEnableStreaming;                                                            // 0x0038 (size: 0x1)
    EWorldPartitionServerStreamingMode ServerStreamingMode;                           // 0x0039 (size: 0x1)
    EWorldPartitionServerStreamingOutMode ServerStreamingOutMode;                     // 0x003A (size: 0x1)
    EWorldPartitionDataLayersLogicOperator DataLayersLogicOperator;                   // 0x003B (size: 0x1)
    class UDataLayerManager* DataLayerManager;                                        // 0x00D0 (size: 0x8)
    class UExternalDataLayerManager* ExternalDataLayerManager;                        // 0x00D8 (size: 0x8)
    class UWorldPartitionStreamingPolicy* StreamingPolicy;                            // 0x00E0 (size: 0x8)

}; // Size: 0x100

class UWorldPartitionBlueprintLibrary : public UBlueprintFunctionLibrary
{

    void UnpinActors(const TArray<FGuid>& InActorsToUnpin);
    void UnloadActors(const TArray<FGuid>& InActorsToUnload);
    void PinActors(const TArray<FGuid>& InActorsToPin);
    void LoadActors(const TArray<FGuid>& InActorsToLoad);
    FBox GetRuntimeWorldBounds();
    bool GetIntersectingActorDescs(const FBox& InBox, TArray<FActorDesc>& OutActorDescs);
    FBox GetEditorWorldBounds();
    class UDataLayerManager* GetDataLayerManager(class UObject* WorldContextObject);
    bool GetActorDescsForActors(const TArray<class AActor*>& InActors, TArray<FActorDesc>& OutActorDescs);
    bool GetActorDescs(TArray<FActorDesc>& OutActorDescs);
}; // Size: 0x28

class UWorldPartitionDestructibleHLODComponent : public USceneComponent
{
    TArray<FName> DestructibleActors;                                                 // 0x0230 (size: 0x10)

}; // Size: 0x240

class UWorldPartitionDestructibleHLODMeshComponent : public UWorldPartitionDestructibleHLODComponent
{
    class UMaterialInterface* DestructibleHLODMaterial;                               // 0x0240 (size: 0x8)
    FWorldPartitionDestructibleHLODState DestructibleHLODState;                       // 0x0248 (size: 0x148)
    class UMaterialInstanceDynamic* VisibilityMaterial;                               // 0x0390 (size: 0x8)
    class UTexture2DDynamic* VisibilityTexture;                                       // 0x0398 (size: 0x8)

}; // Size: 0x3A0

class UWorldPartitionDestructibleInHLODSupportLibrary : public UBlueprintFunctionLibrary
{

    void DestroyInHLOD(const TScriptInterface<class IWorldPartitionDestructibleInHLODInterface>& DestructibleInHLOD);
    void DamageInHLOD(const TScriptInterface<class IWorldPartitionDestructibleInHLODInterface>& DestructibleInHLOD, float DamagePercent);
}; // Size: 0x28

class UWorldPartitionEditorHash : public UObject
{
}; // Size: 0x28

class UWorldPartitionEditorLoaderAdapter : public UObject
{
}; // Size: 0x30

class UWorldPartitionEditorPerProjectUserSettings : public UDeveloperSettings
{
}; // Size: 0x38

class UWorldPartitionEditorSpatialHash : public UWorldPartitionEditorHash
{
}; // Size: 0x28

class UWorldPartitionHLODModifier : public UObject
{
}; // Size: 0x28

class UWorldPartitionHLODRuntimeSubsystem : public UWorldSubsystem
{
}; // Size: 0x118

class UWorldPartitionHLODSourceActors : public UObject
{
}; // Size: 0x28

class UWorldPartitionHLODSourceActorsFromCell : public UWorldPartitionHLODSourceActors
{
}; // Size: 0x28

class UWorldPartitionHLODSourceActorsFromLevel : public UWorldPartitionHLODSourceActors
{
}; // Size: 0x28

class UWorldPartitionLevelStreamingDynamic : public ULevelStreamingDynamic
{
    bool bShouldBeAlwaysLoaded;                                                       // 0x01A0 (size: 0x1)
    TWeakObjectPtr<class UWorldPartitionRuntimeLevelStreamingCell> StreamingCell;     // 0x01A4 (size: 0x8)
    TSoftObjectPtr<UWorldPartition> OuterWorldPartition;                              // 0x01B0 (size: 0x28)

}; // Size: 0x1E0

class UWorldPartitionLevelStreamingPolicy : public UWorldPartitionStreamingPolicy
{
    FTopLevelAssetPath SourceWorldAssetPath;                                          // 0x0278 (size: 0x10)
    TMap<class FName, class FName> SubObjectsToCellRemapping;                         // 0x0288 (size: 0x50)
    FWorldPartitionRuntimeContainerResolver ContainerResolver;                        // 0x02D8 (size: 0x58)
    TArray<TWeakObjectPtr<URuntimeHashExternalStreamingObjectBase>> ExternalStreamingObjects; // 0x0330 (size: 0x10)

}; // Size: 0x340

class UWorldPartitionRuntimeCell : public UObject
{
    bool bIsAlwaysLoaded;                                                             // 0x0038 (size: 0x1)
    FDataLayerInstanceNames DataLayers;                                               // 0x0040 (size: 0x18)
    bool bClientOnlyVisible;                                                          // 0x0058 (size: 0x1)
    bool bIsHLOD;                                                                     // 0x0059 (size: 0x1)
    bool bBlockOnSlowLoading;                                                         // 0x005A (size: 0x1)
    FGuid ContentBundleID;                                                            // 0x005C (size: 0x10)
    FLinearColor CellDebugColor;                                                      // 0x006C (size: 0x10)
    FGuid CellGuid;                                                                   // 0x007C (size: 0x10)
    FGuid SourceCellGuid;                                                             // 0x008C (size: 0x10)
    class UWorldPartitionRuntimeCellData* RuntimeCellData;                            // 0x00A8 (size: 0x8)

}; // Size: 0xB0

class UWorldPartitionRuntimeCellData : public UObject
{
    FBox ContentBounds;                                                               // 0x0050 (size: 0x38)
    TOptional<FBox> CellBounds;                                                       // 0x0088 (size: 0x40)
    FName GridName;                                                                   // 0x00C8 (size: 0x8)
    int32 Priority;                                                                   // 0x00D0 (size: 0x4)
    int32 HierarchicalLevel;                                                          // 0x00D4 (size: 0x4)

}; // Size: 0xE0

class UWorldPartitionRuntimeCellDataSpatialHash : public UWorldPartitionRuntimeCellData
{
    FVector Position;                                                                 // 0x00E0 (size: 0x18)
    float Extent;                                                                     // 0x00F8 (size: 0x4)

}; // Size: 0x150

class UWorldPartitionRuntimeHash : public UObject
{
}; // Size: 0x78

class UWorldPartitionRuntimeHashSet : public UWorldPartitionRuntimeHash
{
    TArray<FRuntimePartitionDesc> RuntimePartitions;                                  // 0x0078 (size: 0x10)
    TArray<FRuntimePartitionStreamingData> RuntimeStreamingData;                      // 0x0088 (size: 0x10)

}; // Size: 0x98

class UWorldPartitionRuntimeLevelStreamingCell : public UWorldPartitionRuntimeCell
{
    class UWorldPartitionLevelStreamingDynamic* LevelStreaming;                       // 0x00B0 (size: 0x8)

    void OnLevelShown();
    void OnLevelHidden();
}; // Size: 0xB8

class UWorldPartitionRuntimeSpatialHash : public UWorldPartitionRuntimeHash
{
    bool bEnableZCulling;                                                             // 0x0078 (size: 0x1)
    FSpatialHashSettings Settings;                                                    // 0x0079 (size: 0x2)
    TArray<FSpatialHashStreamingGrid> StreamingGrids;                                 // 0x0080 (size: 0x10)

}; // Size: 0xE8

class UWorldPartitionSettings : public UDeveloperSettings
{
    EWorldPartitionDataLayersLogicOperator NewMapsDataLayersLogicOperator;            // 0x0038 (size: 0x1)
    bool bNewMapsEnableWorldPartition;                                                // 0x0039 (size: 0x1)
    bool bNewMapsEnableWorldPartitionStreaming;                                       // 0x003A (size: 0x1)
    TSubclassOf<class UWorldPartitionEditorHash> EditorHashDefaultClass;              // 0x0040 (size: 0x8)
    TSubclassOf<class UWorldPartitionRuntimeHash> RuntimeHashDefaultClass;            // 0x0048 (size: 0x8)

}; // Size: 0x50

class UWorldPartitionStreamingPolicy : public UObject
{
    TSet<UWorldPartitionRuntimeCell*> LoadedCells;                                    // 0x0030 (size: 0x50)
    FActivatedCells ActivatedCells;                                                   // 0x0080 (size: 0xA0)
    TArray<class UWorldPartitionRuntimeCell*> ToActivateCells;                        // 0x01D0 (size: 0x10)
    TArray<class UWorldPartitionRuntimeCell*> ToLoadCells;                            // 0x01E0 (size: 0x10)
    bool bShouldMergeStreamingSourceInfo;                                             // 0x01F9 (size: 0x1)

}; // Size: 0x278

class UWorldPartitionStreamingSourceComponent : public UActorComponent
{
    EStreamingSourceTargetBehavior TargetBehavior;                                    // 0x00A8 (size: 0x1)
    TArray<FName> TargetGrids;                                                        // 0x00B0 (size: 0x10)
    FName TargetGrid;                                                                 // 0x00C0 (size: 0x8)
    FColor DebugColor;                                                                // 0x00C8 (size: 0x4)
    TArray<class UHLODLayer*> TargetHLODLayers;                                       // 0x00D0 (size: 0x10)
    class UHLODLayer* TargetHLODLayer;                                                // 0x00E0 (size: 0x8)
    TArray<FStreamingSourceShape> Shapes;                                             // 0x00E8 (size: 0x10)
    EStreamingSourcePriority Priority;                                                // 0x00F8 (size: 0x1)
    bool bStreamingSourceEnabled;                                                     // 0x00F9 (size: 0x1)
    EStreamingSourceTargetState TargetState;                                          // 0x00FA (size: 0x1)

    bool IsStreamingSourceEnabled();
    bool IsStreamingCompleted();
    void EnableStreamingSource();
    void DisableStreamingSource();
}; // Size: 0x100

class UWorldPartitionSubsystem : public UTickableWorldSubsystem
{

    bool IsStreamingCompleted(EWorldPartitionRuntimeCellState QueryState, const TArray<FWorldPartitionStreamingQuerySource>& QuerySources, bool bExactState);
    bool IsAllStreamingCompleted();
}; // Size: 0x2D0

class UWorldSubsystem : public USubsystem
{
}; // Size: 0x30

#endif
